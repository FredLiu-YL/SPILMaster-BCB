//---------------------------------------------------------------------------
// 2015 12 22 - chc A01
//  1. Motion: 21 bits 1048576(切割成各等份)
//  2. MB4U BiSS-C(MN-Y5): 23 bits 1048576*4
//  3. MB4U BiSS-C(NQC): 23 bits 1048576*4
//  4. HeidenHain: 0 - 360度
//
//  NQC: 1024 - 0.3515625度 / Step
//  Heidenhain: 0~360度
//  Motion: 1048576 / 1024 = 1024
//
// 2016 2 18 - chc A02
//  1. 加入iC-NQC
//     要將 NQC1SL_interfaceBcB.lib 放在 F:\WindowsAP\IC_MN_BiSS\BISS-DLL\dll
//     不能將Library Directory設在F:\WindowsAP\IC_MN_BiSS\BISS-DLL\NQC\dll ????
//
// 2016 2 19 - chc A03
// 2016 2 22 - chc
//  1. 修正顯正與加入Database
//
// 2016 2 24 - chc A04
//  1. 加入累進誤差
//
// 2016 2 25 - chc A05
//  1. 加入User Control
//  2. 加入Help
//  3. 累進誤差於Loop中要Reset
//  4. 加入Device Type到Recipe
//  5. 記錄iC-MN/iC-NQC Read Error的次數
//  6. Close時做SV OFF
// 2016 3 3 - chc
//  7. 修正歸0動作
//  8. Loop不再做Motion歸0動作(Command/Counter有誤差)
//     => 可能造成第一筆資料有誤差!!
//  9. 自動: Start後才要做歸0, 手動&外部: 不用歸0
// 10. 手動/外部時可指定是否要動Motion
// 11. 加入: 手動讀取BiSS值
//
// 2016 3 7 - chc A06
//  1. 將累進誤差加入Database
//  2. 加入總表&詳表
//     1.Index		N
//     2.LotNo		A(30)
//     3.BiSSType		S
//     4.Recipe		A(20)
//     5.MeasureMode	S
//     6.Loop		S
//     7.Step		S
//     8.AccurateDiff		N
//     9.Min		N
//     10.Max		N
//     11.TotalNo		N
//     12.NGNo		N
//     13.Result		S
//     14.StdMin		N
//     15.StdMax		N
//     16.Class		A(20)
//     17.SerialNo		A(20)
//     18.Spec		A(20)
//     19.Product		A(20)
//     20.Type		A(20)
//     21.ID		A(20)
//     22.Operator		A(20)
//     23.StartTime		A(20)
//     24.EndTime		A(20)
//
// 2016 3 17 - chc A06
//  1. 修正Hidenhain的讀取動作: Error時再讀5次(298=98, 354=>254)
//  2. 同時做NQC/MN的Initial, 異常時Close. 無法切換要重開機重新Init
//
// 2016 3 31 - chc A07
//  1. 不可以變動Parameter(Inverted - ROT)
//
// 2016 3 31 - chc A08
//  1. 加入License code
// 2016 4 1 - chc
//  2. 加入顯示iC-NQC的ROT值(Direction of Rotation)
//       ROT: 0-反向, 1-正向 => 指與馬達的相對方向性
//
// 2016 4 14 - chc A01
//  1. 改成雷射機: 4軸(PCI-8154)
//  2. CCD: acA1300-30gc, SN: 21244744, 1278*958, 3.75um*3.75um
//     a. Gain
//     b. White Balance
//     c. 1100*890
//     d. iMatch(北科大)
//     e. Pylon: IP 設定
//  3. I/O: PCI-7856(I/O板規格), HSL-DI16-DO16-DB-NN
//  4. AI: HSL-A116A02-M-VV
//  5. T: 3,200,000一轉
//  6. 作業
//     a. CCD取像 & Display
//     b. Pattern Match
//     c. Motion
//     d. Move to
//     e. Recipe點位: X/Y/Z/T
//     f. Offset: 大格(Array), 小格(Die)
//
// 2016 4 14 - chc A02
//  1. 調整Form
//  2. 加入LicenseCode & 原廠碼: 2016WVWV0429
//
// 2016 5 10 - chc A03
//  1. Joystick(AI)
//      _8154_set_max_override_speed是用來啟用/關閉 speed override的功能，其中的參數” OvrdSpeed”是給定一個最大的移動速度，
//      所以當設定好後在移動過程中要執行_8154_speed_override(I16 CAxisNo, F64 NewVelPercent, F64 Time);指令時，
//      其中參數NewVelPercent是以OvrdSpeed這個數值的百分比(0~99)換算成移動的速度。
//      例如當OverdSpeed設定100000時，NewVelPercent設定為10時，此時override新的速度就會變成10000，
//      那Time就是變速(加速或減速)到新的速度所需要的時間。
//
// 2016 5 10 - chc A03
//  1. 若Motion在運作中則為黃燈
//  2. 啟動後綠燈持續亮
//  3. 加入Joystick(X/Y)變速移動
// 2016 5 11 - chc A03
//  4. 修改Joystick(X/Y)變速移動
//  5. InitMotion()後就LockDoor
//  6. AllHome後也LockDoor
//  7. AI的次序相反(0-Y, 1-X)
//  8. 加入DoorLock & DoorUnlock兩個Button
//  9. Pylon CCD取像要重寫! 目前寫法會Timeout & Lag
//
// 2016 5 12 - chc A04
//  1. 修正AI動作
//  2. Pylon改成V3.2版(PylonC是指C, Pylon則為C++)
//  3. 1278*958(1100*890), 3.75um
//
// 2016 5 15 - chc A05
//  1. AI的差異量由0.3增至0.5
//  2. Control Panel的XY移動改成Jog式
//
// 2016 5 19 - chc A06
//  1. PatternMath顯示旋轉角度
//  2. PatternMatch的角度量由正負5度加至10度
//  3. AI的差異量由0.3增至0.5後, 將2對應至35000. 原是2.5 vs 35000
// 2016 5 20 - chc
//  4. Position忘Enable
//  5. 加入Center/Load參數化
//  6. MoveToX未將Status切回NO_MOVE
//  7. 有些訊息改成英文
//
// 2016 5 19 - chc A07
//  1. 加入Joystick個別管制
//
// 2016 5 26 - chc A08
// 2016 5 30 - chc
//  1. Match結果寫入表格 & CSV/TXT輸出 & 選取做顯示及移動
//  2. 可指定Match數量(Max: 10)
//  3. 先做旋轉再移動
//  4. 進入AllHome就讓CCD Live
//  5. Operator不可用CCD
//
// 2016 5 30 - chc A09
//  1. 加入Original Position
//  2. 加入對Position的相對位置移動
//  3. 顯示Recipe的Pattern Image
//
// 2016 5 31 - chc B01
//  1. X/Y/Z精度改成0.1
//
// 2016 6 2 - chc B01a
//  1. 將XY位置示意圖移走
//  2. 加入玄轉時要自動調XY
//  3. 將Reset Laser Center改成OP不可操作
//  4. AllHome時Move的等愛時間由20sec拉長到100sec
//  5. AllHome時T軸轉320萬後要做Reset Command/Position & 改成綠色
//  6. One Axis Home要改成100sec
//  7. 隨時校正T軸Command/Position值(max, 320萬)
//  8. Relative Move 精度改成0.1um
//  9. Set Original錯成 SetLoad了!!
//
// 2016 6 3 - chc B01b
//  1. 加入T移動自動做X/Y 校正
//
// 2016 6 4 - chc B02
//  1. 修正T移動自動做X/Y 校正
//  2. Home Mode: X/Y做完後, 後退2mm, 再以2500速度做Home
// 2016 6 5 - chc
//  3. 將Joystick移到OP
//  4. 加入Jog / Continue 的位移係數
// 2016 6 6 - chc
//  1. MoveToXY中不管X/Y 是否在移動
//
// 2016 6 13 - chc B02a
//  1. T軸: WithinMove不支援Continue
//  2. Joystick作動前先儲存目前Continue值(律強制為Continue), 結束後還原
//  3. Control Panel上T軸作動前(有啟動Within功能時)先儲存目前Continue值, 結束後還原
//  4. 顯示目前Lens的精度值
//
// 2016 6 14 - chc B02b
//  1. 加入Lens.txt對應到Precision
//
// 2016 6 15 - chc B02c
//  1. 加入Lens.txt對應到Precision的名稱
//
// 2016 6 16 - chc B02d
//  1. 不再Log: MainForm->WriteSystemLog(">AI2(Y): Moving... Check Stop or ChangeSpeed?");
//  2. Continue改成Continuous
//  3. 修正Continuous勾選後會被強制消問題
//
// 2016 7 4 - chc B03
// 2016 7 5 - chc
// 2016 7 6 - chc
//  1. Add WDI function
// 2016 7 8 - chc B031
//  2. back to last position
// 2016 7 9 - chc
//  3. User 5 Positions Set/Go
//  4. WDI LLC control modified
// 2016 7 10 - chc
//  5. Lasre Wavelength processing
// 2016 7 11 - chc
//  6. Lasre Profile & Shutter control
// 2016 7 12 - chc B032
//  7. Lasre wavelength mismatch checking
//  8. Profile checking
//  9. Load/Save WDI Parameter
// 2016 7 13 - chc
// 10. Fire Log
// 11. ARRAY/Array/array/Die - Recipe parameter
// 12. Disable Laser & AF before System Exit
// 13. Rotate 90/-90 degree
//
// 2016 7 18 - chc B04
//  1. Backlash processing
//
// 2016 7 19 - chc B04a
//  1.Photon Domain Backlash
//    有關backlash補償,我們有個以前用的方法給您參考.  據我了解,AllHome後,向右或向下走都不會有backlash.
//    所以,只有在向左或向上移動時有backlash的問題.假設最大backlash值為5um.  每次向左(或向上)移動時都多
//    加上6um(或一個大於5um的值),然後再往右(或下)移6um.  這樣做能消掉backlash,而且保持向右(或下)移動時
//    沒有backlash.  控制器的座標與軟體的座標仍舊一致.  軟體只需在兩個方向(左與上)做補償,無須跟蹤同向
//    或反向.
//    您覺得如何?  若有不清楚的地方,我們可明天再討論一下.
//
// 2016 7 20 - chc B04b
//  1. WDI Comport/Baudrate Save/Load
//  2. Point move function
//
// 2016 7 22 - chc B04c
//  1. Laser: "Bust" to "Burst"
//  2. mm to um
//  3. "Wait Motion Done..." message to "Motion Moving..." ~ "Motion Done"
//  4. Array/Die Move Up/Down direction reverse
//  5. #1 can not do Parallel Alignment
//     Add Log in [Regular Alignment]
//
// 2016 7 22 - chc B04d
//  1. Position Move 使用ReviewVel
//  2. Position Move 加入Message
//
// 2016 7 23 - chc B04e
//  1. Devide by zero
//  2. Angular Alignment Can set any two positions
//  3. Array/Die move cause Y-Axis Move Error
//  4. can not save CCD precision of each lens
//  5. turn off Yellow lamp
//
// 2016 7 24 - chc B04f
//  1. WDI LED TUpDown Increment change from 10 to 1
//  2. Blinking AllHome button
//  3. Blinking Start Button
//  4. Create 400ms timer for blinking
//
// 2016 7 26 - chc B04g
//  1. remove System - AllHome
//  2. Start be do first after running
//  3. Continue to Continuous
//  4. remove X/Y/Z/T Restore button
//
// 2016 7 27 - chc B04h
//  1. check power below front door
//  2. Joystick/ControlPanel => only check Joystick
// 2016 7 28 - chc
//  3. Continuous move: immediate Stop when mouseup Event
//  4. Log message to trace Within function
//
// 2016 7 28 - chc B04i
//  1. Continuous move mode: keep moving to positive Y direction until it hits the end
//
// 2016 7 29 - chc B05
//  1. Within function: X/Y/T move
//
// 2016 7 29 - chc B04j
//  1. 操作員可設定5個座標.第四個不工作.顧客提出在按下設定之後多加個對話視窗讓使用者有機會退出
//  2. stage仍會暴走.但只有在使用搖桿時才發生
//  3. WDI照明控制,數字顯示與滑調顯示不一致
//  4. 繞銀幕中心旋轉功能選擇開關好像沒有作用.在一號機這個功能仍無法工作.我會與顧客討論中心點座標是否設定正確
//  5. Y軸有時會自己移動.我會跟顧客要log文檔
//  6. 發生下圖的錯誤訊息, 我會跟顧客要log文檔: type String to integer
//
// 2016 7 30 - chc B04k
//  1. Add try-catch in LoadSystemParameter/LoadUserPosition/LoadLaserPrameter/LoadWDIParameter/LoadRecipe/LoadLensTxt....
// 2016 7 30 - chc
//  2. LED PWM TrackBar & UpDown
//
// 2016 8 3 - chc B04l
//  1. Recipe: WaferSize....
//     ok
//  2. Recipe: Pattern Match move to Shutter(5 Positions) - Pattern(5 Positions)
//     ok
//  3. TOP405
//     ok
//  4. Within function : Smooth
//     ok
//  5. Graphical indicator for the current crosshair location on the chuck: 1"/2"/3"/4"/5"/6"
//
// 2016 8 5 - chc B04m
//  1. tmTMoveTimer(): Error, be Check boolTMove == false
//  2. Set LED Illumination when Lens switch, because it was not set in OnChange of tbLEDPWMOP
//  3. Set AF Off: AF auto off/on when moving
//
// 2016 8 7 - chc B04n
//  1. Bug: AF auto off/on when moving
//  2. Bug: Double click to do "move to center"
//  3. Support Within function when pressing GUI(T axis, 1x/10x/100x) button
//
// 2016 8 9 - chc B04o
//  1. Simulate Double Click
//  2. Within Function : flexible T/X/Y Speed
//
// 2016 8 10 - chc B04p
//  1. Within function by GUI CW & CCW(1x/10x/100x)
//
// 2016 8 11 - chc B04q
//  1. Within function by GUI CW & CCW(1x/10x/100x)
//
// 2016 8 15 - chc B04r
//  1. five user's position : "To" Error
//  2. System - Rel.Move Original to Origin
//  3. Motion.cpp -
//
// 2016 8 19 - chc B04s
//  1. btnBackwardClick() & btnMoveClick() 是看combAxis->ItemIndex; 不是CurrentAxisNo
//     Within功能時T無作動
//
// 2016 8 21 - chc B04t
//  1. ToAdjustXYNoWait(): need to set direction: 1-CW, 2-CCW
//  2. SetLensOffset() need to Check: Is the value of LensOffset is a NULL String?
//
// 2016 8 23 - chc B04u
//  1. Add 6 lensOffset setting button
//
// 2016 8 24 - chc B04v
//  1. avoid re-entrant tmMotionPollingTimer
//
// 2016 8 26 - chc B04w
//  1. Within function: don't do Backlash
//
// 2016 8 28 - chc B04x
//  1. Within function: don't do Backlash
//  2. Within function: Smoothing
//  3. To Center: Don't Backlash
//
// 2016 8 30 - chc B05
//  1. Motion Position mapping: X= 200mm, Y= 205mm, Z= 50mm, T= 360degree
// 2016 8 31 - chc
//  1. To Center(ot other position), Do Backlash and set new position to Table
//  2. To Position: set new positin to Table after doing backlash
//  3. Absolute backlash move function: do nothing when in same position
//  4. Home speed: speed down
//
// 2016 9 2 - chc B05a
//  1. modify: can not display current motion position
//  2. OneHome: X/Y do fast & slow homeing(like AllHome)
//
// 2016 9 5 - chc B05b
//  1. OneAxisHome: Reset all Axis when stop.
//  2. HomeAll: to +EL before doing AllHome()
//
// 2016 9 7 - chc B05c
//  1. AllHome / OneAxisHome: new method(ORG On then Off)
// 2016 9 8 - chc
//  2. Modify: ORG AllHome Error fixed
//
// 2016 9 8 - chc B05d
//  1. ORG AllHome use Lower speed to do ORG Off(half speed)
//
// 2016 9 8 - chc B05e
//  1. Within: use round for convert double to int
//  2. Within: speedup X/Y moving speed
//
// 2016 9 13 - chc B05f
//  1. Use tr_line3() - do three axises move at same time
//
// 2016 9 15 - chc B05g
//  1. AllHome: Add HomeMode1
//  2. Backlash: Add System mode
//
// 2016 9 16 - chc B05h
//  1. tr_line3: R+ / R- same direction!!
//  2. ToLensPosition(): AF On/Off Setting
//
// 2016 9 17 - chc B05i
//  1. WDI Connect: don't check this, now in disconnect state
//  2. HomeMode1 flow: -EL, Home
//
// 2016 9 21 - chc B05j
//  1. Set LensMagnification when lens switch
//  2. Change FA_Speed from 2000 to 200
//
// 2016 9 22 - chc B05k
//  1. ReOpen WDI when Com Port changed
//  2. modify: Baudrate Read
//  3. modify: Backlash setting when mode was changed
//  4. modify: SetLensOffset() before SelectLens()
//
// 2016 9 24 - chc B05l
//  1. do ReStart all(WDI & Laser) when Com Port changed(ReOpen WDI)
//  2. More Log Message
//
// 2016 10 3 - chc B06
//  1. Set Center/LaserCenter of each Lens
// 2016 10 9 - chc
//  2. When loading only need to read comport & baudrate, LoadWDIParameter() be done before OpenLLC()
// 2016 10 12 - chc
// 2016 10 13 - chc
//  1. AdjustTAxis: Need to Reset Counter too(not only command)
//  2.
//
// 2016 10 23 - chc B06a
//  1. 系統Aperture Recipe
//     ApertureRecipeX, ApertureRecipeY
//  2. 說明: 1278*958, 3.75um. 50x-0.075um/pixel, 20x-0.1875um/pixel, 10x-0.375um/pixel, 5x-0.75um/pxiel, 2x-2.875um/pixel
//  3. imCCD size: 1100*890 => 1020*810, dx=258, dy=148, rangex=258/2=129, rangey=148/2=74
//        origin dx,dy=178*68, rangex,rangey=89*34
//
// 2016 10 30 - chc B07
//  1. ybLaser: OnCommNotify, to empty buffer when met SYNTAX or ERROR
//  2. Power(Waveplate) Percentage control
//
// 2016 11 1 - chc B08
//  1. Aperture Calibration
// 2016 11 2 - chc
//  2. Aperture Calibration Update
//
// 2016 11 2 - chc B09
//  1. Aperture Calibration Update
//  2. Aperture Calibration: with any Aperture
//
// 2016 11 4 - chc B10
//  1. Ctrl-Click Left & Right to Alignment: 加入Position的記錄, 否則長距離的轉正與單畫面的轉正方向相反!!
//
// 2016 11 5 - chc B11
//  1. ScrollBar Left/Right: +-1.0
//  2. Aperture Calibration: X and Y can be adjusted independently
//  3. Aperture Calibration: only display the calibrated box
//  4. the "round table view" near the bottom right corner of the window: Y Invert!
//
// 2016 11 8 - chc B12
//  1. Aperture Calibration: Spot size be calculated for the corresponding lens magnification
//  2. Rotate within View: U Checked
//     a. The amount of rotation is often smaller than the “distance” defined in the Parameters
//     b. When “U” is checked, R- does not completely cancel R+.
//     c. When “U” is checked, sometimes X or Y “jumps” quite a bit, and then jumps back
//     d. When ”U” is checked, after the rotation, “To Center”, “To Load” and “To Origin” stop working.
//     e. Running “Rotate within View” at the center creates “divide by zero” error
//  3. Can stop Within operation when running
//
// 2016 11 9 - chc B13
//  1. Aperture same as the color for "Theory" in "Aperture Calibration"
//  2. Pattern Match: sort by score or distance(near the crosshair)
//
// 2016 11 10 - B14
//  1. Match之後藍框位置不對(相反): Reverse
//
// 2016 11 13 - chc B15
//  1. 由內到外搜尋: sno為單邊Pattern數量, 固範圍為sno*PatternWidth,sno*PatternHeight
//
// 2016 11 15 - chc B16
//  1. Match之後藍框的處理
//  2. 一定要滿足Match的數量才會停下
// 2016 11 16 - chc
//  3. 每次DoNCCMatch()前做sgResult的Clear
//  4. tmReadPower: 有切換Power才讀取(Interval=300ms), 連續兩次後就關閉
//  5. sgResult: 點選後不可以變動Table內(CX,CY)值, 因每次會先回到原始Table位置後再移動
//  6. Within功能: 每次寸動就更新T值(原是500ms更新一次)
//  7. X/Y/Z/T更新: 由500ms改成300ms
//
// 2016 11 17 - chc B17
//  1. 加入Recipe Run
//  2. 修正Power SrollBar
//  3. 將tmReadPower Inteval : 300ms to 500ms
//
// 2016 11 18 - chc B18
//  1. Recipe Run: 不強制設定Match-Align參數
//  2. Recipe Run: Move用GoPoint才對
//  3. Power Read寫法錯誤
//
// 2016 11 18 - chc B18a
//  1. 舊Read Power
//
// 2016 11 18a - chc B19
//  說明: 用新Power讀法
//  1. Shift after Rotate: 不做X的移動
//  2. 加入Laser Send Command到Log
//
// 2016 11 19 - chc B20
//  1. Modify: Laser Comport data Receive and process
//  2. Shift after Rotate operation & display value of shift offset
//  3. Turn LED illumination off before fire and on after fire
//
// 2016 11 19a - chc B21
//  1. Revise Laser COMPort Processing
//  2. ERROR: SYNTAX
//  3. Add cbTurnOffLED to system parameter
//
// 2016 11 22 - chc B22
//  1. Ignore "PD>"
//  2. Fire(single Shot) two fires
//  3. Loss "0."
//  4. Moving to Origin
//
// 2016 11 22 - chc B23
//  5. SendPower(): use wavelenth setting
//  6. Check Wavelength before to Save Laser Profile
//
// 2016 11 23 - chc B24
//  1. Power read: 不處理異常值(可能為0. 1. 2. 3. 4.)
//  2. Sleep(400ms) after SIL 0
//****
//  3. GIL: get illuminaiton back before turn off the illumination
//  4. RecipeRun: 加入fire之後的檢查, 並Log Defect Type 及 結果
//  5. 將Wafer Mapping圖加入Recipe
//  6. 加入Defect Type於Map Text檔
//  7. 加入Recipe Profile(by defect type)
//  8.
//
// 2016 12 13 - chc
//  1. TraceMove: 反方向不要用Override, 直接速度移動就可以!!
//
// LoadLensPosition()  - LensPosition.ini
//   "LensPosition"
// LoadLaserPosition() - LaserMotion.ini => 改成只讀LaserPosition, 放到LaserPosition.ini
//   "Laser Center X"
// => LoadSsytemParameter()之後已取得LensNo, 再讀入Lens/Laser Position
//    Ctrl-Alt-Left => 更新目前的Laser Center並寫入LaserPosition.ini
//    更換Lens => 切換LensPosition(只變更目前Center位置而已)/LaserPosition(要變動顯示中心)
//
// N. TOP405
//   File: Profile\TOP405.ini
//   There are 4 parameters for TOP405:
//   	1. Power(Waveplate)Percentage(0-100): AT$P=57.2(floating point)
//   	2. Power(Diode)Percentage(0-100): LA$P=55(integer)
//   	3. Aperture(X/Y; 0-100): XS$P=57.2(floating point)
//
// 2016 12 16 - chc A04d
// 1. 兩圓距離
// 2. 4點中心
// 3. 簡化
// 4. um/mm切換
// 5. 導電粒子
// 6. 軌跡中要禁止X/Y, 但Z可同步
// 7. 加入入料點
// 8. 點位間距離量測
// 9. 結果要由上往下
//
// 2017 1 3 - chc
// 2017 1 4 - chc
//  1. 測試AutoFocus
//
// 2017 2 4 - chc A05
//  1. 修正AutoFocus
//
// 2017 11 6 - chc A06
//  1. Nose Switch, lensno: 1-5(6)
//
// 2018 1 7 - chc A07
//  1. 校正方式改變 - 使用換算的Counter值來表示及計算長度
//     校正.txt檔格式為
//      60  599998
//     120 1199996 ...
//
// 2019 3 14 - chc Auo尚未處理喔
//=================================================
//   1. 2018 1 7 - chc 使用fx,fy的修正: 可能錯了!!!
//   2. rgCircleNo - 的Click不對要取消
//   3. 計算: pnlCircleP1Status->Color == clSilver || pnlCircleP1Status->Color == clSilver || pnlCircleP1Status->Color == clSilver 寫不對!!
//    有這個都是錯的!!
//      // 2018 1 7 - chc 使用fx,fy
//      dx = fx * X_RESOLUTION;
//      dy = fy * Y_RESOLUTION;
//   4. tm250msTimer中各點位不須要再加上Original!!
//=================================================
//
// 2019 6 24 - chc Bruker
// 1. Client Socket TCP/IP
// 2. Victor: LED Controller(Apple/興城)
// 3. CCD: ImagingSource Gray 1280*960 [1120*890]無ScrollBar 3.75um
// 4. TCP/IP: Vision 64 - ConfigurationEdit - TCPIP
// 5. 定義Recipe: A, 幾個Chip, 幾個點, 量測項目
// 6. 運作: 選Recipe, 設定LotID..., 清空數據csv, 定位, [Chip定位, 各點量測], 取回csv, 修改csv
// 7. 上傳 & 顯示
//
// 2019 7 15 - chc
// 1. Lens加入Bruker的Z軸 - 也要自動切換
// 2.
// 2019 7 19 - chc
// 1. iMatch(NCC) - 2016/12/27版本(同Apple - PD) 改用iVisitingKey()
//
// 2019 7 23 - chc 問題整理
// 1. CCD(Area設定) - Lens轉換(Recipe)                                          *)
// 2. Recipe切換?                                                               **
//    => ok
// 3. 可到任一個Area的點位(除Area1之外)
//    => ok
// 4. 加入Alignment(Pattern Match)...                                           *)
// 5. 八向移動是指目前的座標                                                    *
//    => ok
// 6. Measure / Move /... 的速度定義
//    => OK / NG
// 7. 安全機制                                                                  *)
// 8. 主畫面加入MMD切換(0-2)
//    => ok
// 9. 速度切換後的速度值顯示: 一般及Z
//    => ok
// 10. 各位置加入Z(如入料點)... 先動Z再動XY
//    => ok
// 11. Home要先動Z(安全高度; 安全高度設定值)再做Home
//    => ok
// 12. 取得DataBase的CSV                                                        **
//    => ok
// 13. 作業前先將bruker的CSV清除                                                **
//    => ok
// 14. ProgramData\Bruker\Vision\Database                                       **
//                       \Vision\Recipes\Vision => VisionRecipe
//      \\WINDOWS-OMD0END\Vision\Recipes\Vision
//    => ok
//
// new command: 2005/11034(Automation)
// 2005 : 4個: 61/2/1/Path+.csv => *.csv => 單Name(8um SHS)
// 11034: 5個: 28(len+8)/20/1/Path+.csv/1
//
// 2019 8 2 - chc 加入Z的修改
//   BrukerZ尚未完成!
//   用2002: Generate Database
//
// => 先設定Vision Recipe再設定Database才可以
//    2/len/Databasename or 2/1/Databasename
//
// 2019 8 22a - chc 關於Database
//  有三處: 分成 Vision Recipe(相同Vision不用再設定) & Set Database(有設定Vision Recipe才要做, 做同一個) & Measurement
//  Run設同一個Database
//  run中使用同一個Database, 直接呼叫, 不用透過ProcessCSV()
//
// 2019 10 29 - chc 待處理
//  1. 多Area(2個Area)的測試
//  2. PatternMatch
//  3. 問題記錄的處理
//
// 2019 11 28 - chc
//  4. ImagingSource Gain[175 ~ 1020]
//  5. 每2.5sec監控Vision64動作: Lens, MMD, Intensity, Z
//
//
// 2019 11 12 - chc
/*
不可以移動, 與Lens無關, 要移CCD Z(目前沒有動!)
To Lens1/Lens2: 沒有動Z/Intensity!!

檢查ToCCD的動作(位置好像不對) - 是目前Mouse位置
檢查ToLens的動作(位置好像不對) - 要XY同動
X/Y: Command/Counter不一致
 => 要使用XY同動命令(_8154_start_ta_move_xy - AbsoluteMoveXY()), ToLens1/ToLens2/ToCCD/ToLens均有不一致的問題
    ok : ToCCD(有動系統Z)
    ok : ToLens1/2/3/4
       => 但尚未動BrukerZ/Intensity !!, 要以設定CCD/Lens/MMD的BrukerZ來自動校正Z & X & Y
    ok : ToLens是指目前的Lens且是十字中心點

 => 呼叫AbsoluteMoveXY(): MoveToXY() / MoveToXYDirect() / MoveToXYRatio()
    imTableMouseDown()呼叫MoveToXYRatio()
    MoveToXYDirect()沒用到

到各Lens指定位置
 => ok, 改成X/Y同動.

到各指定位置(CCD,Last,Load,Original,AOI)
 => ok, 改成X/Y同動.

做原點Home要移動BrukerZ到安全位置
 => 原就有做(ok)

各Lens之間的切換, 要校正
 => ok(X/Y/Brukerz)

各MMD之間的切換,  要校正
 => ok(X/Y/Brukerz)

加入原點(0,0,0,SafeZ)/入料點移動
 => ok

要可指定DatabaseName
 => ok

量測時各點移動要動CCDZ高度
 => ok

整片對角線Zoom校正

各區域定點與各點位置校正

系統Z要自動對焦

*/
//
// 2019 11 27 - chc 注意
// 1. 切MMD, Lens值不會變動!
//    Save Lens不大對: 可能是MMDNo值不對的關係
//    => 寫錯, "2X" 結果設為 "055X", if/else也寫錯!
//    => 要更新LensPosition.ini到機台內
// 2. 切換MMD/Lens要補償X/Y/z
//    => MMD/Lens切換(寫錯, 要呼叫MouseUp才有動作)
// 3. ToLens / ToCCD....的補償
//    => ??? 要以Z的變化來調BrukerZ
// 4. 到原(入料)點: 移完Brukerz後就不會動! 要加入訊息於Log & MessageBar
//     X/Y大移動後又可正常!
//
//
// 2019 12 7 - chc
//kmf參數(原點, 方向, 單位, 檔名, 原點決定方向)要跟Recipe在一起!
//連線後自動做VisionRecipe的讀取
//載入kmf Parameter & 同步Recipe
//edkmfX ?
//
// 2019 12 14 - chc
// 1. MeasureResult: 0/1/2/3/4/5(3/4/5/6/7) - Ok/無VisionRecipe/VisionRecipe不存在/VisionRecipe指定失敗/Error/Timeout
//
// 2019 12 17 - chc
// 1. HomeAll前Z不必先做上升到-EL動作, 因MotionZ不會碰到平台
//
// 2019 12 17 - chc
// 1. 修正Motion方向問題(看影像移動的方向)
// 2. ToLens的計算方式
//
// 2019 12 23 - chc
// 1. 量測點位BrukerZ的計算方式
//    => [目前的(AreaZ) - 當時的(Area1Z)] + 點位當時的BrukerZ(在Area1上定義)
// 2. 左右移動方向可指定Table方向
//
// 2020 1 5 - chc
// 1. 加入Joystick
//    Project Lib/Incldie
//    a. Include=> D:\DX9BCB\DX9SDK\Include
//    b. Lib=> D:\DX9BCB\DX9SDK\Lib
//    => 在Home之前不可以使用
//
// 2020 1 21 - chc B01
// 1. Operator/SheetNo加入CSV
// 2. 修正kmf檔讀取: 要分正負值
// 3. 修正Recipe/讀檔最後一個欄位清除問題
// 4. 強制要辨識基板擺放方向
// 5. 安全高度7000
//
// 2020 2 8 - chc B02
// 1. 當量測中要夾板, 且不可以使用放開夾板(踏板)
// 2. 指定點數由5點增加為10點
// 3. 可指定原點後, 輸入X/Y做相對位置移動
//
// 2020 2 14a - chc B03
// 1. 加入ServoOn Button
// 2. 監控是否發生Power Off
// 3. 等做完Joystick才顯示要做Motion Home
//
// 2020 3 3 - chc
// 0 度: -355391
// 41 度: 2220721
// 42 度: 2283553
// 62832cnt/度
//
// 2020 3 10 - chc
//  1. z : 到水平量測點, 當T > 0 度, 要過頭再回到水平
//
// 2020 3 12 - chc
//  1. 過頭處理的修正: 過頭誤動到L軸, z : 到水平量測點, 當T > 0 度, 要過頭再回到水平
//
// 2020 5 20 - chc
//  1. 定義L的水平高度
//  2. Maintenance Mode是看DI Bit6的反向, 不用做動作僅顯示而已
//  3. CDA/Vacuum(System/EFEM)不正常則禁止操作
//     => 尚未改
//  4. 操作流程驗證
//     => No: 出入的Alignment & 流片程序
// 2020 5 21 - chc
//  5. 進入Maintenance Mode時由水平改到原點
//
// 2020 6 22 - chc
//  6. 加外罩
//     Olympus Stage要加裝外罩: 有一些新增點位控制
//     a. Robot進出Stage時要開靜電bar跟Stage FFU
//        => ok
//     b. 量測時靜電bar跟Stage FFU要關掉
//        => ok
//     c. Stage的門要打開時，要從你的軟體點開啟, 這時要等Robot的動作做完縮回EFEM裡面
//        才能把電磁鎖釋放讓門被打開, 而門被打開之後Robot都不能動作(Robot不會斷電)
//        , 權限:工程師以上
//     d. 你的UI再新增一組按鈕，維修燈ON/OFF，權限:OP
//     DO-02.DO-06
//     DO-03
//     DO-00,DI-1
//
// 2020 7 15 - chc
//  7. 外罩門的Home問題: LF無法作動到-EL
//  8. 重大異常Log
//     => ?
//
// 2020 11 13 - chc C04
//  1. OP可操作Mouse Wheel
//  2. 1-水平, 2-傾斜: 不做Z設定點移動
//  3. MoveToY()InPosition到100um以內就可以(原10um)
//  4. 水平/傾斜: 先上升10000um(原1000um)
//     => 目前無此碼, 現場才有!!
//     => 已補上碼
//  5. Home: Z 用HomeMode 9-光學尺無Index
//
//
//
//
// DI00 - Open => 警示訊息(電腦維修門未關閉)
// EMO - 紅(Load/UnLoad/Mapping Error)/黃燈亮
// Cassette有門無門均要能取片
// Bar/FFU有開, 但FFU未關
// 疊片未偵測
// 要有Z的極限值
// OP可操作Z
// 入片 - Set Limit - Allow Slope Move - Out - Clear Limit -
//
// unload前檢查: Chuck/Aligner/Robot都不可以有片
// Mapping後若有Error(斜插/疊片)則不可以運作
// Aligner: Sysstem Error(99)要關大電才能正常
//
// 2020 7 20 - chc C01
//  1. Final
//
// 2020 11 2 - chc 問題
// 1. 警報聲 - 做SVON & 原點復歸, 但警報聲未停
// 2. 到水平 : 過10秒才動
// 3. 到傾斜 : 管理員何時會出現?
//
//
//
// Bit1(out)-?
// Bit2(out)-Bumper
// Bit5(in)-Alarm(Bumper - On為過熱或Alarm, 此時不能啟動Bumper)
// RDY/ALM/INP
// DMK 33G445 / 1914139      1280*960 30fps 3.75um Mono
// DMK 33GP031 / 36914044    2592*1944 15fps 2.2um Mono
//
//
//
// 5005/2/1/0.03(762um) - 0.03*25.3=0.762(762um)
//    Byte/Float(5Bytes)
//...
//
// 2021 4 16 - chc
// @@ 暫不做
// 2021 4 24 - chc
// 1. Focus加入加權(10 - 60): edDifferenceRatio
// 初始LED燈
// UI介面整理
// User點位移動不可動到T
// Z安全高度檢查
// Home: -EL速度加快
//
// EFEM初始標要標示在pnlSystemMessage
//
// 2021 6 3 - chc
//  1. 警示模式: Stage & PC 門不Alarm
//     => 要加入設定
//  2.
//
// 2021 6 11 - chc
//  1. InitDO()若Chuck有片要吸真空Bit7
//  2. 將所有Step取消: Robot, 量測
//  3. AutoFocus固定選取
//     => Run中不做autoFocus
//  4. 量測中Stop要恢復pcSystem
//  5. 量測中移動到45的點位要做0/45偏移量校正(第1點除外, 於轉45度時會自動做)
//  6. Wafer在Chuck上關程式之處理 ??
//     *=> 未完成
//  7. 50x定0 度(在45 度不可使用), LM50x 定45 度
//  8. Run時存0 度各量測點的位置, 於45量測時直接引用, 但要加上0/45切換的偏移校正量
//     => max 1000點
//     => 中心點無法使用Pattern match - 無特定Pattern!
//  9. Z連續移動是反向: 方向相反
// 10. 入/退片/Load/UnLoad/Run...時要防止破壞操作: Joystick, UI
//     *=> 未完成
// 11.
//
// 2021 6 30 - chc
//  1. Robot分取放片點位: 1(LoadPort1-11)/2(LoadPort2-21/3(Aligner-1)/4(Chuck-6)
//  2. 可選擇GPIO是否更新
//  3. Robot做完ORGN後要重設速度60%
//  4.
//
// 2021 7 17 - chc 07/13討論修正
// 取片前
//   有一者為clLime, 就取
// 取片後
//   全改成clOlive
// 退片前
//   有一者為clLime, 就不退
// 退片後
//   全改成clLime, 若是自動計數, 則指到下一片
//
// 2021 8 3 - chc
//  1. 加入Aligner的Thickness讀取DPRM: 500(原200) - 1300
//
// 2021 8 6 - chc
//  1. Wafer Die角度
//
// 2021 8 9 - chc
//  1. EFEM Socket Active的Disable要用Close, Enable一樣用true
//
// 2021 8 10 - chc
//  1. W軸Home(-EL): maxvel為1/2, 原是4/5
//  2. W移動加入Log
// 2021 8 11 - chc
//  1. 指定點(Double Click)在Wafer Mapping上的標示
// 2021 8 13 - chc
//  2. 操作指示
// 2021 8 23 - chc
// 2021 8 24 - chc
//  3. 待完成:
//     a. 量測點在WaferMap位置要經過Die中心校正: Wafer中心/Die中心/量測點/傾斜量
//     b. 到位置/WaferMap DoubleClick => 用不同顏色標示於Map圖上(要經過傾斜校正)
//     c. Map上DoubleClick可指定到Die的角落或中心
//     d. 以中心Die的中心 & Wafer中心 => 重畫Mapping圖
//
// 2021 9 23 - chc c1
// 2021 9 23a - chc a1
// 2021 9 23b - chc ButtonDelay: edButtonDelay4->Text
//
// 2021 9 30 - chc
//  1. SSIZ & Home才會變動位置: SSIZ不會動(等1000ms就好), zHome才會移動
//  2. 180度(Notch在下): 原點在左下角
//  3. 點位設定內的DieSize不作用
//  4. Side/No顯示修改
// 2021 9 30b - chc
//  5. WaitAlignerComplete(): 改成100ms, 否則反應太慢! 改用WaitTime();
// 2021 10 4 - chc
//  6. [45度量測]後Z不上升1000um, 改在[切換到5x]後Z上升1000um
//
// 2021 10 10 - chc
//  1. LP1/LP2/Aligner的Send後Status為Red: 修正
// 2021 10 17 - chc
// 2021 10 17a - chc
//  1. SECS連線 / Auto取退片作業
// 2021 10 20 - chc
//  1. ToNextWafer(): 若為SECS連線且Auto則不用重指定
//  2. Auto時也要自動做Start
//  3. 門開不會Alarm給SECS(雄旺?)
// 2021 10 20 - chc
//  4. CIS詢問機台狀態可能分成四種...Init/Idle/Run/Down
//     Init/Idle/Setup/Ready/Executing/Pause
//      => 有改變就送給SECS
//     Init: 開機/ORGN/Home
//     Idle: 已Load, 尚未取Wafer
//     Setup: 做Recipe點位設定
//     Ready: 完成Init
//     Executing: 有Wafer在裡面
//     Pause: 無此壯態
//  5. 量測時不可以用Z/T
//  6. 開程式初始為SECS連線, 並於SetupEFEM前先進行SECS Socket偵測與連線及送出Init
//
// 2021 11 9 - chc
//  1. 取片/退片過程中要設定Load/Unload為Disable
//  2. Load/Unload確認Aligher/Robot/Chuck上有無Wafer的判定除Sensor外也要看Status顏色
//
// 2021 11 11 - chc
//  1. 離線也可以自動取退片,UnLoad作業
// 2021 11 12 - chc
//  2. Aligner GPIO寫錯, 是[7-6/4] => 單動Get Aligner不會動
//  3. 取/退片pcSystem要Disalbe
//  4. Unload時: Robot有片也會做!
//     => 尚未找到原因!
// 2021 11 22 - chc
//  1. EFEM With wafer Alarm: laAlarm
//  2. 尚未檢查LP1/LP2: 是否CST上有Wafer?
//  3. 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
//  4. 加入Chuck Sensor: IsChuckWithWafer
//  5. Local/Remote mode
//  6. Robot/Chuck/Aligner切換有無片
//  7. Read INF
//
// 2021 12 9 - chc
//  1. 顯示XY所在位置距離中心點距離: 上/右為+
//  2. Die下緣中心在Wafer水平中心線上
// 2021 12 15 - chc
//  3. 到Stage取片要Reset中心點位置為空白
//  4. Wafer Mapping以有效Die區域的左下角為(0,0)
// 2021 12 15a - chc
//  5. 再畫一次: DrawBigImage
// 2021 12 18 - chc
//  6. RFID裡面要有OK, 也要送給Yuanli
//  7. Motion Busy Error Code: 造成joystick不會動!
//  Double Click Move
//  Motion Move後, Col/Row值計算
//
// 2022 1 27 - chc C02
//  1. LoopTest記錄SECS離或連線時的取退片狀態
//
// 2022 2 13 - chc C03
//  1. RCMD: 1-Cancel, 2-Abort SECSRemoteCommand
//
// 2022 3 8 - chc C04
//  1. SECS離線強制為Local
//  2. Remote: 要為SECS連線才能切換
//  3. Load前是SECS有連線且是Remote才要送出CSTREAD
//
// 2022 3 11 - chc C05
//  1. 在Local下不送給SECS
//  2. RCMD: Cancel/Abort收到後要回給SECS
//
// 2022 5 18 - chc C06
//  1. 水平與傾斜判斷: 改成80000
//  2. T Wait由30s改成40s
//  3. T Move不對再做一次
//  4. T移動無安全高度: 是Bruker系統才有
//  5. T移動不再做Over處理
// 2022 5 19 - chc
//  6. T到水平/傾斜再確認: cbTCheck->Checked
//
// 2022 6 9 - chc C07
//  1. Recipe建立: PE以上都可用
//
// 2022 12 8 - chc C08
//  1. 漏CMD_RFID處理
//  2. Start: Connect - Init間加入500ms Delay
//  3. 加入Log
//
// 2023 1 3 - chc C09
//  1. WriteRecipe(): combRecipe->ItemIndex為-1, 攔住不處理
//
// 2023 1 4 - chc C10
//  1. 分離RFID-Yuanli
//  2. 寫錯SECS/Yunli Socket Log Message
//  3. 若SECS未連線, 再連線, 10sec
//
// 2023 1 15 - chc
//  4. MoveAbsolute(): ZLimit
//
// 2023 1 28 - chc C11
//  1. edY45Offset: T45度時Y要微調
//  2. Local不亮
//
// 2023 2 7 - chc C12
//  1. Run時不可以DoubleClick
// 2023 2 8 - chc
//  2. Y45Offset Recipe Switch Update - DisplayRecipeSet()
//
// 2023 2 21 - chc C13
//  1. 將btnLoad解開 : pnlLoadPort2Presence, pnlLoadPort2Placement
//  2. 系統異常 => YuanLi未連線
//  3. SECS異常 => SECS未連線
//  4. 取消
//
// 2023 7 19 - chc
//  1. Wafer完成有專屬Color
//  2. Local/Remote: Select用底色區分
//  3. 有專屬重大Error Log顯示
//  4. Wafer所在圖示用類似單動頁面圖示
//  5. LP1/LP2可指定是否連線E84(OHT)
//  =>
//  1. 圖示
//  2. Error Log頁面 & 範例
//  3. LP1/LP2 OHT連線Check
//  4. LoadPort使用中顏色
//
// 2023 7 25 - chc
//  1. Load/UnLoad: LP1/LP2分開
//  2. Robot點位: 分上下Arm(8"/12")
//  3. OLS5000加入
//  4. 與YuanLi連線
//
//
//
//
//
//
//
//  角度計算: 除0
//    => ok
//  SECS: Mapping資料進來有Error(最後版本才有, 前一個ok)
//    => ok, pnlTraySselect25 => pnlTray25Select
//  尋邊重寫: 由最外往內找有亮點
//
//
//
//
//
//
// 說明:
//   1. PCI-8154軸控參數由BiSSMotion.xml檔決定
//   2. iC-NQC ROT Inverted決定Encoder的方向性
//
//   使用50x鏡觀察: Within Mode有問題 - 要逐步移動
//   Motion會有螺桿間隙需要補償的問題
//
//
//
#include <vcl.h>
#pragma hdrstop

#include <math.h>
#include <time.h>
#include <sys\timeb.h>
#include "MainFrm.h"

// 2021 4 15 - chc Motion LIB Mode: 8154(8158)/7856(APS)
#define MOTION_MODE_8154        0
#define MOTION_MODE_APS         1
int MotionMode = MOTION_MODE_APS;

// 2016 2 14 - chc 加入Motion
// PCI-8154 可使用8154.dll(_8154_) or APS168.dll(APS_)
// => 選用APS_(同Mask AOI 880~884; PCI-7856)
// => 有4個DIO
// 2016 11 24 - chc 改用8154
#include "pci_8154.h"
// Motion Status
bool boolMotion,boolDI,boolDO;
void __fastcall InitMotion();
void __fastcall StopAxis(int axisno);
void __fastcall MoveForward();
void __fastcall MoveBackward();

// 2016 8 26 - chc define type value: 0-wait, 1-nowait(for UpdateMotionStatus())
//void __fastcall AxisMove(int mode);
void __fastcall AxisMove(int mode, int type);

bool __fastcall MoveAbsolute(int axisno);
void __fastcall HomeOneAxis();
void __fastcall AllHome();
void __fastcall ResetCommand();
void __fastcall ResetPosition();
void __fastcall ResetErrorCounter();
void __fastcall GetAxisData(int axisno,F64 *dist,F64 *startvel,F64 *maxvel,F64 *tacc,F64 *tdec,F64 *homevel, F64 *reviewvel, F64*uplimit, F64 *lowdistance);
bool __fastcall WaitMotionDone(int axisno, int ms);
void __fastcall SetAOIPosition();
void __fastcall ToAOIPosition();

// 2016 7 9 - chc User Position
void __fastcall SetUserPosition(int no);
int __fastcall round(double f);

// 2016 5 20 - chc Load/Unload
void __fastcall SetLoadPosition();
void __fastcall ToLoadPosition();

// 2016 5 30 - chc Original
void __fastcall SetOriginalPosition();
void __fastcall ToOriginalPosition();

// 2019 7 14 - chc CCD
void __fastcall SetCCDPosition();
void __fastcall ToCCDPosition();

   // 2021 5 3 - chc RealCenter Position
void __fastcall SetRealCenterPosition();
void __fastcall ToRealCenterPosition();

// 2019 12 5 - chc TXT
void __fastcall SetTXTPosition();
void __fastcall ToTXTPosition();
void __fastcall TokmfPosition();

// 2019 7 15 - chc Area, Dot. Base
void __fastcall SetAreaPosition();
void __fastcall SetDotPosition();
void __fastcall SetBase1Position();
void __fastcall SetBase2Position();
bool __fastcall ToAreaPosition();
bool __fastcall ToDotPosition();
bool __fastcall ToBase1Position();
bool __fastcall ToBase2Position();

// 2016 7 8  - chc Last
void __fastcall SetLastPosition();
void __fastcall ToLastPosition();
void __fastcall ToUserPosition(int no);

void __fastcall UpdateMotionStatus();
void __fastcall GetCommand(int axisno, I32 *cmd);
void __fastcall GetPosition(int axisno, F64 *cmd);
bool __fastcall MoveToX(int position);

// 2021 9 11 - chc 加速: MOVE_WAIT
//bool __fastcall MoveToXY(int x, int y);
bool __fastcall MoveToXY(int x, int y, int mode);

bool __fastcall MoveToXYRatio(int x, int y, double ratio);
bool __fastcall MoveToW(int position);
void __fastcall MoveToXYZT(int x,int y,int z, int t, int mode);

// 2021 5 3 - chc 移動X
bool __fastcall MoveToAxisGap(int axisno, int offset);

// 2016 10 14 - chc X/Y Axis absolute move
bool __fastcall MoveToXYDirect(int xpos,int ypos);

bool __fastcall MoveToY(int position);
bool __fastcall MoveToZ(int position, int speed, int mode);

// 2021 9 11 - chc 加速: MOVE_WAIT
//bool __fastcall MoveToZ(int position);
bool __fastcall MoveToZ(int position, int mode);

bool __fastcall MoveToT(int position);
void __fastcall Beep(int mstime);
void __fastcall SetAlmOn();
void __fastcall SetAlmOff();
void __fastcall SetServoOn();
void __fastcall SetServoOff();
// 2016 5 11 - chc DO Reset 0
void __fastcall InitDO(int mode);

void __fastcall WaitMotionDoneXY(int mode, int ms);
void __fastcall DelayTimeM5(int no);

// 2016 8 21 - chc 等完成X/Y/T
void __fastcall WaitMotionDoneXYT(int mode, int ms);

// 2016 7 13 - chc R-Axis 90/-90 degree
void __fastcall MoveToTAdd90();
void __fastcall MoveToTSub90();

extern bool boolTMove;
// T移動後自動校正X/Y
void __fastcall ToAdjustXY();

// 2016 8 2 - chc Lens Position
void __fastcall SetLensPosition(int no);
void __fastcall ToLensPosition(int no);

// 2016 10 9 - chc Lens Z Limit
void __fastcall SetLensZLimit(int no);

// 2016 10 12 - chc 移到指定XYZ位置
void __fastcall RelativeMoveXYZ(double dx, double dy, double dz);

// 2019 11 18 - chc 移到指定XY位置
void __fastcall RelativeMoveXY(double dx, double dy);

// 2021 4 25 - chc Relative Move
void __fastcall DoRelativeMove(int axisno, int offset);

// 2021 4 29 - chc W Set
void __fastcall SetWPosition(int no);
void __fastcall ToWPositionFun(int no);

// 2021 9 11 - chc 是否加速
//bool __fastcall MoveToL(int position);
bool __fastcall MoveToL(int position, bool boolspeedup);

// 2020 2 11 - chc 基準點相對移動
void __fastcall SetMoveBasePosition();
bool __fastcall ToMoveBasePosition();
bool __fastcall WaitMotionXYDone(int ms);

// 2020 2 14a - chc ServoOn
void __fastcall ServoOn();

// 2020 2 16 - chc Save Protect
void __fastcall SetSaveProtect(int mode);

// 2020 2 17 - chc Joystick停止時還要檢查其它軸
void __fastcall StopAllAxis();

// 2021 4 21 - chc 立即停止
void __fastcall StopOneAxis(int axisno);

// 2016 4 19 - chc PCI-7856 + IO Board(ID=1)
// I/O Module 1
bool bool_IO_Status = false;
I32 IO1_ID = 1;
bool HSL_IO_InStatus[16];
unsigned int HSL_IO_OuStatus;
I32 input_IO1 = 0;
I32 AI_ID = 5;
double AIValue[16];

// 使用mkdir
#include <dir.h>

// 2020 1 5 - chc 用Joystick
#include "Joystick.h"

#define SERIES_NO       1

// 2021 4 30 - chc 改成MainForm global
int EFEMStatus = -1;

// 2021 4 30 - chc Log flag
bool boolLogDateTime = true;

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "LMDButton"
#pragma link "LMDCustomButton"
#pragma link "LMDBaseEdit"
#pragma link "LMDButtonControl"
#pragma link "LMDCheckBox"
#pragma link "LMDComboBox"
#pragma link "LMDControl"
#pragma link "LMDCustomBevelPanel"
#pragma link "LMDCustomButtonGroup"
#pragma link "LMDCustomCheckBox"
#pragma link "LMDCustomComboBox"
#pragma link "LMDCustomControl"
#pragma link "LMDCustomEdit"
#pragma link "LMDCustomGroupBox"
#pragma link "LMDCustomPanel"
#pragma link "LMDCustomPanelFill"
#pragma link "LMDCustomParentPanel"
#pragma link "LMDCustomRadioGroup"
#pragma link "LMDCustomSheetControl"
#pragma link "LMDEdit"
#pragma link "LMDGroupBox"
#pragma link "LMDPageControl"
#pragma link "LMDRadioGroup"
#pragma link "LMDThemedComboBox"
#pragma link "YbCommDevice"
#pragma link "LMDCustomMaskEdit"
#pragma link "LMDMaskEdit"
#pragma link "LMDBaseControl"
#pragma link "LMDBaseGraphicControl"
#pragma link "LMDBaseMeter"
#pragma link "LMDCustomProgress"
#pragma link "LMDGraphicControl"
#pragma link "LMDProgress"
#pragma link "LMDCustomTrackBar"
#pragma link "LMDTrackBar"
#pragma link "LMDBaseLabel"
#pragma link "LMDCustomLabel"
#pragma link "LMDLabel"
#pragma link "LMDSBar"
#pragma link "ICImagingControl3_OCX"
#pragma link "LMDBackPanel"
#pragma link "LMDSimplePanel"
#pragma resource "*.dfm"

// 2016 2 15 - chc 加入PCI-8154, 4XMO-C(32bit) <= 源自MaskAOI 7856(4XMO)
I32 pos;
I32 cmd,AxisNo;
U16 io_status;
U16 motion_status;
U8 CPLD_Ver;
U32 Kernel_Ver,Software_Ver;
I16 error_counter,CompType,ret;
I16 Home_Mode=0;
// 使用APS
I32 BoardID, BoardName, BoardHSL, BoardMNET;
I32 Board7856;
I32 StartAxisNo, FirstAxisNo, TotalAxisNo;
char MNET_BUS, HSL_BUS;
bool bool_APS_Status;
I32 X_Axis = 0;
I32 Y_Axis = 1;
I32 Z_Axis = 2;
I32 T_Axis = 3;
// Status
bool bool_X_Status;
bool bool_Y_Status;
bool bool_Z_Status;
bool bool_T_Status;

// 2021 3 22 - chc L/RX
I32 L_Axis = 4;
I32 W_Axis = 5;
bool bool_L_Status;
bool bool_RX_Status;
I32 StartAxisNo2, FirstAxisNo2, TotalAxisNo2;

// I/O Module: Bit0~3
bool IO_InStatus[4];
unsigned int IO_OuStatus;

// 2016 3 31 - chc 讀取網路卡序號
#include "iphlpapi.h"
#include "LicenseCode.h"

// 2016 4 16 - chc Basler Pylon
//-Basler acA1300 Thread--------------------------------------------------------
#include "scA1300Thread.h"
TscA1300 *scA1300Thread = NULL;
// scA1300-gm
#include <pylonc/PylonC.h>
#define CHECK( errc ) if ( GENAPI_E_OK != errc ) ErrorAndExit( errc )
GENAPIC_RESULT          res;                    // Return value of pylon methods.
size_t                  numDevices;             // Number of available devices.
PYLON_DEVICE_HANDLE     hDevscA1300;            // Handle for the pylon device.
PYLON_DEVICE_HANDLE     hDevacA2040;            // Handle for the pylon device.
const int               numGrabs = 10;          // Number of images to grab.
int32_t                 payloadSize;            // Size of an image frame in bytes.
unsigned char*          imgBuf;                 // Buffer used for grabbing.
//unsigned char*          imgBuf[3];            // Buffer used for grabbing.
_Bool                   isAvail;
//調色盤變數
#include <Graphics.hpp>
bool mcolor;
unsigned long GigaWidth,GigaHeight,AlignWidth,AlignHeight;
Graphics::TBitmap *pBitmap;
typedef struct {
   TLogPalette lpal;
   TPaletteEntry dummy[256];
} LogPal;
// Stream Grabber Handle/Object
PYLON_STREAMGRABBER_HANDLE hStg;
PYLON_WAITOBJECT_HANDLE    hWobj;
// GigE CCD : scA1300
bool bool_scA1300_Status;
PylonGrabResult_t grabResult;
_Bool bufferReady;
bool boolInGigaBuffer = false;

// 2016 4 16 - chc 不同CCD對應不同的程式碼
bool boolInGigaBufferAry[3] = {false};
PylonGrabResult_t grabResultAry[3];
_Bool bufferReadyAry[3];
PYLON_DEVICE_HANDLE     hDevGigaAry[3];                                         // Handle for the pylon device.
unsigned char*          imgBufAry[3];                                           // Buffer used for grabbing.
struct CCDINFO_STRU        {
   int Width,Height;
   int No;
   int PixelSize;
   int Type;
   int TotalSize;
   AnsiString Name;
   AnsiString DeviceID;
};
struct CCDINFO_STRU        CCDInfoAry[3];
TscA1300 *scA1300ThreadAry[3] = {NULL};
bool bool_scA1300_StatusAry[3] = {false, false, false};
int CCDSelectNo = -1;

// 2016 5 10 - chc Motion State: 由Motion.cpp移過來
bool boolMotionState;

// 2019 7 15 - chc Motion ccd的精度: 4X
//double MotionCCDPrecision = 4.4;
double MotionCCDPrecision = 1.1;

// Table標示範圍: Motion CCD
int Tx1 = -405201;
int Ty1 = 214318;
int Tx2 = 4527086;
int Ty2 = 6126607;

// Table標示範圍: Bruker CCD
int Vx1 = 649921;
int Vy1 = 308814;
int Vx2 = 5367962;
int Vy2 = 6088443;

// Lens標示範圍: Bruker CCD
int Bx1 = 890446;
int By1 = 602533;
int Bx2 = 5022760;
int By2 = 6081779;

// 2021 4 11 - chc Rorze
// Aligner
bool boolWaitAlignerComplete = false;
bool boolAlignerComplete = false;
void __fastcall DelayTimeRobot(int no);                                         // Robot
// Robot
bool boolWaitRobotComplete = false;
bool boolRobotComplete = false;
// LoadPort1
bool boolWaitLoadPort1Complete = false;
bool boolLoadPort1Complete = false;
// LoadPort2
bool boolWaitLoadPort2Complete = false;
bool boolLoadPort2Complete = false;

// 2021 4 11 - chc EFEM
// 1 - Hirata, 2 - Rorze
#define EFEM_HIRATA             1
#define EFEM_RORZE              2
int EFEMMode = EFEM_RORZE;

//---------------------------------------------------------------------------
// 2016 4 17 - chc NCC
#include "iMatchDLL\iVisionErrs.h"
#include "iMatchDLL\iVision_Types.h"
#include "iMatchDLL\iVision.h"
#include "iMatchDLL\iImage.h"
#include "iMatchDLL\iMatch.h"
LONG_PTR ColorImg,ColorLearnImg,GrayImg,GrayLearnImg;
LONG_PTR iMatchModel;

// 2023 8 1 - chc init ViewWorks CCD
int GetCustomCommand(VWSDK::HCAMERA hCamera, char* cpFeatureName, UINT* unValue, VWSDK::GET_CUSTOM_COMMAND eCmdType);
void GetDeviceInfo(int nIndex, AnsiString *strVenderName, AnsiString *strModelName, AnsiString *strDeviceVersion, AnsiString *strDeviceID);
void MakeUnPackedBuffer();
bool boolVworksCCD = false;


TMainForm *MainForm;
//---------------------------------------------------------------------------
// 2021 9 25 - chc 月日: MMDD
AnsiString MMDD;

__fastcall TMainForm::TMainForm(TComponent* Owner)
        : TForm(Owner)
{

   // 2016 2 19 - chc System Path
   char CurrentDir[250];
   GetCurrentDirectory(sizeof(CurrentDir),CurrentDir);
   SystemDirectory = AnsiString(CurrentDir);
   // 建立Log檔名
   LogDirectory = SystemDirectory + "\\Log";
   if(!DirectoryExists(LogDirectory))
      mkdir(LogDirectory.c_str());
   AnsiString temp;
   DateTimeToString(temp,"yyyymmddhhnnss",Now());
   LogFileName = LogDirectory + "\\" + temp + ".log";
   WriteSystemLog(">>Log Ok");

   // 2021 9 25 - chc 月日: MMDD
   DateTimeToString(MMDD,"mmdd",Date());

   // 2020 5 20a - chc Error Log
   ErrorLogFileName = SystemDirectory + "\\SystemError.log";
   SystemHelpFileName = SystemDirectory + "\\SystemHelp.txt";

   // 2023 7 19 - chc Alarm Log
   AlarmLogFileName = SystemDirectory + "\\SystemAlarm.log";

   // Recipe
   RecipeDirectory = SystemDirectory + "\\Recipe";
   if(!DirectoryExists(RecipeDirectory))
      mkdir(RecipeDirectory.c_str());
   ExportDirectory = SystemDirectory + "\\Export";
   if(!DirectoryExists(ExportDirectory))
      mkdir(ExportDirectory.c_str());
   DatabaseDirectory = SystemDirectory + "\\Database";
   if(!DirectoryExists(DatabaseDirectory))
      mkdir(DatabaseDirectory.c_str());

   // 2016 4 16 - chc 建立BaslerBitmapDirectory
   BaslerBitmapDirectory = SystemDirectory;

   // 2016 7 20 - chc 建立PointDirectory
   PointDirectory = SystemDirectory + "\\Point";
}
//---------------------------------------------------------------------------
__fastcall TMainForm::~TMainForm()
{

   // 2023 8 2 - chc Position
   pnlHomeStep->Left = 380;
   pnlHomeStep->Top = 264;
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::FormShow(TObject *Sender)
{
AnsiString name;

   // 2022 2 13 - chc RCMD: 1-Cancel, 2-Abort SECSRemoteCommand
   SECSRemoteCommand = SECS_REMOTE_NONE;

   // 2021 10 7 - chc 不能在這裡設定: true-正常, false-異常
   boolEFEMVacuum = true;
   boolEFEMCDA = true;
   boolSystemCDA = true;
   boolSystemVacuum = true;

   // 2020 8 12 - chc TSMC修改
   boolPCDoor = false;
   boolPower = false;
   boolLeftMaintenanceDoor = false;
   boolRightMaintenanceDoor = false;
   boolInspectDoor = false;
   boolRedLamp = false;
   boolBuzzer = false;
   boolEFEMError = false;
   pnlRobotErrorCode1->Caption = "";
   pnlAlignerErrorCode1->Caption = "";

   // 2021 9 20a - chc ALarm
   boolCSTWithoutWafer = false;
   boolChuckWithoutWafer = false;
   boolAlignerWithoutWafer = false;
   boolWAxisPositionError = false;
   boolChuckPositionError = false;
   boolWaferNotSpecified = false;
   boolCSTWithWafer = false;
   boolChuckWithWafer = false;
   boolAlignerWithWafer = false;
   boolCenterPointError = false;
   boolImageRecognitionError = false;
   boolWorkflowError = false;
   boolPerformUnauthorizedFunction = false;

   // 2021 6 30 - chc 監看Aligner
   boolAlignerMonitor = false;

   // 2021 5 9 - chc
   boolLP1CassetteMapping = false;
   boolLP2CassetteMapping = false;

   // 2021 5 8 - chc 加入Olympus/SECS socket error
   boolYuanliSocket = false;
   boolSECSSocket = false;

   // 2020 7 15 - chc 記錄是否在Update?
   boolInMotionUpdate = false;

   // 2020 5 21 - chc 記錄Chuck有Wafer
   boolChuckWithWafer = false;

   // 2020 5 21 - chc 記錄是否開始做DIO
   boolDIO = false;

   // 2019 11 26 - chc 軸控異常
   boolMotionError = false;

   // 2016 10 12 - chc AF state
   boolAFState = false;

   // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   boolInLoadWafer = false;
   boolInUnloadWafer = false;;

   // 2016 10 12 - chc Measure
   MeasureState = 0;
   Mx1 = My1 = Mx2 = My2 = -1;

   // Set windows size
   MainForm->Width = 1920;
   //MainForm->Height = 1044;
   MainForm->Height = 1045;

   pnlPattern->Left = 52;
   pnlPattern->Top = 90;

   // 2021 5 8 - chc Button
   btnFocusDone->Top = 399;
   btnFocusDone->Left = 816;

   // 2021 9 30 - chc 定義pnlFocusDone位置
   pnlFocusDone->Top = 399;
   pnlFocusDone->Left = 48;

   // 2022 1 3 - chc 定義pnlFocusDoneE位置
   pnlFocusDoneE->Top = 455;
   pnlFocusDoneE->Left = 48;

   // 2019 7 15 - chc Area / Point title
   AreaPointTitle();

   pcOP->ActivePage = tsRun;

   boolUpdateLastPosition = true;

   // 2016 7 24 - chc Blinking
   // 2016 7 26 - chc 改成true, 要Blinking
   //boolStartState = false;
   boolStartState = true;

   boolAllHomeState = true;

   // 2016 7 27 - chc Check front door
   boolSystemStarted = false;

   sbSystemMessage->Panels->Items[2]->Text = "C13";
   WriteSystemLog(">>Version : C13");

   // 產生ini檔名與目錄名
   SystemINIFilename = SystemDirectory + SYSTEM_INI_FILENAME;

   // 2016 7 9 - chc User filename: UserPosition.ini
   UserINIFilename = SystemDirectory + USER_INI_FILENAME;

   // 2021 4 22 - chc RobotRX.ini檔名與目錄名
   RobotWINIFilename = SystemDirectory + ROBOTW_INI_FILENAME;

   // 2016 7 29 - chc Log
   WriteSystemLog(">>LoadSystemParameter()");
   LoadSystemParameter();

   // 2020 5 4 - chc Read Aligner Parameters
   LoadAlignerParameter();

   // 2016 10 12 - chc Lens filename: LensPosition.ini
   LaserINIFilename = SystemDirectory + LASER_INI_FILENAME;

   // 2016 12 30 - chc Speed ini
   SpeedINIFilename = SystemDirectory + SPEED_INI_FILENAME;

   // 2016 10 9 - chc Read Lens Center and Laser Center
   LoadLaserPosition(LensNo);

   // 2016 12 30 - chc Load Speed Parameter
   LoadSpeedParameter();

   // 2016 12 30 - chc Speed ini
   FocusINIFilename = SystemDirectory + FOCUS_INI_FILENAME;
   LoadFocusParameter();

   // 2016 7 29 - chc Log
   WriteSystemLog(">>LoadUserPosition()");

   // 2016 7 9 - chc Position Move
   LoadUserPosition();

   // 2020 2 14 - chc Load Joystick
   LoadJoystick();

   // 2022 5 17 - chc 移到前面
   if(boolForTest == true)
      LoadUser();

   // 2021 4 21 - chc Load W Position: RobotW.ini
   LoadWPosition();

   // 2020 2 16 - chc Save Protect
   LoadSafe();

   // 2020 6 22 - chc 維護模式
   ReadMaintenanceMode();

   // 2021 6 3 - chc Alarm
   LoadAlarmParameter();

   // 2023 7 25 - chc Load System Parameters
   LoadSystemConfigParameters();

   // 2019 11 29 - chc initial 要為0
   LensNo = 0;

   // 2016 8 2 - chc Load Lens Position
   // Lens filename: LensPosition.ini
   LensINIFilename = SystemDirectory + LENS_INI_FILENAME;
   WriteSystemLog(">>LoadLensPosition()");
   LoadLensPosition(LensNo);

   // 2016 12 22 - chc Load Factor
   // Calibration.ini
   WriteSystemLog(">>LoadCalibrationFactor()");
   LoadCalibrationFactor();

   // 2019 6 24 - chc 切換Recipe: 讀取亮度值
   WriteSystemLog(">>ReadLEDValue()");
   ReadLEDValue();

   // 2019 6 24 - chc LED 2
   WriteSystemLog(">>InitLampControl2()");
   InitLampControl2();

 // 2016 9 21 - chc for Magnification settting: lens.txt must read before LoadWDIParameter
 // try-catch
 try {
   // Load Lens Name: mag, type
   for(int i=0 ; i<6 ; i++) {
      LensInfo[i].Mag = "NA";
      LensInfo[i].Name = "";
      LensInfo[i].Magnification = 5;
   }
   if(FileExists(SystemDirectory+"\\Lens.txt")) {
      FILE *fp;
      char smag[50],stype[50];
      if((fp = fopen((SystemDirectory+"\\Lens.txt").c_str(),"r")) != NULL) {
         for(int i=0 ; i<6 ; i++) {
            if(feof(fp))
               break;
            fscanf(fp,"%s %s\n",smag, stype);
            LensInfo[i].Mag = UpperCase(smag);
            LensInfo[i].Name = UpperCase(stype);

            // 2021 4 23 - chc 屬於WDI
            /*
            // 2016 9 21 - chc Magnification
            // Sets the objective lens magnification for a specified objective lens number.
            // The supported magnification values are: 2x, 5x, 7x, 10x, 20x, 50x, and 100x.
            int pos = LensInfo[i].Mag.Pos("X");
            if(pos > 0) {

               // 2016 12 8 - chc 會有2.5x
               //LensInfo[i].Magnification = LensInfo[i].Mag.SubString(1,pos-1).ToInt();
               LensInfo[i].Magnification = (int)LensInfo[i].Mag.SubString(1,pos-1).ToDouble();

            }
            else {
               LensInfo[i].Magnification = 5;
            }

            TLabel *label;
            // Motion - Move to Center
            label = (TLabel*)(FindComponent("laCCDPrecision" + IntToStr(i+1)));
            label->Caption = LensInfo[i].Mag + " " + LensInfo[i].Name;
            if(LensInfo[i].Mag == "NA") {
               label->Font->Color = clSilver;
            }
            // Microscope - LLC : btnLens1Position
            TLMDButton *button;
            button = (TLMDButton*)(FindComponent("btnLens" + IntToStr(i+1) + "Position"));
            button->Caption = LensInfo[i].Mag + " " + LensInfo[i].Name;
            if(LensInfo[i].Mag == "NA") {
               button->Font->Color = clSilver;
               button->Enabled = false;
            }
            // Decide color of font
            else {
               if(LensInfo[i].Name.SubString(1,1) == "N" || LensInfo[i].Name.SubString(1,1) == "I")
                  button->Font->Color = clRed;
               else if(LensInfo[i].Name.SubString(1,1) == "G")
                  button->Font->Color = clGreen;
               else if(LensInfo[i].Name.SubString(1,1) == "U")
                  button->Font->Color = clPurple;
            }

            // System : btnLens1
            button = (TLMDButton*)(FindComponent("btnLens" + IntToStr(i+1)));
            button->Caption = LensInfo[i].Mag + " " + LensInfo[i].Name;
            if(LensInfo[i].Mag == "NA") {
               button->Font->Color = clSilver;
               button->Enabled = false;

               // 2019 12 3 - chc 也取消顯示
               button->Visible = false;
               DisVisibleLensData(i+1);

            }
            // Decide color of font
            else {
               if(LensInfo[i].Name.SubString(1,1) == "N" || LensInfo[i].Name.SubString(1,1) == "I")
                  button->Font->Color = clRed;
               else if(LensInfo[i].Name.SubString(1,1) == "G")
                  button->Font->Color = clGreen;
               else if(LensInfo[i].Name.SubString(1,1) == "U")
                  button->Font->Color = clPurple;
            }
            */

         }
         fclose(fp);
      }
   }
 }
 catch(Exception &e) {
    WriteSystemLog("LoadLensTxt() - Error");
    sbSystemMessage->Panels->Items[1]->Text = "LoadLensTxt() - Error";
 }

   WriteSystemLog(">>After Parameter Loaded: Motion");

   ResetValue = 0;

   // 2016 2 22 - chc 載入txt檔: Type/Product/Operator/Spec/Mode/Recipe
   // LotNo/SN/ID
   cbType->Items->LoadFromFile(SystemDirectory+"\\Type.txt");
   cbProduct->Items->LoadFromFile(SystemDirectory+"\\Product.txt");
   cbOperator->Items->LoadFromFile(SystemDirectory+"\\Operator.txt");
   cbSpec->Items->LoadFromFile(SystemDirectory+"\\Spec.txt");
   cbMode->Items->LoadFromFile(SystemDirectory+"\\Mode.txt");

 // 2016 7 30 - chc try-catch
 try {

   // 2021 8 24 - chc 先Reset為0
   RecipeCurNo = 0;

   // 要由\Recipe內讀取.ini檔: 建立Recipe.txt
   AnsiString recipename,findname,fname;
   TSearchRec sr;
   int iAttributes = 0;
   int rno = 0;
   //faReadOnly	  $00000001	  Read-only files
   //faHidden	  $00000002	  Hidden files
   //faSysFile	  $00000004	  System files
   //faVolumeID	  $00000008	  Volume ID files
   //faDirectory  $00000010	  Directory files
   //faArchive	  $00000020	  Archive files
   //faAnyFile	  $0000003F	  Any file
   recipename = SystemDirectory + "\\Recipe.txt";
   FILE *fp;
   fp = fopen(recipename.c_str(),"w+t");
   findname = RecipeDirectory + "\\*.ini";
   iAttributes |= faArchive;
   RecipeTotalNo = 0;
   if(FindFirst(findname, iAttributes, sr) == 0) {
      do {
         if((sr.Attr & iAttributes) == sr.Attr) {                               // 檔名在sr.Name
            fname = sr.Name.SubString(1,sr.Name.Length()-4);                    // 全檔名
            fprintf(fp,"%s\n",fname.c_str());

            // 2021 8 24 - chc 核對RecipeName
            if(RecipeName == fname) {
               RecipeCurNo = rno;
            }

            rno++;
            if(ReadRecipe(sr.Name) == true) {
               RecipeTotalNo++;
               if(RecipeTotalNo >= RECIPE_MAX)
                  break;
            }
         }
      } while (FindNext(sr) == 0);
   }
   FindClose(sr);
   fclose(fp);
   cbRecipe->Items->LoadFromFile(SystemDirectory+"\\Recipe.txt");
   combRecipe->Items->LoadFromFile(SystemDirectory+"\\Recipe.txt");
   if(rno > 0) {

      // 2021 8 24 - chc 核對RecipeName
      if(RecipeCurNo > 0) {
         cbRecipe->ItemIndex = RecipeCurNo;
         combRecipe->ItemIndex = RecipeCurNo;
         cbRecipe->Text = RecipeName;
         combRecipe->Text = RecipeName;
      }
      else {

         RecipeCurNo = 0;
         RecipeName = RecipeBuffer[0].Name;
         cbRecipe->ItemIndex = 0;
         combRecipe->ItemIndex = 0;
         cbRecipe->Text = RecipeBuffer[0].Name;
         combRecipe->Text = RecipeBuffer[0].Name;
      }

      // 2016 12 29 - chc 顯示目前Recipe
      pnlRecipeSet->Caption = cbRecipe->Text;

      DisplayRecipe(0);
      UpdateRecipe();

      // 2019 12 13a - chc 也要顯示Run資訊
      pnlRunRecipe->Caption = cbRecipe->Text;
      pnlRunAreaTNo->Caption = edAreaTNo->Text;
      pnlRunDotTNo->Caption = edDotTNo->Text;

   }
   else {
      cbRecipe->Items->Clear();
      cbRecipe->Text = "";
      cbRecipe->ItemIndex = -1;
      combRecipe->ItemIndex = -1;
      combRecipe->Text = "";
      RecipeCurNo = 0;
   }

 // 2016 7 30 - chc try-catch
 }
 catch(Exception &e) {
    WriteSystemLog("LoadRecipe() - Error");
    sbSystemMessage->Panels->Items[1]->Text = "LoadRecipe() - Error";
 }

   // 2016 4 16 - chc 進行SetupMotion時間
   SetupTimeCount = 0;
   boolSetupTime = false;

   // 2020 1 5 - chc Joystick
   InitJoystick(Handle);

   // 2023 8 2 - chc Init Start
   pnlHomeStep->Visible = true;
   pnlMotionUnit->Caption = "Initialize...";

   // 2016 4 18 - chc Motion: PCI8158/7856-DI16DO16
   SetupMotion();

   if(MotionMode == MOTION_MODE_APS) {
      pnl8154Status->Visible = false;
      la8154Status->Visible = false;
   }
   if(boolMotion == true) {
      pnl8154Status->Color = clLime;
      // 設定成可操作: 軸控參數
      pcMotion->Enabled = true;

      // 2023 8 2 - chc Step
      pnlMotionUnit->Caption = "Completed.";

   }
   else {
      pnl8154Status->Color = clRed;

      // 2023 8 2 - chc Step
      pnlMotionUnit->Caption = "Fail!";
      pnlMotionUnit->Font->Color = clRed;

      // 2021 9 5 - chc CCD Error
      // Code,Set/Reset,Level,Message
      SetSECSAlarm(21001,1,1,"Motion Device Abnormal");
      if(boolDI == false || boolDO == false)
         SetSECSAlarm(22001,1,1,"DIO Device Abnormal");

   }

   // 2016 11 25 - chc Log
   //WriteSystemLog("SetupscA1300()...");
   WriteSystemLog("Setup CCD...");

   // 2023 8 2 - chc Init Start
   pnlInspCCDUnit->Caption = "Initialize...";

   // 2023 6 5 - chc init ViewWorks CCD
   InitVworks();
   if(boolVworksCCD == true) {
      pnlOpenCCD->Color = clLime;

      // 2023 8 2 - chc Init Start
      pnlInspCCDUnit->Caption = "Completed.";

   }
   else {
      pnlOpenCCD->Color = clRed;

      // 2023 8 2 - chc Init Start
      pnlInspCCDUnit->Caption = "Fail!";
      pnlInspCCDUnit->Font->Color = clRed;

   }

   // 2023 8 2 - chc Init Start
   pnlMatchCCDUnit->Caption = "Initialize...";

   // 2016 4 16 - chc scA1300 CCD
   // .2(Review)
   SetupscA1300();                                                              // 要個自啟動Thread來取像
   if(bool_scA1300_StatusAry[0] == true) {
      pnlCCDStatus->Color = clLime;
      AlarmStatus.boolReviewCCD = false;

      // 2023 8 2 - chc Init Start
      pnlMatchCCDUnit->Caption = "Completed.";

   }
   else {
      pnlCCDStatus->Color = clRed;
      btnReviewLive->Enabled = false;
      AlarmStatus.boolReviewCCD = true;
      UpdateAlarmStatus();

      // 2021 9 5 - chc CCD Error
      // Code,Set/Reset,Level,Message
      SetSECSAlarm(15001,1,1,"CCD Abnormal");

      // 2023 8 2 - chc Init Start
      pnlMatchCCDUnit->Caption = "Fail!";
      pnlMatchCCDUnit->Font->Color = clRed;

   }

   // 2016 11 25 - chc Log
   WriteSystemLog("Setup Database...");

   // Database
   tblData->DatabaseName = DatabaseDirectory;
   tblData->TableName = "HDData.db";
   tblHD->DatabaseName = DatabaseDirectory;
   tblHD->TableName = "HD.db";
   AnsiString temp;
   DateTimeToString(temp,"yyyymmddhhnnss",Now());
   edLotNo->Text = temp;

   // 位置
   pnlMotionZero->Left = 904;
   pnlMotionZero->Top = 144;
   pnlError->Left = 352;
   pnlError->Top = 336;
   pcSystem->ActivePage = tsSystem;
   pcMotion->ActivePage = tsMotionStatus;

   // 2016 11 25 - chc Log
   WriteSystemLog("Load User.ini...");

   // 2016 2 25 - chc User
   // Password: User.ini
   UserTitle();
   LoadUser();
   PriorityLevel = PRIORITY_OP;
   SwitchLevel();
   pnlPassword->Left = 655;
   pnlPassword->Top = 99;
   // 先確認help.txt檔是否存在?
   SystemHelpFilename = SystemDirectory + SYSTEM_HELP_FILENAME;
   if(FileExists(SystemHelpFilename))
      mmHelp->Lines->LoadFromFile(SystemHelpFilename);

   // 2020 5 6 - chc 先設定顯示頁面
   SetLevel(false);

   // 2016 3 7 - chc 將畫面存成bmp file
   SaveBMPSerialNo = 1;

   // 2016 11 25 - chc Log
   WriteSystemLog("Check License...");

   // 2016 3 31 - chc License code
   ExitYes = false;
   //MACAddress = GetMACAddress();
   //first: CCDSN = "21244744";                                                 // License Code=9QI9I-JLAFP-58CMR-GA9VJ
   //second: CCDSN = "21790894";                                                 // License Code=HQO90-HTUNP-W3UWO-0I9EK
   //CCDSN = "21244744";
   //CCDSN = "21790894";
   // 2016 11 25 - chc 不檢查License
   /*
   MACAddress = CCDSN;
   if(CheckMACAddress() == false) {
      Application->MessageBox("Invalid License! Please contact HD", " License Checking", MB_OK);
      ExitYes = true;
   }
   */

   // Beep
   // Shorter
   //Beep(300);
   Beep(100);

   MainForm->Top = 0;
   MainForm->Left = 4;

   // 2016 11 25 - chc Log
   WriteSystemLog("Init CCD Buffer...");

   // 2016 4 17 - chc 強制為Color CCD : 1278*958, 3.75um
   if(numDevices == 0) {

      // 2023 8 2 - chc Init Start
      pnlMatchCCDUnit->Caption = "Fail!";
      pnlMatchCCDUnit->Font->Color = clRed;

      // 2021 4 19 - chc Log
      WriteSystemLog("未偵測到CCD! 強制設為Color CCD: 1280*1014");

      // 2016 10 23 - chc Set size of usb_ImageAry[0]
      // 2016 11 28 - chc ImagingSource 1280*1024
      //GigaWidth = 1278;
      //GigaHeight = 958;
      // 2021 5 4 - chc 設為灰階
      //GigaWidth = 1280;
      //GigaHeight = 1024;
      //usb_ImageAry[0].SetSize(GigaWidth,GigaHeight);
      //CCDInfoAry[0].Type = BASLER_CCD_COLOR;
      //usb_ImageROIAry[0].Attach(&usb_ImageAry[0]);
      //usb_ImageMarkROIAry[0].Attach(&usb_ImageAry[0]);
      //CCDInfoAry[0].Width = 1280;
      //CCDInfoAry[0].Height = 1024;
      GigaWidth = 1600;
      GigaHeight = 1200;
      CCDInfoAry[0].Width = GigaWidth;
      CCDInfoAry[0].Height = GigaHeight;
      CCDInfoAry[0].Type = BASLER_CCD_BW;
      scA1300ImageAry[0].SetSize(GigaWidth,GigaHeight);
      scA1300ImageROIAry[0].Attach(&scA1300ImageAry[0]);
      scA1300ImageROIAry[0].Attach(&scA1300ImageAry[0]);

   }

   imCCD->Left = 43;
   imCCD->Top = 42;
   imCCD->Width = 1120;
   imCCD->Height = 834;

   // 2016 10 30 - chc CCD FOV vs CCDImage Area
   CCDDx = CCDInfoAry[0].Width - imCCD->Width;
   CCDDy = CCDInfoAry[0].Height - imCCD->Height;
   CCDRangeX = CCDDx / 2;
   CCDRangeY = CCDDy / 2;

   // 2021 4 27 - chc Log
   //WriteSystemLog("CCD width,height,w,h,Cx,Cy,Rx,Ry= " + IntToStr(CCDInfoAry[0].Width) + "," + IntToStr(CCDInfoAry[0].Height) + "," +
   //                                                      IntToStr(imCCD->Width) + "," + IntToStr(imCCD->Height) + "," +
   //                                                      IntToStr(CCDDx) + "," + IntToStr(CCDDy)+ "," +
   //                                                      IntToStr(CCDRangeX) + "," + IntToStr(CCDRangeY));

   // 2016 11 25 - chc Log
   WriteSystemLog("Setup NCC...");

   // 2023 8 2 - chc Init Start
   pnlMatchKernelUnit->Caption = "Initialize...";
   if(CheckNCCMatch() == false) {
      pnlMatchKernelUnit->Caption = "Fail!";
      pnlMatchKernelUnit->Font->Color = clRed;
   }
   else {
      pnlMatchKernelUnit->Caption = "Completed.";
   }

   // NCC
   //if(CheckNCCMatch() == false) {
   //   pnlSystemMessage->Caption = "NCC Dongle Not Exist!";
   //}
   // 2016 11 25 - chc No NCC
   // 2019 7 19 - chc 有Match, 要做
   ColorImg = CreateColoriImage();
   ColorLearnImg = CreateColoriImage();
   GrayImg = CreateGrayiImage();
   GrayLearnImg = CreateGrayiImage();
   iMatchModel = CreateNCCMatch();

   // 指定各Panel位置
   pnlDoorOpen->Left = 312;
   pnlDoorOpen->Top = 278;
   pnlAxisError->Left = 360;
   pnlAxisError->Top = 350;

   // 2023 8 2 - chc 不需要
   //pnlStartMessage->Left = 320;
   //pnlStartMessage->Top = 517;
   pnlStartMessage->Left = 380;
   pnlStartMessage->Top = 500;

   pnlPassword->Left = 655;
   pnlPassword->Top = 99;
   pnlError->Left = 583;
   pnlError->Top = 512;
   btnMotionReset->Left = 408;
   btnMotionReset->Top = 592;

   // 2021 8 13 - chc 位置
   pnlMoving->Top = 93;
   pnlMoving->Left = 272;

   // 是否執行過Home?
   boolHomeDone = false;
   WriteSystemLog("Init: Do SetMotionStatus(). - False");
   SetMotionStatus();

   // 2021 4 19 - chc 先等候才做Home: AxisSVON()
   //btnHome->Enabled = true;
   //pnlStartMessage->Visible = true;
   //pnlStartMessage->Caption = "Please execute homing...";

   // 記錄是否有開門或按下EMC
   boolDoorEMC = false;

   tmSystem->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tmSystem");

   // 2016 5 11 - chc 黃燈
   tm500ms->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tm500ms");

   // 2016 11 16 - chc 300ms單獨處理X/Y/Z/T執更新
   tm250ms->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tm250ms");

   // 2016 7 24 - chc Eanble timer
   // 2021 10 15 - chc for test
   if(boolForTest == false)

      tm400ms->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tm400ms");

   // 2016 6 4 - chc From Relative Move
   boolRelativeMove = false;

   // 2016 10 30 - chc Set Laser Machine
   boolSetLaserAperture = false;
   boolToSameSize = false;

   // 2016 11 25 - chc 初始軸 <= Apple
   CurrentAxisNo = X_AXIS;
   combAxis->ItemIndex = 0;

   // 2016 11 25 - chc Log
   WriteSystemLog("FormShow Completed.");
   // 將MainForm置於最上端, 左右中間(Position要設為poDefault才行)
   MainForm->Top = 0;
   MainForm->Width = MASTER_SCREEN_WIDTH;
   MainForm->Left = (MASTER_SCREEN_WIDTH - MainForm->Width)/2;

   // 2016 12 30 - chc Lens Controller init

   // 2020 1 5 - chc for test
   if(boolForTest == true) {
      pcMotion->Enabled = true;
      tsMotion->Enabled = true;
      btnSetLimit->Visible = true;
      pnlSetLimit->Visible = true;
      btnTargetPosition->Visible = true;
      pnlTargetPosition->Visible = true;
   }

   // 2020 1 5 - chc Joystick
   if(boolJoystick == true) {
      MainForm->tmJoystick->Enabled = true;

      // 2020 4 16 - chc Log -> Timer問題
      WriteSystemLog(">>[Timer]: tmJoystick - 1");

   }

   // 2021 5 6 - chc 先不顯示原點復歸
   if(pnlHome2->Visible == true)
      pnlHome2->Visible = false;

   // 2020 2 14a - chc 監控是否發生Power Off
   boolMotionPowerOff = false;

   // 2020 2 16 - chc 記錄目前做連續移動中: 軸與移動方向(1/2: 正/反, 0-沒有移動)
   MoveDirection = 0;
   MoveIgnore = false;

   // 2020 2 28 - chc 取消不顯示
   NonVisible();

   // 2019 12 18 - chc 位置
   pnlMatchError->Left = 1224;
   pnlMatchError->Top = 728;

   // 2020 3 17 - chc EFEM: Robot/LoadPort/Aligner ComPort & Communication(ORGN/STAS/ORGN)
   // 2020 4 27 - chc Motion Done後要由Timer來做
   // => 因有W軸, 故要於AllHome()前做EFEM才行, 尤其是Robot上是否有片及是否有做ORG?
   //    Timer啟動(1000ms), 做完後才顯示做"原點復歸"
   //if(SetupEFEM() == false) {
   //   pnlEFEMReady->Color = clRed;
   //   pnlLeftWindow->Color = clGray;
   //}
   //else {
   //   pnlEFEMReady->Color = clLime;
   //   pnlLeftWindow->Color = clSilver;
   //}
   boolEFEMStatus = false;
   tmSetupEFEM->Enabled = true;

   // 2020 5 20 - chc init Com Port
   boolRobotStatus = false;
   RobotButton();
   boolLoadPortStatus = false;
   LoadPortButton(0);
   boolAlignerStatus = false;
   AlignerButton();

   // Wafer Map: 1.1um, 12"/8"
   sbWaferMap->Left = pnlLeftWindow->Left;
   sbWaferMap->Top = pnlLeftWindow->Top;
   sbWaferMap->Width = pnlLeftWindow->Width;
   sbWaferMap->Height = pnlLeftWindow->Height;
   //imWaferMap->Width = 27272727;
   //imWaferMap->Height = 27272727;

   InitWaferMap();

   // 2023 8 2 - chc Init Start
   pnlCDAVacuumUnit->Caption = "Initialize...";

   // 2020 5 20a - chc 若HomeDone檢查Vacuum, CDA
   // => 先不做檢查, 待SetupEFEM後再檢查
   WriteSystemLog("FormShow完成: 檢查Vacuum, CDA");
   boolCDAVacuum = false;
   CheckCDAVacuum();
   LoadErrorLog();
   LoadAlarmLog();

   // 2023 8 2 - chc Init Start
   // => 此時DIO pooling尚未運作
   //if(boolCDAVacuum == false) {
   //   pnlCDAVacuumUnit->Caption = "Fail!";
   //   pnlCDAVacuumUnit->Font->Color = clRed;
   //}
   //else {
   //   pnlCDAVacuumUnit->Caption = "Completed.";
   //}

   // 2021 4 25 - chc 指定為Lens#3(50x)
   LensNo = 3;

   // 2021 5 5 - chc 是否送出Command
   boolSendSCESCommand = false;
   boolSendYuanliCommand = false;

   // 2021 4 25 - chc YuanLi Socket
   SetCmdSet();
   SetSECSCmdSet();
   boolInMeasure = false;

   // 2020 7 14 - chc Check Door
   //CheckStageDoor();

   // 2021 10 24 - chc fot Test
   if(boolForTest == false) {
      laTestX->Visible = false;
      laTestY->Visible = false;
      edTestX->Visible = false;
      edTestY->Visible = false;
   }
   else {
      laTestX->Visible = true;
      laTestY->Visible = true;
      edTestX->Visible = true;
      edTestY->Visible = true;
   }

   // 2021 12 18 - chc Load Mode Parameter
   LoadModeParameter();

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::FormClose(TObject *Sender, TCloseAction &Action)
{

   if(ExitYes == true)
      goto toexit;

   if(Application->MessageBox("Sure to Exit System?      ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      Action = caNone;
      return;
   }

toexit:

   // 2020 5 12 - chc 若已Load要先UnLoad
   if(pnlLoadPortLoad->Color == clLime && btnCassetteLoad->Caption == "UnLoad") {
      if(Application->MessageBox("離開前將Cassette UnLoad?      ", "Cassette Operation", MB_YESNO|MB_SYSTEMMODAL) == IDYES) {

         // 2020 5 21 - chc 退Cassette
         pcEFEMH->Visible = false;
         pnlCassetteStatus->Visible = false;
         pnlStartMessage->Caption = "Cassette Unloading...";
         pnlStartMessage->Visible = true;

         btnCassetteLoadClick(this);
         WaitTime(2000);

         // 2020 5 21 - chc 退Cassette
         pnlStartMessage->Visible = false;

      }
   }

   // 2016 5 20 - chc 加入Try-Catch
   try {

      // 2020 1 5 - chc Joystick
      if(boolJoystick == true) {
         FreeJoystick();
         tmJoystick->Enabled = false;
      }

      // 2019 7 9 - chc Close all Timer
      CloseAllTimer();

      // 2016 4 19 - chc Free HSL/APS - System
      if(bool_APS_Status == true) {

         // 2016 5 11 - chc DO Reset 0
         InitDO(2);

         // 2016 5 12 0 chc Log
         WriteSystemLog("Close DO");

         // 2021 4 15 - chc APS Close
         if(bool_IO_Status == true) {
            APS_stop_field_bus(BoardMNET, MNET_BUS);
         }
         APS_stop_field_bus(BoardHSL, HSL_BUS);

         APS_close();

         // 2016 5 12 0 chc Log
         WriteSystemLog("Close APS Function");

      }

   // 2016 5 20 - chc 加入Try-Catch
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "Motion Error!";
   }

   WriteSystemLog("Close Done.");
   Action = caFree;

}
//---------------------------------------------------------------------------
// 2020 7 15 - chc 記錄tmMotionPolling次數
int tmMotionCount = 0;

void __fastcall TMainForm::tmSystemTimer(TObject *Sender)
{
AnsiString str;
static int cnt = 0;

// 2021 4 19 - chc Thread Resume在此做, 進行SetupMotion時間: 2sec後
static int SetupTimeCount = 0;
static bool boolSetupTime = false;

// 2020 7 15 - chc 記錄tmMotionPolling次數
static int tmcnt = 0;
static bool boolopen = true;
   tmcnt++;

   // 2021 11 22 - chc EFEM With wafer Alarm: laAlarm
   if(WaferInSystem() == true) {
      if(laAlarm->Visible == false)
         laAlarm->Visible = true;
      if(laAlarm->Color == (TColor)0x0037FFFF) {
         laAlarm->Color = clRed;
         laAlarm->Font->Color = (TColor)0x0037FFFF;
      }
      else {
         laAlarm->Color = (TColor)0x0037FFFF;
         laAlarm->Font->Color = clRed;
      }
   }
   else {
      if(laAlarm->Visible == true)
         laAlarm->Visible = false;
   }

   // 2022 5 17 - chc 是PE: 固定60秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE) {
      if(ChangePriorityCount > 0) {
         ChangePriorityCount--;
         AnsiString msg;
         //msg.sprintf("自動切換密碼等級: %d秒",ChangePriorityCount);
         //ShowSystemMessages(msg);
         if(ChangePriorityCount <= 0) {
            PriorityLevel = PRIORITY_OP;
            SwitchLevel();
         }
      }
   }

   // 2020 8 12 - chc TSMC修改: 改成3秒
   //if(tmcnt > 5) {
   // 2021 6 24 - chc 改成5秒
   //if(tmcnt > 3) {
   // 2023 7 27 - chc 改成4sec
   //if(tmcnt > 5) {
   if(tmcnt > 3) {

      // 2021 5 5 - chc 若SESC未連線, 再連線
      //if(pnlSECSConnect->Color != clLime) {
      //   WriteSystemLog("檢查SECS Socket連線...");
      //   btnSECSReConnectClick(this);
      //   WriteSystemLog("檢查SECS Socket連線.");
      //}

      tmcnt = 0;
      if(tmMotionCount == 0) {

         // 2020 8 12 - chc TSMC修改: 改成3秒
         // 2021 6 24 - chc 改成5秒
         //WriteSystemLog("Error: 連續3秒未執行Motion及IO更新!");
         WriteSystemLog("Error: 連續5秒未執行Motion及IO更新!");

         // 2020 9 3 - chc for test
         if(boolForTest == false)

            gbSystemCommand->Color = clRed;
      }
      else {
         if(gbSystemCommand->Color == clRed)
            gbSystemCommand->Color = clBtnFace;
      }
      tmMotionCount = 0;

      // 2021 5 4 - chc 每3秒更新GPIO
      // 2021 6 30 - chc 可選擇GPIO是否更新
      if(cbLoadPort1GPIO->Checked == true)

         btnLoadPort1GPIOClick(this);

      // 2021 6 30 - chc 可選擇
      if(cbLoadPort2GPIO->Checked == true)

         btnLoadPort2GPIOClick(this);
      // 設定boolCDAVacuum
      CheckCDAVacuum();

      // 2021 6 30 - chc 監看Aligner
      // 2021 6 30a - chc
      //if(boolAlignerMonitor == true) {
      //   btnAlignerGPRSClick(this);
      //}

   }

   // 2021 4 19 - chc Thread Resume在此做, 進行SetupMotion時間: 2sec後
   // => 且要在EFEM Setup完成且Robot已完成ORG才能做
   SetupTimeCount++;
   if(SetupTimeCount >= 2 && boolSetupTime == false && boolEFEMStatus == true) {
      boolSetupTime = true;

      // 是否要做?? @@
      //InspectThread->Resume();
      //RoutineThread->Resume();
      //scA1300Thread->Resume();
      //usbCCDThread->Resume();
      //WriteSystemLog(">>RoutineThread->Resume().");

      // Motion Init
      if(bool_APS_Status == true) {
         pnl7856Status->Color = clLime;
         pnlSystemMessage->Caption = "等待Motion SVON...";
         AxisSVON();
         if(btnHome->Enabled == true)
            pnlSystemMessage->Caption = "Motion SVON OK.";
         else
            pnlSystemMessage->Caption = "Motion SVON Fail!";
      }
   }

   // 2020 8 12 - chc TSMC修改
   boolPCDoor = HSL_IO_InStatus[0];
   boolPower = HSL_IO_InStatus[1];
   boolLeftMaintenanceDoor = HSL_IO_InStatus[4];
   boolRightMaintenanceDoor = HSL_IO_InStatus[5];
   boolInspectDoor = HSL_IO_InStatus[13];
   bool boolbuzzeralarm = false;
   bool boolredalarm = false;

   // 2021 6 23 - chc Off是切水平: 可開 - 要Alarm
   boolMaintenanceMode = HSL_IO_InStatus[6];

   // Yuanli/SECS連線狀態是否加入警示?
   // 2021 6 23 - chc Alarm整理
   //if(boolPCDoor == false || boolPower == false || boolLeftMaintenanceDoor == false || boolRightMaintenanceDoor == false ||
   //   boolInspectDoor == false || boolEFEMError == true) {
   //   boolredalarm = true;
   //}
   // RedLamp
   if(boolPCDoor == false && cbPCDoorRed->Checked == true)
      boolredalarm = true;
   if(boolLeftMaintenanceDoor == false && cbEFEMLeftDoorRed->Checked == true)
      boolredalarm = true;
   if(boolRightMaintenanceDoor == false && cbEFEMRightDoorRed->Checked == true)
      boolredalarm = true;
   if(boolInspectDoor == false && cbStageDoorRed->Checked == true)
      boolredalarm = true;
   if(boolMaintenanceMode == false && cbMaintenanceModeRed->Checked == true)
      boolredalarm = true;
   // Power
   if(boolPower == false)
      boolredalarm = true;
   // Buzzer
   if(boolPCDoor == false && cbPCDoorAlarm->Checked == true)
      boolbuzzeralarm = true;
   if(boolLeftMaintenanceDoor == false && cbEFEMLeftDoorAlarm->Checked == true)
      boolbuzzeralarm = true;
   if(boolRightMaintenanceDoor == false && cbEFEMRightDoorAlarm->Checked == true)
      boolbuzzeralarm = true;
   if(boolInspectDoor == false && cbStageDoorAlarm->Checked == true)
      boolbuzzeralarm = true;
   if(boolMaintenanceMode == false && cbMaintenanceModeAlarm->Checked == true)
      boolbuzzeralarm = true;
   // EFEM
   if(boolEFEMError == true)
      boolredalarm = true;

   // 2021 6 3 - chc 警示模式: Stage & PC 門不Alarm
   //if(boolPCDoor == false || boolPower == false || boolInspectDoor == false) {
   if(boolPower == false) {

      boolbuzzeralarm = true;

      // 2021 4 11 - chc 原因
      // @@ 暫不做
      //if(boolPCDoor == false)
      //   WriteSystemLog("Error Alarm: PC Door");
      if(boolPower == false)
         WriteSystemLog("Error Alarm: Power");
      if(boolInspectDoor == false)
         WriteSystemLog("Error Alarm: Stage Door");

   }
   if(boolredalarm == true)
      RedLamp(true);
   else
      RedLamp(false);
   if(boolbuzzeralarm == true)
      Buzzer(true);
   else
      Buzzer(false);
   // SECS PC: boolSECSSocket

   // 2023 1 28 - chc Local不亮
   //if(boolSECSSocket == true)
   if(boolSECSSocket == true && cbOffLine->Checked == false)

      BlueLamp(true);
   else
      BlueLamp(false);

   // 2016 3 31 - chc Close - License Fail
   if(ExitYes == true)
      Close();

   // 2016 12 17 - chc Set Top to 0, 將MainForm置於最上端, 左右中間(Position要設為poDefault才行)
   cnt++;
   if(cnt > 1 && cnt < 5) {
      if(MainForm->Top != 0) {
         MainForm->Top = 0;

         // 2020 1 5 - chc 作動
         // 2020 3 11 - chc 不需要, 否則MainForm不動, 要按一下才能用
         //MainForm->Refresh();
         //PostMessage(MainForm->Handle, WM_LBUTTONDOWN, 0, 0);

      }
   }

   // Chuck有片, 才能Enable"退片"
   if(pnlBit7->Color == clLime)
      btnUnloadWafer->Enabled = true;
   else {
      // for test
      if(boolForTest == true)
         btnUnloadWafer->Enabled = true;
      else
         btnUnloadWafer->Enabled = false;
   }

   DateTimeToString(str,"yyyy'/'mm'/'dd hh':'nn':'ss",Now());
   sbSystemMessage->Panels->Items[5]->Text = str;
}
//---------------------------------------------------------------------------
// 2016 2 15 - chc Log
void __fastcall TMainForm::WriteSystemLog(AnsiString msg)
{
static bool flag = false;

   // 避免ReEntrance
   if(flag == true) {
      return;
   }
   flag = true;

   // 2021 9 25 - chc 月日: MMDD
   AnsiString temp;
   DateTimeToString(temp,"mmdd",Date());
   if(temp != MMDD) {
      MMDD = temp;
      DateTimeToString(temp,"yyyymmddhhnnss",Now());
      LogFileName = LogDirectory + "\\" + temp + ".log";
      WriteSystemLog(">>Log: " + LogFileName);
   }

   // Exception Error
   try {                                                                        // 追蹤Exception Error
      AnsiString logMessage;
      AnsiString dstr,tstr;
      FILE *logFile;
      DateTimeToString(dstr,"yyyy'/'mm'/'dd",Date());
      DateTimeToString(tstr,"hh':'nn':'ss':'zzz",Time());

      // 2021 4 30 - chc Log DateTime
      if(boolLogDateTime == false)
         logMessage = msg + "\n";
      else

         logMessage = dstr + " " + tstr + "-" + msg + "\n";
      logFile = fopen(LogFileName.c_str(),"a+t");
      fprintf(logFile,logMessage.c_str());
      fclose(logFile);
   }
   catch(Exception &e) {
      MainForm->WriteSystemLog(">>Error(WriteSystemLog): "+e.Message);
   }
   // 避免ReEntrance
   flag = false;
}
//---------------------------------------------------------------------------
// 2016 4 18 - chc APS
void __fastcall TMainForm::SetupMotion()
{

   // 由motion.cpp負責
   InitMotion();
   CurrentAxisNo = X_AXIS;

}
//---------------------------------------------------------------------------
// 2016 2 16 - chc X往前
void __fastcall TMainForm::btnMoveXClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = X_AXIS;

   // 2019 12 23 - chc Table方向
   // 2019 12 27 - chc 不需要做
   //if(cbTableDirection->Checked == true)
   //   btnBackwardClick(this);
   //else

      btnMoveClick(this);

}
//---------------------------------------------------------------------------
// 2016 2 16 - chc X 往後
void __fastcall TMainForm::btnBackwardXClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = X_AXIS;
   btnBackwardClick(this);

}
//---------------------------------------------------------------------------
// 2016 2 16 - chc Wait Routine : 軸控
void __fastcall TMainForm::WaitRoutine1(int sleepno)
{
static bool active = false;

   if(active == false) {
      active = true;
      Sleep(sleepno);
      Application->ProcessMessages();
      active = false;
   }
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc Stop
void __fastcall TMainForm::btnStopRelativeClick(TObject *Sender)
{

   StopAxis(combAxis->ItemIndex);
   // 停止運作
   if(cbContinueMove->Checked == true) {
      boolJogMove = false;
   }
   MotionStatus(true);
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc 往前
void __fastcall TMainForm::btnMoveClick(TObject *Sender)
{

   // 2020 2 12 - chc 不使用搖桿
   MainForm->SetJoystickActive(false);

   // 連動
   if(MainForm->cbContinueMove->Checked == true)
      return;
   MoveForward();
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc 往後
void __fastcall TMainForm::btnBackwardClick(TObject *Sender)
{

   // 2020 2 12 - chc 不使用搖桿
   MainForm->SetJoystickActive(false);

   // 連動
   if(MainForm->cbContinueMove->Checked == true)
      return;
   MoveBackward();
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc 連續移動變化
void __fastcall TMainForm::btnMoveMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定Axis
   CurrentAxisNo = combAxis->ItemIndex;

   if(cbContinueMove->Checked == false)
      return;

   // 記錄在move中, 不可以同時Continue move
   if(boolInAxisMove == false) {
      boolJogMove = true;

      // 2020 2 12 - chc 不使用搖桿
      MainForm->SetJoystickActive(false);

      // 2016 8 26 - chc define type value: 0-wait, 1-nowait(for UpdateMotionStatus())
      //AxisMove(0);
      AxisMove(0,0);

   }
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc 連續移動變化
void __fastcall TMainForm::btnMoveXMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = X_AXIS;

   // 2019 12 18 - chc 要為btnBackwardMouseDown
   //btnMoveMouseDown(this,Button, Shift, X, Y);
   // 2019 12 23 - chc Table方向
   if(cbTableDirection->Checked == true)
      btnMoveMouseDown(this,Button, Shift, X, Y);
   else

      btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc 連續移動變化
void __fastcall TMainForm::btnMoveXMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2021 4 21 - chc 立即停止
   pnlAlarmMessage->Caption = "X軸停止.";
   pnlAlarmMessage->Refresh();
   StopOneAxis(X_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnMoveMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2019 7 8 - chc Log
   MainForm->WriteSystemLog("Mouse Up.");
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc Absolute Move
void __fastcall TMainForm::btnMoveAbsoluteClick(TObject *Sender)
{

   if(MoveAbsolute(combAxis->ItemIndex) == false) {
      pnlSystemMessage->Caption = "Absolut Move Fail!";
   }
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc Absolute Move Stop
void __fastcall TMainForm::btnStopAbsoluteClick(TObject *Sender)
{

   StopAxis(combAxis->ItemIndex);
}
//---------------------------------------------------------------------------
// 2016 2 16 - chc Reset Motion 4X
void __fastcall TMainForm::btnResetAllClick(TObject *Sender)
{

   for(int axisno=0 ; axisno<MAX_AXIS_NO ; axisno++) {
      combAxis->ItemIndex = axisno;
      btnResetOneAxisClick(this);
   }
}
//---------------------------------------------------------------------------
// 2016 2 17 - chc Motion Parameter
void __fastcall TMainForm::btnUpdateMotionClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   // 2016 2 25 - chc 檢查等級
   if(PriorityLevel < PRIORITY_AD) {
      pnlSystemMessage->Caption = "未授權! 無法變更參數.";
      return;
   }

   // 2016 10 14 - chc Confirm
   if(Application->MessageBox("確認要更新軸控參數?", "參數更新作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   pnlSystemMessage->Caption = "參數更新中...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   // CCD Precision
   // 2019 10 17 - chc 定義CCDPrecision1
   //CCDPrecision = edCCDPrecision1->Text.ToDouble();
   //pSystemFile->WriteFloat("System Parameter" ,"CCD Precision"                  ,CCDPrecision);
   CCDPrecision1 = edCCDPrecision1->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"CCD Precision1"                  ,CCDPrecision1);

   // 2019 10 17 - chc 定義CCDPrecision參數化
   CCDPrecision = edCCDPrecision->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"CCD Precision"                  ,CCDPrecision);

   // 2020 3 10 - chc L: Up/Down
   LUp = edLUp->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,L_UP                           ,LUp);
   LDown = edLDown->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,L_DOWN                         ,LDown);

   // 2021 10 28 - chc Log刪除天數
   LogReservedDay = edLogReservedDay->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,LOG_RESERVED_DAY               ,LogReservedDay);

   // 2020 7 16 - chc ZLimit, ZOffset
   ZLimit = edZLimit->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,Z_LIMIT                        ,ZLimit);
   ZOffset = edZOffset->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,Z_OFFSET                       ,ZOffset);

   // 2021 6 9 - chc 加入中心點參數: CenterSize, CenterOffset
   CenterSize = edWaferCenterSize->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,CENTER_SIZE                    ,CenterSize);
   CenterOffset = edWaferCenterOffset->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,CENTER_OFFSET                  ,CenterOffset);
   CenterCnt = edWaferCenterCnt->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,CENTER_CNT                     ,CenterCnt);

   // 2021 9 15 - chc 將灰階量改成參數: WaferEdgeGray
   WaferEdgeGray = edWaferEdgeGray->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,"Wafer Edge Gray"              ,WaferEdgeGray);

   // 2022 5 17 - chc 不是操作員: 固定10秒後切換到操作員等級: edPasswordSwitchSecond
   int ssec = edPasswordSwitchSecond->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,"PasswordSwitchSecond"         ,ssec);

   // 2022 5 19 - chc T到水平/傾斜再確認
   bool check = cbTCheck->Checked;
   pSystemFile->WriteBool("System Parameter" ,"TCheck"                          ,check);

   // 2020 4 23 - chc 解真空高度
   LVacuumOff = edLVacuumOff->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,L_VACUUM_OFF                   ,LVacuumOff);

   // 2020 5 20 - chc L水平高度:1630
   LLevel = edLLevel->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,L_LEVEL                        ,LLevel);

   // 2016 6 3 - chc 2~5 Lens
   CCDPrecision2 = edCCDPrecision2->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"CCD Precision2"                  ,CCDPrecision2);
   CCDPrecision3 = edCCDPrecision3->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"CCD Precision3"                  ,CCDPrecision3);
   CCDPrecision4 = edCCDPrecision4->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"CCD Precision4"                  ,CCDPrecision4);
   CCDPrecision5 = edCCDPrecision5->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"CCD Precision5"                  ,CCDPrecision5);

   // 2016 7 14 - chc sixth lens definition
   CCDPrecision6 = edCCDPrecision6->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"CCD Precision6"                  ,CCDPrecision6);

   // 2016 6 3 - chc MatchNo & LensNo
   MatchNo = cbMatchNo->ItemIndex;
   pSystemFile->WriteInteger("System Parameter" ,"Match No"                     ,MatchNo);
   pSystemFile->WriteInteger("System Parameter" ,"Lens No"                      ,LensNo);

   // 2016 11 9 - chc Sort Mode & Min Score
   pSystemFile->WriteInteger("System Parameter" ,"Sort Mode"                    ,rgSortMode->ItemIndex);
   pSystemFile->WriteFloat("System Parameter" ,"Score"                          ,edScore->Text.ToDouble());

   // 2016 6 4 - chc GridPixel
   GridPixel = edGridPixel->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,"Grid Pixel"                   ,GridPixel);

   // 2016 6 3 - chc AI Min Vibrate
   AIMinVibrate = edMinVibrate->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"AI Min Vibrate"                 ,AIMinVibrate);

   // 2016 6 5 - chc Factor of Rotate Within View
   JogFactor = edJogFactor->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"Jog Factor"                     ,JogFactor);
   ContinueFactor = edContinueFactor->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,"Continue Factor"                ,ContinueFactor);

   // 2016 9 7 - chc Home Method
   AllHomeMethod = rgAllHomeMethod->ItemIndex;
   pSystemFile->WriteInteger("System Parameter" ,"All Home Method"              ,AllHomeMethod);

   // Recipe Name
   RecipeName = cbRecipe->Text;
   pSystemFile->WriteString("System Parameter" ,"Recipe Name"                   ,RecipeName);
   // Move to Center
   boolMoveToCenter = cbMoveToCenter->Checked;
   pSystemFile->WriteBool("System Parameter","bool Move to Center"              ,boolMoveToCenter);

   // 2016 5 26 - chc Rotate Before Move
   boolRotateBeforeMove = cbRotateBeforeMove->Checked;
   pSystemFile->WriteBool("System Parameter","bool Rotate Before Move"          ,boolRotateBeforeMove);

   // CCD X Direction
   boolCCDXDirection = cbCCDXDirection->Checked;
   pSystemFile->WriteBool("System Parameter","bool CCD X Direction"             ,boolCCDXDirection);
   // CCD Y Direction
   boolCCDYDirection = cbCCDYDirection->Checked;
   pSystemFile->WriteBool("System Parameter","bool CCD Y Direction"             ,boolCCDYDirection);
   // Rotate Direction
   boolRotateDirection = cbRotateDirection->Checked;
   pSystemFile->WriteBool("System Parameter","bool Rotate Direction"            ,boolRotateDirection);

   // 2016 5 30 - chc 加入旋轉方向
   boolCCDTDirection = cbCCDTDirection->Checked;
   pSystemFile->WriteBool("System Parameter","bool CCD T Direction"             ,boolCCDTDirection);

   // DirectMove
   boolDirectMove = cbDirectMove->Checked;
   pSystemFile->WriteBool("System Parameter","bool Direct Move"                 ,boolDirectMove);

   // 2016 5 25 - chc Joystick
   // 2020 1 5 - chc 不用
   //boolJoystick = cbJoystick->Checked;
   //pSystemFile->WriteBool("System Parameter","bool Joystick"                    ,boolJoystick);

   // Continue move
   boolContinueMove = cbContinueMove->Checked;
   pSystemFile->WriteBool("System Parameter","bool Continue Move"               ,boolContinueMove);
   // Speed
   iSpeed = rgSpeed->ItemIndex;
   pSystemFile->WriteInteger("System Parameter","int Speed"                     ,iSpeed);
   // Ruler Color
   iRulerColor = rgRulerColor->ItemIndex;
   pSystemFile->WriteInteger("System Parameter","int Ruler Color"               ,iRulerColor);
   // Cross Mark
   iCrossMark = rgRulerType->ItemIndex;
   pSystemFile->WriteInteger("System Parameter","int Cross Mark"                ,iCrossMark);

   // Basler Shutter & Gain: 等setupsca1300後才能設定
   BaslerShutter = rgBaslerShutter->ItemIndex;
   BaslerGain = tbBaslerGain->Position;
   pSystemFile->WriteInteger("System Parameter","Basler Shutter"                ,BaslerShutter);
   pSystemFile->WriteInteger("System Parameter","Basler Gain"                   ,BaslerGain);
   scA1300ShutterAry[0] = BaslerShutter;
   scA1300GainAry[0] = BaslerGain;

   // 各軸資訊
   // X
   XStartVel  = edStartVelX->Text.ToInt();
   XMaxVel    = edMaxVelX->Text.ToInt();
   XDistance  = edDistanceX->Text.ToInt();
   XTacc      = edTaccX->Text.ToDouble();
   XTdec      = edTdecX->Text.ToDouble();
   XPosition  = edPositionX->Text.ToInt();
   XHomeVel   = edHomeVelX->Text.ToInt();
   XReviewVel = edReviewVelX->Text.ToInt();
   XUpLimit   = edUpLimitX->Text.ToInt();
   XLowDistance = edLowDistanceX->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,X_START_VEL              ,XStartVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,X_MAX_VEL                ,XMaxVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,X_DISTANCE               ,XDistance);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,X_TACC                     ,XTacc);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,X_TDEC                     ,XTdec);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,X_POSITION               ,XPosition);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,X_HOME_VEL               ,XHomeVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,X_REVIEW_VEL             ,XReviewVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,X_UP_LIMIT               ,XUpLimit);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,X_LOW_DISTANCE           ,XLowDistance);
   // Y
   YStartVel  = edStartVelY->Text.ToInt();
   YMaxVel    = edMaxVelY->Text.ToInt();
   YDistance  = edDistanceY->Text.ToInt();
   YTacc      = edTaccY->Text.ToDouble();
   YTdec      = edTdecY->Text.ToDouble();
   YPosition  = edPositionY->Text.ToInt();
   YHomeVel   = edHomeVelY->Text.ToInt();
   YReviewVel = edReviewVelY->Text.ToInt();
   YUpLimit   = edUpLimitY->Text.ToInt();
   YLowDistance = edLowDistanceY->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Y_START_VEL              ,YStartVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Y_MAX_VEL                ,YMaxVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Y_DISTANCE               ,YDistance);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,Y_TACC                     ,YTacc);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,Y_TDEC                     ,YTdec);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Y_POSITION               ,YPosition);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Y_HOME_VEL               ,YHomeVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Y_REVIEW_VEL             ,YReviewVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Y_UP_LIMIT               ,YUpLimit);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Y_LOW_DISTANCE           ,YLowDistance);
   // Z
   ZStartVel  = edStartVelZ->Text.ToInt();
   ZMaxVel    = edMaxVelZ->Text.ToInt();
   ZDistance  = edDistanceZ->Text.ToInt();
   ZTacc      = edTaccZ->Text.ToDouble();
   ZTdec      = edTdecZ->Text.ToDouble();
   ZPosition  = edPositionZ->Text.ToInt();
   ZHomeVel   = edHomeVelZ->Text.ToInt();
   ZReviewVel = edReviewVelZ->Text.ToInt();
   ZUpLimit   = edUpLimitZ->Text.ToInt();
   ZLowDistance = edLowDistanceZ->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Z_START_VEL             ,ZStartVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Z_MAX_VEL               ,ZMaxVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Z_DISTANCE              ,ZDistance);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,Z_TACC                    ,ZTacc);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,Z_TDEC                    ,ZTdec);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Z_POSITION              ,ZPosition);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Z_HOME_VEL              ,ZHomeVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Z_REVIEW_VEL            ,ZReviewVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Z_UP_LIMIT              ,ZUpLimit);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,Z_LOW_DISTANCE          ,ZLowDistance);
   // T
   TStartVel  = edStartVelT->Text.ToInt();
   TMaxVel    = edMaxVelT->Text.ToInt();
   TDistance  = edDistanceT->Text.ToInt();
   TTacc      = edTaccT->Text.ToDouble();
   TTdec      = edTdecT->Text.ToDouble();
   TPosition  = edPositionT->Text.ToInt();
   THomeVel   = edHomeVelT->Text.ToInt();
   TReviewVel = edReviewVelT->Text.ToInt();
   TUpLimit   = edUpLimitT->Text.ToInt();
   TLowDistance = edLowDistanceT->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,T_START_VEL              ,TStartVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,T_MAX_VEL                ,TMaxVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,T_DISTANCE               ,TDistance);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,T_TACC                     ,TTacc);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,T_TDEC                     ,TTdec);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,T_POSITION               ,TPosition);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,T_HOME_VEL               ,THomeVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,T_REVIEW_VEL             ,TReviewVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,T_UP_LIMIT               ,TUpLimit);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,T_LOW_DISTANCE           ,TLowDistance);

   // 2021 4 15 - chc APS
   // L
   LStartVel  = edStartVelL->Text.ToInt();
   LMaxVel    = edMaxVelL->Text.ToInt();
   LDistance  = edDistanceL->Text.ToInt();
   LTacc      = edTaccL->Text.ToDouble();
   LTdec      = edTdecL->Text.ToDouble();
   LPosition  = edPositionL->Text.ToInt();
   LHomeVel   = edHomeVelL->Text.ToInt();
   LReviewVel = edReviewVelL->Text.ToInt();
   LUpLimit   = edUpLimitL->Text.ToInt();
   LLowDistance = edLowDistanceL->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,L_START_VEL              ,LStartVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,L_MAX_VEL                ,LMaxVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,L_DISTANCE               ,LDistance);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,L_TACC                     ,LTacc);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,L_TDEC                     ,LTdec);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,L_POSITION               ,LPosition);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,L_HOME_VEL               ,LHomeVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,L_REVIEW_VEL             ,LReviewVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,L_UP_LIMIT               ,LUpLimit);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,L_LOW_DISTANCE           ,LLowDistance);
   // W
   WStartVel  = edStartVelW->Text.ToInt();
   WMaxVel    = edMaxVelW->Text.ToInt();
   WDistance  = edDistanceW->Text.ToInt();
   WTacc      = edTaccW->Text.ToDouble();
   WTdec      = edTdecW->Text.ToDouble();
   WPosition  = edPositionW->Text.ToInt();
   WHomeVel   = edHomeVelW->Text.ToInt();
   WReviewVel = edReviewVelW->Text.ToInt();
   WUpLimit   = edUpLimitW->Text.ToInt();
   WLowDistance = edLowDistanceW->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,W_START_VEL              ,WStartVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,W_MAX_VEL                ,WMaxVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,W_DISTANCE               ,WDistance);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,W_TACC                     ,WTacc);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION,W_TDEC                     ,WTdec);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,W_POSITION               ,WPosition);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,W_HOME_VEL               ,WHomeVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,W_REVIEW_VEL             ,WReviewVel);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,W_UP_LIMIT               ,WUpLimit);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,W_LOW_DISTANCE           ,WLowDistance);

   // 2016 5 20 - chc 加入Position: Center/Unload
   // Center
   CenterX = edAOIX->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Center X"               ,CenterX);
   CenterY = edAOIY->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Center Y"               ,CenterY);
   CenterZ = edAOIZ->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Center Z"               ,CenterZ);
   CenterT = edAOIT->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Center T"               ,CenterT);

   // Load
   LoadX = edLoadX->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Load X"                 ,LoadX);
   LoadY = edLoadY->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Load Y"                 ,LoadY);
   LoadZ = edLoadZ->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Load Z"                 ,LoadZ);
   LoadT = edLoadT->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Load T"                 ,LoadT);

   // 2016 6 3 - chc Original
   OriginalX = edOriginalX->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Original X"             ,OriginalX);
   OriginalY = edOriginalY->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Original Y"             ,OriginalY);
   OriginalZ = edOriginalZ->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Original Z"             ,OriginalZ);
   OriginalT = edOriginalT->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Original T"             ,OriginalT);

   // 2019 7 14 - chc CCD Position
   CCDX = edCCDX->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"CCD X"                  ,CCDX);
   CCDY = edCCDY->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"CCD Y"                  ,CCDY);
   CCDZ = edCCDZ->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"CCD Z"                  ,CCDZ);
   CCDT = edCCDT->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"CCD T"                  ,CCDT);

   // 2019 12 5 - chc TXT Position
   // 2019 12 11 - chc 不在這裡做
   //TXTX = edkmfX->Text.ToInt();
   //pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"TXT X"                  ,TXTX);
   //TXTY = edkmfY->Text.ToInt();
   //pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"TXT Y"                  ,TXTY);

   // 2019 7 30 - chc Last Position
   LastX = edLastX->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"LAST X"                  ,LastX);
   LastY = edLastY->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"LAST Y"                  ,LastY);
   LastZ = edLastZ->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"LAST Z"                  ,LastZ);
   LastT = edLastT->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"LAST T"                  ,LastT);

   // 2021 5 3 - chc RealCenter Position
   RealCenterX = edRealCenterX->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Real Center X"                  ,RealCenterX);
   RealCenterY = edRealCenterY->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Real Center Y"                  ,RealCenterY);
   RealCenterZ = edRealCenterZ->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Real Center Z"                  ,RealCenterZ);
   RealCenterT = edRealCenterT->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Real Center T"                  ,RealCenterT);

   // 2020 4 25 - chc ComPort設定值
   // Robot
   RobotBaudrate = combRobotBaudrate->ItemIndex;
   pSystemFile->WriteInteger(LENS_SECTION,ROBOT_BAUDRATE                        ,RobotBaudrate);
   RobotComPort = combRobotComport->ItemIndex;
   pSystemFile->WriteInteger(LENS_SECTION,ROBOT_COM_PORT                        ,RobotComPort);
   // LoadPort
   LoadPortBaudrate = combLoadPortBaudrate->ItemIndex;
   pSystemFile->WriteInteger(LENS_SECTION,LOADPORT_BAUDRATE                     ,LoadPortBaudrate);
   LoadPortComPort = combLoadPortComport->ItemIndex;
   pSystemFile->WriteInteger(LENS_SECTION,LOADPORT_COM_PORT                     ,LoadPortComPort);
   // Aligner
   AlignerBaudrate = combAlignerBaudrate->ItemIndex;
   pSystemFile->WriteInteger(LENS_SECTION,ALIGNER_BAUDRATE                      ,AlignerBaudrate);
   AlignerComPort = combAlignerComport->ItemIndex;
   pSystemFile->WriteInteger(LENS_SECTION,ALIGNER_COM_PORT                      ,AlignerComPort);

   // 2021 9 23b - chc ButtonDelay: edButtonDelay4->Text
   int delaytime = edButtonDelay1->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Button Delay1"         ,delaytime);
   delaytime = edButtonDelay2->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Button Delay2"         ,delaytime);
   delaytime = edButtonDelay3->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Button Delay3"         ,delaytime);
   delaytime = edButtonDelay4->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Button Delay4"         ,delaytime);

   delete pSystemFile;

   pnlSystemMessage->Caption = "Parameter update complete.";

}
//---------------------------------------------------------------------------
// 2016 2 17 - chc 連動: 後退
void __fastcall TMainForm::btnBackwardXMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = X_AXIS;

   // 2019 12 18 - chc 要為btnMoveMouseDown
   //btnBackwardMouseDown(this,Button, Shift, X, Y);
   // 2019 12 23 - chc Table方向
   if(cbTableDirection->Checked == true)
      btnBackwardMouseDown(this,Button, Shift, X, Y);
   else

      btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2016 2 17 - chc 連動: 後退
void __fastcall TMainForm::btnBackwardXMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2021 4 21 - chc 立即停止
   pnlAlarmMessage->Caption = "X軸停止.";
   pnlAlarmMessage->Refresh();
   StopOneAxis(X_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBackwardMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定Axis
   CurrentAxisNo = combAxis->ItemIndex;

   if(cbContinueMove->Checked == false)
      return;

   // 記錄在move中, 不可以同時Continue move
   if(boolInAxisMove == false) {
      boolJogMove = true;

      // 2020 2 12 - chc 不使用搖桿
      MainForm->SetJoystickActive(false);

      // 2016 8 26 - chc define type value: 0-wait, 1-nowait(for UpdateMotionStatus())
      //AxisMove(1);
      AxisMove(1,0);

   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBackwardMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------
// 2016 2 17 - chc Reset One Axis
void __fastcall TMainForm::btnHomeOneAxisClick(TObject *Sender)
{

   HomeOneAxis();
}
//---------------------------------------------------------------------------
// 2019 11 27 - chc 第一次做Home
bool boolFirstHome = true;

// 2016 2 17 - chc Reset One Axis
void __fastcall TMainForm::btnHomeClick(TObject *Sender)
{
I16 Done;
int cnt,timeoutcnt;
U16 io_sts;
static bool first = true;

   // 是否Motion Ready?
   if(pnl7856Status->Color == clRed) {
      //pnlSystemMessage->Caption = "Motion Not Ready, Can not do Home!";
      pnlSystemMessage->Caption = "軸控異常, 無法執行原點復歸!";
      imClose->Enabled = true;
      return;
   }

   // Hide button or system page
   // 2020 2 14 - chc 移到前面
   if(pnlHome2->Visible == true)
      pnlHome2->Visible = false;

   // 2023 8 2 - chc Step
   pnlMotionHomeUnit->Caption = "Check the Stage door lock";

   CheckStageDoor();

   // 2021 4 19 - chc Log
   WriteSystemLog(">btnHomeClick(): 檢查Stage門鎖完成.");

   // 2020 2 14a - chc 監控是否發生Power Off
   if(pnlBit1->Color != clLime) {
      pnlSystemMessage->Caption = "Motion未Power On!, Can not do Home!";

      // 2023 8 2 - chc Step
      pnlMotionHomeUnit->Caption = "Motion not Power on!";
      pnlMotionHomeUnit->Font->Color = clRed;
      imClose->Enabled = true;

      return;
   }
   if(MainForm->boolMotionPowerOff == true) {

      // 2023 7 21 - chc Log
      WriteSystemLog(">btnHomeClick(): SVON...");

      // 2023 8 2 - chc Step
      pnlMotionHomeUnit->Caption = "Motion SVON...";

      btnSvonClick(this);
   }

   // Check上是否有Wafer
   // 2021 7 17 - chc EFEM Setup不檢察Stage
   pnlSystemMessage->Caption = "Home: Stage上是否有Wafer?";
   if(IsChuckWithWafer() == true) {
      WriteSystemLog("btnHomeClick() Stage with wafer!");
      pnlAlarmMessage->Caption = "Stage上有Wafer!";

      // 2023 8 2 - chc Step
      pnlMotionHomeUnit->Caption = "Stage has wafer!";

      Beep(500);
      if(Application->MessageBox("Stage上有Wafer, 確認要執行原點復歸(若確認, 請於原點復歸後手動排除Wafer)?      ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         imClose->Enabled = true;
         return;
      }
   }

   // 2021 5 5 - chc 作業中訊息
   if(pnlMoving->Visible == false) {
      pnlMoving->Visible = true;
      pnlMoving->Caption = "Working...";
   }

   // 2016 7 27 - chc Check front door
   boolSystemStarted = true;

   // 2016 7 24 - chc Blinking
   boolStartState = false;
   boolAllHomeState = false;
   btnHome2->Font->Color = clBlack;

   // 2016 7 9 - chc Hide button or system page
   // 2020 2 14 - chc 移到前面
   //if(pnlHome2->Visible == true)
   //   pnlHome2->Visible = false;

   // 是否Motion Ready?
   // 2020 2 14 - chc 移到前面
   //if(pnl8154Status->Color == clRed) {
   //   pnlSystemMessage->Caption = "Motion Not Ready, Can not do Home!";
   //   return;
   //}

   WriteSystemLog(">Enter AllHome()");

   // 2016 7 22 - chc visible message panel
   if(pnlStartMessage->Visible == false)
       pnlStartMessage->Visible = true;

   // 2016 5 12 - chc Wait Motion Homing
   if(pnlStartMessage->Visible == true) {
      pnlStartMessage->Caption = "System Homing...";
   }
   if(pnlDoorOpen->Visible == true) {
      pnlDoorOpen->Caption = "System Homing...";
   }

   // 2023 8 2 - chc Step
   pnlMotionHomeUnit->Caption = "Homing...";

   // 2019 11 26 - chc 若有軸控異常要先做SVON - Off
   if(boolMotionError == true) {

   }

   // 2021 4 19 - chc 確認 @@暫
   //if(Application->MessageBox("準備呼叫AllHome(), 續做Home?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
   //   return;
   //}

   // 2021 4 19 - chc Log
   WriteSystemLog(">btnHomeClick(): 呼叫AllHome().");

   // Home結束會自動到退料區, 並設定boolHomeDone = true;
   pnlSystemMessage->Caption = "軸控未備妥, 無法復歸!";
   AllHome();
   WriteSystemLog(">Leave AllHome()");

   // 啟動所有Motion功能: boolHomeDone
   WriteSystemLog("AfterAllHome: Do SetMotionStatus(). - False");
   SetMotionStatus();
   WriteSystemLog(">Leave setMotionStatus()");

   // 2021 4 30 - chc 若Home失敗則不動
   if(pnlAllHomeStatus->Color == clLime) {

      // 第一次Home之後
      if(first == true) {
         first = false;

         // 2023 8 2 - chc Step
         pnlMotionHomeUnit->Caption = "To Load location...";

         // 移到原點(0 度)
         WriteSystemLog("移到原點...");
         btnToOriginalClick(this);
         WriteSystemLog("移到原點.");

         // 2023 8 2 - chc Step
         pnlMotionHomeUnit->Caption = "Completed.";

         MainForm->pnlCassetteStatus->Visible = true;
         if(MainForm->pnlEFEMReady->Color == clLime) {
            MainForm->btnCassetteLoad->Visible = true;
            MainForm->pnlCassetteLoad->Visible = true;
         }

         // 啟動Motion Button
         // Z
         btnBackwardZ1->Visible = true;
         btnUp100x->Visible = true;
         btnUp10x->Visible = true;
         btnUp5x->Visible = true;
         btnUp1x->Visible = true;
         btnDown1x->Visible = true;
         btnDown5x->Visible = true;
         btnDown10x->Visible = true;
         btnDown100x->Visible = true;
         btnMoveZ1->Visible = true;
         // X
         btnBackwardX1->Visible = true;
         btnLeft10x->Visible = true;
         btnLeft5x->Visible = true;
         btnLeft1x->Visible = true;
         btnRight1x->Visible = true;
         btnRight5x->Visible = true;
         btnRight10x->Visible = true;
         btnMoveX1->Visible = true;
         // Y
         btnMoveY1->Visible = true;
         btnRear10x->Visible = true;
         btnRear5x->Visible = true;
         btnRear1x->Visible = true;
         btnFront1x->Visible = true;
         btnFront5x->Visible = true;
         btnFront10x->Visible = true;
         btnBackwardY1->Visible = true;

         // 2021 10 24 - chc T Active
         pnlMoveTCounterclockwise->Visible = true;
         pnlMoveTClockwise->Visible = true;

      }

      // 檢查SECS/YuanLi連線
      bool boolyuanli,boolsecs;
      pnlMoving->Caption = "Communication test...";

      // 2021 10 21 - chc 要開機時先做SECS
      //pnlStartMessage->Caption = "YuanLi, SECS通訊測試...";
      pnlStartMessage->Caption = "YuanLi Communication test...";

      // 2023 8 2 - chc 取消Step Window
      pnlYuanliUnit->Caption = "Initialize...";

      pnlStartMessage->Visible = true;
      pnlMoving->Visible = true;
      boolyuanli = YuanLiConnect();

      // 2021 10 21 - chc 要開機時先做SECS
      //boolsecs = SECSConnect();

      if(boolyuanli == false) {
         pnlAlarmMessage->Caption = "YuanLi無法連線(Timeout), 請檢查.";
         pnlStartMessage->Caption = "YuanLi System Disconnected!";

         // 2023 8 2 - chc 取消Step Window
         //pnlMoving->Caption = "YuanLi Disconnected";
         pnlYuanliUnit->Caption = "Disconnected!";
         pnlYuanliUnit->Font->Color = clRed;
      }

      // 2023 8 2 - chc 取消Step Window
      else {
         pnlYuanliUnit->Caption = "Connected.";
      }

      // 2021 10 21 - chc 要開機時先做
      //if(boolsecs == false) {
      //   pnlAlarmMessage->Caption = "SECS無法連線(Timeout), 請檢查.";
      //   pnlStartMessage->Caption = "SECS回報系統無法連線!";
      //}
      //if(boolyuanli == true && boolsecs == true) {
      if(boolyuanli == true && boolSECSSocket == true) {

         pnlMoving->Visible = false;
         pnlStartMessage->Visible = false;
         pnlSystemRun->Caption = "Ready";

         // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause
         // 2021 10 27 - chc Init完成為Idle
         //SendSECSStatus(EQ_STATUS_READY);
         SendSECSStatus(EQ_STATUS_IDLE);

      }

   }

   // 2019 11 27 - chc 第一次做Home
   boolFirstHome = false;

   // 2021 5 4 - chc SEC init
   InitSECSStatus();

   // 2016 7 18 - chc Backlash control
   // 2016 12 18 - chc 不需要
   //ResetBacklash();

   // 2021 5 5 - chc 切到"作業"Page
   pcSystem->ActivePage = tsOperation;
   pcOP->ActivePage = tsRun;
   imClose->Enabled = true;

   // 2023 8 2 - chc 全部ok則自動inVisible
   if(pnlMotionUnit->Font->Color != clRed && pnlInspCCDUnit->Font->Color != clRed && pnlMatchCCDUnit->Font->Color != clRed &&
      pnlMatchKernelUnit->Font->Color != clRed && pnlCDAVacuumUnit->Font->Color != clRed && pnlEFEMUnit->Font->Color != clRed &&
      pnlSECSUnit->Font->Color != clRed && pnlMotionHomeUnit->Font->Color != clRed && pnlYuanliUnit->Font->Color != clRed) {
      pnlHomeStep->Visible = false;
   }
   pnlMoving->Visible = false;

   return;
}
//---------------------------------------------------------------------------
// 2016 2 17 - chc Reset One Axis
void __fastcall TMainForm::btnResetOneAxisClick(TObject *Sender)
{

   CurrentAxisNo = combAxis->ItemIndex;
   ResetCommand();
   ResetPosition();
   ResetErrorCounter();
}
//---------------------------------------------------------------------------
// 更新Recipe
void __fastcall TMainForm::btnUpdateRecipeClick(TObject *Sender)
{

   // 2019 12 3 - chc 詢問是否存檔?
   if(Application->MessageBox(("確認儲存[" + combRecipe->Text + "]的Recipe參數? ").c_str(), "Recipe參數儲存作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   // 2023 1 3 - chc WriteRecipe(): combRecipe->ItemIndex為-1, 攔住不處理
   //WriteRecipe();
   if(WriteRecipe() == false)
      return;

   // 2016 8 3 - chc if selected recipe is the current recipe need to update
   if(combRecipe->ItemIndex == cbRecipe->ItemIndex)
      DisplayRecipe(combRecipe->ItemIndex);

   // 2021 5 4 - chc Create recipe
   edSECSRecipeID->Text = cbRecipe->Text;
   rgSECSRecipe->ItemIndex = RECIPE_MODIFY;
   WriteSystemLog("boolSendSCESCommand: 1");
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_RCPM - SECS_CMD_STAT_1;

}
//---------------------------------------------------------------------------
// 2016 5 26 - chc 填上sgResult抬頭
//	int    Width;
//	int    Height;
//	double CX;
//	double CY;
//	double Angle;
//	double Scale;
//	double Score;
//#define RESULT_FIELD_INDEX                0               // index
//#define RESULT_FIELD_WIDTH                1
//#define RESULT_FIELD_HEIGHT               2
//#define RESULT_FIELD_CX                   3
//#define RESULT_FIELD_CY                   4
//#define RESULT_FIELD_ANGLE                5
//#define RESULT_FIELD_SCALE                6
//#define RESULT_FIELD_SCORE                7
void __fastcall TMainForm::ResultTitle()
{

   // 2019 7 19 - chc 改成量測結果
   //#define RESULT_FIELD_INDEX                0               // index
   //#define RESULT_FIELD_AREA                 1
   //#define RESULT_FIELD_DOT                  2
   //#define RESULT_FIELD_VISIONRECIPE         3
   //#define RESULT_FIELD_RESULT               4
   //#define RESULT_FIELD_TIME                 5
   sgResult->RowCount = 2;
   sgResult->ColCount = 6;
   sgResult->Cells[RESULT_FIELD_INDEX][0]         = "編號";
   sgResult->Cells[RESULT_FIELD_AREA][0]          = "區域";
   sgResult->Cells[RESULT_FIELD_DOT][0]           = "點位";
   sgResult->Cells[RESULT_FIELD_VISIONRECIPE][0]  = "Recipe";
   sgResult->Cells[RESULT_FIELD_RESULT][0]        = "結果-角度";
   sgResult->Cells[RESULT_FIELD_TIME][0]          = "時間(sec)";
   // 寬度
   sgResult->ColWidths[RESULT_FIELD_INDEX]        = 60;
   sgResult->ColWidths[RESULT_FIELD_AREA]         = 60;
   sgResult->ColWidths[RESULT_FIELD_DOT]          = 60;
   sgResult->ColWidths[RESULT_FIELD_VISIONRECIPE] = 180;
   sgResult->ColWidths[RESULT_FIELD_RESULT]       = 150;
   sgResult->ColWidths[RESULT_FIELD_TIME]         = 70;
   // 清除sgResult
   sgResult->RowCount = 2;
   sgResult->Cells[RESULT_FIELD_INDEX][1]         = "";
   sgResult->Cells[RESULT_FIELD_AREA][1]          = "";
   sgResult->Cells[RESULT_FIELD_DOT][1]           = "";
   sgResult->Cells[RESULT_FIELD_VISIONRECIPE][1]  = "";
   sgResult->Cells[RESULT_FIELD_RESULT][1]        = "";
   sgResult->Cells[RESULT_FIELD_TIME][1]          = "";
   return;
}
//---------------------------------------------------------------------------
// 2016 2 25 - chc 填上sgUser抬頭
// Data: Name, Password, Level
//#define USER_FIELD_NO                  0               // No
//#define USER_FIELD_NAME                1               // Name
//#define USER_FIELD_PASSWORD            2               // Password
//#define USER_FIELD_LEVEL               3               // Level
void __fastcall TMainForm::UserTitle()
{

   sgUser->Cells[USER_FIELD_NO][0]            = "No";
   sgUser->Cells[USER_FIELD_NAME][0]          = "Name";
   sgUser->Cells[USER_FIELD_PASSWORD][0]      = "Password";
   sgUser->Cells[USER_FIELD_LEVEL][0]         = "Level";

   // 寬度
   sgUser->ColWidths[USER_FIELD_NO]           = 50;
   sgUser->ColWidths[USER_FIELD_NAME]         = 120;
   sgUser->ColWidths[USER_FIELD_PASSWORD]     = 280;
   sgUser->ColWidths[USER_FIELD_LEVEL]        = 80;

   // 清除sgUser
   sgUser->RowCount = 2;
   sgUser->Cells[USER_FIELD_NO][1]            = "";
   sgUser->Cells[USER_FIELD_NAME][1]          = "";
   sgUser->Cells[USER_FIELD_PASSWORD][1]      = "";
   sgUser->Cells[USER_FIELD_LEVEL][1]         = "";

}
//---------------------------------------------------------------------------
// 2016 2 18 - chc 置中顯示
void __fastcall TMainForm::sgResultDrawCell(TObject *Sender,
      int ACol, int ARow, TRect &Rect, TGridDrawState State)
{
AnsiString Str=" ";
TColor fontcolor;
bool boolbold;

// 區分大小來源
TStringGrid *stringgrid;
stringgrid = (TStringGrid*)Sender;

   ((TStringGrid*)Sender)->Canvas->Font = ((TStringGrid*)Sender)->Font;
   for(int i=0 ; i<((TStringGrid*)Sender)->RowCount ; i++){
      if(((TStringGrid*)Sender)->Cells[ACol][i].Length() > Str.Length())
         Str = ((TStringGrid*)Sender)->Cells[ACol][i];

   }
   int colWidth = ((TStringGrid*)Sender)->Canvas->TextWidth(Str)+4;
   if(colWidth > ((TStringGrid*)Sender)->ColWidths[ACol])
      ((TStringGrid*)Sender)->ColWidths[ACol] = colWidth;
   fontcolor = clBlack;

   if(ARow != 0) {
      // 差量加上顏色
      if(ACol == RESULT_FIELD_SCORE) {
         boolbold = true;
         ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x00CCCC99;
         if(((TStringGrid*)Sender)->Cells[RESULT_FIELD_SCORE][ARow] != "") {
            if(((TStringGrid*)Sender)->Cells[RESULT_FIELD_SCORE][ARow].ToDouble() < 0.90) {
               fontcolor = clRed;
            }
         }
      }
      else {
         fontcolor = clBlack;
         boolbold = false;
         // 結果欄顏色設定
         if(ACol == RESULT_FIELD_SCORE)
            ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x0099B5FF;
         else {
            // 奇偶數不同顏色
            if((ARow % 2) != 0)
               ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x0093F4F2;
            else
                ((TStringGrid*)Sender)->Canvas->Brush->Color = clWhite;
         }
      }
   }

   // 改變字體顏色
   ((TStringGrid*)Sender)->Canvas->Font->Color = fontcolor;
   if(boolbold == true)
      ((TStringGrid*)Sender)->Canvas->Font->Style = TFontStyles()<< fsBold;

   ((TStringGrid*)Sender)->Canvas->FillRect(Rect);
   DrawText(((TStringGrid*)Sender)->Canvas->Handle,((TStringGrid*)Sender)->Cells[ACol][ARow].c_str(),-1,(RECT*)&Rect,DT_SINGLELINE|DT_VCENTER|DT_CENTER);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnManualOkClick(TObject *Sender)
{

   pnlError->Visible = false;
}
//---------------------------------------------------------------------------
// 加入Database & sgResult
//   #define RESULT_FIELD_INDEX                0               // index
//   #define RESULT_FIELD_WIDTH                1
//   #define RESULT_FIELD_HEIGHT               2
//   #define RESULT_FIELD_CX                   3
//   #define RESULT_FIELD_CY                   4
//   #define RESULT_FIELD_ANGLE                5
//   #define RESULT_FIELD_SCALE                6
//   #define RESULT_FIELD_SCORE                7
void __fastcall TMainForm::AddsgResult(int index, int width, int height, int cx, int cy, double angle, double scale, double score)
{
AnsiString temp;

   MainForm->sgResult->Cells[RESULT_FIELD_INDEX][MainForm->sgResult->RowCount-1]   = index;
   MainForm->sgResult->Cells[RESULT_FIELD_WIDTH][MainForm->sgResult->RowCount-1]   = width;
   MainForm->sgResult->Cells[RESULT_FIELD_HEIGHT][MainForm->sgResult->RowCount-1]  = height;
   MainForm->sgResult->Cells[RESULT_FIELD_CX][MainForm->sgResult->RowCount-1]      = cx;
   MainForm->sgResult->Cells[RESULT_FIELD_CY][MainForm->sgResult->RowCount-1]      = cy;
   temp.sprintf("%.3f",angle);
   MainForm->sgResult->Cells[RESULT_FIELD_ANGLE][MainForm->sgResult->RowCount-1]   = temp;
   temp.sprintf("%.2f",scale);
   MainForm->sgResult->Cells[RESULT_FIELD_SCALE][MainForm->sgResult->RowCount-1]   = temp;
   temp.sprintf("%.3f",score);
   MainForm->sgResult->Cells[RESULT_FIELD_SCORE][MainForm->sgResult->RowCount-1]   = temp;

   MainForm->sgResult->RowCount++;
   // 清除最後一Row
   MainForm->sgResult->Cells[RESULT_FIELD_INDEX][MainForm->sgResult->RowCount-1]   = "";
   MainForm->sgResult->Cells[RESULT_FIELD_WIDTH][MainForm->sgResult->RowCount-1]   = "";
   MainForm->sgResult->Cells[RESULT_FIELD_HEIGHT][MainForm->sgResult->RowCount-1]  = "";
   MainForm->sgResult->Cells[RESULT_FIELD_CX][MainForm->sgResult->RowCount-1]      = "";
   MainForm->sgResult->Cells[RESULT_FIELD_CY][MainForm->sgResult->RowCount-1]      = "";
   MainForm->sgResult->Cells[RESULT_FIELD_ANGLE][MainForm->sgResult->RowCount-1]   = "";
   MainForm->sgResult->Cells[RESULT_FIELD_SCALE][MainForm->sgResult->RowCount-1]   = "";
   MainForm->sgResult->Cells[RESULT_FIELD_SCORE][MainForm->sgResult->RowCount-1]   = "";

   // 指到最後一筆
   MainForm->sgResult->Row = MainForm->sgResult->RowCount-1;
}
//---------------------------------------------------------------------------
// 切換Recipe
void __fastcall TMainForm::combRecipeChange(TObject *Sender)
{
int no;

   no = 0;
   //UpdateRecipe();
}
//---------------------------------------------------------------------------
// Read Recipe : Max 50組
// RecipeTotalNo
/*
   #define RECICPE_STEP_NO           "Step No"
   #define RECICPE_DELAY_TIME        "Delay Time"
   #define RECICPE_LOOP              "Loop"
   #define RECICPE_SPEED             "Speed"
   #define RECICPE_INTERVAL          "Interval"
   #define RECICPE_MODE              "Mode"
   #define RECICPE_BOOL_SAME_SPEED   "Bool Same Speed"
   #define RECICPE_BOOL_ZERO         "Bool Zero"
   #define RECICPE_MIN               "Min"
   #define RECICPE_MAX               "Max"
   #define RECICPE_BOOL_AXIS1        "Bool Axis1"
   #define RECICPE_BOOL_AXIS2        "Bool Axis2"
   #define RECICPE_BOOL_AXIS3        "Bool Axis3"
   #define RECICPE_BOOL_AXIS4        "Bool Axis4"
   #define RECICPE_COUNTER_TBITS     "Counter TBits"
   #define RECICPE_COUNTER_EBITS     "Counter EBits"
   #define RECICPE_COUNTER_POS       "Counter Pos"
   #define RECICPE_ANGLE_TBITS       "Angle TBits"
   #define RECICPE_ANGLE_EBITS       "Angle EBits"
   #define RECICPE_ANGLE_POS         "Angle Pos"
   #define RECICPE_NAME              "Name"
   struct RECIPE_STRU   {
      int StepNo;
      int DelayTime;
      int Loop;
      int Speed;
      int Interval;
      int Mode;
      bool boolSameSpeed;
      bool boolZero;
      double Min,Max;
      bool boolAxis1,boolAxis2,boolAxis3,boolAxis4;
      int CounterTBits,CounterEBits,CounterPos;
      int AngleTBits,AngleEBits,AnglePos;
      AnsiString Name;
   };
   struct RECIPE_STRU RecipeBuffer[RECIPE_MAX];
*/
int ArrayRow,ArrayCol;
int ArrayRowOri=-1,ArrayColOri=-1;
double ArrayRowPos,ArrayColPos;
bool __fastcall TMainForm::ReadRecipe(AnsiString rfname)
{
TIniFile *pSystemFile;
AnsiString str,fname;

   // ini檔名與目錄: BiSSMotion.ini
   fname = RecipeDirectory + "\\" + rfname;
   if(!FileExists(fname)) {
      sbSystemMessage->Panels->Items[1]->Text = rfname + "Not Existed!";
      return false;
   }
   // 載入ini檔
   pSystemFile = new TIniFile(fname);
   RecipeBuffer[RecipeTotalNo].Name          = pSystemFile->ReadString(RECIPE_INFORMATION_SECTION,RECICPE_NAME            ,"A1");
   // Array/Die Size
   RecipeBuffer[RecipeTotalNo].ArrayWidth    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Array Width"          ,5000);
   RecipeBuffer[RecipeTotalNo].ArrayHeight   = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Array Height"         ,5000);
   RecipeBuffer[RecipeTotalNo].DieWidth      = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Die Width"            ,5000);
   RecipeBuffer[RecipeTotalNo].DieHeight     = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Die Height"           ,5000);

   // 2016 7 13 - chc @#@# Array & array
   RecipeBuffer[RecipeTotalNo].Array1Width    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Array1 Width"          ,5000);
   RecipeBuffer[RecipeTotalNo].Array1Height   = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Array1 Height"         ,5000);
   RecipeBuffer[RecipeTotalNo].Array2Width    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Array2 Width"          ,5000);
   RecipeBuffer[RecipeTotalNo].Array2Height   = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Array2 Height"         ,5000);

   // 2016 8 3 - chc Wafer Size & Pattern/Aperture Position
   RecipeBuffer[RecipeTotalNo].WaferSize        = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Wafer Size"            ,3);
   RecipeBuffer[RecipeTotalNo].PatternPosition  = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pattern Position"      ,0);
   RecipeBuffer[RecipeTotalNo].AperturePosition = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Aperture Position"     ,0);

   // 2016 10 13 - chc Pattern Shift Offset
   RecipeBuffer[RecipeTotalNo].PatternOffsetX  = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"Pattern Offset X"       ,0.0);
   RecipeBuffer[RecipeTotalNo].PatternOffsetY  = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"Pattern Offset Y"       ,0.0);
   // Laser Size
   RecipeBuffer[RecipeTotalNo].LaserSizeX      = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"Laser Size X"           ,4.8);
   RecipeBuffer[RecipeTotalNo].LaserSizeY      = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"Laser Size Y"           ,4.8);

   // 2019 7 15 - chc 讀取Recipe: Base/Area/Dot & Display
   for(int i=0 ; i<2 ; i++) {
      RecipeBuffer[RecipeTotalNo].BaseBuf[i].X    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" X"       ,20000+i);
      RecipeBuffer[RecipeTotalNo].BaseBuf[i].Y    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" Y"       ,20000+i);
      RecipeBuffer[RecipeTotalNo].BaseBuf[i].Z    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" Z"       ,20000+i);
   }
   RecipeBuffer[RecipeTotalNo].AreaNo    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Area No"                        ,5);
   if(RecipeBuffer[RecipeTotalNo].AreaNo > MAX_AREA_NO)
      RecipeBuffer[RecipeTotalNo].AreaNo = MAX_AREA_NO;

   // 2019 12 13 - chc 要加2
   //sgArea->RowCount = RecipeBuffer[RecipeTotalNo].AreaNo + 1;
   sgArea->RowCount = RecipeBuffer[RecipeTotalNo].AreaNo + 2;

   for(int i=0 ; i<RecipeBuffer[RecipeTotalNo].AreaNo ; i++) {
      RecipeBuffer[RecipeTotalNo].AreaBuf[i].X    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Area"+IntToStr(i+1)+" X"       ,20000+i);
      RecipeBuffer[RecipeTotalNo].AreaBuf[i].Y    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Area"+IntToStr(i+1)+" Y"       ,20000+i);
      RecipeBuffer[RecipeTotalNo].AreaBuf[i].Z    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Area"+IntToStr(i+1)+" Z"       ,20000+i);
      sgArea->Cells[0][i+1] = IntToStr(i+1);
      sgArea->Cells[1][i+1] = IntToStr(RecipeBuffer[RecipeTotalNo].AreaBuf[i].X);
      sgArea->Cells[2][i+1] = IntToStr(RecipeBuffer[RecipeTotalNo].AreaBuf[i].Y);
      sgArea->Cells[3][i+1] = IntToStr(RecipeBuffer[RecipeTotalNo].AreaBuf[i].Z);
   }

   // 2019 12 13 - chc 清除最後一Row
   for(int i=0 ; i<4 ; i++)
      sgArea->Cells[i][sgArea->RowCount-1] = "";

   RecipeBuffer[RecipeTotalNo].DotNo    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot No"                        ,5);
   if(RecipeBuffer[RecipeTotalNo].DotNo > MAX_DOT_NO)
      RecipeBuffer[RecipeTotalNo].DotNo = MAX_DOT_NO;

   // 2019 12 13 - chc 要加2
   //sgDot->RowCount = RecipeBuffer[RecipeTotalNo].DotNo + 1;
   sgDot->RowCount = RecipeBuffer[RecipeTotalNo].DotNo + 2;

   for(int i=0 ; i<RecipeBuffer[RecipeTotalNo].DotNo ; i++) {
      RecipeBuffer[RecipeTotalNo].DotBuf[i].X    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" X"       ,20000+i);
      RecipeBuffer[RecipeTotalNo].DotBuf[i].Y    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Y"       ,20000+i);
      RecipeBuffer[RecipeTotalNo].DotBuf[i].Z    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Z"       ,20000+i);
      RecipeBuffer[RecipeTotalNo].DotBuf[i].Intensity    = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Intensity"       ,10+i);
      RecipeBuffer[RecipeTotalNo].DotBuf[i].Row    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Row"       ,32);
      RecipeBuffer[RecipeTotalNo].DotBuf[i].Col    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Col"       ,32);

      sgDot->Cells[0][i+1] = IntToStr(i+1);
      sgDot->Cells[1][i+1] = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[i].X);
      sgDot->Cells[2][i+1] = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[i].Y);
      sgDot->Cells[3][i+1] = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[i].Z);
      str.sprintf("%.2f",RecipeBuffer[RecipeTotalNo].DotBuf[i].Intensity);
      sgDot->Cells[4][i+1] = str;
      RecipeBuffer[RecipeTotalNo].DotBuf[i].Recipe    = pSystemFile->ReadString(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Recipe"       ,"NA");
      sgDot->Cells[5][i+1] = RecipeBuffer[RecipeTotalNo].DotBuf[i].Recipe;
      sgDot->Cells[6][i+1] = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[i].Row);
      sgDot->Cells[7][i+1] = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[i].Col);
   }

   // 2019 12 13 - chc 清除最後一Row
   for(int i=0 ; i<8 ; i++)
      sgDot->Cells[i][sgDot->RowCount-1] = "";

   // 設定第1 Area/Dot值
   edAreaNo->Text = "1";
   edAreaTNo->Text = IntToStr(RecipeBuffer[RecipeTotalNo].AreaNo);
   pnlAreaX->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].AreaBuf[0].X);
   pnlAreaY->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].AreaBuf[0].Y);
   pnlAreaZ->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].AreaBuf[0].Z);
   // Dot
   edDotNo->Text = "1";
   edDotTNo->Text = IntToStr(RecipeBuffer[RecipeTotalNo].DotNo);
   pnlDotX->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[0].X);
   pnlDotY->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[0].Y);
   pnlDotZ->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[0].Z);
   str.sprintf("%.2f",RecipeBuffer[RecipeTotalNo].DotBuf[0].Intensity);
   pnlDotIntensity->Caption = str;
   comboOlympusVisionName1->Text = RecipeBuffer[RecipeTotalNo].DotBuf[0].Recipe;
   pnlDotRow->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[0].Row);
   pnlDotCol->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].DotBuf[0].Col);
   // Base
   pnlBase1X->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].BaseBuf[0].X);
   pnlBase1Y->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].BaseBuf[0].Y);
   pnlBase1Z->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].BaseBuf[0].Z);
   pnlBase2X->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].BaseBuf[1].X);
   pnlBase2Y->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].BaseBuf[1].Y);
   pnlBase2Z->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].BaseBuf[1].Z);

   // 2019 12 9 - chc 加入: 儲存座標檔參數: 路徑, 檔名, 原點座標, 單位, 方向.
   RecipeBuffer[RecipeTotalNo].kmfPath = pSystemFile->ReadString(RECIPE_INFORMATION_SECTION,KMF_PATH         ,"D:\\WVMove-System\\kmf");
   RecipeBuffer[RecipeTotalNo].kmfFilename = pSystemFile->ReadString(RECIPE_INFORMATION_SECTION,KMF_FILENAME ,"kmf-am9-00_2_sensofar-nom.txt");
   RecipeBuffer[RecipeTotalNo].kmfX = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,KMF_X              ,0);
   RecipeBuffer[RecipeTotalNo].kmfY = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,KMF_Y              ,0);
   RecipeBuffer[RecipeTotalNo].kmfUnit = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,KMF_UNIT        ,0);
   RecipeBuffer[RecipeTotalNo].kmfDirection = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,KMF_DIRECTION   ,0);
   RecipeBuffer[RecipeTotalNo].boolkmfDirection = pSystemFile->ReadBool(RECIPE_INFORMATION_SECTION,KMF_BOOL_DIRECTION   ,true);

   // 2021 6 16 - chc 加入Die size
   RecipeBuffer[RecipeTotalNo].DieSizeX = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"DieSizeX"                ,5000);
   RecipeBuffer[RecipeTotalNo].DieSizeY = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"DieSizeY"                ,5000);
   RecipeBuffer[RecipeTotalNo].DieSizeGapX = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"DieSizeGapX"          ,0);
   RecipeBuffer[RecipeTotalNo].DieSizeGapY = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"DieSizeGapY"          ,0);
   str.sprintf("%.2f",RecipeBuffer[RecipeTotalNo].DieSizeX);
   edDieSizeX1->Text = str;
   edDieSizeX->Text = str;
   edDieWidth->Text = str;
   str.sprintf("%.2f",RecipeBuffer[RecipeTotalNo].DieSizeY);
   edDieSizeY1->Text = str;
   edDieSizeY->Text = str;
   edDieHeight->Text = str;
   str.sprintf("%.2f",RecipeBuffer[RecipeTotalNo].DieSizeGapX);
   edDieSizeGapX1->Text = str;
   edDieSizeGapX->Text = str;
   edDieGapX->Text = str;
   str.sprintf("%.2f",RecipeBuffer[RecipeTotalNo].DieSizeGapY);
   edDieSizeGapY1->Text = str;
   edDieSizeGapY->Text = str;
   edDieGapY->Text = str;

   // 2023 1 28 - chc edY45Offset
   RecipeBuffer[RecipeTotalNo].Y45Offset = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Y45Offset"                ,0);
   edY45Offset->Text = IntToStr(RecipeBuffer[RecipeTotalNo].Y45Offset);

   // 2021 8 6 - chc 加入Wafer角度設定
   RecipeBuffer[RecipeTotalNo].Pos1X = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pos1X"                 ,0);
   RecipeBuffer[RecipeTotalNo].Pos1Y = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pos1Y"                 ,0);
   RecipeBuffer[RecipeTotalNo].Pos2X = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pos2X"                 ,0);
   RecipeBuffer[RecipeTotalNo].Pos2Y = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pos2Y"                 ,0);
   RecipeBuffer[RecipeTotalNo].Pos3X = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pos3X"                 ,0);
   RecipeBuffer[RecipeTotalNo].Pos3Y = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pos3Y"                 ,0);
   RecipeBuffer[RecipeTotalNo].Pos4X = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pos4X"                 ,0);
   RecipeBuffer[RecipeTotalNo].Pos4Y = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Pos4Y"                 ,0);
   RecipeBuffer[RecipeTotalNo].XDegree = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"DieXDegree"            ,0);
   RecipeBuffer[RecipeTotalNo].YDegree = pSystemFile->ReadFloat(RECIPE_INFORMATION_SECTION,"DieYDegree"            ,0);
   RecipeBuffer[RecipeTotalNo].DieCenterX = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"DieCenterX"       ,0);
   RecipeBuffer[RecipeTotalNo].DieCenterY = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"DieCenterY"       ,0);
   pnlWaferPosition1X->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].Pos1X);
   pnlWaferPosition1Y->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].Pos1Y);
   pnlWaferPosition2X->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].Pos2X);
   pnlWaferPosition2Y->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].Pos2Y);
   pnlWaferPosition3X->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].Pos3X);
   pnlWaferPosition3Y->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].Pos3Y);
   pnlWaferPosition4X->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].Pos4X);
   pnlWaferPosition4Y->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].Pos4Y);
   str.sprintf("%.4f",RecipeBuffer[RecipeTotalNo].XDegree);
   pnlWaferDegreeX->Caption = str;
   str.sprintf("%.4f",RecipeBuffer[RecipeTotalNo].YDegree);
   pnlWaferDegreeY->Caption = str;
   pnlWaferDieCenterX->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].DieCenterX);
   pnlWaferDieCenterY->Caption = IntToStr(RecipeBuffer[RecipeTotalNo].DieCenterY);

   // 2021 10 6 - chc 若未定義用尋找中心
   // => 若偏移量太大就不做偏移量就好
   //if(RecipeBuffer[RecipeTotalNo].DieCenterX == 0)
   //   pnlWaferDieCenterX->Caption = pnlCenterXFind->Caption;
   //if(RecipeBuffer[RecipeTotalNo].DieCenterY == 0)
   //   pnlWaferDieCenterY->Caption = pnlCenterYFind->Caption;

   delete pSystemFile;
   return true;
}
//---------------------------------------------------------------------------
// Recipe Switch
bool __fastcall TMainForm::DisplayRecipe(int no)
{
AnsiString str;

   // 2019 7 18 - chc 顯示Area/Dot/Base Information
   if(RecipeBuffer[no].AreaNo > MAX_AREA_NO)
      RecipeBuffer[no].AreaNo = MAX_AREA_NO;

   // 2019 12 13 - chc 要加2
   //sgArea->RowCount = RecipeBuffer[no].AreaNo + 1;
   sgArea->RowCount = RecipeBuffer[no].AreaNo + 2;

   edAreaTNo->Text = IntToStr(RecipeBuffer[no].AreaNo);
   for(int i=0 ; i<RecipeBuffer[no].AreaNo ; i++) {
      sgArea->Cells[0][i+1] = IntToStr(i+1);
      sgArea->Cells[1][i+1] = IntToStr(RecipeBuffer[no].AreaBuf[i].X);
      sgArea->Cells[2][i+1] = IntToStr(RecipeBuffer[no].AreaBuf[i].Y);
      sgArea->Cells[3][i+1] = IntToStr(RecipeBuffer[no].AreaBuf[i].Z);
   }

   // 2019 12 11 - chc 清除最後一Row
   for(int i=0 ; i<4 ; i++)
      sgArea->Cells[i][sgArea->RowCount-1] = "";

   if(RecipeBuffer[no].DotNo > MAX_DOT_NO)
      RecipeBuffer[no].DotNo = MAX_DOT_NO;

   // 2019 12 13 - chc 要加2
   //sgDot->RowCount = RecipeBuffer[no].DotNo + 1;
   sgDot->RowCount = RecipeBuffer[no].DotNo + 2;

   edDotTNo->Text = IntToStr(RecipeBuffer[no].DotNo);
   for(int i=0 ; i<RecipeBuffer[no].DotNo ; i++) {
      sgDot->Cells[0][i+1] = IntToStr(i+1);
      sgDot->Cells[1][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].X);
      sgDot->Cells[2][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].Y);
      sgDot->Cells[3][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].Z);
      str.sprintf("%.2f",RecipeBuffer[no].DotBuf[i].Intensity);
      sgDot->Cells[4][i+1] = str;
      sgDot->Cells[5][i+1] = RecipeBuffer[no].DotBuf[i].Recipe;
      sgDot->Cells[6][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].Row);
      sgDot->Cells[7][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].Col);
   }

   // 2019 12 11 - chc 清除最後一Row
   for(int i=0 ; i<8 ; i++)
      sgDot->Cells[i][sgDot->RowCount-1] = "";

   // 設定第1 Area/Dot值
   edAreaNo->Text = "1";
   edAreaTNo->Text = IntToStr(RecipeBuffer[no].AreaNo);
   pnlAreaX->Caption = IntToStr(RecipeBuffer[no].AreaBuf[0].X);
   pnlAreaY->Caption = IntToStr(RecipeBuffer[no].AreaBuf[0].Y);
   pnlAreaZ->Caption = IntToStr(RecipeBuffer[no].AreaBuf[0].Z);
   // Dot
   edDotNo->Text = "1";
   edDotTNo->Text = IntToStr(RecipeBuffer[no].DotNo);
   pnlDotX->Caption = IntToStr(RecipeBuffer[no].DotBuf[0].X);
   pnlDotY->Caption = IntToStr(RecipeBuffer[no].DotBuf[0].Y);
   pnlDotZ->Caption = IntToStr(RecipeBuffer[no].DotBuf[0].Z);
   str.sprintf("%.2f",RecipeBuffer[no].DotBuf[0].Intensity);
   pnlDotIntensity->Caption = str;
   comboOlympusVisionName1->Text = RecipeBuffer[no].DotBuf[0].Recipe;
   pnlDotRow->Caption = IntToStr(RecipeBuffer[no].DotBuf[0].Row);
   pnlDotCol->Caption = IntToStr(RecipeBuffer[no].DotBuf[0].Col);
   // Base
   pnlBase1X->Caption = IntToStr(RecipeBuffer[no].BaseBuf[0].X);
   pnlBase1Y->Caption = IntToStr(RecipeBuffer[no].BaseBuf[0].Y);
   pnlBase1Z->Caption = IntToStr(RecipeBuffer[no].BaseBuf[0].Z);
   pnlBase2X->Caption = IntToStr(RecipeBuffer[no].BaseBuf[1].X);
   pnlBase2Y->Caption = IntToStr(RecipeBuffer[no].BaseBuf[1].Y);
   pnlBase2Z->Caption = IntToStr(RecipeBuffer[no].BaseBuf[1].Z);

   // 2019 12 13 - chc 要設定Recipe的Recipe Name
   combRecipe->Text = cbRecipe->Text;
   pnlRecipeTypeRecipe->Caption = cbRecipe->Text;

   // 2019 12 9 - chc 加入: 儲存座標檔參數: 路徑, 檔名, 原點座標, 單位, 方向.
   edkmfPath->Text = RecipeBuffer[no].kmfPath;
   edkmfFilename->Text = RecipeBuffer[no].kmfFilename;
   edkmfX->Text = IntToStr(RecipeBuffer[no].kmfX);
   edkmfY->Text = IntToStr(RecipeBuffer[no].kmfY);
   rgkmfUnit->ItemIndex = RecipeBuffer[no].kmfUnit;
   rgkmfDirection->ItemIndex = RecipeBuffer[no].kmfDirection;
   cbkmfDirection->Checked = RecipeBuffer[no].boolkmfDirection;

   // 2020 1 21 - chc 強制為true
   cbkmfDirection->Checked = true;

   // 直接讀取
   btnReadkmfClick(this);
   return true;

}
//---------------------------------------------------------------------------
// 2016 10 14 - chc Recipe Switch
bool __fastcall TMainForm::DisplayRecipeSet(int no)
{
AnsiString str;

   // Array/Die Size
   edArrayWidthRecipe->Text = IntToStr(RecipeBuffer[no].ArrayWidth);
   edArrayHeightRecipe->Text = IntToStr(RecipeBuffer[no].ArrayHeight);
   edDieWidthRecipe->Text = IntToStr(RecipeBuffer[no].DieWidth);
   edDieHeightRecipe->Text = IntToStr(RecipeBuffer[no].DieHeight);

   // Array & array
   edArray1WidthRecipe->Text = IntToStr(RecipeBuffer[no].Array1Width);
   edArray1HeightRecipe->Text = IntToStr(RecipeBuffer[no].Array1Height);
   edArray2WidthRecipe->Text = IntToStr(RecipeBuffer[no].Array2Width);
   edArray2HeightRecipe->Text = IntToStr(RecipeBuffer[no].Array2Height);

   // Wafer Size & Pattern/Aperture Position
   combSizeRecipe->ItemIndex = RecipeBuffer[no].WaferSize;

   // 2023 7 25 - chc title標示尺寸
   gbArrayOperation->Caption = AnsiString("Type1(") + edArrayWidthRecipe->Text + "," + edArrayHeightRecipe->Text + ")";
   gbArray1Operation->Caption = AnsiString("Type2(") + edArray1WidthRecipe->Text + "," + edArray1HeightRecipe->Text + ")";
   gbArray2Operation->Caption = AnsiString("Type3(") + edArray2WidthRecipe->Text + "," + edArray2HeightRecipe->Text + ")";
   gbDieOperation->Caption = AnsiString("Type4(") + edDieWidthRecipe->Text + "," + edDieHeightRecipe->Text + ")";

   // 2019 7 23 - chc 顯示目前的Recipe: Array/Dot
   // Area/Dot/Base 更新至Buffer & Write to recipe.ini
   // Area
   edAreaTNo->Text = IntToStr(RecipeBuffer[no].AreaNo);

   // 2019 12 13 - chc 要加2
   //sgArea->RowCount = RecipeBuffer[no].AreaNo + 1;
   sgArea->RowCount = RecipeBuffer[no].AreaNo + 2;

   for(int i=0 ; i<RecipeBuffer[no].AreaNo ; i++) {
      sgArea->Cells[0][i+1] = IntToStr(i+1);
      sgArea->Cells[1][i+1] = IntToStr(RecipeBuffer[no].AreaBuf[i].X);
      sgArea->Cells[2][i+1] = IntToStr(RecipeBuffer[no].AreaBuf[i].Y);
      sgArea->Cells[3][i+1] = IntToStr(RecipeBuffer[no].AreaBuf[i].Z);
   }

   // 2019 12 11 - chc 清除最後一Row
   for(int i=0 ; i<4 ; i++)
      sgArea->Cells[i][sgArea->RowCount-1] = "";

   // Base1
   pnlBase1X->Caption = IntToStr(RecipeBuffer[no].BaseBuf[0].X);
   pnlBase1Y->Caption = IntToStr(RecipeBuffer[no].BaseBuf[0].Y);
   pnlBase1Z->Caption = IntToStr(RecipeBuffer[no].BaseBuf[0].Z);
   pnlBase2X->Caption = IntToStr(RecipeBuffer[no].BaseBuf[1].X);
   pnlBase2Y->Caption = IntToStr(RecipeBuffer[no].BaseBuf[1].Y);
   pnlBase2Z->Caption = IntToStr(RecipeBuffer[no].BaseBuf[1].Z);
   // Dot
   edDotTNo->Text = IntToStr(RecipeBuffer[no].DotNo);

   // 2019 12 13 - chc 要加2
   //sgDot->RowCount = RecipeBuffer[no].DotNo + 1;
   sgDot->RowCount = RecipeBuffer[no].DotNo + 2;

   for(int i=0 ; i<RecipeBuffer[no].DotNo ; i++) {

      // 2021 10 6 - chc 標示編號
      sgDot->Cells[0][i+1] = IntToStr(i+1);

      // Set to Buffer
      sgDot->Cells[1][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].X);
      sgDot->Cells[2][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].Y);
      sgDot->Cells[3][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].Z);
      str.sprintf("%.2f",RecipeBuffer[no].DotBuf[i].Intensity);
      sgDot->Cells[4][i+1] = str;
      sgDot->Cells[5][i+1] = RecipeBuffer[no].DotBuf[i].Recipe;
      sgDot->Cells[6][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].Row);
      sgDot->Cells[7][i+1] = IntToStr(RecipeBuffer[no].DotBuf[i].Col);
   }

   // 2021 6 16 - chc 更新DieSize
   str.sprintf("%.2f",RecipeBuffer[no].DieSizeX);
   edDieSizeX1->Text = str;
   edDieSizeX->Text = str;
   edDieWidth->Text = str;
   str.sprintf("%.2f",RecipeBuffer[no].DieSizeY);
   edDieSizeY1->Text = str;
   edDieSizeY->Text = str;
   edDieHeight->Text = str;
   str.sprintf("%.2f",RecipeBuffer[no].DieSizeGapX);
   edDieSizeGapX1->Text = str;
   edDieSizeGapX->Text = str;
   edDieGapX->Text = str;
   str.sprintf("%.2f",RecipeBuffer[no].DieSizeGapY);
   edDieSizeGapY1->Text = str;
   edDieSizeGapY->Text = str;
   edDieGapY->Text = str;

   // 2021 8 6 - chc 加入Wafer角度設定
   pnlWaferPosition1X->Caption = IntToStr(RecipeBuffer[no].Pos1X);
   pnlWaferPosition1Y->Caption = IntToStr(RecipeBuffer[no].Pos1Y);
   pnlWaferPosition2X->Caption = IntToStr(RecipeBuffer[no].Pos2X);
   pnlWaferPosition2Y->Caption = IntToStr(RecipeBuffer[no].Pos2Y);
   pnlWaferPosition3X->Caption = IntToStr(RecipeBuffer[no].Pos3X);
   pnlWaferPosition3Y->Caption = IntToStr(RecipeBuffer[no].Pos3Y);
   pnlWaferPosition4X->Caption = IntToStr(RecipeBuffer[no].Pos4X);
   pnlWaferPosition4Y->Caption = IntToStr(RecipeBuffer[no].Pos4Y);
   str.sprintf("%.4f",RecipeBuffer[no].XDegree);
   pnlWaferDegreeX->Caption = str;
   str.sprintf("%.4f",RecipeBuffer[no].YDegree);
   pnlWaferDegreeY->Caption = str;
   pnlWaferDieCenterX->Caption = IntToStr(RecipeBuffer[no].DieCenterX);
   pnlWaferDieCenterY->Caption = IntToStr(RecipeBuffer[no].DieCenterY);

   // 2023 2 8 - chc Y45Offset Update - DisplayRecipeSet()
   edY45Offset->Text = IntToStr(RecipeBuffer[no].Y45Offset);

   // 2021 10 6 - chc 若未定義用尋找中心
   // => 若偏移量太大就不做偏移量就好
   //if(RecipeBuffer[no].DieCenterX == 0)
   //   pnlWaferDieCenterX->Caption = pnlCenterXFind->Caption;
   //if(RecipeBuffer[no].DieCenterY == 0)
   //   pnlWaferDieCenterY->Caption = pnlCenterYFind->Caption;

   // 2019 12 11 - chc 清除最後一Row
   for(int i=0 ; i<8 ; i++)
      sgDot->Cells[i][sgDot->RowCount-1] = "";

   // 2019 12 11 - chc 找量測影像檔: comboPattern
   AnsiString recipename = RecipeBuffer[no].Name;
   AnsiString mfname;
   comboPattern->Items->Clear();
   TSearchRec sr;
   int iAttributes = 0;
   int rno = 0;
   //faReadOnly	  $00000001	  Read-only files
   //faHidden	  $00000002	  Hidden files
   //faSysFile	  $00000004	  System files
   //faVolumeID	  $00000008	  Volume ID files
   //faDirectory  $00000010	  Directory files
   //faArchive	  $00000020	  Archive files
   //faAnyFile	  $0000003F	  Any file
   mfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-M*.bmp";
   iAttributes |= faArchive;
   if(FindFirst(mfname, iAttributes, sr) == 0) {
      do {
         if((sr.Attr & iAttributes) == sr.Attr) {                               // 檔名在sr.Name
            comboPattern->Items->Append(sr.Name);
            rno++;
         }
      } while (FindNext(sr) == 0);
   }
   FindClose(sr);

   // 2019 12 13 - chc 要有選項才可以設定
   if(rno > 0) {

      comboPattern->ItemIndex = 0;
      comboPattern->Text = comboPattern->Items->Strings[0];
   }

   return true;
}
//---------------------------------------------------------------------------
// Recipe Setting
bool __fastcall TMainForm::UpdateRecipe()
{
int no;
AnsiString str;

   no = combRecipe->ItemIndex;

   // 2016 12 29 - chc 不顯示在這裡
   //pnlRecipeSet->Caption = RecipeBuffer[no].Name;
   pnlRecipeTypeRecipe->Caption = RecipeBuffer[no].Name;

   // 2016 10 14 - chc need to display
   DisplayRecipeSet(no);

   return true;
}
//---------------------------------------------------------------------------
// Recipe Setting
bool __fastcall TMainForm::WriteRecipe()
{
int no;
AnsiString str;

   no = combRecipe->ItemIndex;
   if(no < 0) {

      // 2023 1 3 - chc WriteRecipe(): combRecipe->ItemIndex為-1, 攔住不處理
      AnsiString str;
      str = "Recipe名稱異常: " + combRecipe->Text + ", 不更新Recipe.     ";
      Application->MessageBox(str.c_str(),"Recipe寫入作業",MB_ICONINFORMATION|MB_SYSTEMMODAL|MB_OK);
      str.sprintf("WriteRecipe() - Recipe名稱異常: %s, %d",combRecipe->Text.c_str(),combRecipe->ItemIndex);
      WriteSystemLog(str);
      return false;

      no = 0;
      combRecipe->ItemIndex = 0;
   }
   RecipeBuffer[no].Name                = combRecipe->Text;

   // Array/Die Size
   RecipeBuffer[no].ArrayWidth          = edArrayWidthRecipe->Text.ToInt();
   RecipeBuffer[no].ArrayHeight         = edArrayHeightRecipe->Text.ToInt();
   RecipeBuffer[no].DieWidth            = edDieWidthRecipe->Text.ToInt();
   RecipeBuffer[no].DieHeight           = edDieHeightRecipe->Text.ToInt();

   // 2016 7 13 - chc @#@# Array & array
   RecipeBuffer[no].Array1Width          = edArray1WidthRecipe->Text.ToInt();
   RecipeBuffer[no].Array1Height         = edArray1HeightRecipe->Text.ToInt();
   RecipeBuffer[no].Array2Width          = edArray2WidthRecipe->Text.ToInt();
   RecipeBuffer[no].Array2Height         = edArray2HeightRecipe->Text.ToInt();

   // Write .ini
   TIniFile *pSystemFile;
   AnsiString fname;
   // ini檔名與目錄: BiSSMotion.ini
   fname = RecipeDirectory + "\\" + RecipeBuffer[no].Name + ".ini";
   pSystemFile = new TIniFile(fname);
   pSystemFile->WriteString(RECIPE_INFORMATION_SECTION,RECICPE_NAME             ,RecipeBuffer[no].Name);
   // Array/Die Size
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Array Width"           ,RecipeBuffer[no].ArrayWidth);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Array Height"          ,RecipeBuffer[no].ArrayHeight);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Die Width"             ,RecipeBuffer[no].DieWidth);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Die Height"            ,RecipeBuffer[no].DieHeight);

   // 2016 7 13 - chc @#@# Array & array
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Array1 Width"          ,RecipeBuffer[no].Array1Width);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Array1 Height"         ,RecipeBuffer[no].Array1Height);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Array2 Width"          ,RecipeBuffer[no].Array2Width);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Array2 Height"         ,RecipeBuffer[no].Array2Height);

   // 2016 8 3 - chc Wafer Size & Pattern/Aperture Position
   RecipeBuffer[no].WaferSize          = combSizeRecipe->ItemIndex;
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Wafer Size"            ,RecipeBuffer[no].WaferSize);

   // 2021 5 4 - chc 限制為1
   edAreaTNo->Text = "1";

   // Area/Dot/Base 更新至Buffer & Write to recipe.ini
   // Area
   RecipeBuffer[no].AreaNo = edAreaTNo->Text.ToInt();
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Area No"               ,RecipeBuffer[no].AreaNo);
   for(int i=0 ; i<RecipeBuffer[no].AreaNo ; i++) {
      RecipeBuffer[no].AreaBuf[i].X = sgArea->Cells[1][i+1].ToInt();
      RecipeBuffer[no].AreaBuf[i].Y = sgArea->Cells[2][i+1].ToInt();
      RecipeBuffer[no].AreaBuf[i].Z = sgArea->Cells[3][i+1].ToInt();
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Area"+IntToStr(i+1)+" X"       ,RecipeBuffer[no].AreaBuf[i].X);
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Area"+IntToStr(i+1)+" Y"       ,RecipeBuffer[no].AreaBuf[i].Y);
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Area"+IntToStr(i+1)+" Z"       ,RecipeBuffer[no].AreaBuf[i].Z);
   }

   // Base1
   // 2021 5 4 - chc 不寫入
   /*
   RecipeBuffer[no].BaseBuf[0].X = pnlBase1X->Caption.ToInt();
   RecipeBuffer[no].BaseBuf[0].Y = pnlBase1Y->Caption.ToInt();
   RecipeBuffer[no].BaseBuf[0].Z = pnlBase1Z->Caption.ToInt();
   RecipeBuffer[no].BaseBuf[1].X = pnlBase2X->Caption.ToInt();
   RecipeBuffer[no].BaseBuf[1].Y = pnlBase2Y->Caption.ToInt();
   RecipeBuffer[no].BaseBuf[1].Z = pnlBase2Z->Caption.ToInt();
   for(int i=0 ; i<2 ; i++) {
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" X"       ,RecipeBuffer[no].BaseBuf[i].X);
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" Y"       ,RecipeBuffer[no].BaseBuf[i].Y);
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" Z"       ,RecipeBuffer[no].BaseBuf[i].Z);
   }
   */

   // Dot
   RecipeBuffer[no].DotNo = edDotTNo->Text.ToInt();
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Dot No"                 ,RecipeBuffer[no].DotNo);
   for(int i=0 ; i<RecipeBuffer[no].DotNo ; i++) {
      // Set to Buffer
      RecipeBuffer[no].DotBuf[i].X              = sgDot->Cells[1][i+1].ToInt();
      RecipeBuffer[no].DotBuf[i].Y              = sgDot->Cells[2][i+1].ToInt();
      RecipeBuffer[no].DotBuf[i].Z              = sgDot->Cells[3][i+1].ToInt();
      RecipeBuffer[no].DotBuf[i].Intensity      = sgDot->Cells[4][i+1].ToDouble();
      RecipeBuffer[no].DotBuf[i].Recipe         = sgDot->Cells[5][i+1];
      RecipeBuffer[no].DotBuf[i].Row            = sgDot->Cells[6][i+1].ToInt();
      RecipeBuffer[no].DotBuf[i].Col            = sgDot->Cells[7][i+1].ToInt();
      // Write to ini
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" X"              ,RecipeBuffer[no].DotBuf[i].X);
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Y"              ,RecipeBuffer[no].DotBuf[i].Y);
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Z"              ,RecipeBuffer[no].DotBuf[i].Z);
      pSystemFile->WriteFloat(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Intensity"        ,RecipeBuffer[no].DotBuf[i].Intensity);
      pSystemFile->WriteString(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Recipe"          ,RecipeBuffer[no].DotBuf[i].Recipe);
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Row"            ,RecipeBuffer[no].DotBuf[i].Row);
      pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Col"            ,RecipeBuffer[no].DotBuf[i].Col);
   }

   // 2021 6 16 - chc 加入Die size
   // 2021 9 27 - chc 以WaferMap為主
   //RecipeBuffer[no].DieSizeX = edDieSizeX1->Text.ToDouble();
   //RecipeBuffer[no].DieSizeY = edDieSizeY1->Text.ToDouble();
   //RecipeBuffer[no].DieSizeGapX = edDieSizeGapX1->Text.ToDouble();
   //RecipeBuffer[no].DieSizeGapY = edDieSizeGapY1->Text.ToDouble();
   RecipeBuffer[no].DieSizeX = edDieSizeX->Text.ToDouble();
   RecipeBuffer[no].DieSizeY = edDieSizeY->Text.ToDouble();
   RecipeBuffer[no].DieSizeGapX = edDieSizeGapX->Text.ToDouble();
   RecipeBuffer[no].DieSizeGapY = edDieSizeGapY->Text.ToDouble();

   pSystemFile->WriteFloat(RECIPE_INFORMATION_SECTION,"DieSizeX"                ,RecipeBuffer[no].DieSizeX);
   pSystemFile->WriteFloat(RECIPE_INFORMATION_SECTION,"DieSizeY"                ,RecipeBuffer[no].DieSizeY);
   pSystemFile->WriteFloat(RECIPE_INFORMATION_SECTION,"DieSizeGapX"             ,RecipeBuffer[no].DieSizeGapX);
   pSystemFile->WriteFloat(RECIPE_INFORMATION_SECTION,"DieSizeGapY"             ,RecipeBuffer[no].DieSizeGapY);
   str.sprintf("%.2f",RecipeBuffer[no].DieSizeX);

   // 2023 1 28 - chc edY45Offset
   RecipeBuffer[no].Y45Offset = edY45Offset->Text.ToInt();
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Y45Offset"             ,RecipeBuffer[no].Y45Offset);

   // 2021 9 27 - chc 以WaferMap為主
   //edDieSizeX->Text = str;
   edDieSizeX1->Text = str;

   edDieWidth->Text = str;
   str.sprintf("%.2f",RecipeBuffer[no].DieSizeY);

   // 2021 9 27 - chc 以WaferMap為主
   //edDieSizeY->Text = str;
   edDieSizeY1->Text = str;

   edDieHeight->Text = str;
   str.sprintf("%.2f",RecipeBuffer[no].DieSizeGapX);
   edDieSizeGapX->Text = str;
   edDieSizeGapX1->Text = str;
   edDieGapX->Text = str;
   str.sprintf("%.2f",RecipeBuffer[no].DieSizeGapY);
   edDieSizeGapY->Text = str;
   edDieSizeGapY1->Text = str;
   edDieGapY->Text = str;

   // 2021 8 6 - chc 加入Wafer角度設定
   RecipeBuffer[no].Pos1X = pnlWaferPosition1X->Caption.ToInt();
   RecipeBuffer[no].Pos1Y = pnlWaferPosition1Y->Caption.ToInt();
   RecipeBuffer[no].Pos2X = pnlWaferPosition2X->Caption.ToInt();
   RecipeBuffer[no].Pos2Y = pnlWaferPosition2Y->Caption.ToInt();
   RecipeBuffer[no].Pos3X = pnlWaferPosition3X->Caption.ToInt();
   RecipeBuffer[no].Pos3Y = pnlWaferPosition3Y->Caption.ToInt();
   RecipeBuffer[no].Pos4X = pnlWaferPosition4X->Caption.ToInt();
   RecipeBuffer[no].Pos4Y = pnlWaferPosition4Y->Caption.ToInt();
   RecipeBuffer[no].XDegree = pnlWaferDegreeX->Caption.ToDouble();
   RecipeBuffer[no].YDegree = pnlWaferDegreeY->Caption.ToDouble();
   RecipeBuffer[no].DieCenterX = pnlWaferDieCenterX->Caption.ToInt();
   RecipeBuffer[no].DieCenterY = pnlWaferDieCenterY->Caption.ToInt();
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Pos1X"                 ,RecipeBuffer[no].Pos1X);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Pos1Y"                 ,RecipeBuffer[no].Pos1Y);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Pos2X"                 ,RecipeBuffer[no].Pos2X);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Pos2Y"                 ,RecipeBuffer[no].Pos2Y);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Pos3X"                 ,RecipeBuffer[no].Pos3X);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Pos3Y"                 ,RecipeBuffer[no].Pos3Y);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Pos4X"                 ,RecipeBuffer[no].Pos4X);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"Pos4Y"                 ,RecipeBuffer[no].Pos4Y);
   pSystemFile->WriteFloat(RECIPE_INFORMATION_SECTION,"DieXDegree"              ,RecipeBuffer[no].XDegree);
   pSystemFile->WriteFloat(RECIPE_INFORMATION_SECTION,"DieYDegree"              ,RecipeBuffer[no].YDegree);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"DieCenterX"            ,RecipeBuffer[no].DieCenterX);
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,"DieCenterY"            ,RecipeBuffer[no].DieCenterY);

   delete pSystemFile;

   // 2021 5 9 - chc 若Path尚未建立, 要自動產生
   AnsiString path = RecipeDirectory + "\\" + RecipeBuffer[no].Name;
   if(!DirectoryExists(path))
      mkdir(path.c_str());

   return true;
}
//---------------------------------------------------------------------------
// Switch Recipe
void __fastcall TMainForm::cbRecipeChange(TObject *Sender)
{

   //DisplayRecipe();

}
//---------------------------------------------------------------------------
// 2021 12 15 - chc 最小Row,Col
int MinRow = -1;
int MinCol = -1;
int MaxRow = -1;
int MaxCol = -1;

// 2021 8 11 - chc 指定點
int SelectRow = -1;
int SelectCol = -1;

// 2021 8 24 - chc 中心Die座標
int CenterDieRow = -1;
int CenterDieCol = -1;

// 切換Recipe
void __fastcall TMainForm::combRecipeSelect(TObject *Sender)
{

   // 2021 12 18 - chc Reset MinCol, MinRow
   MinCol = -1;
   MinRow = -1;

   UpdateRecipe();

   // 2021 10 6 - chc 更新RecipeCurNo
   RecipeCurNo = combRecipe->ItemIndex;

   // 2021 8 11 - chc 指定點
   // 2021 10 6 - chc Table Die位置, 與Recipe無關
   //SelectRow = -1;
   //SelectCol = -1;

   // 2021 10 24 - chc 若在WaferMap頁面要重繪Mapper
   if(pcRecipe->ActivePage == tsWaferMap) {
      DrawBigImage();

      // 2021 12 15a - chc 加入再畫一次
      btnGenerateMapClick(this);
   }

}
//---------------------------------------------------------------------------
// Switch Recipe
void __fastcall TMainForm::cbRecipeSelect(TObject *Sender)
{

   DisplayRecipe(cbRecipe->ItemIndex);

   // 2016 12 29 - chc 顯示目前Recipe
   pnlRecipeSet->Caption = cbRecipe->Text;

   // 2021 5 9 - chc 記錄
   RecipeName = cbRecipe->Text;

   // 2019 12 13 - chc 也要顯示Run資訊
   pnlRunRecipe->Caption = cbRecipe->Text;
   pnlRunAreaTNo->Caption = edAreaTNo->Text;
   pnlRunDotTNo->Caption = edDotTNo->Text;

   // 2021 5 4 - chc SECS : oRCPM
   edSECSRecipeID->Text = cbRecipe->Text;
   rgSECSRecipe->ItemIndex = RECIPE_CHANGE;
   WriteSystemLog("boolSendSCESCommand: 2");
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_RCPM - SECS_CMD_STAT_1;

}
//---------------------------------------------------------------------------
// 下拉
void __fastcall TMainForm::combRecipeDropDown(TObject *Sender)
{
AnsiString fname;

   // 2019 12 14 - chc 不要做
   //fname = SystemDirectory + "\\Recipe.txt";
   //if(FileExists(fname)) {
   //   combRecipe->Items->LoadFromFile(fname);
   //}
}
//---------------------------------------------------------------------------
// 加入新Recipe
void __fastcall TMainForm::combRecipeExit(TObject *Sender)
{
AnsiString fname;

   if(combRecipe->Items->IndexOf(combRecipe->Text) == -1 && combRecipe->Text != "") {
      // 複製一份新的Recipe
      // 2016 2 25 - chc 檢查等級
      //if(RecipeTotalNo < RECIPE_MAX) {
      // 2022 6 9 - chc PE以上都可用
      //if(RecipeTotalNo < RECIPE_MAX && PriorityLevel >= PRIORITY_AD) {
      if(RecipeTotalNo < RECIPE_MAX && PriorityLevel >= PRIORITY_PE) {

         if(Application->MessageBox(("Sure to Add new Recipe: [" + combRecipe->Text + "]?").c_str(), " Recipe Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
notupdate:
            if(RecipeTotalNo > 0 && combRecipe->ItemIndex < RecipeTotalNo) {
               combRecipe->Text = RecipeBuffer[combRecipe->ItemIndex].Name;
            }
            else {
               combRecipe->Text = "";
               combRecipe->ItemIndex = -1;
            }
            return;
         }

         // 2023 1 3 - chc WriteRecipe(): combRecipe->ItemIndex為-1, 攔住不處理
         // 2023 1 11 - chc 錯
         //if(WriteRecipe() == false) {
         //   goto notupdate;
         //}

         combRecipe->Items->Append(combRecipe->Text);
         combRecipe->ItemIndex = RecipeTotalNo;
         fname = SystemDirectory + "\\Recipe.txt";
         combRecipe->Items->SaveToFile(fname);

         // 2023 1 11 - chc 錯
         //WriteRecipe();
         if(WriteRecipe() == false) {
            goto notupdate;
         }

         // 2019 12 7 - chc 複製資料夾: pnlRecipeTypeRecipe to combRecipe->Text
         CopyRecipeFile();

         // 2019 12 13 - chc 要變更pnlRecipeTypeRecipe
         pnlRecipeTypeRecipe->Caption = combRecipe->Text;

         RecipeTotalNo++;
         combRecipe->ItemIndex = RecipeTotalNo - 1;
         cbRecipe->Items->LoadFromFile(fname);
         if(cbRecipe->ItemIndex < 0)
            cbRecipe->ItemIndex = 0;

         // 2021 5 4 - chc Create recipe
         edSECSRecipeID->Text = cbRecipe->Text;
         rgSECSRecipe->ItemIndex = RECIPE_CREATE;
         WriteSystemLog("boolSendSCESCommand: 3");
         rgSecsCommandSet->ItemIndex = -1;
         boolSendSCESCommand = true;
         rgSecsCommandSet->ItemIndex = SECS_CMD_RCPM - SECS_CMD_STAT_1;

      }
   }
}
//---------------------------------------------------------------------------
// 加入新Recipe
void __fastcall TMainForm::combRecipeKeyDown(TObject *Sender, WORD &Key,
      TShiftState Shift)
{

   if(combRecipe->Items->IndexOf(combRecipe->Text) == -1 && Key == 13) {
      // 將Focus到別的地方: 會呼叫OnExit
      pnlRecipeLabel->SetFocus();
   }
}
//---------------------------------------------------------------------------
// 下拉
void __fastcall TMainForm::cbRecipeDropDown(TObject *Sender)
{
AnsiString fname;

   // 2019 12 14 - chc 不要做
   //fname = SystemDirectory + "\\Recipe.txt";
   //if(FileExists(fname)) {
   //   cbRecipe->Items->LoadFromFile(fname);
   //}
}
//---------------------------------------------------------------------------
// Wait
void __fastcall TMainForm::WaitTime(int ms)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;

   // 2016 11 25 - chc Log
   //WriteSystemLog("Wait...");

   GetTimeTic(&StartTime,&StartTick);
   while(1) {

      // 2016 11 25 - chc 改成1
      //Sleep(10);
      Sleep(1);

      Application->ProcessMessages();

      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > ms) {

         // 2016 11 25 - chc Log
         //AnsiString msg;
         //msg.sprintf("WaitTime: %ld, %d",Elapsedms,ms);
         //WriteSystemLog(msg);

         break;
      }
   }

   // 2016 11 25 - chc Log
   //WriteSystemLog("Wait done.");

}
//---------------------------------------------------------------------------
void TMainForm::GetTimeTic(long *time, short *millitm)
{
struct timeb t;

   ftime(&t);
   *time = t.time;
   *millitm = t.millitm;
}
//---------------------------------------------------------------------------
// Password: User.ini
void __fastcall TMainForm::LoadUser()
{
TIniFile *pSystemFile;
AnsiString str,fname;

   // 清除sgUser
   sgUser->RowCount = 2;
   sgUser->Cells[USER_FIELD_NO][1]            = "";
   sgUser->Cells[USER_FIELD_NAME][1]          = "";
   sgUser->Cells[USER_FIELD_PASSWORD][1]      = "";
   sgUser->Cells[USER_FIELD_LEVEL][1]         = "";

   // ini檔名與目錄: User.ini
   fname = SystemDirectory + "\\User.ini" ;
   if(!FileExists(fname)) {
      sbSystemMessage->Panels->Items[1]->Text = "User.ini Not Existed!";
      return;
   }
   // 載入ini檔
   pSystemFile = new TIniFile(fname);

   UserNums        = pSystemFile->ReadInteger(PASSWORD_SECTION,USER_NUMS        ,0);
   for(int i=0 ; i<UserNums ; i++) {
      UserList[i].Name     = pSystemFile->ReadString(PASSWORD_SECTION,USER+IntToStr(i+1)+NAME            ,"A1");
      UserList[i].Level    = pSystemFile->ReadString(PASSWORD_SECTION,USER+IntToStr(i+1)+LEVEL           ,"OP");
      UserList[i].Password = pSystemFile->ReadString(PASSWORD_SECTION,USER+IntToStr(i+1)+PASSWORD        ,"1234");

      // 加入sgUser
      sgUser->Cells[USER_FIELD_NO][sgUser->RowCount-1]                          = IntToStr(i+1);
      sgUser->Cells[USER_FIELD_NAME][sgUser->RowCount-1]                        = UserList[i].Name;
      sgUser->Cells[USER_FIELD_PASSWORD][sgUser->RowCount-1]                    = UserList[i].Password;
      sgUser->Cells[USER_FIELD_LEVEL][sgUser->RowCount-1]                       = UserList[i].Level;
      sgUser->RowCount++;
      // 清除最後一Row
      sgUser->Cells[USER_FIELD_NO][sgUser->RowCount-1]                        = "";
      sgUser->Cells[USER_FIELD_NAME][sgUser->RowCount-1]                      = "";
      sgUser->Cells[USER_FIELD_PASSWORD][sgUser->RowCount-1]                  = "";
      sgUser->Cells[USER_FIELD_LEVEL][sgUser->RowCount-1]                     = "";
      // 指到最後一筆
      sgUser->Row = sgUser->RowCount-1;
   }
   sgUser->Refresh();

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// Password: User.ini
void __fastcall TMainForm::SaveUser()
{
TIniFile *pSystemFile;
AnsiString str,fname;

   // ini檔名與目錄: User.ini
   fname = SystemDirectory + "\\User.ini" ;
   // 刪除
   if(FileExists(fname)) {
      DeleteFile(fname.c_str());
   }
   pSystemFile = new TIniFile(fname);

   pSystemFile->WriteInteger(PASSWORD_SECTION,USER_NUMS        ,UserNums);
   for(int i=0 ; i<UserNums ; i++) {
      pSystemFile->WriteString(PASSWORD_SECTION,USER+IntToStr(i+1)+NAME            ,UserList[i].Name);
      pSystemFile->WriteString(PASSWORD_SECTION,USER+IntToStr(i+1)+LEVEL           ,UserList[i].Level);
      pSystemFile->WriteString(PASSWORD_SECTION,USER+IntToStr(i+1)+PASSWORD        ,UserList[i].Password);
   }

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 切換Password
bool boolWaitLog;
void __fastcall TMainForm::btnPasswordClick(TObject *Sender)
{

   // 2016 3 3 - chc 清除記錄
   edLogName->Text = "";
   medCurrentPassword->Text = "";

   pnlPassword->Visible = true;
   pcSystem->Enabled = false;

   // 2021 7 19 - chc 改用runabort
   WriteSystemLog("關閉作業頁面1.");

   edLogName->SetFocus();
   // 等待輸入Log On
   boolWaitLog = false;
   while(1) {
      if(boolWaitLog == true) {

         // 2016 11 25 - chc Log
         WriteSystemLog("boolWaitLog = true Done.");

         break;
      }

      // 2016 11 25 - chc Log
      //WriteSystemLog("Wait: boolWaitLog = true...");

      WaitTime(100);

      // 2016 11 25 - chc Log
      //WriteSystemLog("Wait: boolWaitLog = true...Next");

   }

   // 2016 11 25 - chc Log
   WriteSystemLog("End Log1.");

   pcSystem->Enabled = true;

   // 2016 11 25 - chc Log
   WriteSystemLog("End Log2.");

   pnlPassword->Visible = false;

   // 2016 11 25 - chc Log
   WriteSystemLog("End Log3.");
   Application->ProcessMessages();
   WriteSystemLog("End Log.");

}
//---------------------------------------------------------------------------
// 切換Priority: PriorityLevel
//   #define PRIORITY_OP          0
//   #define PRIORITY_PE          1
//   #define PRIORITY_AD          2
//   #define PRIORITY_EE          3
void __fastcall TMainForm::SwitchLevel()
{

   // 2020 7 14 - chc 啟動UI
   if(PriorityLevel != PRIORITY_OP) {
      if(MainForm->pcEFEMH->Visible == false)
         MainForm->pcEFEMH->Visible = true;
      if(MainForm->pnlCassetteStatus->Visible == false)
         MainForm->pnlCassetteStatus->Visible = true;
      if(MainForm->btnCassetteLoad->Visible == false)
         MainForm->btnCassetteLoad->Visible = true;
      if(MainForm->pnlCassetteLoad->Visible == false)
         MainForm->pnlCassetteLoad->Visible = true;

      // 2022 5 17 - chc 不是操作員: 固定10秒後切換到操作員等級: edPasswordSwitchSecond
      if(PriorityLevel == PRIORITY_PE)
         ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   }

   if(PriorityLevel == PRIORITY_OP) {
      tsSystem->TabVisible = true;
      tsOperation->TabVisible = true;
      tsParameter->TabVisible = false;                                          // Recipe
      tsMotion->TabVisible = false;
      tsRorzeEFEM->TabVisible = false;
      tsOlympus->TabVisible = false;
      tsSECSGEM->TabVisible = false;
      tsCCD->TabVisible = false;
      tsFocus->TabVisible = false;
      tsHelp->TabVisible = false;
      tsUser->TabVisible = false;

      // 2021 4 25 - chc 要關EFEMR & Focus
      tsMatch->TabVisible = false;

      // 不可用Laser Center
      btnResetLaserCenter->Enabled = false;
      gbMotion->Enabled = false;
      btnPassword->Caption = "Operator";
      // Disable Laser "Send" Command
      cbTXInvert->Visible = false;
      cbTYInvert->Visible = false;
      cbRotateDirection->Visible = false;

      // 2019 11 28 - chc 不可以動歸0
      btnHomeOneAxis->Visible = false;
      btnResetOneAxis->Visible = false;
      btnResetAll->Visible = false;

      pnlMove->Visible = false;
      pnlCurrentSpeed->Visible = false;
   }
   else if(PriorityLevel == PRIORITY_PE) {
      tsSystem->TabVisible = true;
      tsOperation->TabVisible = true;
      tsParameter->TabVisible = true;                                           // Recipe
      tsMotion->TabVisible = false;
      tsRorzeEFEM->TabVisible = false;
      tsOlympus->TabVisible = false;
      tsSECSGEM->TabVisible = false;
      tsCCD->TabVisible = false;
      tsFocus->TabVisible = false;
      tsHelp->TabVisible = false;
      tsUser->TabVisible = false;

      tsMatch->TabVisible = false;

      // 可用Laser Center
      btnResetLaserCenter->Enabled = true;
      gbMotion->Enabled = true;
      btnPassword->Caption = "Engineer";
      // defined in password
      pcOP->Enabled = true;

      // Enable Laser "Send" Command
      cbTXInvert->Visible = true;
      cbTYInvert->Visible = true;
      cbRotateDirection->Visible = true;

      // 2019 11 28 - chc 不可以動歸0
      btnHomeOneAxis->Visible = false;
      btnResetOneAxis->Visible = false;
      btnResetAll->Visible = false;

      // 2020 5 14 - chc
      pnlMove->Visible = true;
      pnlMessage->Visible = true;
      pnlCurrentSpeed->Visible = true;

   }
   else if(PriorityLevel == PRIORITY_AD) {
      tsSystem->TabVisible = true;
      tsOperation->TabVisible = true;
      tsParameter->TabVisible = true;                                           // Recipe
      tsMotion->TabVisible = true;
      tsRorzeEFEM->TabVisible = true;
      tsOlympus->TabVisible = true;
      tsSECSGEM->TabVisible = true;
      tsCCD->TabVisible = true;
      tsFocus->TabVisible = true;
      tsHelp->TabVisible = true;
      tsUser->TabVisible = true;

      tsMatch->TabVisible = true;

      // 可用Laser Center
      btnResetLaserCenter->Enabled = true;
      gbMotion->Enabled = true;
      btnPassword->Caption = "Admin.";
      // defined in password
      pcOP->Enabled = true;

      // Enable Laser "Send" Command
      cbTXInvert->Visible = true;
      cbTYInvert->Visible = true;
      cbRotateDirection->Visible = true;

      pcSystem->ActivePage = tsSystem;
      pcMotion->ActivePage = tsMotionStatus;
      MotionStatus(true);

      // 2019 11 28 - chc 不可以動歸0
      btnHomeOneAxis->Visible = false;
      btnResetOneAxis->Visible = false;
      btnResetAll->Visible = false;

      // 2020 5 14 - chc
      pnlMove->Visible = true;
      pnlMessage->Visible = true;
      pnlCurrentSpeed->Visible = true;

   }
   else {
      tsSystem->TabVisible = true;
      tsOperation->TabVisible = true;
      tsParameter->TabVisible = true;                                           // Recipe
      tsMotion->TabVisible = true;
      tsRorzeEFEM->TabVisible = true;
      tsOlympus->TabVisible = true;
      tsSECSGEM->TabVisible = true;
      tsCCD->TabVisible = true;
      tsFocus->TabVisible = true;
      tsHelp->TabVisible = true;
      tsUser->TabVisible = true;

      tsMatch->TabVisible = true;

      // 可用Laser Center
      btnResetLaserCenter->Enabled = true;
      gbMotion->Enabled = true;
      btnPassword->Caption = "Factory";
      // defined in password
      pcOP->Enabled = true;

      // Enable Laser "Send" Command
      cbTXInvert->Visible = true;
      cbTYInvert->Visible = true;
      cbRotateDirection->Visible = true;

      // 2019 11 28 - chc 不可以動歸0
      btnHomeOneAxis->Visible = true;
      btnResetOneAxis->Visible = true;
      btnResetAll->Visible = true;

      // 2020 5 14 - chc
      pnlMove->Visible = true;
      pnlMessage->Visible = true;
      pnlCurrentSpeed->Visible = true;

   }
   pcSystem->Refresh();
}
//---------------------------------------------------------------------------
// 按下Log On
void __fastcall TMainForm::btnLogClick(TObject *Sender)
{
AnsiString name,password;
bool boolset = false;

// 2020 5 4 - chc 是否存在?
bool boolmatch = false;

   // 比對
   name = edLogName->Text;
   password = medCurrentPassword->Text;

   // 2021 6 24 - chc License code
   //===========================================================================
   AnsiString licensecode;
   licensecode = GetPasswordCode(password);
   password = licensecode;
   //===========================================================================

   for(int i=0 ; i<UserNums ; i++) {
      if(name == UserList[i].Name && password == UserList[i].Password) {

         // 2020 5 4 - chc 是否存在?
         boolmatch = true;

         PriorityLevel = PRIORITY_OP;
         if(UserList[i].Level == "PE") {
            PriorityLevel = PRIORITY_PE;

            // 2022 5 17 - chc PE不可以操作T
            //boolset = true;
            boolset = false;

         }
         else if(UserList[i].Level == "AD") {
            PriorityLevel = PRIORITY_AD;
            boolset = true;
         }
         else if(UserList[i].Level == "EE") {
            PriorityLevel = PRIORITY_EE;
            boolset = true;
         }
         else {
            boolset = false;
         }

         // boolset
         // 2020 5 4 - chc 共用Routine
         /*
         pcOP->Visible = boolset;
         btnUpdateSystemParameter->Visible = boolset;
         btnEFEMMaintenanceMode->Visible = boolset;
         pnlEFEMMaintenanceMode->Visible = boolset;
         btnBackwardZ1->Visible = boolset;
         btnUp100x->Visible = boolset;
         btnUp10x->Visible = boolset;
         btnUp5x->Visible = boolset;
         btnUp1x->Visible = boolset;
         btnDown1x->Visible = boolset;
         btnDown5x->Visible = boolset;
         btnDown10x->Visible = boolset;
         btnDown100x->Visible = boolset;
         btnMoveZ1->Visible = boolset;
         btnBackwardX1->Visible = boolset;
         btnLeft10x->Visible = boolset;
         btnLeft5x->Visible = boolset;
         btnLeft1x->Visible = boolset;
         btnRight1x->Visible = boolset;
         btnRight5x->Visible = boolset;
         btnRight10x->Visible = boolset;
         btnMoveX1->Visible = boolset;
         btnBackwardY1->Visible = boolset;
         btnFront10x->Visible = boolset;
         btnFront5x->Visible = boolset;
         btnFront1x->Visible = boolset;
         btnRear1x->Visible = boolset;
         btnRear5x->Visible = boolset;
         btnRear10x->Visible = boolset;
         btnMoveY1->Visible = boolset;
         pnlZUnit->Visible = boolset;
         // Robot
         tsRobotTest->TabVisible = boolset;
         // loop Test
         gbLoopTest->Visible = boolset;
         */
         SetLevel(boolset);

         SwitchLevel();
         break;
      }
   }

   // 2020 5 4 - chc 是否存在?
   if(boolmatch == false) {
      boolset = false;
      PriorityLevel = PRIORITY_OP;
      SetLevel(boolset);
      SwitchLevel();
   }
   if(PriorityLevel == PRIORITY_OP) {
      pcSystem->ActivePage = tsOperation;
   }

   // 2016 11 25 - chc Log
   WriteSystemLog("Logged. Set boolWaitLog to true.");

   boolWaitLog = true;
}
//---------------------------------------------------------------------------
// 2016 2 25 - chc 置中
void __fastcall TMainForm::sgUserDrawCell(TObject *Sender, int ACol,
      int ARow, TRect &Rect, TGridDrawState State)
{
AnsiString Str=" ";
TColor fontcolor;
bool boolbold;

   ((TStringGrid*)Sender)->Canvas->Font = ((TStringGrid*)Sender)->Font;
   for(int i=0 ; i<((TStringGrid*)Sender)->RowCount ; i++){
      if(((TStringGrid*)Sender)->Cells[ACol][i].Length() > Str.Length())
         Str = ((TStringGrid*)Sender)->Cells[ACol][i];
   }
   int colWidth = ((TStringGrid*)Sender)->Canvas->TextWidth(Str)+4;
   if(colWidth > ((TStringGrid*)Sender)->ColWidths[ACol])
      ((TStringGrid*)Sender)->ColWidths[ACol] = colWidth;
   fontcolor = clBlack;

   if(ARow != 0) {
      // 等級加上顏色
      if(ACol == USER_FIELD_LEVEL) {
         boolbold = true;
         ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x00CCCC99;
         if(((TStringGrid*)Sender)->Cells[USER_FIELD_LEVEL][ARow] == "AD") {
            fontcolor = clMaroon;
         }
         if(((TStringGrid*)Sender)->Cells[USER_FIELD_LEVEL][ARow] == "EE") {
            fontcolor = clRed;
         }
      }
      else {
         fontcolor = clBlack;
         boolbold = false;
         // Level欄顏色設定
         if(ACol == USER_FIELD_LEVEL)
            ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x0099B5FF;
         else {
            // 奇偶數不同顏色
            if((ARow % 2) != 0)
               ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x0093F4F2;
            else
                ((TStringGrid*)Sender)->Canvas->Brush->Color = clWhite;
         }
      }
   }

   // 改變字體顏色
   ((TStringGrid*)Sender)->Canvas->Font->Color = fontcolor;
   if(boolbold == true)
      ((TStringGrid*)Sender)->Canvas->Font->Style = TFontStyles()<< fsBold;

   ((TStringGrid*)Sender)->Canvas->FillRect(Rect);
   DrawText(((TStringGrid*)Sender)->Canvas->Handle,((TStringGrid*)Sender)->Cells[ACol][ARow].c_str(),-1,(RECT*)&Rect,DT_SINGLELINE|DT_VCENTER|DT_CENTER);
}
//---------------------------------------------------------------------------
// 2016 2 25 - chc New/Modify
void __fastcall TMainForm::btnUserNewClick(TObject *Sender)
{
AnsiString name,password;
bool modified;

   modified = false;
   name = edUserName->Text;
   password = edUserPassword->Text;
   for(int i=0 ; i<UserNums ; i++) {
      // Modify
      if(UserList[i].Name == name) {
         UserList[i].Level = rgLevel->Items->Strings[rgLevel->ItemIndex];
         UserList[i].Password = password;
         modified = true;
         break;
      }
   }
   // New
   if(modified == false) {
      if(UserNums < MAX_USER) {
         UserList[UserNums].Name = name;

         // 2021 6 24 - chc License code
         AnsiString licensecode;
         licensecode = GetPasswordCode(password);
         password = licensecode;

         UserList[UserNums].Password = password;
         UserList[UserNums].Level = rgLevel->Items->Strings[rgLevel->ItemIndex];
         UserNums++;
      }
   }
   // Update to .ini & sgUser
   SaveUser();
   LoadUser();

}
//---------------------------------------------------------------------------
// 2016 2 25 - chc sgUser Delete
void __fastcall TMainForm::btnUserDeleteClick(TObject *Sender)
{

   if(sgUser->Row > 0 && sgUser->Row <= UserNums) {
      for(int i=sgUser->Row ; i<UserNums ; i++) {
         UserList[i-1].Name = UserList[i].Name;
         UserList[i-1].Password = UserList[i].Password;
         UserList[i-1].Level = UserList[i].Level;
      }
      UserNums--;
      // Update to .ini & sgUser
      SaveUser();
      LoadUser();
   }
}
//---------------------------------------------------------------------------
// 2016 2 25 - chc User Refresh
void __fastcall TMainForm::btnUserRefreshClick(TObject *Sender)
{

   LoadUser();
}
//---------------------------------------------------------------------------
// 2016 3 7 - chc Save Screen
void __fastcall TMainForm::SaveWindowScreen(TForm *Form)
{
Graphics::TBitmap *FormImage;
AnsiString fullpath,filename;

   if(!DirectoryExists(".\\WayBMP"))
      mkdir(".\\WayBMP");

   Printer()->Title = "儲存視窗圖檔";
   FormImage = Form->GetFormImage();
   Application->ProcessMessages();

   filename = filename.sprintf("WayBMP%04d.bmp",SaveBMPSerialNo);
   fullpath = SystemDirectory+"\\WayBMP\\"+filename;
   sbSystemMessage->Panels->Items[1]->Text = filename + " Saving...";
   FormImage->SaveToFile(fullpath.c_str());
   sbSystemMessage->Panels->Items[1]->Text = filename + " Saved.";
   SaveBMPSerialNo++;

   delete FormImage;
}
//---------------------------------------------------------------------------
// 2016 3 7 - chc Save Screen
void __fastcall TMainForm::FormKeyDown(TObject *Sender, WORD &Key,
      TShiftState Shift)
{

   // Alt-P Print Screen(Current Windows)
   if(Key == 80 && Shift.Contains(ssAlt)){
      SaveWindowScreen(MainForm);
      return;
   }
}
//---------------------------------------------------------------------------
// 網路序號檢查: 取得MAC
//---------------------------------------------------------------------------
// 2016 3 31 - chc 檢查網路卡序號
// 2020 7 17 - chc Not Used
/*
bool __fastcall TMainForm::CheckMACAddress()
{
TIniFile *pSystemFile;
AnsiString fname;

   // 將ini檔名要指定路徑
   fname = SystemDirectory + "\\WVLaserMotion.ini";
   pSystemFile = new TIniFile(fname);
   LicenseCodeSet = pSystemFile->ReadString("System","License Code","0000000000");
   delete pSystemFile;
   // 記錄是否要離開?

   // 光寶
   //MACAddress = "0BAB47BBCA";

   WVCodeGenerate *GetLicenseCode = NULL;
   GetLicenseCode = new WVCodeGenerate();
   GetLicenseCode->SetCode(MACAddress);
   LicenseCode = GetLicenseCode->GetCode(1);
   delete GetLicenseCode;
   if(LicenseCode == LicenseCodeSet)
      return true;

   // 2016 4 29 - chc 原廠授權2016WVWV0429
   if(LicenseCodeSet == "2016WVWV0429")
      return true;


   return false;
}
*/
//---------------------------------------------------------------------------
// 網路序號讀取: 取得MAC
//---------------------------------------------------------------------------
typedef DWORD(CALLBACK * PGAINFO)(PIP_ADAPTER_INFO, PULONG);                    //讀取網路卡卡號
AnsiString __fastcall TMainForm::GetMACAddress()
{
HINSTANCE hInst;		                                                // 準備載入 DLL 用
AnsiString adr;
PGAINFO pGAInfo;		                                                // 要承接傳回的函數指標用
AnsiString dllPath = SystemDirectory + "\\iphlpapi.dll";

   hInst = LoadLibrary(dllPath.c_str());
   if(!hInst)
      ShowMessage("iphlpapi.dll not supported in this platform!");
   else {
      pGAInfo = (PGAINFO)GetProcAddress(hInst, "GetAdaptersInfo");	        // 取得函數指標
      PIP_ADAPTER_INFO pInfo = NULL;
      ULONG ulsize = 0;
      // 取得Size
      pGAInfo(pInfo, &ulsize);
      pInfo = (PIP_ADAPTER_INFO)new(char[ulsize]);

      // 這個方式取得的ulsize=640, 但上式取得為1280 ??????
      //ulsize = sizeof(IP_ADAPTER_INFO);
      //pInfo = (PIP_ADAPTER_INFO)new(char[ulsize]);

      pGAInfo(pInfo, &ulsize);				                        // 呼叫 GetAdaptersInfo 函數
      while(pInfo) {
         // index = pInfo->Index;
         // CLEVO-NB-00:90:F5:3C:4E:CC
         // License Code=JHOCA-2E8HJ-YBLKP-6FJMA
         // 取後面10碼90F53C4ECC
         //adr.sprintf("%02X:%02X:%02X:%02X:%02X:%02X",
         //            (unsigned int)pInfo->Address[0],
         //            (unsigned int)pInfo->Address[1],
         //            (unsigned int)pInfo->Address[2],
         //            (unsigned int)pInfo->Address[3],
         //            (unsigned int)pInfo->Address[4],
         //            (unsigned int)pInfo->Address[5]);
         adr.sprintf("%02X%02X%02X%02X%02X",
                     (unsigned int)pInfo->Address[1],
                     (unsigned int)pInfo->Address[2],
                     (unsigned int)pInfo->Address[3],
                     (unsigned int)pInfo->Address[4],
                     (unsigned int)pInfo->Address[5]);

         // 不可以只向下一個, 若下一個不存在於離開前Delete會有Error
         //pInfo = pInfo->Next;

         // 只取第一個Port
         break;
      }
      delete pInfo;
   }
   FreeLibrary(hInst);
   return adr;
}
//---------------------------------------------------------------------------
// 2015 9 7 - chc GigE CCD : scA1300-gm 由Thread呼叫
void __fastcall TMainForm::GigaCapture1()
{
int no;
GENAPIC_RESULT res;                    // Return value of pylon methods.

   no = 0;
   // 加入取像時間顯示
   GetTimeTic(&BaslerCaptureStartTimeAry[no],&BaslerCaptureStartTickAry[no]);
   //lbGiga->Items->Add("Trigger CCD1...");
   res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0, imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 1000);
   //lbGiga->Items->Add("Trigger CCD1: " + IntToStr(res) + "," + IntToStr(GENAPI_E_OK));

   // 2016 5 12 - chc 新寫法
   if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
      // Timeout occurred.
      AnsiString msg;
      static int count = 0;
      msg.sprintf("Frame1 %d: timeout\n", count+1);
      lbGiga->Items->Add(msg);
      pnlSystemMessage->Caption = msg;
   }

}
//---------------------------------------------------------------------------
// 2015 9 7 - chc GigE CCD : scA1300-gm 由Thread呼叫
void __fastcall TMainForm::GigaCapture2()
{
int no;
GENAPIC_RESULT res;                    // Return value of pylon methods.

   no = 1;
   // 加入取像時間顯示
   GetTimeTic(&BaslerCaptureStartTimeAry[no],&BaslerCaptureStartTickAry[no]);
   //lbGiga->Items->Add("Trigger CCD...");
   res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0, imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 1000);
   //lbGiga->Items->Add("Trigger CCD: " + IntToStr(res) + "," + IntToStr(GENAPI_E_OK));
}
//---------------------------------------------------------------------------
// 2015 9 7 - chc GigE CCD : scA1300-gm 由Thread呼叫
void __fastcall TMainForm::GigaCapture3()
{
int no;
GENAPIC_RESULT res;                    // Return value of pylon methods.

   no = 2;
   // 加入取像時間顯示
   GetTimeTic(&BaslerCaptureStartTimeAry[no],&BaslerCaptureStartTickAry[no]);
   //lbGiga->Items->Add("Trigger CCD...");
   res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0, imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 1000);
   //lbGiga->Items->Add("Trigger CCD: " + IntToStr(res) + "," + IntToStr(GENAPI_E_OK));
}
//---------------------------------------------------------------------------
// 2015 8 20 - chc 不同CCD對應不同的程式碼
void __fastcall TMainForm::GigaBuffer3(int ccdtype)
{

   CaptureGigaFrame3(3,ccdtype);
}
//---------------------------------------------------------------------------
// 2015 8 20 - chc 不同CCD對應不同的程式碼
void __fastcall TMainForm::GigaBuffer2(int ccdtype)
{

   CaptureGigaFrame2(2,ccdtype);
}
//---------------------------------------------------------------------------
// 2015 8 20 - chc 不同CCD對應不同的程式碼
void __fastcall TMainForm::GigaBuffer1(int ccdtype)
{

   CaptureGigaFrame1(1,ccdtype);
}
//---------------------------------------------------------------------------
static int Table_fv1[256] = { -180, -179, -177, -176, -174, -173, -172, -170, -169, -167, -166, -165, -163, -162, -160, -159, -158, -156, -155,
                              -153, -152, -151, -149, -148, -146, -145, -144, -142, -141, -139, -138, -137,  -135, -134, -132, -131, -130, -128,
                              -127, -125, -124, -123, -121, -120, -118, -117, -115, -114, -113, -111, -110, -108, -107, -106, -104, -103, -101,
                              -100, -99, -97, -96, -94, -93, -92, -90,  -89, -87, -86, -85, -83, -82, -80, -79, -78, -76, -75, -73, -72, -71,
                              -69, -68, -66, -65, -64,-62, -61, -59, -58, -57, -55, -54, -52, -51, -50, -48, -47, -45, -44, -43, -41, -40, -38,
                              -37,  -36, -34, -33, -31, -30, -29, -27, -26, -24,
                              -23, -22, -20, -19, -17, -16, -15, -13, -12, -10, -9, -8, -6, -5, -3, -2, 0, 1, 2, 4, 5, 7, 8, 9, 11, 12, 14, 15,
                              16, 18, 19, 21, 22, 23, 25, 26, 28, 29, 30, 32, 33, 35, 36, 37, 39, 40, 42, 43, 44, 46, 47, 49, 50, 51, 53, 54,
                              56, 57, 58, 60, 61, 63, 64, 65, 67, 68, 70, 71, 72, 74, 75, 77, 78, 79, 81, 82, 84, 85, 86, 88, 89, 91, 92, 93,
                              95, 96, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110, 112, 113, 114, 116, 117, 119, 120, 122, 123, 124, 126,
                              127, 129, 130, 131, 133, 134, 136, 137, 138, 140, 141, 143, 144, 145, 147, 148,  150, 151, 152, 154, 155, 157,
                              158, 159, 161, 162, 164, 165, 166, 168, 169, 171, 172, 173, 175, 176, 178 };
static int Table_fv2[256] = { -92, -91, -91, -90, -89, -88, -88, -87, -86, -86, -85, -84, -83, -83, -82, -81, -81, -80, -79, -78, -78, -77,
                              -76, -76, -75, -74, -73, -73, -72, -71, -71, -70, -69, -68, -68, -67, -66, -66, -65, -64, -63, -63, -62, -61,
                              -61, -60, -59, -58, -58, -57, -56, -56, -55, -54, -53, -53, -52, -51, -51, -50, -49, -48, -48, -47, -46, -46,
                              -45, -44, -43, -43, -42, -41, -41, -40, -39, -38, -38, -37, -36, -36, -35, -34, -33, -33, -32, -31, -31, -30,
                              -29, -28, -28, -27, -26, -26, -25, -24, -23, -23, -22, -21, -21, -20, -19, -18, -18, -17, -16, -16, -15, -14,
                              -13, -13, -12, -11, -11, -10, -9, -8, -8, -7, -6, -6, -5, -4, -3,
                              -3, -2, -1, 0, 0, 1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 9, 10, 10, 11, 12, 12, 13, 14, 15, 15, 16, 17, 17, 18, 19,
                              20, 20, 21, 22, 22, 23, 24, 25, 25, 26, 27, 27, 28, 29, 30, 30, 31, 32, 32, 33, 34, 35, 35, 36, 37, 37, 38, 39,
                              40, 40, 41, 42, 42, 43, 44, 45, 45, 46, 47, 47, 48, 49, 50, 50, 51, 52, 52, 53, 54, 55, 55, 56, 57, 57, 58, 59,
                              60, 60, 61, 62, 62, 63, 64, 65, 65, 66, 67, 67, 68, 69, 70, 70, 71, 72, 72, 73, 74, 75, 75, 76, 77, 77, 78, 79,
                              80, 80, 81, 82, 82, 83, 84, 85, 85, 86, 87, 87, 88, 89, 90, 90 };
static int Table_fu1[256] = { -44, -44, -44, -43, -43, -43, -42, -42, -42, -41, -41, -41, -40, -40, -40, -39, -39, -39, -38, -38, -38, -37,
                              -37, -37, -36, -36, -36, -35, -35, -35, -34, -34, -33, -33, -33, -32, -32, -32, -31, -31, -31, -30, -30, -30,
                              -29, -29, -29, -28, -28, -28, -27, -27, -27, -26, -26, -26, -25, -25, -25, -24, -24, -24, -23, -23, -22, -22,
                              -22, -21, -21, -21, -20, -20, -20, -19, -19, -19, -18, -18, -18, -17, -17, -17, -16, -16, -16, -15, -15, -15,
                              -14, -14, -14, -13, -13, -13, -12, -12, -11, -11, -11, -10, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7, -7, -6,
                              -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, 0,
                              0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12,
                              12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21,
                              22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 27, 28, 28, 28, 29, 29, 29, 30, 30, 30, 31,
                              31, 31, 32, 32, 33, 33, 33, 34, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 38, 39, 39, 39, 40, 40, 40,
                              41, 41, 41, 42, 42, 42, 43, 43 };
static int Table_fu2[256] = { -227, -226, -224, -222, -220, -219, -217, -215, -213, -212, -210, -208, -206, -204, -203, -201, -199, -197, -196,
                              -194, -192, -190, -188, -187, -185, -183, -181, -180, -178, -176, -174, -173, -171, -169, -167, -165, -164, -162,
                              -160, -158, -157, -155, -153, -151, -149, -148, -146, -144, -142, -141, -139, -137, -135, -134, -132, -130, -128,
                              -126, -125, -123, -121, -119, -118, -116, -114, -112, -110, -109, -107, -105, -103, -102, -100, -98, -96, -94,
                              -93, -91, -89, -87, -86, -84, -82, -80, -79, -77, -75, -73, -71, -70, -68, -66, -64, -63, -61, -59, -57, -55,
                              -54, -52, -50, -48, -47, -45, -43, -41, -40, -38, -36,
                              -34, -32, -31, -29, -27, -25, -24, -22, -20, -18, -16, -15, -13, -11, -9, -8, -6, -4, -2, 0, 1, 3, 5, 7, 8, 10, 12,
                              14, 15, 17, 19, 21, 23, 24, 26, 28, 30, 31, 33, 35, 37, 39, 40, 42, 44, 46, 47, 49, 51, 53, 54, 56, 58, 60, 62, 63,
                              65, 67, 69, 70, 72, 74, 76, 78, 79, 81, 83, 85, 86, 88, 90, 92, 93, 95, 97, 99, 101, 102, 104, 106, 108, 109, 111,
                              113, 115, 117, 118, 120, 122, 124, 125, 127, 129, 131, 133, 134, 136, 138, 140, 141, 143, 145, 147, 148, 150, 152,
                              154, 156, 157, 159, 161, 163, 164, 166, 168, 170, 172, 173, 175, 177, 179, 180, 182, 184, 186, 187, 189, 191, 193,
                              195, 196, 198, 200, 202, 203, 205, 207, 209, 211, 212, 214, 216, 218, 219, 221, 223, 225 };
//---------------------------------------------------------------------------

// 2015 9 4 - chc GigE CCD : 取得影像並顯示(BW/Color)
//   #define BASLER_CCD_BW                0
//   #define BASLER_CCD_COLOR             1
//   int BaslerCCDType[3];
// mode : 0 - 要呼叫 PylonDeviceGrabSingleFrame()
//        1 - 不要呼叫 PylonDeviceGrabSingleFrame()
void __fastcall TMainForm::CaptureGigaFrame1_old(int no, int mode)
{
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;
static bool first = false;

   // Index
   pnlCCDStatus->Color = clSilver;
   no--;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - w) / 2;
   //sy = (height - h) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   //lbGiga->Items->Add("CCD1進入取像...");
   // 在影像處理中
   boolInGigaBufferAry[no] = true;

   // 2015 9 9 - chc 要加速
   if(first == false) {
      first = true;

      // Grab one single frame from stream channel 0. The
      // camera is set to single frame acquisition mode.
      // Wait up to 500 ms for the image to be grabbed.
      // Software Trigger
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);

      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);

      switch(res) {
         case GENAPI_E_FAIL:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-1");
            break;
         case GENAPI_E_INDEX_ERROR:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-2");
            break;
         case GENAPI_E_INSUFFICIENT_BUFFER:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-3");
            break;
         case GENAPI_E_INVALID_ARG:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-4");
            break;
         case GENAPI_E_INVALID_NODECALLBACKHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-5");
            break;
         case GENAPI_E_INVALID_NODEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-6");
            break;
         case GENAPI_E_INVALID_NODEMAPHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-7");
            break;
         case GENAPI_E_LIMITS_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-8");
            break;
         case GENAPI_E_LOGICAL_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-9");
            break;
         case GENAPI_E_NODE_NOT_FOUND:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-10");
            break;
         case GENAPI_E_OBJECT_ILLEGAL_STATE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-11");
            break;
         case GENAPI_E_OK:
            //lbGiga->Items->Add("IntToStr(no+1) + Captured-12");
            break;
         case GENAPI_E_PROPERTY_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-13");
            break;
         case GENAPI_E_RESULT_RANGE_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-14");
            break;
         case GENAPI_E_TIMEOUT:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-15");
            break;
         case GENAPI_E_TYPE_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-16");
            break;
         case PYLON_E_INVALID_CHUNKPARSERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-17");
            break;
         case PYLON_E_INVALID_CONVERTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-18");
            break;
         case PYLON_E_INVALID_DEVICEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-19");
            break;
         case PYLON_E_INVALID_DEVICEINFO_PROPERTY:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-20");
            break;
         case PYLON_E_INVALID_DEVICEINFOHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-21");
            break;
         case PYLON_E_INVALID_EVENTADAPTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-22");
            break;
         case PYLON_E_INVALID_EVENTGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured23");
            break;
         case PYLON_E_INVALID_STREAMGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-24");
            break;
         case PYLON_E_INVALID_WAITOBJECTHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-25");
            break;
         case PYLON_E_INVALID_WAITOBJECTSHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-26");
            break;
      }

      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame1 %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
      //CHECK(res);
   }

   // Log
   //lbGiga->Items->Add("CCD1進入取像1...");

   // chc
   //grabResultAry[no].Status = Grabbed;

   // Check to see if the image was grabbed successfully.
   if(grabResultAry[no].Status == Grabbed) {
      count++;
      unsigned char *pt,*pt1;
      int i;
      int pointer;
      // 1278*958 - 1294*964
      if(grabResultAry[no].SizeX != CCDInfoAry[no].Width || grabResultAry[no].SizeY != CCDInfoAry[no].Height) {
         lbGiga->Items->Add("Size1 Error!");
         pnlSystemMessage->Caption = "Size1 Error!";
         // 在影像處理中
         boolInGigaBufferAry[no] = false;
         pnlCCDStatus->Color = clRed;

         // 2015 9 8 - chc Log
         WriteSystemLog("CaptureGigaFrame1() RealSize Error!" + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         WriteSystemLog("CaptureGigaFrame1() SensorSize Error!" + IntToStr(CCDInfoAry[no].Width) + "," + IntToStr(CCDInfoAry[no].Height));

         return;
      }
      i = 0;
      // 記錄Basler存檔中...
      if(boolInGigaSaveAry[no] == true) {
         //lbGiga->Items->Add("存檔中, 不更新影像");
         pnlSystemMessage->Caption = "Saving1 Image...";
         boolInGigaBufferAry[no] = false;
         return;
      }
      pnlCCDStatus->Color = clLime;

      // Log
      //lbGiga->Items->Add("CCD1進入取像2...");

      // 全取: 要區分BW/C24
      // BW : scA1300ImageAry
      if(CCDInfoAry[no].Type == BASLER_CCD_BW) {

         // Log
         //lbGiga->Items->Add("CCD1進入取像2BW...");

         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)scA1300ImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX);
            i += grabResultAry[no].SizeX;
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         scA1300ImageROIAry[no].SetPlacement(x,y,w,h);
         scA1300ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }
      // Color : usb_ImageAry
      else {

         // Log
         //lbGiga->Items->Add("CCD1進入取像2Color... " + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         //lbGiga->Items->Add("CCD Size: " + IntToStr((int)grabResultAry[no].PayloadSize));

         // 2016 4 16 - chc 寫入檔案: YUV422
         /*
         FILE *fp;
         i = 0;
         static boolsave = false;
         if(boolsave == false) {
            if((fp = fopen("D:\\test.yuv","wb")) != NULL) {
               for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
                  fwrite((void *)&imgBufAry[no][i],1,grabResultAry[no].SizeX*2,fp);
                  i += (grabResultAry[no].SizeX * 2);
               }
               fclose(fp);
            }
            boolsave = true;
         }
         */
         //---------------------------------------------------------------------
         // YUV422 to RGB
         //i = 0;
         //for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
         //   pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
         //   memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX*2);
         //   i += (grabResultAry[no].SizeX * 2);
         //}
         unsigned char *yuvbuf,*pt;
         yuvbuf = &imgBufAry[no][0];
         // Y0,U0,Y1,V0 - Table
         int y0,u0,y1,v0,pdx,idx;
         int rdif,invgdif,bdif,w2,vr,vg,vb;
         w2 = width * 2;
         for(int i=0 ; i<height ; i++) {
            pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,i);
            idx = i * w2;
            pdx = 0;
            // 4bytes => 2Pixel
            for(int j=0 ; j<w2 ; j+=4) {
               u0 = yuvbuf[idx++];
               y0 = yuvbuf[idx++];
               v0 = yuvbuf[idx++];
               y1 = yuvbuf[idx++];

               rdif = Table_fv1[v0];
               invgdif = Table_fu1[u0] + Table_fv2[v0];
               bdif = Table_fu2[u0];

               // p1
               vb = y0 + bdif;
               vg = y0 - invgdif;
               vr = y0 + rdif;
               // BGR
               if(vb < 0)
                  vb = 0;
               else if(vb > 255)
                  vb = 255;
               pt[pdx++] = vb;
               if(vg < 0)
                  vg = 0;
               else if(vg > 255)
                  vg = 255;
               pt[pdx++] = vg;
               if(vr < 0)
                  vr = 0;
               else if(vr > 255)
                  vr = 255;
               pt[pdx++] = vr;
               // p2
               vb = y1 + bdif;
               vg = y1 - invgdif;
               vr = y1 + rdif;
               // BGR
               if(vb < 0)
                  vb = 0;
               else if(vb > 255)
                  vb = 255;
               pt[pdx++] = vb;
               if(vg < 0)
                  vg = 0;
               else if(vg > 255)
                  vg = 255;
               pt[pdx++] = vg;
               if(vr < 0)
                  vr = 0;
               else if(vr > 255)
                  vr = 255;
               pt[pdx++] = vr;
            }
         }
         //---------------------------------------------------------------------

         //lbGiga->Items->Add("CCD1: Move影像ok");

         // 要顯示在主畫面
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();

         //lbGiga->Items->Add("CCD1: 顯示影像ok");
      }

      // Basler Pylon GigE CCD
      boolBaslerImageLoadedAry[no] = true;
      BaslerCaptureNoAry[no]++;
      if((count % 5) == 0) {
         GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
         BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
         double ratio;
         AnsiString msg;

         // 2016 7 23 - chc Devide by zero
         if(BaslerElapsedmsAry[no] != 0) {

            ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
            msg.sprintf("%.1f",ratio);
            pnlCapturedNo->Caption = msg;
         }
      }
   }

   // 無法取像
   //else if(grabResult.Status == Failed) {
   else {

      // fprintf( stderr,  "Frame %d wasn't grabbed successfully.  Error code = 0x%08X\n",
      //    i+1, grabResult.ErrorCode );
      lbGiga->Items->Add("grabResult1 = Failed");
      pnlSystemMessage->Caption = "grabResult = Failed";

      // 訊息
      //AddAlignMessage("AutoAlign Capture - Fail!");
   }

   // 2015 9 9 - chc 再Trigger一次
   if(first == true) {
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);
      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);
      // Timeout?
      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame1a %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
}
//---------------------------------------------------------------------------
// 2016 5 12 - chc 新寫法, GigE CCD : 取得影像並顯示(BW/Color)
//   #define BASLER_CCD_BW                0
//   #define BASLER_CCD_COLOR             1
//   int BaslerCCDType[3];
// mode : 0 - 要呼叫 PylonDeviceGrabSingleFrame()
//        1 - 不要呼叫 PylonDeviceGrabSingleFrame()
void __fastcall TMainForm::CaptureGigaFrame1(int no, int mode)
{
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;
static bool first = false;

   // Index
   pnlCCDStatus->Color = clSilver;
   no--;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - w) / 2;
   //sy = (height - h) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   //lbGiga->Items->Add("CCD1進入取像...");
   // 在影像處理中
   boolInGigaBufferAry[no] = true;

   // Check to see if the image was grabbed successfully.
   if(grabResultAry[no].Status == Grabbed) {
      count++;
      unsigned char *pt,*pt1;
      int i;
      int pointer;
      // 1278*958 - 1294*964
      if(grabResultAry[no].SizeX != CCDInfoAry[no].Width || grabResultAry[no].SizeY != CCDInfoAry[no].Height) {
         lbGiga->Items->Add("Size1 Error!");
         pnlSystemMessage->Caption = "Size1 Error!";
         // 在影像處理中
         boolInGigaBufferAry[no] = false;
         pnlCCDStatus->Color = clRed;

         // 2015 9 8 - chc Log
         WriteSystemLog("CaptureGigaFrame1() RealSize Error!" + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         WriteSystemLog("CaptureGigaFrame1() SensorSize Error!" + IntToStr(CCDInfoAry[no].Width) + "," + IntToStr(CCDInfoAry[no].Height));

         return;
      }
      i = 0;
      // 記錄Basler存檔中...
      if(boolInGigaSaveAry[no] == true) {
         //lbGiga->Items->Add("存檔中, 不更新影像");
         pnlSystemMessage->Caption = "Saving1 Image...";
         boolInGigaBufferAry[no] = false;
         return;
      }
      pnlCCDStatus->Color = clLime;

      // Log
      //lbGiga->Items->Add("CCD1進入取像2...");

      // 全取: 要區分BW/C24
      // BW : scA1300ImageAry
      if(CCDInfoAry[no].Type == BASLER_CCD_BW) {

         // Log
         //lbGiga->Items->Add("CCD1進入取像2BW...");

         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)scA1300ImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX);
            i += grabResultAry[no].SizeX;
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         scA1300ImageROIAry[no].SetPlacement(x,y,w,h);
         scA1300ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }
      // Color : usb_ImageAry
      else {

         // Log
         //lbGiga->Items->Add("CCD1進入取像2Color... " + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         //lbGiga->Items->Add("CCD Size: " + IntToStr((int)grabResultAry[no].PayloadSize));

         // 2016 4 16 - chc 寫入檔案: YUV422
         /*
         FILE *fp;
         i = 0;
         static boolsave = false;
         if(boolsave == false) {
            if((fp = fopen("D:\\test.yuv","wb")) != NULL) {
               for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
                  fwrite((void *)&imgBufAry[no][i],1,grabResultAry[no].SizeX*2,fp);
                  i += (grabResultAry[no].SizeX * 2);
               }
               fclose(fp);
            }
            boolsave = true;
         }
         */
         //---------------------------------------------------------------------
         // YUV422 to RGB
         //i = 0;
         //for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
         //   pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
         //   memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX*2);
         //   i += (grabResultAry[no].SizeX * 2);
         //}
         unsigned char *yuvbuf,*pt;
         yuvbuf = &imgBufAry[no][0];
         // Y0,U0,Y1,V0 - Table
         int y0,u0,y1,v0,pdx,idx;
         int rdif,invgdif,bdif,w2,vr,vg,vb;
         w2 = width * 2;
         for(int i=0 ; i<height ; i++) {
            pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,i);
            idx = i * w2;
            pdx = 0;
            // 4bytes => 2Pixel
            for(int j=0 ; j<w2 ; j+=4) {
               u0 = yuvbuf[idx++];
               y0 = yuvbuf[idx++];
               v0 = yuvbuf[idx++];
               y1 = yuvbuf[idx++];

               rdif = Table_fv1[v0];
               invgdif = Table_fu1[u0] + Table_fv2[v0];
               bdif = Table_fu2[u0];

               // p1
               vb = y0 + bdif;
               vg = y0 - invgdif;
               vr = y0 + rdif;
               // BGR
               if(vb < 0)
                  vb = 0;
               else if(vb > 255)
                  vb = 255;
               pt[pdx++] = vb;
               if(vg < 0)
                  vg = 0;
               else if(vg > 255)
                  vg = 255;
               pt[pdx++] = vg;
               if(vr < 0)
                  vr = 0;
               else if(vr > 255)
                  vr = 255;
               pt[pdx++] = vr;
               // p2
               vb = y1 + bdif;
               vg = y1 - invgdif;
               vr = y1 + rdif;
               // BGR
               if(vb < 0)
                  vb = 0;
               else if(vb > 255)
                  vb = 255;
               pt[pdx++] = vb;
               if(vg < 0)
                  vg = 0;
               else if(vg > 255)
                  vg = 255;
               pt[pdx++] = vg;
               if(vr < 0)
                  vr = 0;
               else if(vr > 255)
                  vr = 255;
               pt[pdx++] = vr;
            }
         }
         //---------------------------------------------------------------------

         //lbGiga->Items->Add("CCD1: Move影像ok");

         // 要顯示在主畫面
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();

         //lbGiga->Items->Add("CCD1: 顯示影像ok");
      }

      // Basler Pylon GigE CCD
      boolBaslerImageLoadedAry[no] = true;
      BaslerCaptureNoAry[no]++;
      if((count % 5) == 0) {
         GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
         BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
         double ratio;
         AnsiString msg;

         // 2016 7 23 - chc Devide by zero
         if(BaslerElapsedmsAry[no] != 0) {

            ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
            msg.sprintf("%.1f",ratio);
            pnlCapturedNo->Caption = msg;
         }
      }
   }

   // 無法取像
   //else if(grabResult.Status == Failed) {
   else {

      // fprintf( stderr,  "Frame %d wasn't grabbed successfully.  Error code = 0x%08X\n",
      //    i+1, grabResult.ErrorCode );
      lbGiga->Items->Add("grabResult1 = Failed");
      pnlSystemMessage->Caption = "grabResult = Failed";

      // 訊息
      //AddAlignMessage("AutoAlign Capture - Fail!");
   }

   // 取像時間顯示
   GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
   BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                    (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
   pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
}
//---------------------------------------------------------------------------
// 2015 9 4 - chc GigE CCD : 取得影像並顯示(BW/Color)
//   #define BASLER_CCD_BW                0
//   #define BASLER_CCD_COLOR             1
//   int BaslerCCDType[3];
// mode : 0 - 要呼叫 PylonDeviceGrabSingleFrame()
//        1 - 不要呼叫 PylonDeviceGrabSingleFrame()
void __fastcall TMainForm::CaptureGigaFrame2(int no, int mode)
{
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;
static bool first = false;

   // Index
   pnlCCDStatus->Color = clSilver;
   no--;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - w) / 2;
   //sy = (height - h) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   //lbGiga->Items->Add("進入取像...");
   // 在影像處理中
   boolInGigaBufferAry[no] = true;

   // 2015 9 9 - chc 要加速
   if(first == false) {
      first = true;

      // Grab one single frame from stream channel 0. The
      // camera is set to single frame acquisition mode.
      // Wait up to 500 ms for the image to be grabbed.
      // Software Trigger
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);

      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);

      switch(res) {
         case GENAPI_E_FAIL:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-1");
            break;
         case GENAPI_E_INDEX_ERROR:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-2");
            break;
         case GENAPI_E_INSUFFICIENT_BUFFER:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-3");
            break;
         case GENAPI_E_INVALID_ARG:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-4");
            break;
         case GENAPI_E_INVALID_NODECALLBACKHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-5");
            break;
         case GENAPI_E_INVALID_NODEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-6");
            break;
         case GENAPI_E_INVALID_NODEMAPHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-7");
            break;
         case GENAPI_E_LIMITS_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-8");
            break;
         case GENAPI_E_LOGICAL_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-9");
            break;
         case GENAPI_E_NODE_NOT_FOUND:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-10");
            break;
         case GENAPI_E_OBJECT_ILLEGAL_STATE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-11");
            break;
         case GENAPI_E_OK:
            //lbGiga->Items->Add("IntToStr(no+1) + Captured-12");
            break;
         case GENAPI_E_PROPERTY_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-13");
            break;
         case GENAPI_E_RESULT_RANGE_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-14");
            break;
         case GENAPI_E_TIMEOUT:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-15");
            break;
         case GENAPI_E_TYPE_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-16");
            break;
         case PYLON_E_INVALID_CHUNKPARSERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-17");
            break;
         case PYLON_E_INVALID_CONVERTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-18");
            break;
         case PYLON_E_INVALID_DEVICEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-19");
            break;
         case PYLON_E_INVALID_DEVICEINFO_PROPERTY:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-20");
            break;
         case PYLON_E_INVALID_DEVICEINFOHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-21");
            break;
         case PYLON_E_INVALID_EVENTADAPTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-22");
            break;
         case PYLON_E_INVALID_EVENTGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured23");
            break;
         case PYLON_E_INVALID_STREAMGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-24");
            break;
         case PYLON_E_INVALID_WAITOBJECTHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-25");
            break;
         case PYLON_E_INVALID_WAITOBJECTSHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-26");
            break;
      }

      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame2 %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
      //CHECK(res);
   }

   // chc
   //grabResultAry[no].Status = Grabbed;

   // Check to see if the image was grabbed successfully.
   if(grabResultAry[no].Status == Grabbed) {
      count++;
      unsigned char *pt,*pt1;
      int i;
      int pointer;
      if(grabResultAry[no].SizeX != CCDInfoAry[no].Width || grabResultAry[no].SizeY != CCDInfoAry[no].Height) {
         lbGiga->Items->Add("Size Error!");
         pnlSystemMessage->Caption = "Size2 Error!";
         // 在影像處理中
         boolInGigaBufferAry[no] = false;
         pnlCCDStatus->Color = clRed;

         // 2015 9 8 - chc Log
         WriteSystemLog("CaptureGigaFrame2() Size Error!" + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         WriteSystemLog("CaptureGigaFrame2() Size Error!" + IntToStr(CCDInfoAry[no].Width) + "," + IntToStr(CCDInfoAry[no].Height));

         return;
      }
      i = 0;
      // 記錄Basler存檔中...
      if(boolInGigaSaveAry[no] == true) {
         lbGiga->Items->Add("In Saving2... Stop Refeshing Image");
         pnlSystemMessage->Caption = "In Saving... Stop Refeshing Image";
         boolInGigaBufferAry[no] = false;
         return;
      }
      pnlCCDStatus->Color = clLime;

      // 全取: 要區分BW/C24
      // BW : scA1300ImageAry
      if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)scA1300ImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX);
            i += grabResultAry[no].SizeX;
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         scA1300ImageROIAry[no].SetPlacement(x,y,w,h);
         scA1300ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }
      // Color : usb_ImageAry
      else {
         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX*3);
            i += (grabResultAry[no].SizeX * 3);
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }

      // Basler Pylon GigE CCD
      boolBaslerImageLoadedAry[no] = true;
      BaslerCaptureNoAry[no]++;
      if((count % 5) == 0) {
         GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
         BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
         double ratio;
         AnsiString msg;

         // 2016 7 23 - chc Devide by zero
         if(BaslerElapsedmsAry[no] != 0) {

            ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
            msg.sprintf("%.1f",ratio);
            pnlCapturedNo->Caption = msg;
         }
      }
   }

   // 無法取像
   //else if(grabResult.Status == Failed) {
   else {

      // fprintf( stderr,  "Frame %d wasn't grabbed successfully.  Error code = 0x%08X\n",
      //    i+1, grabResult.ErrorCode );
      lbGiga->Items->Add("grabResult2 = Failed");
      pnlSystemMessage->Caption = "grabResult = Failed";

      // 訊息
      //AddAlignMessage("AutoAlign Capture - Fail!");
   }

   // 2015 9 9 - chc 再Trigger一次
   if(first == true) {
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);
      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);
      // Timeout?
      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame2a %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
}
//---------------------------------------------------------------------------
// 2015 9 4 - chc GigE CCD : 取得影像並顯示(BW/Color)
//   #define BASLER_CCD_BW                0
//   #define BASLER_CCD_COLOR             1
//   int BaslerCCDType[3];
// mode : 0 - 要呼叫 PylonDeviceGrabSingleFrame()
//        1 - 不要呼叫 PylonDeviceGrabSingleFrame()
void __fastcall TMainForm::CaptureGigaFrame3(int no, int mode)
{
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;
static bool first = false;

   // Index
   pnlCCDStatus->Color = clSilver;
   no--;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - w) / 2;
   //sy = (height - h) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   //lbGiga->Items->Add("進入取像...");
   // 在影像處理中
   boolInGigaBufferAry[no] = true;

   // 2015 9 9 - chc 要加速
   if(first == false) {
      first = true;

      // Grab one single frame from stream channel 0. The
      // camera is set to single frame acquisition mode.
      // Wait up to 500 ms for the image to be grabbed.
      // Software Trigger
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);

      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);

      switch(res) {
         case GENAPI_E_FAIL:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-1");
            break;
         case GENAPI_E_INDEX_ERROR:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-2");
            break;
         case GENAPI_E_INSUFFICIENT_BUFFER:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-3");
            break;
         case GENAPI_E_INVALID_ARG:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-4");
            break;
         case GENAPI_E_INVALID_NODECALLBACKHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-5");
            break;
         case GENAPI_E_INVALID_NODEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-6");
            break;
         case GENAPI_E_INVALID_NODEMAPHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-7");
            break;
         case GENAPI_E_LIMITS_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-8");
            break;
         case GENAPI_E_LOGICAL_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-9");
            break;
         case GENAPI_E_NODE_NOT_FOUND:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-10");
            break;
         case GENAPI_E_OBJECT_ILLEGAL_STATE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-11");
            break;
         case GENAPI_E_OK:
            //lbGiga->Items->Add("IntToStr(no+1) + Captured-12");
            break;
         case GENAPI_E_PROPERTY_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-13");
            break;
         case GENAPI_E_RESULT_RANGE_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-14");
            break;
         case GENAPI_E_TIMEOUT:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-15");
            break;
         case GENAPI_E_TYPE_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-16");
            break;
         case PYLON_E_INVALID_CHUNKPARSERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-17");
            break;
         case PYLON_E_INVALID_CONVERTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-18");
            break;
         case PYLON_E_INVALID_DEVICEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-19");
            break;
         case PYLON_E_INVALID_DEVICEINFO_PROPERTY:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-20");
            break;
         case PYLON_E_INVALID_DEVICEINFOHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-21");
            break;
         case PYLON_E_INVALID_EVENTADAPTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-22");
            break;
         case PYLON_E_INVALID_EVENTGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured23");
            break;
         case PYLON_E_INVALID_STREAMGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-24");
            break;
         case PYLON_E_INVALID_WAITOBJECTHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-25");
            break;
         case PYLON_E_INVALID_WAITOBJECTSHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-26");
            break;
      }

      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame3 %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
      //CHECK(res);
   }

   // chc
   //grabResultAry[no].Status = Grabbed;

   // Check to see if the image was grabbed successfully.
   if(grabResultAry[no].Status == Grabbed) {
      count++;
      unsigned char *pt,*pt1;
      int i;
      int pointer;
      if(grabResultAry[no].SizeX != CCDInfoAry[no].Width || grabResultAry[no].SizeY != CCDInfoAry[no].Height) {
         lbGiga->Items->Add("Size3 Error!");
         pnlSystemMessage->Caption = "Size Error!";
         // 在影像處理中
         boolInGigaBufferAry[no] = false;
         pnlCCDStatus->Color = clRed;

         // 2015 9 8 - chc Log
         WriteSystemLog("CaptureGigaFrame3() Size Error!" + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         WriteSystemLog("CaptureGigaFrame3() Size Error!" + IntToStr(CCDInfoAry[no].Width) + "," + IntToStr(CCDInfoAry[no].Height));

         return;
      }
      i = 0;
      // 記錄Basler存檔中...
      if(boolInGigaSaveAry[no] == true) {
         lbGiga->Items->Add("In Saving3... Stop Refeshing Image");
         pnlSystemMessage->Caption = "In Saving... Stop Refeshing Image";
         boolInGigaBufferAry[no] = false;
         return;
      }
      pnlCCDStatus->Color = clLime;

      // 全取: 要區分BW/C24
      // BW : scA1300ImageAry
      if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)scA1300ImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX);
            i += grabResultAry[no].SizeX;
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         scA1300ImageROIAry[no].SetPlacement(x,y,w,h);
         scA1300ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }
      // Color : usb_ImageAry
      else {
         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX*3);
            i += (grabResultAry[no].SizeX * 3);
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }

      // Basler Pylon GigE CCD
      boolBaslerImageLoadedAry[no] = true;
      BaslerCaptureNoAry[no]++;
      if((count % 5) == 0) {
         GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
         BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
         double ratio;
         AnsiString msg;

         // 2016 7 23 - chc Devide by zero
         if(BaslerElapsedmsAry[no] != 0) {

            ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
            msg.sprintf("%.1f",ratio);
            pnlCapturedNo->Caption = msg;
         }
      }
   }

   // 無法取像
   //else if(grabResult.Status == Failed) {
   else {

      // fprintf( stderr,  "Frame %d wasn't grabbed successfully.  Error code = 0x%08X\n",
      //    i+1, grabResult.ErrorCode );
      lbGiga->Items->Add("grabResult3 = Failed");
      pnlSystemMessage->Caption = "grabResult = Failed";

      // 訊息
      //AddAlignMessage("AutoAlign Capture - Fail!");
   }

   // 2015 9 9 - chc 再Trigger一次
   if(first == true) {
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);
      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);
      // Timeout?
      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame3a %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
}
//---------------------------------------------------------------------------
// 2015 9 7 - chc GigE CCD : scA1300-gm
//    Review(192.168.1.11): Basler scA1000-30gc(1032*778), 1/3", 4.65um*4.65um  Device ID=21699292
//    上(192.168.1.12): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um     Device ID=21706344
//    下(192.168.1.13): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um     Device ID=21706349
// 要取得: no(CCD編號/序號), name(CCD名稱), type(BW/Color), Width, Height
//struct CCDINFO_STRU        {
//   int width,Height;
//   int No;
//   int PixelSize;
//   int Type;
//   AnsiString Name;
//};
//struct CCDINFO_STRU        CCDInfoAry[3];
void __fastcall TMainForm::SetupscA1300()
{
int baslerccdno;
AnsiString msg;
int pos,pixelsize,width,height;
AnsiString ccdname,deviceid;

// 2019 7 5 - chc 設定為自動還是手動
bool boolauto = true;

   // 2019 7 5 - chc Log
   WriteSystemLog("Setup CCD: 1");

   // CCD編號(0/1/2/3...)
   baslerccdno = 0;
   lbGiga->Items->Add("Setup CCD...");

   // 2019 7 5 - chc Log
   WriteSystemLog("Setup CCD: 2");

   // 最多三個CCD
   for(int i=0 ; i<3 ; i++)
      bool_scA1300_StatusAry[i] = false;

   // 2019 7 5 - chc Log
   WriteSystemLog("Setup CCD: [" + ISCCDName + "], [" + ISCCDSerialNo + "]");

   // 2019 12 7 - chc for test
   if(boolForTest == true)
      return;

   // 2020 2 28 - chc CCD
   if(boolCCD == false)
      return;

   // 2019 7 5 - chc 透過ShowDeviceSettingDialog來設定
   if(boolauto == false) {
      ICImagingControl1->ShowDeviceSettingsDialog();
      WriteSystemLog("CCD: " + ICImagingControl1->Device + "," + ICImagingControl1->DeviceUniqueName + "," + IntToStr(ICImagingControl1->ImageWidth));
      WriteSystemLog("CCD: bit= " + IntToStr(ICImagingControl1->ImageBitsPerPixel));
   }
   else {

      // 2016 11 25 - chc 改用ImagingSource
      ICImagingControl1->Device = ISCCDName;                                       // "DFK 33G274";
      WriteSystemLog("Setup CCD: ISCCDName");
      ICImagingControl1->DeviceUniqueName = ISCCDName + " " + ISCCDSerialNo;       // "DFK 33G274 11124360";
   }

   // 2019 7 5 - chc Log
   WriteSystemLog("Setup CCD: Enable...");

   // 2016 12 17 - chc 加入Try-catch
   try {

      if(boolauto == true) {                                                                         // 43614991(AUO1)
         ICImagingControl1->Enabled = true;
         MakeDeviceSettings();
      }

      if(ICImagingControl1->DeviceValid == true) {

         // 2019 7 5 - chc Log
         WriteSystemLog("Setup CCD Device: ok");
         numDevices = 1;

         bool_scA1300_StatusAry[0] = true;
         // CCD: 取得編號, 名稱, Bit數, Width, Height
         CCDInfoAry[baslerccdno].No = 0;                                           // First CCD
         CCDInfoAry[baslerccdno].Name = ISCCDName;
         CCDInfoAry[baslerccdno].PixelSize = ICImagingControl1->ImageBitsPerPixel / 8;
         CCDInfoAry[baslerccdno].Width = ICImagingControl1->ImageWidth;
         CCDInfoAry[baslerccdno].Height = ICImagingControl1->ImageHeight;
         CCDInfoAry[baslerccdno].DeviceID = ISCCDSerialNo;;

         // 2019 7 5 - chc Color or BW
         WriteSystemLog("CCD Bits: " + IntToStr(ICImagingControl1->ImageBitsPerPixel));
         if(ICImagingControl1->ImageBitsPerPixel > 8) {
            CCDInfoAry[baslerccdno].Type = BASLER_CCD_COLOR;
            WriteSystemLog("CCD: Color");
         }
         else {
            CCDInfoAry[baslerccdno].Type = BASLER_CCD_BW;
            WriteSystemLog("CCD: Gray");
         }

         // Live
         ICImagingControl1->LiveStart();
         tmISCCD->Enabled = true;

         pnlISCCDStaus->Color = clLime;
         msg.sprintf("%dx%d %d %s 4.4um",CCDInfoAry[baslerccdno].Width,CCDInfoAry[baslerccdno].Height,CCDInfoAry[baslerccdno].PixelSize,CCDInfoAry[baslerccdno].DeviceID.c_str());
         pnlISCCDInfo->Caption = msg;
         WriteSystemLog(msg);
         msg.sprintf("%dx%d %d",CCDInfoAry[baslerccdno].Width,CCDInfoAry[baslerccdno].Height,CCDInfoAry[baslerccdno].PixelSize);
         pnlCCDSize->Caption = msg;
         // 不能設為Live, 設為Live就會啟動Basler的取像與顯示作業
         //scA1300ThreadAry[baslerccdno]->boolBaslerLive = true;
         BaslerCaptureNoAry[baslerccdno] = 0;
         GetTimeTic(&BaslerStartTimeAry[baslerccdno],&BaslerStartTickAry[baslerccdno]);
         btnReviewLive->Caption = "Grab";

         // 2019 11 26 - chc 設定Gain/Shutter: BaslerShutter, BaslerGain
         rgBaslerShutter->ItemIndex = scA1300ShutterAry[0];
         rgBaslerShutterClick(this);
         tbBaslerGain->Position = BaslerGain;
         pnlBaslerGain->Caption = IntToStr(BaslerGain);

      }
      else {

         // 2019 7 5 - chc Log
         WriteSystemLog("Setup CCD Device: fail");

         pnlISCCDStaus->Color = clRed;
      }

   }
   catch(Exception &e) {
      pnlISCCDStaus->Color = clRed;
      WriteSystemLog("Setup ImagingSource CCD - Error");
      sbSystemMessage->Panels->Items[1]->Text = "Setup ImagingSource CCD - Error";
   }

   return;

   // Before using any pylon methods, the pylon runtime must be initialized.
   PylonInitialize();
   // Enumerate all camera devices. You must call PylonEnumerateDevices() before creating a device!
   res = PylonEnumerateDevices(&numDevices);
   if(0 == numDevices) {
      pnlSystemMessage->Caption = "No GigE devices found!";
      pnlSystemMessage->Caption = "No devices found!";
      // Before exiting a program, PylonTerminate() should be called to release all pylon related resources.
      PylonTerminate();
      return;
   }

   for(int i=0 ; i<numDevices ; i++) {
      baslerccdno = i;
      // Get a handle for the first device found.
      res = PylonCreateDeviceByIndex( baslerccdno, &hDevGigaAry[baslerccdno]);
      //CHECK(res);

      // Before using the device, it must be opened. Open it for configuring parameters and for grabbing images.
      res = PylonDeviceOpen( hDevGigaAry[baslerccdno], PYLONC_ACCESS_MODE_CONTROL | PYLONC_ACCESS_MODE_STREAM );
      //CHECK(res);
      {
         char buf[256];
         size_t siz = sizeof(buf);
         _Bool isReadable;
         ccdname = "";
         deviceid = "";
         width = 0;
         height = 0;
         pixelsize = 0;
         isReadable = PylonDeviceFeatureIsReadable(hDevGigaAry[baslerccdno], "DeviceModelName");
         if ( isReadable ) {
            res = PylonDeviceFeatureToString(hDevGigaAry[baslerccdno], "DeviceModelName", buf, &siz );
            //CHECK(res);
            lbGiga->Items->Add(buf);
            ccdname.sprintf("%s", buf);
            pnlSystemMessage->Caption = "CCDName: " + ccdname;
         }
      }

      //    Review(192.168.1.11): Basler scA1000-30gc(1032*778), 1/3", 4.65um*4.65um
      //    上(192.168.1.12): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um
      //    下(192.168.1.13): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um
      // 找gc or gm
      // bits per pixel
      res = PylonDeviceGetIntegerFeatureInt32( hDevGigaAry[baslerccdno], "PixelSize", &pixelsize);
      res = PylonDeviceGetIntegerFeatureInt32( hDevGigaAry[baslerccdno], "SensorWidth", &width);
      res = PylonDeviceGetIntegerFeatureInt32( hDevGigaAry[baslerccdno], "SensorHeight", &height);
      {
         char buf[256];
         size_t siz = sizeof(buf);
         _Bool isReadable;
         isReadable = PylonDeviceFeatureIsReadable(hDevGigaAry[baslerccdno], "DeviceID");
         if ( isReadable ) {
            res = PylonDeviceFeatureToString(hDevGigaAry[baslerccdno], "DeviceID", buf, &siz );
            //CHECK(res);
            lbGiga->Items->Add(buf);
            deviceid.sprintf("%s", buf);
            pnlSystemMessage->Caption = "CCD ID: " + deviceid;
            // 取得序號
            CCDSN = deviceid;
         }
      }

      // 2016 4 16 - chc 修正w/h: RealSize=>1278*958 - Sensor Size=>1294*964???
      if(width == 1294)
         width = 1278;
      if(height == 964)
         height = 958;
      if(pixelsize == 0) {
         lbGiga->Items->Add("PixelSize: 0 to 2!!!");
         pixelsize = 2;
      }

      // CCD: 取得編號, 名稱, Bit數, Width, Height
      CCDInfoAry[baslerccdno].No = baslerccdno;
      CCDInfoAry[baslerccdno].Name = ccdname;
      CCDInfoAry[baslerccdno].PixelSize = pixelsize;
      CCDInfoAry[baslerccdno].Width = width;
      CCDInfoAry[baslerccdno].Height = height;
      CCDInfoAry[baslerccdno].DeviceID = deviceid;
      pos = ccdname.Pos("gc");
      // BW
      if(pos == 0) {
         // CCD: 取得Type
         lbGiga->Items->Add("Gray CCD");
         CCDInfoAry[baslerccdno].Type = BASLER_CCD_BW;
         WriteSystemLog(">CCD" + IntToStr(baslerccdno+1) + ": Gray");
         // Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel.
         // ... Check first to see if the device supports the Mono8 format.
         isAvail = PylonDeviceFeatureIsAvailable(hDevGigaAry[baslerccdno],"EnumEntry_PixelFormat_Mono8");
         if(!isAvail) {
            pnlSystemMessage->Caption = "Device doesn't support the Mono8 pixel format";
            pnlSystemMessage->Caption = "Not support Mono8";
            // Before exiting a program, PylonTerminate() should be called to release all pylon related resources.
            PylonTerminate();
            return;
         }
         // ... Set the pixel format to Mono8.
         res = PylonDeviceFeatureFromString(hDevGigaAry[baslerccdno], "PixelFormat", "Mono8" );
         //CHECK(res);
      }
      // Color
      else {
         lbGiga->Items->Add("Color CCD: PixelSize=" + IntToStr(pixelsize));
         // CCD: 取得Type
         CCDInfoAry[baslerccdno].Type = BASLER_CCD_COLOR;
         WriteSystemLog(">CCD" + IntToStr(baslerccdno+1) + ": Color");
         // Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel.
         // ... Check first to see if the device supports the Mono8 format.

         // ###暫不處理: 可能YUV422只有16bits
         /*
         isAvail = PylonDeviceFeatureIsAvailable(hDevGigaAry[baslerccdno],"EnumEntry_PixelFormat_RGB8Packed");
         if(!isAvail) {
            pnlSystemMessage->Caption = "Device doesn't support the RGB8Packed pixel format";
            pnlSystemMessage->Caption = "Not support RGB8Packed";
            // Before exiting a program, PylonTerminate() should be called to release all pylon related resources.
            PylonTerminate();
            return;
         }
         // ... Set the pixel format to RGB8Packed.
         res = PylonDeviceFeatureFromString(hDevGigaAry[baslerccdno], "PixelFormat", "RGB8Packed" );
         */

         //CHECK(res);
      }
      WriteSystemLog(">CCD" + IntToStr(baslerccdno+1) + ": " + ccdname + "," + deviceid + "," + IntToStr(CCDInfoAry[baslerccdno].PixelSize) + "," +
                           IntToStr(CCDInfoAry[baslerccdno].Width) + "," + IntToStr(CCDInfoAry[baslerccdno].Height));
      // Disable acquisition start trigger if available
      isAvail = PylonDeviceFeatureIsAvailable( hDevGigaAry[baslerccdno], "EnumEntry_TriggerSelector_AcquisitionStart");
      if(isAvail) {
         //res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerSelector", "AcquisitionStart");
         //CHECK(res);
         //res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerMode", "Off");
         //CHECK(res);
      }

      //Disable frame start trigger if available
      isAvail = PylonDeviceFeatureIsAvailable( hDevGigaAry[baslerccdno], "EnumEntry_TriggerSelector_FrameStart");
      if(isAvail) {
         // res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerSelector", "FrameStart");
         //CHECK(res);
         // res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerMode", "Off");
         //CHECK(res);
      }

      // 2011 10 9 - chc Software Trigger說明 - 參考範例
      // Software and Hardware Trigger -> TriggerSelector_FrameStart
      // Software -> TriggerSelector_AcquisitionStart
      // Camera uses the acquisition start trigger as the only trigger mode.
      //         Camera.TriggerSelector.SetValue(TriggerSelector_AcquisitionStart);
      //         Camera.TriggerMode.SetValue(TriggerMode_On);
      //         triggerSelectorValue = TriggerSelector_AcquisitionStart;
      // Enable continous acquisition mode
      //     Camera.AcquisitionMode.SetValue(AcquisitionMode_Continuous);
      // 無法作動, 先不用
      /*
      res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerSelector"  , "AcquisitionStart");
      res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerMode"      , "On");
      res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerSource"    , "Software");
      res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "AcquisitionMode"  , "Continuous");
      */

      // For GigE cameras, we recommend increasing the packet size for better
      //    performance. If the network adapter supports jumbo frames, set the packet
      //    size to a value > 1500, e.g., to 8192. In this sample, we only set the packet size
      //    to 1500.
      // ... Check first to see if the GigE camera packet size parameter is supported
      //     and if it is writable.
      isAvail = PylonDeviceFeatureIsWritable(hDevGigaAry[baslerccdno], "GevSCPSPacketSize");
      if(isAvail) {
         // ... The device supports the packet size feature. Set a value.
         res = PylonDeviceSetIntegerFeature( hDevGigaAry[baslerccdno], "GevSCPSPacketSize", 1500 );
         //CHECK(res);
      }

      // Determine the required size of the grab buffer.
      res = PylonDeviceGetIntegerFeatureInt32( hDevGigaAry[baslerccdno], "PayloadSize", &payloadSize );
      //CHECK(res);
      // CCD: 取得TotalSize
      CCDInfoAry[baslerccdno].TotalSize = payloadSize;
      WriteSystemLog(">CCD" + IntToStr(baslerccdno+1) + " TotalSize: " + IntToStr(CCDInfoAry[baslerccdno].TotalSize));

      // Allocate memory for grabbing.
      imgBufAry[baslerccdno] = NULL;
      imgBufAry[baslerccdno] = (unsigned char*) malloc( payloadSize );
      if(imgBufAry[baslerccdno] == NULL) {
         pnlSystemMessage->Caption = "Out of memory";
         pnlSystemMessage->Caption = "Out of memory";
         // Before exiting a program, PylonTerminate() should be called to release all pylon related resources.
         PylonTerminate();
         lbGiga->Items->Add("Out of Memory!");
         return;
      }

      pnlCCDSize->Caption = IntToStr(CCDInfoAry[baslerccdno].Width) + "x" + IntToStr(CCDInfoAry[baslerccdno].Height) + " 4.4um";
      GigaWidth = CCDInfoAry[baslerccdno].Width;
      GigaHeight = CCDInfoAry[baslerccdno].Height;
      // 1100 * 890
      AlignWidth = imCCD->Width;
      AlignHeight = imCCD->Height;

      // 區分BW/Color
      if(CCDInfoAry[baslerccdno].Type == BASLER_CCD_BW) {
         // 前面已Initial, 要先Detech
         scA1300ImageROIAry[baslerccdno].Detach();
         // scA1300的影像顯示改由EImageBW8 - CPU效能問題!!!!
         scA1300ImageAry[baslerccdno].SetSize(GigaWidth,GigaHeight);
         scA1300ImageROIAry[baslerccdno].Attach(&scA1300ImageAry[baslerccdno]);
         scA1300ImageROIAry[baslerccdno].SetPlacement((GigaWidth-AlignWidth)/2,(GigaHeight-AlignHeight)/2,AlignWidth,AlignHeight);

         // 2016 4 17 - chc 加入Mark
         scA1300ImageMarkROIAry[baslerccdno].Detach();
         scA1300ImageMarkROIAry[baslerccdno].Attach(&scA1300ImageAry[baslerccdno]);

      }
      else {
         // 前面已Initial, 要先Detech
         usb_ImageROIAry[baslerccdno].Detach();
         usb_ImageAry[baslerccdno].SetSize(GigaWidth,GigaHeight);
         usb_ImageROIAry[baslerccdno].Attach(&usb_ImageAry[baslerccdno]);
         usb_ImageROIAry[baslerccdno].SetPlacement((GigaWidth-AlignWidth)/2,(GigaHeight-AlignHeight)/2,AlignWidth,AlignHeight);

         // 2016 4 17 - chc 加入Mark
         usb_ImageMarkROIAry[baslerccdno].Detach();
         usb_ImageMarkROIAry[baslerccdno].Attach(&usb_ImageROIAry[baslerccdno]);

      }
      lbGiga->Items->Add("CCD " + IntToStr(baslerccdno+1) + " Initial Success.");
      bool_scA1300_StatusAry[baslerccdno] = true;
      boolBaslerGrabbedAry[baslerccdno] = false;
      boolBaslerImageLoadedAry[baslerccdno] = false;
      boolInGigaSaveAry[baslerccdno] = false;
      // 建立Thread
      scA1300ThreadAry[baslerccdno] = new TscA1300(true, baslerccdno+1, CCDInfoAry[baslerccdno].Name, CCDInfoAry[baslerccdno].Type,
                                   CCDInfoAry[baslerccdno].Width, CCDInfoAry[baslerccdno].Height);

      lbGiga->Items->Add("CCD Thread Created.");
      // 設定選項
//    Review(192.168.1.11): Basler scA1000-30gc(1032*778), 1/3", 4.65um*4.65um  Device ID=21699292
//    上(192.168.1.12): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um     Device ID=21706344
//    下(192.168.1.13): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um     Device ID=21706349
      // ### 暫不處理
      //if(CCDInfoAry[baslerccdno].DeviceID == "21699292") {
      //   rgCCDSelect->Items->Strings[baslerccdno] = "Color(R)";
      //}
      //else if(CCDInfoAry[baslerccdno].DeviceID == "21706344") {
      //   rgCCDSelect->Items->Strings[baslerccdno] = "Gray(U)";
      //}
      //else {
      //   rgCCDSelect->Items->Strings[baslerccdno] = "Gray(D)";
      //}

      // Let the camera acquire images continuously ( Acquisiton mode equals
      // Continuous! )
      //Camera.AcquisitionStart.Execute();
      PylonDeviceExecuteCommandFeature(hDevGigaAry[baslerccdno], "AcquisitionStart");
      // 取得StreamGrabber
      //PylonDeviceGetStreamGrabber(PYLON_DEVICE_HANDLE hDevscA1300, size_t index, RETVAL_PAR PYLON_STREAMGRABBER_HANDLE *phStg);
      PylonDeviceGetStreamGrabber(hDevGigaAry[baslerccdno], 0, &hStg);

      // 改變Shutter/Gain
      rgBaslerShutter->ItemIndex = scA1300ShutterAry[baslerccdno];
      //rgBaslerShutterClick(this);
      lbGiga->Items->Add("Basler CCD Gain: " + IntToStr(scA1300GainAry[baslerccdno]));
      tbBaslerGain->Position = scA1300GainAry[baslerccdno];
      //tbBaslerGainChange(this);

      lbGiga->Items->Add("Setup CCD Ok.");
   }
}
//---------------------------------------------------------------------------
// 2016 4 16 - chc 取得影像區域
void __fastcall TMainForm::GetImageXY(int width,int height,int sx,int sy,int w,int h,int *x,int *y)
{
int px,py;

   if((sx + w) >= width)
      px = width - w;
   else
      px = sx;
   if((sy + h) >= height)
      py = height - h;
   else
      py = sy;
   *x = px;
   *y = py;
}
//---------------------------------------------------------------------------
// 2016 4 16 - chc Live
void __fastcall TMainForm::btnReviewLiveClick(TObject *Sender)
{
int no;

   // 2016 12 8 - chc 暫不提供!
   return;
}
//---------------------------------------------------------------------------
// 2016 4 16 - chc Loag Image
void __fastcall TMainForm::btnReviewLoadClick(TObject *Sender)
{
int no,width,height,sx,sy,x,y,w,h;

   // 固定為0
   no = 0;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - w) / 2;
   //sy = (height - h) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   // 取像中要先擷取
   // 2016 12 8 - chc 不做此動作: Live尚未改
   //if(btnReviewLive->Caption == "Grab")
   //   btnReviewLiveClick(this);

   opCCDImage->InitialDir = BaslerBitmapDirectory;
   if(opCCDImage->Execute()) {
      if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
         scA1300ImageAry[no].Load(opCCDImage->FileName.c_str());
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         scA1300ImageROIAry[no].SetPlacement(x,y,w,h);
         scA1300ImageROIAry[no].Draw(imCCD->Canvas->Handle);
      }
      else {
         usb_ImageAry[no].Load(opCCDImage->FileName.c_str());
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
      }
      // 若沒有Refresh就不會顯示
      imCCD->Refresh();

      boolBaslerImageLoadedAry[no] = true;
      pnlSystemMessage->Caption = "Image Loaded.";
   }

}
//---------------------------------------------------------------------------
// 2016 4 16 - chc Save
void __fastcall TMainForm::btnReviewSaveClick(TObject *Sender)
{
AnsiString filename;
int no;

   // 固定為0
   no = 0;

   // 取像中要先擷取
   // 2016 12 8 - chc 不做此動作: Live尚未改
   //if(btnReviewLive->Caption == "Grab")
   //   btnReviewLiveClick(this);

   if(boolBaslerImageLoadedAry[no]) {
      spCCDImage->InitialDir = BaslerBitmapDirectory;

      // 2016 12 21 - chc 設定filtet
      spCCDImage->Filter = "BMP(*.bmp)|*.bmp";

      if(spCCDImage->Execute()) {
         // 改變副檔名
         filename = ChangeFileExt(spCCDImage->FileName,".bmp");

         // 2016 12 8 - chc 存ROI
         /*
         if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
            scA1300ImageAry[no].Save(filename.c_str(),E_FILE_FORMAT_GRAY_LEVEL_BMP);
         }
         else {
            usb_ImageAry[no].Save(filename.c_str(),E_FILE_FORMAT_COLOR_BMP);
         }
         */
         // 2019 11 27 - chc 是Gray才對
         if(CCDInfoAry[no].Type == BASLER_CCD_BW)
            scA1300ImageAry[no].Save(filename.c_str(),E_FILE_FORMAT_GRAY_LEVEL_BMP);
         else

            usb_ImageROIAry[no].Save(filename.c_str(),E_FILE_FORMAT_COLOR_BMP);
         pnlSystemMessage->Caption = "Image Saved.";
      }
   }
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::UpdateAlarmStatus()
{
int no;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::imCCDMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy;

   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imCCD->Canvas->Pixels[X][Y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = X + sx;
   pnlCCDY->Caption = Y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",X,Y);
   sbSystemMessage->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystemMessage->Panels->Items[4]->Text = str;

   // 2016 12 15 - chc 校正
   double fx,fy;
   fx = pnlXFactor->Caption.ToDouble();
   fy = pnlYFactor->Caption.ToDouble();

   // 2016 12 22 - chc 取得Factor: 固定為1.0/1.0
   GetFactor(&fx,&fy,edCounterX->Text.ToDouble(),edCounterY->Text.ToDouble(),edOriginalX->Text.ToDouble(),edOriginalY->Text.ToDouble());

   // 2016 12 8 - chc 距離Origin的距離
   double tx,ty,resolution;
   int cx,cy;
   resolution = GetLensPrecision();
   tx = edCounterX->Text.ToDouble() - edOriginalX->Text.ToInt();
   ty = edCounterY->Text.ToDouble() - edOriginalY->Text.ToInt();
   tx *= X_RESOLUTION;
   ty *= Y_RESOLUTION;

   // 2016 12 15 - chc 校正
   tx *= fx;
   ty *= fy;

   // 2018 1 7 - chc 使用fx,fy
   tx = fx * X_RESOLUTION;
   ty = fy * Y_RESOLUTION;

   cx = shVertical->Left - imCCD->Left;
   cy = shHorizontal->Top - imCCD->Top;
   tx += (X-cx)*resolution;
   ty += (Y-cy)*resolution;
   // 2016 12 14 - chc 加入長度
   if(pnlUnit->Caption == "um")
      str.sprintf("長=%.1fum",sqrt(tx*tx + ty*ty));
   else
      str.sprintf("長=%.3fmm",sqrt(tx*tx + ty*ty)/MM_TO_UM);
   pnlPositionLength->Caption = str;

   // 2016 10 14 - chc Measure Crosshair
   if(cbMeasure->Checked == true && cbCrossHair->Checked == true) {
      shRightPosition->Left = X + imCCD->Left;
      shUpPosition->Top = Y + imCCD->Top;
   }

   // 2016 10 12 - chc Measure
   if(MeasureState == 1 && cbMeasure->Checked == true) {
      Mx2 = X;
      My2 = Y;
      /*
      imCCD->Canvas->Pen->Color = clBlue;
      imCCD->Canvas->Brush->Color = clBlue;
      imCCD->Canvas->Pen->Width = 1;
      imCCD->Canvas->MoveTo(Mx1,My1);
      imCCD->Canvas->LineTo(Mx1,My2);
      imCCD->Canvas->LineTo(Mx2,My2);
      imCCD->Canvas->LineTo(Mx2,My1);
      imCCD->Canvas->LineTo(Mx1,My1);
      imCCD->Canvas->Pen->Color = clLime;
      imCCD->Canvas->Brush->Color = clLime;
      imCCD->Canvas->Pen->Width = 2;
      imCCD->Canvas->LineTo(Mx2,My2);
      */
      int w,h,l,t;
      if(Mx1 < Mx2)
         l = Mx1;
      else
         l = Mx2;
      if(My1 < My2)
         t = My1;
      else
         t = My2;
      w = abs(Mx2 - Mx1);
      h = abs(My2 - My1);
      shMeasure->Left = l + imCCD->Left;
      shMeasure->Top = t + imCCD->Top;
      shMeasure->Width = w;
      shMeasure->Height = h;

      // Realtime display
      double wvalue,hvalue,lvalue,dx;
      AnsiString msg;
      dx = GetLensPrecision();
      // Width
      wvalue = (abs(Mx2 - Mx1)+1) * dx;
      // Height
      hvalue = (abs(My2 - My1)+1) * dx;

      // Length
      // 2016 12 15 - chc 校正
      //lvalue = sqrt((Mx2-Mx1)*(Mx2-Mx1) + (My2-My1)*(My2-My1)) * dx;
      lvalue = sqrt(wvalue*wvalue + hvalue*hvalue);

      if(pnlUnit->Caption == "um")
         msg.sprintf("(um)W:%.2f  H:%.2f  L:%.2f  A:%.2f  a:%.2f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
      else {
         wvalue /= MM_TO_UM;
         hvalue /= MM_TO_UM;
         lvalue /= MM_TO_UM;
         msg.sprintf("(mm)W:%.3f  H:%.3f  L:%.3f  A:%.4f  a:%.4f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
      }
      pnlMeasureResult->Caption = msg;
      shEllipse->Left = shMeasure->Left;
      shEllipse->Top = shMeasure->Top;
      shEllipse->Width = shMeasure->Width;
      shEllipse->Height = shMeasure->Height;
      shEllipse->Visible = true;

   }
}
//---------------------------------------------------------------------------
// 2016 4 16 - chc YUV422 to RGB
void __fastcall TMainForm::pnlCCDSizeClick(TObject *Sender)
{
FILE *fp;
int w,h,iw,ih,row,col,i;
int no = 0;
unsigned char *yuvbuf,*pt;

   if((fp = fopen("D:\\test-1278x958.yuv","rb")) == NULL)
      return;

   w = 1278;
   h = 958;
   iw = imCCD->Width;
   ih = imCCD->Height;
   usb_ImageROIAry[no].Detach();
   usb_ImageAry[no].SetSize(w,h);
   usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
   usb_ImageROIAry[no].SetPlacement((w-iw)/2,(h-ih)/2,iw,ih);
   yuvbuf = NULL;
   yuvbuf = (unsigned char*) malloc(w*h*2);
   i = 0;
   for(int row=0 ; row<h ; row++) {
      fread((void *)&yuvbuf[i],1,w*2,fp);
      i += (w*2);
   }
   fclose(fp);

   int width,height;
   width = w;
   height = h;
   unsigned char* pYUV;
   pYUV = yuvbuf;
   const long len = width * height;
   unsigned char* yData = pYUV;

   unsigned char* vData = &yData[len];
   unsigned char* uData = &vData[len >> 2];
   //unsigned char* uData = &yData[len];
   //unsigned char* vData = &uData[len >> 2];

   int bgr[3];
   int yIdx,uIdx,vIdx,idx;

   /*
   // Y0,Y1,Y2....,U0,U1...,V0,V1...
   yIdx = 0;
   vIdx = 0;
   uIdx = 0;
   for(int i=0 ; i<height ; i++) {
      pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,i);
      for(int j=0 ; j<width ; j++) {

         bgr[0] = (int)(yData[yIdx] + 1.732446 * (uData[vIdx] - 128));                                    // b分量
         bgr[1] = (int)(yData[yIdx] - 0.698001 * (uData[uIdx] - 128) - 0.703125 * (vData[vIdx] - 128));   // g分量
         bgr[2] = (int)(yData[yIdx] + 1.370705 * (vData[uIdx] - 128));                                    // r分量

         for(int k=0 ; k<3 ; k++) {
            idx = j * 3 + k;
            if(bgr[k] >= 0 && bgr[k] <= 255)
               pt[idx] = bgr[k];
            else {
               if(bgr[k] < 0)
                  pt[idx] = 0;
               else if(bgr[k] > 255)
                  pt[idx] = 255;
            }
         }

         yIdx++;
         if((j % 2) != 0) {
            uIdx++;
            vIdx++;
         }
      }
   }
   */

   long StartTime,StopTime,Elapsedms1,Elapsedms2;
   short StartTick,StopTick;
   GetTimeTic(&StartTime,&StartTick);
   for(int loop=0 ; loop<10 ; loop++) {

   // Nature: 123.5ms
   //
   // Y0,U0,Y1,V0
   int y0,u0,y1,v0,pdx;
   for(int i=0 ; i<height ; i++) {
      pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,i);
      idx = i*(width * 2);
      pdx = 0;
      // 4bytes => 2Pixel
      for(int j=0 ; j<width*2 ; j+=4) {
         u0 = yuvbuf[idx++];
         y0 = yuvbuf[idx++];
         v0 = yuvbuf[idx++];
         y1 = yuvbuf[idx++];

         // p1
         bgr[0] = (int)(y0 + 1.732446 * (u0 - 128));                                    // b 分量
         bgr[1] = (int)(y0 - 0.698001 * (u0 - 128) - 0.703125 * (v0 - 128));            // g 分量
         bgr[2] = (int)(y0 + 1.370705 * (v0 - 128));                                    // r 分量
         for(int k=0 ; k<3 ; k++) {
            if(bgr[k] >= 0 && bgr[k] <= 255)
               pt[pdx++] = bgr[k];
            else
               pt[pdx++] = (bgr[k] < 0)?0:255;
         }
         // p2
         bgr[0] = (int)(y1 + 1.732446 * (u0 - 128));                                    // b 分量
         bgr[1] = (int)(y1 - 0.698001 * (u0 - 128) - 0.703125 * (v0 - 128));            // g 分量
         bgr[2] = (int)(y1 + 1.370705 * (v0 - 128));                                    // r 分量
         for(int k=0 ; k<3 ; k++) {
            if(bgr[k] >= 0 && bgr[k] <= 255)
               pt[pdx++] = bgr[k];
            else
               pt[pdx++] = (bgr[k] < 0)?0:255;
         }
      }
   }

   }
   GetTimeTic(&StopTime,&StopTick);
   Elapsedms1 = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
   GetTimeTic(&StartTime,&StartTick);
   for(int loop=0 ; loop<10 ; loop++) {

   //
   // Table: 25.0ms
   // Y0,U0,Y1,V0
   int y0,u0,y1,v0,pdx;
   int rdif,invgdif,bdif,w2,vr,vg,vb;
   w2 = width * 2;
   for(int i=0 ; i<height ; i++) {
      pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,i);
      idx = i * w2;
      pdx = 0;
      // 4bytes => 2Pixel
      for(int j=0 ; j<w2 ; j+=4) {
         u0 = yuvbuf[idx++];
         y0 = yuvbuf[idx++];
         v0 = yuvbuf[idx++];
         y1 = yuvbuf[idx++];

         rdif = Table_fv1[v0];
         invgdif = Table_fu1[u0] + Table_fv2[v0];
         bdif = Table_fu2[u0];

         // p1
         vb = y0 + bdif;
         vg = y0 - invgdif;
         vr = y0 + rdif;
         // BGR
         if(vb < 0)
            vb = 0;
         else if(vb > 255)
            vb = 255;
         pt[pdx++] = vb;
         if(vg < 0)
            vg = 0;
         else if(vg > 255)
            vg = 255;
         pt[pdx++] = vg;
         if(vr < 0)
            vr = 0;
         else if(vr > 255)
            vr = 255;
         pt[pdx++] = vr;
         // p2
         vb = y1 + bdif;
         vg = y1 - invgdif;
         vr = y1 + rdif;
         // BGR
         if(vb < 0)
            vb = 0;
         else if(vb > 255)
            vb = 255;
         pt[pdx++] = vb;
         if(vg < 0)
            vg = 0;
         else if(vg > 255)
            vg = 255;
         pt[pdx++] = vg;
         if(vr < 0)
            vr = 0;
         else if(vr > 255)
            vr = 255;
         pt[pdx++] = vr;
      }
   }

   }
   GetTimeTic(&StopTime,&StopTick);
   Elapsedms2 = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
   AnsiString str;
   str.sprintf("Nature: %d, Table: %d",Elapsedms1,Elapsedms2);
   pnlSystemMessage->Caption = str;

   int sx,sy,x,y;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - iw) / 2;
   //sy = (height - ih) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   GetImageXY(width,height,sx,sy,iw,ih,&x,&y);
   usb_ImageROIAry[no].SetPlacement(x,y,iw,ih);
   usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
   // 若沒有Refresh就不會顯示
   imCCD->Refresh();
   free(yuvbuf);
}
//---------------------------------------------------------------------------
/*
m_imgsize = w * h;
m_framesize = m_imgsize + (m_imgSize >> 1)

unsigned char *cTemp[3];
cTemp[0] = m_yuv + n;					// y
cTemp[1] = cTemp[0] + m_imgSize;			// u
cTemp[2] = cTemp[1] + (m_imgSize >> 1);			// v

R = y + 1.4022 * (v - 128);
G = y - 0.3456*(u-128) - 0.7145 * (v - 128);
B = y + 1.771 * (u - 128);
*/
// 2016 4 17 - chc 移動Center Pattern區
bool boolCenterMove = false;
int CenterX,CenterY;
void __fastcall TMainForm::shCenterMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterMove = true;
   CenterX = X;
   CenterY = Y;
}
//---------------------------------------------------------------------------
// 2016 4 17 - chc 移動Center Pattern區
void __fastcall TMainForm::shCenterMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height;

   // 移動中
   if(boolCenterMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      dx = X - CenterX;
      dy = Y - CenterY;
      x1 = shCenter->Left + dx;
      y1 = shCenter->Top + dy;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      if(x1 < 0) {
         x1 = 0;
         x2 = x1 + shCenter->Width - 1;
      }
      if(y1 < 0) {
         y1 = 0;
         y2 = y1 + shCenter->Height - 1;
      }
      if(x2 >= width) {
         x2 = width - 1;
         x1 = x2 - shCenter->Width + 1;
      }
      if(y2 >= height) {
         y2 = height - 1;
         y1 = y2 - shCenter->Height + 1;
      }
      shCenter->Left = x1;
      shCenter->Top = y1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc 移動Center Pattern區
void __fastcall TMainForm::shCenterMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 17 - chc 移動Center Pattern區
void __fastcall TMainForm::UpdateCenterDotPosition()
{
int x1,y1,x2,y2,w,h,cx,cy;

   x1 = shCenter->Left;
   y1 = shCenter->Top;
   x2 = shCenter->Left + shCenter->Width;
   y2 = shCenter->Top + shCenter->Height;
   // 設定各調整點位置
   cx = (x1+x2) / 2;
   cy = (y1+y2) / 2;
   w = shLeft->Width;
   h = shLeft->Height;
   // 左
   shLeft->Left = x1 - w;
   shLeft->Top = cy - h/2;
   // 左上
   shLeftUp->Left = x1 - w;
   shLeftUp->Top = y1 - h;
   // 左下
   shLeftDown->Left = x1 - w;
   shLeftDown->Top = y2;
   // 右
   shRight->Left = x2;
   shRight->Top = cy - h/2;
   // 右上
   shRightUp->Left = x2;
   shRightUp->Top = y1 - h;
   // 右下
   shRightDown->Left = x2;
   shRightDown->Top = y2;
   // 上
   shUp->Left = cx - w/2;
   shUp->Top = y1 - h;
   // 下
   shDown->Left = cx - w/2;
   shDown->Top = y2;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc LeftUp移動
bool boolCenterLeftUpMove = false;
int CenterLeftUpX,CenterLeftUpY;
void __fastcall TMainForm::shLeftUpMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftUpMove = true;
   CenterLeftUpX = X;
   CenterLeftUpY = Y;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc LeftUp移動
void __fastcall TMainForm::shLeftUpMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterLeftUpMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterLeftUpX;
      dy = Y - CenterLeftUpY;
      if((x2 - (x1+dx)) >= minx) {
         x1 += dx;
      }
      if((y2 - (y1+dy)) >= miny) {
         y1 += dy;
      }
      if(x1 < 0)
         x1 = 0;
      if(y1 < 0)
         y1 = 0;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc LeftUp移動
void __fastcall TMainForm::shLeftUpMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftUpMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Left移動
bool boolCenterLeftMove = false;
int CenterLeftX,CenterLeftY;

// 2016 5 13 - chc 漏掉
void __fastcall TMainForm::shLeftMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftMove = true;
   CenterLeftX = X;
   CenterLeftY = Y;
}

//---------------------------------------------------------------------------
// 2016 4 17 chc Left移動
void __fastcall TMainForm::shLeftMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterLeftMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterLeftX;
      if((x2 - (x1+dx)) >= minx) {
         x1 += dx;
      }
      if(x1 < 0)
         x1 = 0;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Left移動
void __fastcall TMainForm::shLeftMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc LeftDown移動
bool boolCenterLeftDownMove = false;
int CenterLeftDownX,CenterLeftDownY;
void __fastcall TMainForm::shLeftDownMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftDownMove = true;
   CenterLeftDownX = X;
   CenterLeftDownY = Y;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc LeftDown移動
void __fastcall TMainForm::shLeftDownMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterLeftDownMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterLeftUpX;
      dy = Y - CenterLeftUpY;
      if((x2 - (x1+dx)) >= minx) {
         x1 += dx;
      }
      if(((y2+dy) - y1) >= miny) {
         y2 += dy;
      }
      if(x1 < 0)
         x1 = 0;
      if(y2 >= height)
         y2 = height - 1;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc LeftDown移動
void __fastcall TMainForm::shLeftDownMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftDownMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Up移動
bool boolCenterUpMove = false;
int CenterUpX,CenterUpY;
void __fastcall TMainForm::shUpMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterUpMove = true;
   CenterUpX = X;
   CenterUpY = Y;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Up移動
void __fastcall TMainForm::shUpMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterUpMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dy = Y - CenterUpY;
      if((y2 - (y1+dy)) >= miny) {
         y1 += dy;
      }
      if(y1 < 0)
         y1 = 0;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Up移動
void __fastcall TMainForm::shUpMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterUpMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Down移動
bool boolCenterDownMove = false;
int CenterDownX,CenterDownY;
void __fastcall TMainForm::shDownMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterDownMove = true;
   CenterDownX = X;
   CenterDownY = Y;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Down移動
void __fastcall TMainForm::shDownMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterDownMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dy = Y - CenterDownY;
      if(((y2+dy) - y1) >= miny) {
         y2 += dy;
      }
      if(y2 >= height)
         y2 = height - 1;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Down移動
void __fastcall TMainForm::shDownMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterDownMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc RightUp移動
bool boolCenterRightUpMove = false;
int CenterRightUpX,CenterRightUpY;
void __fastcall TMainForm::shRightUpMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightUpMove = true;
   CenterRightUpX = X;
   CenterRightUpY = Y;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc RightUp移動
void __fastcall TMainForm::shRightUpMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterRightUpMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterRightUpX;
      dy = Y - CenterRightUpY;
      if(((x2+dx) - x1) >= minx) {
         x2 += dx;
      }
      if((y2 - (y1+dy)) >= miny) {
         y1 += dy;
      }
      if(x2 >= width)
         x2 = width - 1;
      if(y1 < 0)
         y1 = 0;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc RightUp移動
void __fastcall TMainForm::shRightUpMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightUpMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Right移動
bool boolCenterRightMove = false;
int CenterRightX,CenterRightY;
void __fastcall TMainForm::shRightMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightMove = true;
   CenterRightX = X;
   CenterRightY = Y;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Right移動
void __fastcall TMainForm::shRightMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterRightMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterRightX;
      if(((x2+dx) - x1) >= minx) {
         x2 += dx;
      }
      if(x2 >= width)
         x2 = width - 1;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc Right移動
void __fastcall TMainForm::shRightMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc RightDown移動
bool boolCenterRightDownMove = false;
int CenterRightDownX,CenterRightDownY;
void __fastcall TMainForm::shRightDownMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightDownMove = true;
   CenterRightDownX = X;
   CenterRightDownY = Y;
}
//---------------------------------------------------------------------------
// 2016 4 17 chc RightDown移動
void __fastcall TMainForm::shRightDownMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterRightDownMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterRightDownX;
      dy = Y - CenterRightDownY;
      if(((x2+dx) - x1) >= minx) {
         x2 += dx;
      }
      if(((y2+dy) - y1) >= miny) {
         y2 += dy;
      }
      if(x2 >= width)
         x2 = width - 1;
      if(y2 >= height)
         y2 = height - 1;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 chc RightDown移動
void __fastcall TMainForm::shRightDownMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightDownMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 16 - chc Standard Pattern
void __fastcall TMainForm::cbStdPatternClick(TObject *Sender)
{

   shCenter->Visible = cbStdPattern->Checked;
   shLeft->Visible = cbStdPattern->Checked;
   shRight->Visible = cbStdPattern->Checked;
   shUp->Visible = cbStdPattern->Checked;
   shDown->Visible = cbStdPattern->Checked;
   shLeftUp->Visible = cbStdPattern->Checked;
   shLeftDown->Visible = cbStdPattern->Checked;
   shRightUp->Visible = cbStdPattern->Checked;
   shRightDown->Visible = cbStdPattern->Checked;
   if(cbStdPattern->Checked == true) {
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 2016 4 17 - chc 顯示中心線
void __fastcall TMainForm::cbRulerClick(TObject *Sender)
{

   // 畫出New尺規: imGrid
   DrawRuler();
}
//---------------------------------------------------------------------------
// 2016 4 17 - chc 格線種類
void __fastcall TMainForm::rgRulerTypeClick(TObject *Sender)
{

   // 畫出New尺規: imGrid
   DrawRuler();
}
//---------------------------------------------------------------------------
// 2016 4 17 - chc 畫出New尺規: imGrid
void __fastcall TMainForm::DrawRuler()
{
int index,width,height,dy,dx,y,no,x,cx,cy;
int d = 10;

   index = rgRulerType->ItemIndex;

   // 2016 6 4 - chc Log
   WriteSystemLog("DrawRuler()");

   width = imCCD->Width;
   height = imCCD->Height;
   cx = width / 2;
   cy = height / 2;

   TColor color,color1;
   TShape* shape;
   switch(rgRulerColor->ItemIndex) {
      case 0:
         color = clRed;
         color1 = clLime;
         break;
      case 1:
         color = clBlue;
         color1 = clYellow;
         break;
      case 2:
         color = clLime;
         color1 = clRed;
         break;
      case 3:
         color = clBlack;
         color1 = clWhite;
         break;
      case 4:
         color = clWhite;
         color1 = clBlack;
         break;
      case 5:
         color = clYellow;
         color1 = clBlue;
         break;
      case 6:
         color = clFuchsia;
         color1 = clLime;
         break;
   }
   switch(index) {
      // 十字線
      case 0:
         shHorizontal->Pen->Color = color;
         shHorizontal->Visible = true;
         shVertical->Pen->Color = color;
         shVertical->Visible = true;
         // 取消網格
         for(int i=0 ; i<16 ; i++) {
            shape = (TShape*)(FindComponent("shHorizontalUp" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shHorizontalDown" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalLeft" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalRight" + IntToStr(i+1)));
            shape->Visible = false;
         }
         // 取消中心
         for(int i=0 ; i<8 ; i++) {
            shape = (TShape*)(FindComponent("shCenter" + IntToStr(i+1)));
            shape->Visible = false;
         }
         break;
      // 網格
      case 1:
         shHorizontal->Pen->Color = color1;
         shVertical->Pen->Color = color1;
         shHorizontal->Visible = true;
         shVertical->Visible = true;

         // 顯示網格
         dy = edGridPixel->Text.ToInt();
         if(dy < 40)
            dy = 40;
         y = height / 2;
         no = 1;
         while(y > no*dy) {
            shape = (TShape*)(FindComponent("shHorizontalUp" + IntToStr(no)));
            shape->Pen->Color = color;
            shape->Top = shHorizontal->Top - dy * no;
            shape->Width = shHorizontal->Width;
            shape->Visible = true;
            shape = (TShape*)(FindComponent("shHorizontalDown" + IntToStr(no)));
            shape->Pen->Color = color;
            shape->Top = shHorizontal->Top + dy * no;
            shape->Width = shHorizontal->Width;
            shape->Visible = true;
            no++;
            if(no > 16)
               break;
         }
         dx = edGridPixel->Text.ToInt();
         if(dx < 40)
            dx = 40;
         x = width / 2;
         no = 1;
         while(x > no*dx) {
            shape = (TShape*)(FindComponent("shVerticalLeft" + IntToStr(no)));
            shape->Pen->Color = color;
            shape->Left = shVertical->Left - dx * no;
            shape->Height = shVertical->Height;
            shape->Visible = true;
            shape = (TShape*)(FindComponent("shVerticalRight" + IntToStr(no)));
            shape->Pen->Color = color;
            shape->Left = shVertical->Left + dx * no;
            shape->Height = shVertical->Height;
            shape->Visible = true;
            no++;
            if(no > 16)
               break;
         }
         for(int i=no ; i<=16 ; i++) {
            shape = (TShape*)(FindComponent("shVerticalLeft" + IntToStr(i)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalRight" + IntToStr(i)));
            shape->Visible = false;
         }

         // 取消中心
         for(int i=0 ; i<8 ; i++) {
            shape = (TShape*)(FindComponent("shCenter" + IntToStr(i+1)));
            shape->Visible = false;
         }
         break;
      // 一字線
      case 2:
         shHorizontal->Pen->Color = color;
         shHorizontal->Visible = true;
         shVertical->Visible = false;
         // 取消網格
         for(int i=0 ; i<16 ; i++) {
            shape = (TShape*)(FindComponent("shHorizontalUp" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shHorizontalDown" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalLeft" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalRight" + IntToStr(i+1)));
            shape->Visible = false;
         }
         // 取消中心
         for(int i=0 ; i<8 ; i++) {
            shape = (TShape*)(FindComponent("shCenter" + IntToStr(i+1)));
            shape->Visible = false;
         }
         break;
      // 十字線 + 中心
      case 3:
         shHorizontal->Pen->Color = color;
         shHorizontal->Visible = true;
         shVertical->Pen->Color = color;
         shVertical->Visible = true;
         // 取消網格
         for(int i=0 ; i<16 ; i++) {
            shape = (TShape*)(FindComponent("shHorizontalUp" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shHorizontalDown" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalLeft" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalRight" + IntToStr(i+1)));
            shape->Visible = false;
         }
         // 顯示中心
         for(int i=0 ; i<8 ; i++) {
            shape = (TShape*)(FindComponent("shCenter" + IntToStr(i+1)));
            shape->Pen->Color = color;
            shape->Visible = true;
         }
         break;
      // None
      case 4:
         shHorizontal->Visible = false;
         shVertical->Visible = false;
         // 取消網格
         for(int i=0 ; i<16 ; i++) {
            shape = (TShape*)(FindComponent("shHorizontalUp" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shHorizontalDown" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalLeft" + IntToStr(i+1)));
            shape->Visible = false;
            shape = (TShape*)(FindComponent("shVerticalRight" + IntToStr(i+1)));
            shape->Visible = false;
         }
         // 取消中心
         for(int i=0 ; i<8 ; i++) {
            shape = (TShape*)(FindComponent("shCenter" + IntToStr(i+1)));
            shape->Visible = false;
         }
         break;
   }

}
//---------------------------------------------------------------------------
// 2016 4 17 - chc 選則格線顏色
void __fastcall TMainForm::rgRulerColorClick(TObject *Sender)
{

   // 畫出New尺規: imGrid
   DrawRuler();
   return;
}
//---------------------------------------------------------------------------
// 2016 4 17 - chc NCC
// iVisitingKeyPro or iGetKeyProState
bool __fastcall TMainForm::CheckNCCMatch()
{
char* VersionStr;
char* VersionDateStr;

   VersionStr = iGetiImageVersion();
   VersionDateStr = iGetiMatchVersionDate();

   // iMatchModel Keypro
   E_iVision_ERRORS Err = E_NULL;
   // E_TRUE or E_FALSE
   // iGetKeyProState(E_TRUE/E_FALSE)不對! 改用iVisitingKeyPro(E_OK1)
   // 2019 7 19 - chc 改用iVisitingKey()
   //Err = iVisitingKeyPro(iMatchModel);
   Err = iVisitingKey();

   // iGetKeyProState(E_TRUE/E_FALSE)不對! 改用iVisitingKeyPro(E_OK1)
   //if(Err != E_TRUE)
   // ###
   if(Err != E__OK)
      return false;
   return true;
}
//---------------------------------------------------------------------------
// 2016 11 15 - chc 原點(Match的左上角)
int OX,OY;

// 2016 11 16 - chc 也要記錄當時Table位置, 否則切換Pattern時會錯: 先回原位置再作動
I32 OTableX,OTableY;

// 2016 4 17 - chc 北科大
int DetectNums;
int DontcareThreshold;
int MinReduceArea;
bool Rotated,Scaled,UsingDoncare;
double MinScore,MaxAngle,MinAngle,MaxScale,MinScale;
bool UsingColor;
bool LoadColor;
E_iVision_ERRORS NCCError;
char *NCCStr;
NCCFind FindObj;
//typedef struct
//{
//	int    Width;
//	int    Height;
//	double CX;
//	double CY;
//	double Angle;
//	double Scale;
//	double Score;
//}NCCFind;
// 2016 11 13 - chc 由內到外搜尋: sno為單邊Pattern數量, 固範圍為sno*PatternWidth,sno*PatternHeight
//bool __fastcall TMainForm::DoNCCMatch()
// 2019 7 19 - chc 加入patternfname
//bool __fastcall TMainForm::DoNCCMatch(int sno,int stdwidth,int stdheight)
bool __fastcall TMainForm::DoNCCMatch(int sno,int stdwidth,int stdheight, AnsiString patternfname)

{
// 記錄是否做過Match的前作業 - 改成Global
static boolfirst = false;
static int w,h,iw,ih;
int row,col,no,x,y,x1,y1,x2,y2;
AnsiString learnfname,tmp;
int matchno, selectno;
double score;
unsigned char *ptr1,*ptr2;

// 2019 12 4 - chc 若分數低於0.7 則再做一次
bool boolfirstdo = true;

   WriteSystemLog("DoNCCMatch: Enter...");

   // NCC 設定初值, 可指定數量
   DetectNums = cbMatchNo->Text.ToInt();
   DontcareThreshold = 0;
   Rotated = true;
   Scaled = false;
   UsingDoncare = false;
   MinScore = edMinScore->Text.ToDouble();
   MaxAngle = 10;
   MinAngle = -10;
   MaxScale = 1.1;
   MinScale = 0.9;
   UsingColor = true;
   LoadColor = false;
   MinReduceArea = 64;

// 2019 12 4 - chc 若分數低於0.7 則再做一次
again:

   shMarkMatch->Visible = false;
   WriteSystemLog("DoNCCMatch: Enter...1");

   // ----------------------------------------------------------------------------
   // 以原始影像處理
   // 來源: usb_ImageAry[no], usb_ImageROIAry[no]
   no = rgCCDSelect->ItemIndex;
   // 固定為0
   no = 0;
   if(boolfirst == false) {
      // BW : scA1300ImageAry
      if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
         ProcessImage.SetSize(&scA1300ImageAry[no]);
         w = scA1300ImageAry[no].GetWidth();
         h = scA1300ImageAry[no].GetHeight();
      }
      else {
         ProcessImage.SetSize(&usb_ImageAry[no]);
         w = usb_ImageAry[no].GetWidth();
         h = usb_ImageAry[no].GetHeight();
      }
      iw = imCCD->Width;
      ih = imCCD->Height;
   }

   WriteSystemLog("DoNCCMatch: SetSize.");
   // Image => ProcessImage
   for(row=0 ; row<h ; row++) {
      // BW : scA1300ImageAry
      if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
         ptr1 = (unsigned char *)scA1300ImageAry[no].GetImagePtr(0,row);
         ptr2 = (unsigned char *)ProcessImage.GetImagePtr(0,row);
         memcpy(ptr2,ptr1,w);
      }
      else {
         ptr1 = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
         ptr2 = (unsigned char *)ProcessImage.GetImagePtr(0,row);
         memcpy(ptr2,ptr1,w*3);
      }
   }

   WriteSystemLog("DoNCCMatch: Captured.");
   // 搜尋區域: (x1,y1) - (x2,y2)
   // LaserCenter X/Y
   // => Lasr Cneter: 固定為80,35
   x1 = LaserCenterX;
   y1 = LaserCenterY;

   int cx,cy;
   // 目前Laser Center所在位置
   // 對NCC來說, 目前畫面的影像區域是由(LaserCenterX,LaserCenterY)起算
   cx = (shVertical->Left-imCCD->Left + x1);
   cy = (shHorizontal->Top-imCCD->Top + y1);

   // 要Match的影像區域(相對CCD視野)
   // 記錄起點: 只看十字中心位置
   x1 = cx - imCCD->Width/2 + 10;
   y1 = cy - imCCD->Height/2 + 10;
   x2 = cx + imCCD->Width/2 - 10;
   y2 = cy + imCCD->Height/2 - 10;
   OX = LaserCenterX + 10;
   OY = LaserCenterY + 10;
   tmp.sprintf("DoNCCMatch: (x1,y1,x2,y2,OX,OY) = (%d,%d,%d,%d,%d,%d)",x1,y1,x2,y2,OX,OY);
   WriteSystemLog(tmp);

   // 也要記錄當時Table位置, 否則切換Pattern時會錯: 先回原位置再作動
   // => ?
   GetCommand(X_AXIS, &OTableX);
   GetCommand(Y_AXIS, &OTableY);

   // NCC, 設定GrayImg & 取得影像Data: x1,y1,W:(x2-x1),H:(y2-y1)
   MatchImageROI.Detach();
   MatchImageROI.Attach(&ProcessImage);
   MatchImageROI.SetPlacement(x1,y1,(x2-x1+1),(y2-y1+1));                        // X,Y,Width,Height
   AnsiString imgfilename;

   // BW : scA1300ImageAry
   if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
      imgfilename = SystemDirectory + "\\GrayImg.bmp";
      MatchImageROI.Save(imgfilename.c_str(),E_FILE_FORMAT_GRAY_LEVEL_BMP);
      WriteSystemLog("DoNCCMatch: Save GrayImg.bmp.");
      NCCError = iReadImage(GrayImg,imgfilename.c_str());
      WriteSystemLog("DoNCCMatch: Read GrayImg.bmp. " + IntToStr(NCCError));
   }
   else {
      imgfilename = SystemDirectory + "\\ColorImg.bmp";
      MatchImageROI.Save(imgfilename.c_str(),E_FILE_FORMAT_COLOR_BMP);
      WriteSystemLog("DoNCCMatch: Save ColorImg.bmp.");
      NCCError = iReadImage(ColorImg,imgfilename.c_str());
      WriteSystemLog("DoNCCMatch: Read ColorImg.bmp. " + IntToStr(NCCError));
   }

   NCCStr = iGetErrorText(NCCError);
   pnlSystemMessage->Caption = NCCStr;
   // ###
   if(NCCError != E__OK) {
      WriteSystemLog("DoNCCMatch: Read ColorImg.bmp Fail!");
      pnlSystemMessage->Caption = (AnsiString)NCCStr + "-ILoad";
      return false;
   }

   // Match的時間
   GetTimeTic(&NCCStartTime,&NCCStartTick);
   if(boolfirst == false) {
      if(CheckNCCMatch() == false) {
         pnlSystemMessage->Caption = "NCC Dongle Not Exist!";
         WriteSystemLog("DoNCCMatch: NCC dongle NotExist!");
         return false;
      }
      boolfirst = true;
      // 設定參數
      iSetAngle(iMatchModel,MaxAngle,MinAngle);
      iSetScale(iMatchModel,MaxScale,MinScale);

      // Minscore & DefectNums Must set each time
      //iSetMinScore(iMatchModel,MinScore);
      //iSetOccurrence(iMatchModel,DetectNums);

      iSetMinReduceArea(iMatchModel,MinReduceArea);
      iSetIsRotated(iMatchModel,Rotated);
      iSetIsScaled(iMatchModel,Scaled);
      if(iIsColorModel(iMatchModel) == E_TRUE)
         UsingColor = true;
      else
         UsingColor = false;
      WriteSystemLog("DoNCCMatch: Set Parameter.");
   }

   // Minscore & DefectNums Must set each time
   iSetMinScore(iMatchModel,MinScore);
   iSetOccurrence(iMatchModel,DetectNums);
   WriteSystemLog("DoNCCMatch: Set Score, Occurrence.");

   // Learn Std: 已在呼叫前載入: patternfname
   //learnfname = RecipeDirectory + "\\" + RecipeName + "\\" + RecipeName + "-p.bmp";
   //if(!FileExists(learnfname)) {
   //   pnlSystemMessage->Caption = "Pattern File Not Exist! " + learnfname;
   //   return false;
   //}
   //StdImage.Load(learnfname.c_str());
   learnfname = patternfname;

   // BW : scA1300ImageAry
   if(CCDInfoAry[no].Type == BASLER_CCD_BW)
      NCCError = iReadImage(GrayLearnImg,learnfname.c_str());
   else
      NCCError = iReadImage(ColorLearnImg,learnfname.c_str());
   NCCStr = iGetErrorText(NCCError);
   pnlSystemMessage->Caption = NCCStr;
   // ###
   if(NCCError != E__OK) {
      pnlSystemMessage->Caption = (AnsiString)NCCStr + "-LLoad!";
      WriteSystemLog("DoNCCMatch: iReadImage Error!");
      return false;
   }
   WriteSystemLog("DoNCCMatch: Read Pattern.");

   LoadColor = true;
   iSetDontCareThreshold(iMatchModel, DontcareThreshold);

   if(CCDInfoAry[no].Type == BASLER_CCD_BW)
      NCCError = CreateNCCModel(GrayLearnImg,iMatchModel,UsingDoncare);
   else
      NCCError = CreateNCCModel(ColorLearnImg,iMatchModel,UsingDoncare);

   // ###
   if(NCCError != E__OK) {
      NCCStr = iGetErrorText(NCCError);
      pnlSystemMessage->Caption = (AnsiString)NCCStr + "-Learn!";
      WriteSystemLog("DoNCCMatch: CreateNCCModel Error!");
      return false;
   }
   WriteSystemLog("DoNCCMatch: CreateNCCModel.");

   if(CCDInfoAry[no].Type == BASLER_CCD_BW)
      NCCError = MatchNCCModel(GrayImg,iMatchModel);
   else
      NCCError = MatchNCCModel(ColorImg,iMatchModel);
   WriteSystemLog("DoNCCMatch: MatchNCCModel.");

   // ###
   if(NCCError != E__OK) {
      NCCStr = iGetErrorText(NCCError);
      pnlSystemMessage->Caption = (AnsiString)NCCStr + "Match!";
      matchno = 0;
      WriteSystemLog("DoNCCMatch: MatchNCCModel Fail!");
      return false;
   }
   else {
      iGetNCCMatchNum(iMatchModel,&matchno);
      WriteSystemLog("DoNCCMatch: MatchNCCModel ok= " + IntToStr(matchno));
   }
   // Update Matched No
   pnlMatchedNo->Caption = IntToStr(matchno);

   // 失敗
   if(matchno < 1) {
      pnlSystemMessage->Caption = "Match Fail!";
      WriteSystemLog("DoNCCMatch: Match Fail!");
      return false;
   }
   GetTimeTic(&NCCStopTime,&NCCStopTick);
   NCCElapsedms = ((NCCStopTime*1000+NCCStopTick) - (NCCStartTime*1000+NCCStartTick));
   pnlSystemMessage->Caption = "Match Success. " + IntToStr(NCCElapsedms) + "ms";

   // 2016 11 9 - chc Sort Mode of Matched : maxno: 10
   // sort by near
   // AddsgResult(index,FindObj.Width,FindObj.Height,FindObj.CX,FindObj.CY,FindObj.Angle,FindObj.Scale,FindObj.Score);
   // void __fastcall TMainForm::AddsgResult(int index, int width, int height, int cx, int cy, double angle, double scale, double score)
   struct SORT_STRU     {
      double Score;
      double Distance;
      int Index;
      bool Selected;
      bool Done;
   };
   struct SORT_STRU     sortbuffer[15];
   int sx,sy,selno,sortedno,ino;
   double dx,dy,minscore,mindistance;

   // 2019 7 19 - chc 不需要: for PD Apple, 固定為Sort
   rgSortMode->ItemIndex = 0;

   // Near
   if(rgSortMode->ItemIndex == 1) {
      sx = shVertical->Left - imCCD->Left;
      sy = shHorizontal->Top - imCCD->Top;
      minscore = edScore->Text.ToDouble();
      selno = 0;
      // Get all matched information
      for(int i=0 ; i<matchno ; i++) {
         iGetNCCMatchResults(iMatchModel,i,&FindObj);
         sortbuffer[i].Score = FindObj.Score;

         // 2016 11 15 - chc 要校正
         //dx = sx - FindObj.CX;
         //dy = sy - FindObj.CY;
         dx = sx - (FindObj.CX + OX);
         dy = sy - (FindObj.CY + OY);

         sortbuffer[i].Distance = sqrt(dx*dx + dy*dy);
         if(sortbuffer[i].Score >= minscore) {
            sortbuffer[i].Selected = true;
            selno++;
         }
         else
            sortbuffer[i].Selected = false;
         sortbuffer[i].Index = -1;
         sortbuffer[i].Done = false;
      }
      if(selno == 0)
         goto sortbyscore;
      sortedno = 0;
      for(int j=0 ; j<selno ; j++) {
         mindistance = 100000;
         ino = -1;
         for(int i=0 ; i<matchno ; i++) {
            if(sortbuffer[i].Selected == true && sortbuffer[i].Done == false && sortbuffer[i].Distance < mindistance) {
               mindistance = sortbuffer[i].Distance;
               ino = i;
            }
         }
         if(ino != -1) {
            sortbuffer[ino].Done = true;
            sortbuffer[ino].Index = sortedno;
            sortedno++;
            if(sortedno >= selno)
               break;
         }
         else
            break;
      }
      // Add Selected: Done and sort by Index
      for(int j=0 ; j<sortedno ; j++) {
         for(int i=0 ; i<matchno ; i++) {
            if(sortbuffer[i].Done == true && sortbuffer[i].Index == j) {
               iGetNCCMatchResults(iMatchModel,i,&FindObj);
               AddMatchData(i+1);
               // Display first one: same as sort by score
               if(j == 0) {
                  // 存角度值
                  MarkAngle = FindObj.Angle;

                  // 2016 11 15 - chc 要校正
                  //x = FindObj.CX;
                  //y = FindObj.CY;
                  x = FindObj.CX + OX;
                  y = FindObj.CY + OY;

                  // 存到Global
                  MarkCenterX = x;
                  MarkCenterY = y;
                  score = FindObj.Score;
                  tmp.sprintf("%.3f",score);
                  pnlScore->Caption = tmp;
                  // 指向
                  shMarkMatch->Width = StdImage.GetWidth();
                  shMarkMatch->Height = StdImage.GetHeight();

                  // 對NCC來說, 目前畫面的影像區域是由(LaserCenterX,LaserCenterY)起算
                  // 2019 7 22 - chc 要減LaserCenter
                  //shMarkMatch->Top = y + imCCD->Top - shMarkMatch->Height/2;
                  //shMarkMatch->Left = x + imCCD->Left - shMarkMatch->Width/2;
                  shMarkMatch->Top = y + imCCD->Top - shMarkMatch->Height/2 - LaserCenterY;
                  shMarkMatch->Left = x + imCCD->Left - shMarkMatch->Width/2 - LaserCenterX;

                  shMarkMatch->Visible = true;
                  pnlNCC->Color = clLime;
                  pnlNCC1->Color = clLime;
                  // 加入角度值
                  tmp.sprintf("%.3f",FindObj.Angle);
                  pnlRotateAngle->Caption = tmp;
               }
               break;
            }
         }
      }
      // Add Non-Selcted
      for(int i=0 ; i<matchno ; i++) {
         if(sortbuffer[i].Done == false) {
            iGetNCCMatchResults(iMatchModel,i,&FindObj);
            AddMatchData(i+1);
         }
      }
      return true;
   }
sortbyscore:

   // 2016 5 26 - chc 可設多個
   //selectno = 0;                                                                // 取第一個Match者
   // 2019 7 19 - chc 不需要: for PD Apple, 只找一個
   //for(selectno=0 ; selectno<matchno ; selectno++) {
   for(selectno=0 ; selectno<1 ; selectno++) {

      iGetNCCMatchResults(iMatchModel,selectno,&FindObj);

      // 2016 5 26 - chc 加入記錄, 但只顯示第1個
      // 2019 7 19 - chc 不需要: for PD Apple, 不加入
      //AddMatchData(selectno+1);

      if(selectno > 0)
         continue;

      // 2016 5 30 - chc 存角度值
      MarkAngle = FindObj.Angle;

      x = FindObj.CX;
      y = FindObj.CY;

      // 2016 11 15 - chc 校正: OX = LaserCenterX + 10, OY = LaserCenterY + 10
      x += OX;
      y += OY;

      // 存到Global: 原始1280*960影像區
      MarkCenterX = x;
      MarkCenterY = y;

      score = FindObj.Score;
      tmp.sprintf("%.3f",score);
      pnlScore->Caption = tmp;
      // 指向
      shMarkMatch->Width = StdImage.GetWidth();
      shMarkMatch->Height = StdImage.GetHeight();

      // 對NCC來說, 目前畫面的影像區域是由(LaserCenterX,LaserCenterY)起算
      // 2019 7 22 - chc 要減LaserCenter
      //shMarkMatch->Top = y + imCCD->Top - shMarkMatch->Height/2;
      //shMarkMatch->Left = x + imCCD->Left - shMarkMatch->Width/2;
      shMarkMatch->Top = y + imCCD->Top - shMarkMatch->Height/2 - LaserCenterY;
      shMarkMatch->Left = x + imCCD->Left - shMarkMatch->Width/2 - LaserCenterX;

      shMarkMatch->Visible = true;
      pnlNCC->Color = clLime;
      pnlNCC1->Color = clLime;

      // 2016 5 19 - chc 加入角度值
      tmp.sprintf("%.3f",FindObj.Angle);
      pnlRotateAngle->Caption = tmp;

      // 2019 12 3 - chc Log
      tmp.sprintf("DoNCCMatch: MarkCenterX,MarkCenterY,cx,cy,LaserCenterX,LaserCenterY=%d,%d,%d,%d,%d,%d",MarkCenterX,MarkCenterY,(int)FindObj.CX,(int)FindObj.CY,LaserCenterX,LaserCenterY);
      WriteSystemLog(tmp);

   }

   // 2019 12 4 - chc 若分數低於0.7 則再做一次
   if(score < 0.7) {
      if(boolfirstdo == true) {
         boolfirstdo = false;
         goto again;
      }
   }

   // 2019 7 19 - chc Log
   WriteSystemLog("DoNCCMatch: Done.");

   return true;
}
//---------------------------------------------------------------------------
// 2023 2 21 - chc 可以移動
bool boolDBClick = false;

// 2019 11 29 - chc Do NCC Match
int DoubleClickX,DoubleClickY;
void __fastcall TMainForm::btnAutoMatchClick(TObject *Sender)
{
int no,cx,cy,mcx,mcy,dx,dy;
bool ret;
double fdy,ccdprecision,fdx;
int axisno,position;
I32 cmd;
AnsiString msg;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   // 2019 7 19 - chc for test
   //AnsiString imgfilename;
   //imgfilename = SystemDirectory + "\\ColorImg.bmp";
   //NCCError = iReadImage(ColorImg,imgfilename.c_str());

   // Disable Std Frame
   if(shCenter->Visible == true) {
      cbStdPattern->Checked = false;
   }
   // Log
   WriteSystemLog("btnAutoMatchClick Enter...");

   // 固定CCD0
   no = 0;
   pnlNCC->Color = clSilver;
   pnlNCC1->Color = clSilver;
   if(boolBaslerImageLoadedAry[no] == false) {
      pnlNCC->Color = clRed;
      pnlNCC1->Color = clRed;
      pnlSystemMessage->Caption = "No Image! Load/Capture image first.";
      WriteSystemLog("btnAutoMatchClick: " + pnlSystemMessage->Caption);
      return;
   }

   // 2016 11 13 - chc 由內到外搜尋: sno為單邊Pattern數量, 固範圍為sno*PatternWidth,sno*PatternHeight
   //ret = DoNCCMatch();
   AnsiString patternfname,recipename;
   int stdheight,stdwidth,areaheight,areawidth,sno;

   recipename = combRecipe->Text;
   // 區域
   if(rgMatchSource->ItemIndex == 0) {
      int ano;
      ano = edAreaNo->Text.ToInt();
      patternfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-A" + IntToStr(ano) + ".bmp";
   }
   // 基1
   else if(rgMatchSource->ItemIndex == 1) {
      patternfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-B1.bmp";
   }
   // 基2
   else if(rgMatchSource->ItemIndex == 2) {
      patternfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-B2.bmp";
   }
   // 量測
   else if(rgMatchSource->ItemIndex == 3) {
      int mno;
      mno = edDotNo->Text.ToInt();
      patternfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-M" + IntToStr(mno) + ".bmp";
   }

   areaheight = imCCD->Height;
   areawidth = imCCD->Width;
   if(!FileExists(patternfname)) {
      pnlSystemMessage->Caption = "Pattern File Not Exist! " + patternfname;
      pnlNCC->Color = clRed;
      pnlNCC1->Color = clRed;
      WriteSystemLog("btnAutoMatchClick: " + pnlSystemMessage->Caption);
      return;
   }
   StdImage.Load(patternfname.c_str());
   stdheight = StdImage.GetHeight();
   stdwidth = StdImage.GetWidth();
   ret = false;

   // Load P1ttern
   imPattern->Picture->Bitmap->Width = stdwidth;
   imPattern->Picture->Bitmap->Height = stdheight;
   imPattern->Width = stdwidth;
   imPattern->Height = stdheight;
   pnlPattern->Width = imPattern->Width + 10;
   pnlPattern->Height = imPattern->Height + 10;
   imPattern->Top = 5;
   imPattern->Left = 5;
   imPattern->Picture->LoadFromFile(patternfname);
   pnlPattern->Visible = true;

   // Log
   WriteSystemLog("btnAutoMatchClick: Load StdPattern(W*H)= " + IntToStr(stdwidth) + "," + IntToStr(stdheight));
   sno = 0;
   ret = DoNCCMatch(sno,stdwidth,stdheight,patternfname);

   // 連續15個範圍均找不到!!
   if(ret == false) {
      pnlSystemMessage->Caption = "Pattern Not found!";
      pnlNCC->Color = clRed;
      pnlNCC1->Color = clRed;
      return;
   }
   pnlNCC->Color = clLime;
   pnlNCC1->Color = clLime;

   // 2019 12 3 - chc 是否移到中心位置?
   if(cbMoveToCenterMatched->Checked == true) {
      // MarkCenterX, MarkCenterY: Match的中心點(對CCD來定義: 1280*960)
      int cx,cy,mcx,mcy;
      AnsiString msg;
      cx = shVertical->Left - imCCD->Left;
      cy = shHorizontal->Top - imCCD->Top;
      mcx = MarkCenterX;
      mcy = MarkCenterY;
      // mcx,mcy: 轉成對imCCD來定義: 1120*890
      mcx -= LaserCenterX;
      mcy -= LaserCenterY;
      // DoubleClickX,DoubleClickY: 以imCCD為(0,0)點
      DoubleClickX = mcx;
      DoubleClickY = mcy;

      // 2023 2 21 - chc 可以移動
      boolDBClick = true;

      // Double Click
      imCCDDblClick(this);

      // 2023 2 21 - chc 可以移動
      boolDBClick = false;

      msg.sprintf("btnAutoMatchClick(MoveToCenter): MarkCenterX,MarkCenterY,cx,cy,LaserCenterX,LaserCenterY=%d,%d,%d,%d,%d,%d",MarkCenterX,MarkCenterY,cx,cy,LaserCenterX,LaserCenterY);
      WriteSystemLog(msg);
      MarkCenterX = cx + LaserCenterX;
      MarkCenterY = cy + LaserCenterY;
      // 指向
      shMarkMatch->Top = cy + imCCD->Top - shMarkMatch->Height/2;
      shMarkMatch->Left = cx + imCCD->Left - shMarkMatch->Width/2;
   }
}
//---------------------------------------------------------------------------
// 2016 4 18 - chc 設定Center
void __fastcall TMainForm::btnAOIPositionClick(TObject *Sender)
{

   SetAOIPosition();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnToAOIPositionClick(TObject *Sender)
{

   pnlToAOIPosition->Color = clSilver;
   pnlTargetPosition->Color = clSilver;
   MotionStatus(false);

   // 2016 7 22 - chc Message
   pnlStartMessage->Caption = "To tilt measurement point...";
   pnlStartMessage->Visible = true;

   ToAOIPosition();

err:
   // 2016 7 22 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);
}
//---------------------------------------------------------------------------

// 2016 4 18 - chc DIO Update
void __fastcall TMainForm::tmMotionPollingTimer(TObject *Sender)
{
// 2021 4 18 - chc first 1000ms => 100ms
bool boolfirst = true;

   // 2016 8 24 - chc set false to avoid re-entrant
   // 2016 8 26 - chc not set
   //tmMotionPolling->Enabled = false;

tmMotionPolling->Enabled = false;

   // 2021 4 18 - chc first 1000ms => 100ms
   // 可能XML尚未設定完成
   if(boolfirst == true)
      tmMotionPolling->Interval = 100;
   boolfirst = false;

   // 2020 7 15 - chc 記錄tmMotionPolling次數
   tmMotionCount++;

   // 2021 3 22 - chc Log
   //WriteSystemLog(">>[tmMotionPollingTimer]: UpdateMotionStatus...");

   // 由Motion負責
   UpdateMotionStatus();

   // 2021 3 22 - chc Log
   //WriteSystemLog(">>[tmMotionPollingTimer]: UpdateMotionStatus.");
   //WriteSystemLog(">>[tmMotionPollingTimer]: UpdateTablePosition...");

   // 2021 3 22 - chc Log
   //WriteSystemLog(">>[tmMotionPollingTimer]: UpdateTablePosition.");

   // 2016 8 24 - chc set true to avoid re-entrant
   // 2016 8 26 - chc not set
   //tmMotionPolling->Enabled = true;

   // 2020 3 10 - chc 更新角度值: 彰化=>是T軸(不是Y軸)
   // 2023 8 1 - chc Auto無T
   /*
   int zero = edLoadY->Text.ToInt();
   double y;
   AnsiString msg;
   // 傾斜
   y = edAOIT->Text.ToInt();
   y = y - zero;
   y *= Y_RESOLUTION;
   msg.sprintf("T=%.3f",y);
   laAOI->Caption = msg;
   // 水平
   y = edLoadT->Text.ToInt();
   y = y - zero;
   y *= Y_RESOLUTION;
   msg.sprintf("T=%.3f",y);
   laLoad->Caption = msg;
   // 原點
   y = edOriginalT->Text.ToInt();
   y = y - zero;
   y *= Y_RESOLUTION;
   msg.sprintf("T=%.3f",y);
   laOriginal->Caption = msg;
   */

   // 2020 3 10 - chc 畫面更新
   // 2020 4 16 - chc 不要, 會頓!!
   //Application->ProcessMessages();

   tmMotionPolling->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   // 2020 4 23 - chc 不Log
   // 2021 4 18 - chc 要Log
   //WriteSystemLog(">>[Timer]: tmMotionPolling - Leave");

}
//---------------------------------------------------------------------------
// 2020 6 22 - chc 記錄取片中
bool boolInLoad = false;

// 2020 6 22 - chc 記錄退片中
bool boolInUnLoad = false;

// 2021 9 25 - chc 量測中
bool boolInMeasureRun = false;

// 2016 4 18 - chc Motion Protect
void __fastcall TMainForm::MotionStatus(bool mode)
{

   // 連動時不可以Disable否則不會停
   if(mode == true || cbContinueMove->Checked == false) {
      btnMove->Enabled = mode;
      btnBackward->Enabled = mode;
      btnMoveX->Enabled = mode;
      btnBackwardX->Enabled = mode;
      btnMoveY->Enabled = mode;
      btnBackwardY->Enabled = mode;
      btnMoveT->Enabled = mode;
      btnBackwardT->Enabled = mode;
      btnMoveZ->Enabled = mode;
      btnBackwardZ->Enabled = mode;
   }

   btnMoveAbsolute->Enabled = mode;

   // DO也要管制
   tsDO->Enabled = mode;
   rgRelativeMove->Enabled = mode;
   rgAbsoluteMove->Enabled = mode;
   // Home要管制
   btnHomeOneAxis->Enabled = mode;
   btnHome->Enabled = mode;
   combAxis->Enabled = mode;

   // 2020 9 3 - chc for test
   if(boolForTest == false)
      pcMotion->Enabled = mode;

   gbArrayOperation->Enabled = mode;
   gbArray1Operation->Enabled = mode;
   gbArray2Operation->Enabled = mode;
   gbDieOperation->Enabled = mode;

   // 2016 5 25 - chc Joystick
   cbJoystick->Enabled = mode;

   // 2016 5 30 - chc 加入Relative Move
   rgRelativeMove->Enabled = mode;

   // 2016 7 9 - chc Set
   pcOP->Enabled = mode;

   // 2020 3 16 - chc 鎖定
   // 2021 5 5 - chc 區分APS
   if(EFEMMode == EFEM_RORZE) {
      tsRorzeEFEM->Enabled = mode;
      if(mode == true)
         MainForm->WriteSystemLog("MotionStatus: 設定tsRorzeEFEM為true");
      else
         MainForm->WriteSystemLog("MotionStatus: 設定tsRorzeEFEM為false");
   }
   else {

      pcEFEMH->Enabled = mode;
      if(mode == true)
         MainForm->WriteSystemLog("MotionStatus: 設定pcRobot為true");
      else
         MainForm->WriteSystemLog("MotionStatus: 設定pcRobot為false");
   }

   if(mode == false) {
      pnlMoving->Visible = true;

      // 2021 9 30 - chc 勿動
      if(pnlMoving->Caption != "轉45度:勿動" && pnlMoving->Caption != "轉0度:勿動")

         pnlMoving->Caption = "Working...";
   }
   else {

      // 2021 9 25 - chc 在Load/UnLoad/Measure中不可以取消
      if(boolInLoad == false && boolInUnLoad == false && boolInMeasureRun == false)

         pnlMoving->Visible = false;
   }

}
//---------------------------------------------------------------------------
// 2016 4 18 - chc 是否執行過Home? - boolHomeDone
void __fastcall TMainForm::SetMotionStatus()
{

   MotionStatus(boolHomeDone);
}
//---------------------------------------------------------------------------
// 2016 4 18 - chc For Motion
void __fastcall TMainForm::MoveMouseUp()
{
TMouseButton Button;
TShiftState Shift;
int X;
int Y;

   btnMoveMouseUp(this, Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2016 4 18 - chc For Motion
void __fastcall TMainForm::BackwardMouseUp()
{
TMouseButton Button;
TShiftState Shift;
int X;
int Y;

   // 2020 3 3 - chc Log
   WriteSystemLog("BackwardMouseUp()...");

   btnBackwardMouseUp(this,Button,Shift,X,Y);
}
//---------------------------------------------------------------------------
// 2016 4 18 - chc 播放音效
void __fastcall TMainForm::AlarmSound()
{
char fname[180];

   //sprintf(fname,"%s\\Powerup.WAV",SystemDirectory);
   sprintf(fname,"%s\\notify.WAV",SystemDirectory);
   PlaySound(fname,0,SND_ASYNC);
}
//---------------------------------------------------------------------------
// 2016 4 19 - chc 處理Alt / Ctrl - LeftMouse
void __fastcall TMainForm::imCCDMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
int level;
double fdy,ccdprecision,fdx;
int axisno,position;
I32 cmd;
AnsiString msg;

// 2016 5 10 - chc 未設中心點
int cx,cy;
   cx = imCCD->Width / 2;
   cy = imCCD->Height / 2;

   // 2016 10 17 - chc Center fix in 511, 486
   // 2016 11 2 - chc Center at inCCD(509,405), not fixed at(511,486)
   //cx = 511;
   //cy = 486;

   // 2016 11 6 - chc use shVertical & shHorizontal(imCCD: 1020*810)
   // shVertical->Left = 553
   // imCCD->Left = 43
   // imCCD->Width/2=510
   // shHorizontal->Top = 448
   // imCCD->Top = 42
   // imCCD->Height/2=405
   cx = shVertical->Left - imCCD->Left;
   cy = shHorizontal->Top - imCCD->Top;

   // 2016 5 26 - chc Ctrl-Alt - Mouse Left Click, Laser Center
   if(Shift.Contains(ssAlt) && Shift.Contains(ssCtrl) && Button == mbLeft) {

      // 2016 6 2 - chc Operator不可以使用
      if(PriorityLevel > PRIORITY_OP) {

         pnlLaserCenter->Color = clSilver;
         // 更新LaserCenter(X/Y)
         int dx,dy;
         dx = X - cx;
         dy = Y - cy;
         LaserCenterX += dx;
         LaserCenterY += dy;
         bool errflag = false;
         if(LaserCenterX < 0) {

            // 2016 10 23 - chc 不限制在CCD FOV內
            shVertical->Left = pnlLeftWindow->Width/2 + LaserCenterX;

            pnlSystemMessage->Caption = "X Error, out of range!";
            errflag = true;
         }
         if(LaserCenterY < 0) {

            // 2016 10 23 - chc 不限制在CCD FOV內
            shHorizontal->Top = pnlLeftWindow->Height/2 + LaserCenterY;

            if(errflag == true)
               pnlSystemMessage->Caption = "XY Error, out of range!";
            else
               pnlSystemMessage->Caption = "X Error, out of range!";
            errflag = true;
         }

         // 89/34 : 178/68
         // 2016 10 30 - chc to parameter
         //if(LaserCenterX > 177) {
         if(LaserCenterX > (CCDDx-1)) {

            // 2016 10 23 - chc 不限制在CCD FOV內
            // 2016 10 30 - chc to parameter
            //shVertical->Left = pnlLeftWindow->Width/2 + (LaserCenterX-177);
            shVertical->Left = pnlLeftWindow->Width/2 + (LaserCenterX-(CCDDx-1));

            pnlSystemMessage->Caption = "X Error, out of range!";
            errflag = true;
         }

         // 2016 10 30 - chc to parameter
         //if(LaserCenterY > 67) {
         if(LaserCenterY > (CCDDy-1)) {

            // 2016 10 23 - chc 不限制在CCD FOV內
            // 2016 10 30 - chc to parameter
            //shHorizontal->Top = pnlLeftWindow->Height/2 + (LaserCenterY-67);
            shHorizontal->Top = pnlLeftWindow->Height/2 + (LaserCenterY-(CCDDy-1));

            if(errflag == true)
               pnlSystemMessage->Caption = "XY Error, out of range!";
            else
               pnlSystemMessage->Caption = "X Error, out of range!";
            errflag = true;
         }

         if(errflag == false)
            pnlLaserCenter->Color = clLime;
         else
            pnlLaserCenter->Color = clRed;
         // 寫入ini檔
         TIniFile *pSystemFile;
         // ini檔名與目錄:
         pSystemFile = new TIniFile(MainForm->SystemINIFilename);
         pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Laser Center X"     ,LaserCenterX);
         pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Laser Center Y"     ,LaserCenterY);
         delete pSystemFile;

         // 2016 10 12 - chc Save Laser Position
         LensPosition[LensNo-1].LaserX = LaserCenterX;
         LensPosition[LensNo-1].LaserY = LaserCenterY;
         SaveLaserPosition(LensNo);

         // 更新顯示
         // 若沒有Refresh就不會顯示
         int no = 0;
         int width = CCDInfoAry[no].Width;
         int height = CCDInfoAry[no].Height;
         int w = imCCD->Width;
         int h = imCCD->Height;
         int sx = LaserCenterX;
         int sy = LaserCenterY;
         int x,y;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         imCCD->Refresh();

         // 2016 5 30 - chc 顯示LaserCenter
         pnlLaserCenterPosition->Caption = "(" + IntToStr(LaserCenterX) + "," + IntToStr(LaserCenterY) + ")";

         // 2016 10 30 - chc Display in View Window
         pnlLaserCenterPosition1->Caption = pnlLaserCenterPosition->Caption;

      }
   }

   // Alt - Mouse Left Click, move to center
   else if(Shift.Contains(ssAlt) && Button == mbLeft) {
      pnlSystemMessage->Caption = "Alt - MouseLeftButton: XYMoving...";
      // Y軸
      pnlYMove->Color = clSilver;
      level = shHorizontal->Top;

      // 2016 6 3 - chc GetLensPrecision
      //ccdprecision = edCCDPrecision1->Text.ToDouble();
      ccdprecision = GetLensPrecision();

      // 2016 5 10 - chc 未設中心點
      //fdy = (Y - level) * ccdprecision;
      fdy = (Y - (level - imCCD->Top)) * ccdprecision;
      msg.sprintf("Y,level,top,fy= %d,%d,%d,%.4f",Y,level,imCCD->Top,fdy);
      WriteSystemLog(msg);

      if(cbCCDYDirection->Checked == true)
         fdy = 0 - fdy;
      msg.sprintf("%.3f",fdy);
      pnlYAltOffset->Caption = msg;
      // 移動Y軸 - absolute
      axisno = Y_AXIS;

      // 2016 12 9 - chc 改成Position
      //GetCommand(axisno, &cmd);
      double fcmd;
      GetPosition(axisno, &fcmd);
      cmd = fcmd;

      position = cmd + (fdy / Y_RESOLUTION);
      if(MoveToY(position) == false) {
         pnlSystemMessage->Caption = "Alt - MouseLeftButton: YMove Fail!";
         pnlYMove->Color = clRed;
         // Beep聲
         Beep(500);

         // 2016 6 4 - chc Alarm Message
         pnlAlarmMessage->Caption = " Y-Axis Move Error!";

         // 2021 5 5 - chc Error Control: 1-10000
         sErrorCode = AnsiString(SYSTEM_ERROR_HEAD) + SYSTEM_MOTION_ERROR;

      }
      else {
         pnlYMove->Color = clLime;
         pnlSystemMessage->Caption = "Alt - MouseLeftButton: YMove Success";
      }
      // X軸
      pnlXMove->Color = clSilver;
      level = shVertical->Left;

      // 2016 5 10 - chc 未設中心點
      //fdx = (X - level) * ccdprecision;
      fdx = (X - (level - imCCD->Left)) * ccdprecision;
      msg.sprintf("X,level,left,fx= %d,%d,%d,%.4f",X,level,imCCD->Left,fdx);
      WriteSystemLog(msg);

      if(cbCCDXDirection->Checked == true)
         fdx = 0 - fdx;
      msg.sprintf("%.3f",fdx);
      pnlXAltOffset->Caption = msg;
      // 移動X軸 - absolute
      axisno = X_AXIS;

      // 2016 12 9 - chc 改成Position
      //GetCommand(axisno, &cmd);
      GetPosition(axisno, &fcmd);
      cmd = fcmd;

      position = cmd + (fdx / X_RESOLUTION);
      if(MoveToX(position) == false) {
         pnlSystemMessage->Caption = "Alt - MouseLeftButton: XMove Fail!";
         pnlXMove->Color = clRed;
         // Beep聲
         Beep(500);

         // 2016 6 4 - chc Alarm Message
         pnlAlarmMessage->Caption = " X-Axis Move Error!";

      }
      else {
         pnlXMove->Color = clLime;
         pnlSystemMessage->Caption = "Alt - MouseLeftButton: XMove Success";
      }

      // 強制切到X軸
      axisno = X_AXIS;
      combAxis->ItemIndex = axisno;
   }

   // Ctrl - Mouse Left Click, Angular alignment
   // XHomePosition來分辨左右(左小, 右大)
   else if(Shift.Contains(ssCtrl) && Button == mbLeft) {

      // 2016 7 13 - chc Horizontal / Vertical Angular Alignment
      // Vertical
      if(cbAngularHorizontal->Checked == false) {
         axisno = Y_AXIS;
         GetCommand(axisno, &cmd);

         // 2016 7 22 - chc Log: Angular Alignment
         WriteSystemLog("Ctrl-LeftMose: Vertical, pos,Y=" + IntToStr(cmd) + "," + edAOIY->Text);

         // 2016 7 23 - chc Any Position
         /*
         // Up: 大者
         if(cmd > edAOIY->Text.ToInt()) {
            RotateLeftYPos = cmd;
            RotateLeftXPos = X;
            pnlRemoteLeft->Color = clLime;
         }
         // Down: 小者
         else {
            RotateRightYPos = cmd;
            RotateRightXPos = X;
            pnlRemoteRight->Color = clLime;
         }
         */
         // First
         double ccdprecision = GetLensPrecision();
         if(pnlRemoteLeft->Color != clLime) {
            RotateLeftYPos = cmd + ((imCCD->Height/2 - Y) * ccdprecision) / Y_RESOLUTION;
            RotateLeftXPos = X;
            pnlRemoteLeft->Color = clLime;
            pnlAssignResult->Color = clLime;

            // 2016 11 4 - chc 加入Position的記錄, 否則長距離的轉正與單畫面的轉正方向相反!!
            RotateUpYCmd = cmd;

         }
         // Second
         else if(pnlRemoteRight->Color != clLime) {
            RotateRightYPos = cmd + ((imCCD->Height/2 - Y) * ccdprecision) / Y_RESOLUTION;
            RotateRightXPos = X;
            pnlRemoteRight->Color = clLime;
            pnlAssignResult->Color = clLime;

            // 2016 11 4 - chc 加入Position的記錄, 否則長距離的轉正與單畫面的轉正方向相反!!
            RotateDownYCmd = cmd;

         }
         // Error
         else {
            pnlSystemMessage->Caption = "Clear before re-assigning!";
            pnlAssignResult->Color = clRed;
         }

      }
      // Horizontal
      else {

         axisno = X_AXIS;
         GetCommand(axisno, &cmd);

         // 2016 7 22 - chc Log: Angular Alignment
         WriteSystemLog("Ctrl-LeftMose: Horizontal, pos,X=" + IntToStr(cmd) + "," + edAOIX->Text);

         // 2016 7 23 - chc Any Position
         /*
         // Left: 大者
         if(cmd > edAOIX->Text.ToInt()) {
            RotateLeftYPos = Y;
            RotateLeftXPos = cmd;
            pnlRemoteLeft->Color = clLime;
         }
         // Right: 小者
         else {
            RotateRightYPos = Y;
            RotateRightXPos = cmd;
            pnlRemoteRight->Color = clLime;
         }
         */
         // First
         double ccdprecision = GetLensPrecision();
         if(pnlRemoteLeft->Color != clLime) {
            RotateLeftYPos = Y;
            RotateLeftXPos = cmd + ((X - imCCD->Width/2) * ccdprecision) / X_RESOLUTION;
            pnlRemoteLeft->Color = clLime;
            pnlAssignResult->Color = clLime;

            // 2016 11 4 - chc 加入Position的記錄, 否則長距離的轉正與單畫面的轉正方向相反!!
            RotateLeftXCmd = cmd;

         }
         // Second
         else if(pnlRemoteRight->Color != clLime) {
            RotateRightYPos = Y;
            RotateRightXPos = cmd + ((X - imCCD->Width/2) * ccdprecision) / X_RESOLUTION;
            pnlRemoteRight->Color = clLime;
            pnlAssignResult->Color = clLime;

            // 2016 11 4 - chc 加入Position的記錄, 否則長距離的轉正與單畫面的轉正方向相反!!
            RotateRightXCmd = cmd;

         }
         // Error
         else {
            pnlSystemMessage->Caption = "Clear before re-assigning!";
            pnlAssignResult->Color = clRed;
         }

      }
   }

}
//---------------------------------------------------------------------------
// 2016 4 19 - chc Array Left
// 要檢查極限
void __fastcall TMainForm::btnArrayLeftClick(TObject *Sender)
{
double fdx;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // X軸
   fdx = edArrayWidthRecipe->Text.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetCommand(axisno, &cmd);
   position = cmd - (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "ARRAY Left : XMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " X-Axis Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "ARRAY Left : XMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;

}
//---------------------------------------------------------------------------
// 2016 4 19 - chc Array Right
void __fastcall TMainForm::btnArrayRightClick(TObject *Sender)
{
double fdx;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // X軸
   fdx = edArrayWidthRecipe->Text.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetCommand(axisno, &cmd);
   position = cmd + (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "ARRAY Right : XMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " X-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "ARRAY Right : XMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// 2016 4 19 - chc Array Up
void __fastcall TMainForm::btnArrayUpClick(TObject *Sender)
{
double fdy;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // Y軸
   fdy = edArrayHeightRecipe->Text.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetCommand(axisno, &cmd);

   // 2016 7 22 - chc Direction reverse!!
   //position = cmd - (fdy / Y_RESOLUTION);
   position = cmd + (fdy / Y_RESOLUTION);

   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "ARRAY Up : YMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "ARRAY Up : YMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// 2016 4 19 - chc Array Down
void __fastcall TMainForm::btnArrayDownClick(TObject *Sender)
{
double fdy;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // Y軸
   fdy = edArrayHeightRecipe->Text.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetCommand(axisno, &cmd);

   // 2016 7 22 - chc Direction reverse!!
   //position = cmd + (fdy / Y_RESOLUTION);
   position = cmd - (fdy / Y_RESOLUTION);

   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "ARRAY Down : YMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "ARRAY Down : YMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// 2016 4 19 - chc Die Left
// 要檢查極限
void __fastcall TMainForm::btnDieLeftClick(TObject *Sender)
{
double fdx;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // X軸
   fdx = edDieWidthRecipe->Text.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetCommand(axisno, &cmd);
   position = cmd - (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "DieLeft : XMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " X-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "DieLeft : XMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// 2016 4 19 - chc Die Right
void __fastcall TMainForm::btnDieRightClick(TObject *Sender)
{
double fdx;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // X軸
   fdx = edDieWidthRecipe->Text.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetCommand(axisno, &cmd);
   position = cmd + (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "DieRight : XMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " X-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "Dieright : XMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// 2016 4 19 - chc Die Up
void __fastcall TMainForm::btnDieUpClick(TObject *Sender)
{
double fdy;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // Y軸
   fdy = edDieHeightRecipe->Text.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetCommand(axisno, &cmd);

   // 2016 7 22 - chc Direction reverse!!
   //position = cmd - (fdy / Y_RESOLUTION);
   position = cmd + (fdy / Y_RESOLUTION);

   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "DieUp : YMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "DieUp : YMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// 2016 4 19 - chc Die Down
void __fastcall TMainForm::btnDieDownClick(TObject *Sender)
{
double fdy;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // Y軸
   fdy = edDieHeightRecipe->Text.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetCommand(axisno, &cmd);

   // 2016 7 22 - chc Direction reverse!!
   //position = cmd + (fdy / Y_RESOLUTION);
   position = cmd - (fdy / Y_RESOLUTION);

   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "DieDown : YMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "DieDown : YMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// Stop Beep
// 兩點轉正
void __fastcall TMainForm::btnRemoteRotateClick(TObject *Sender)
{
double dx,ccdprecision,dy,degree,meany,value,fdy,meanx,fdx;
I32 cmd;
AnsiString msg;
int axisno,pos,level;

   WriteSystemLog(">[Angular Alignment]");

   // 2016 6 3 - chc GetLensPrecision
   //ccdprecision = edCCDPrecision1->Text.ToDouble();
   ccdprecision = GetLensPrecision();

   // 2016 7 22 - chc Log
   msg.sprintf(">CCD Precision: %.3f",ccdprecision);
   WriteSystemLog(msg);

   if(pnlRemoteLeft->Color == clLime && pnlRemoteRight->Color == clLime) {
      pnlRemoteRotate->Color = clSilver;

      // 2016 7 22 - chc Log
      WriteSystemLog(">Do Angular Alignment...");

      // 2016 7 13 - chc Vertical Angular Alignment
      // Vertical
      if(cbAngularHorizontal->Checked == false) {
         // Y Distance

         // 2016 7 23 - chc any Position, Left: Larger
         // 2016 11 4 - chc 加入Position的記錄, 否則長距離的轉正與單畫面的轉正方向相反!!
         if(RotateLeftXCmd != RotateRightXCmd) {                                   // 有動到X-Axis位置
            if(RotateLeftYPos > RotateRightYPos)
               dx = RotateRightXPos - RotateLeftXPos;                              // Difference of two point
            else
               dx = RotateLeftXPos-RotateRightXPos;                                // Difference of two point
         }
         else {

            if(RotateLeftYPos < RotateRightYPos)
               dx = RotateRightXPos - RotateLeftXPos;                              // Difference of two point
            else

               dx = RotateLeftXPos-RotateRightXPos;                                // Difference of two point
         }
         dy = abs(RotateLeftYPos - RotateRightYPos);                            // Distance of two point

         if(dx == 0 || dy == 0)
            degree = 0;
         else {
            value = (double)(dx * ccdprecision) / (dy * X_RESOLUTION);
            // radian
            degree = atan(value);
            // degree
            degree = (360 * degree) / (2*M_PI);
            pos = degree / T_RESOLUTION;
            if(cbRotateDirection->Checked == false)
               pos = 0 - pos;
            axisno = T_AXIS;
            GetCommand(axisno, &cmd);
            pos = pos + cmd;
            if(MoveToT(pos) == false) {
               pnlSystemMessage->Caption = "Axis-T Rotate Fail!";
               pnlRemoteRotate->Color = clRed;
               // Beep
               Beep(500);
               pnlAlarmMessage->Caption = " T-Axis Move Error!";

               // 2016 7 22 - chc Log
               WriteSystemLog(">Angular Alignment: Fail!");

            }
            else {
               pnlRemoteRotate->Color = clLime;

               // 2016 7 22 - chc Log
               WriteSystemLog(">Angular Alignment: Ok. dx= " + IntToStr((int)dx));

            }
         }
         // Shift
         if(cbDirectMove->Checked == true) {

            // 2016 11 18a - chc 不需要做Y
            /*
            meany = (RotateLeftYPos + RotateRightYPos) / 2;
            level = shHorizontal->Top;
            fdy = (meany - level) * ccdprecision;
            if(cbCCDYDirection->Checked == true)
               fdy = 0 - fdy;
            msg.sprintf("%.3f",fdy);
            pnlYAltOffset->Caption = msg;
            // Y-Axis - absolute
            axisno = Y_AXIS;
            GetCommand(axisno, &cmd);
            pos = cmd + (fdy / Y_RESOLUTION);
            if(MoveToY(pos) == false) {
               pnlSystemMessage->Caption = "Axis-Y Shift Fail!";
               // Beep
               Beep(500);
               pnlAlarmMessage->Caption = " Y-Axis Move Error!";
            }
            */

            meanx = (RotateLeftXPos + RotateRightXPos) / 2;
            level = shVertical->Left;

            // 2016 11 19 - chc minus imCCD->Top
            level -= imCCD->Left;

            fdx = (meanx - level) * ccdprecision;
            if(cbCCDXDirection->Checked == true)
               fdx = 0 - fdx;
            msg.sprintf("%.3f",fdx);
            pnlXAltOffset->Caption = msg;
            // X-Axis - absolute
            axisno = X_AXIS;
            GetCommand(axisno, &cmd);
            pos = cmd + (fdx / X_RESOLUTION);
            if(MoveToX(pos) == false) {
               pnlSystemMessage->Caption = "Axis-X Shift Fail!";
               // Beep
               Beep(500);
               pnlAlarmMessage->Caption = " X-Axis Move Error!";
            }
         }

         // set to X-Axis
         axisno = X_AXIS;
         combAxis->ItemIndex = axisno;

         msg.sprintf("%d",(int)dx);
         pnlTRemoteOffset->Caption = msg;
         msg.sprintf("%.3f",degree);
         pnlTRemoteDegree->Caption = msg;
         pnlRemoteLeft->Color = clSilver;
         pnlRemoteRight->Color = clSilver;

         // 2016 7 23 - chc Any position
         pnlAssignResult->Color = clSilver;

      }
      // Horizontal
      else {

         // X Distance
         dx = abs(RotateLeftXPos-RotateRightXPos);

         // 2016 7 23 - chc any Position, Left: Larger
         // 2016 11 4 - chc 加入Position的記錄, 否則長距離的轉正與單畫面的轉正方向相反!!
         if(RotateLeftXCmd != RotateRightXCmd) {                                   // 有動到X-Axis位置
            if(RotateLeftXPos > RotateRightXPos)
               dy = RotateRightYPos - RotateLeftYPos;
            else
               dy = RotateLeftYPos - RotateRightYPos;
         }
         else {

            if(RotateLeftXPos < RotateRightXPos)
               dy = RotateRightYPos - RotateLeftYPos;
            else

               dy = RotateLeftYPos - RotateRightYPos;
         }
         if(dx == 0 || dy == 0)
            degree = 0;
         else {
            value = (double)(dy * ccdprecision) / (dx * X_RESOLUTION);
            // Radian
            degree = atan(value);
            // Degree
            degree = (360 * degree) / (2*M_PI);
            pos = degree / T_RESOLUTION;
            if(cbRotateDirection->Checked == false)
               pos = 0 - pos;
            axisno = T_AXIS;
            GetCommand(axisno, &cmd);
            pos = pos + cmd;
            if(MoveToT(pos) == false) {
               pnlSystemMessage->Caption = "Axis-T Rotate Fail!";
               pnlRemoteRotate->Color = clRed;
               // Beep
               Beep(500);
               pnlAlarmMessage->Caption = " T-Axis Move Error!";

               // 2016 7 22 - chc Log
               WriteSystemLog(">Angular Alignment: Fail!");

            }
            else {
               pnlRemoteRotate->Color = clLime;

               // 2016 7 22 - chc Log
               WriteSystemLog(">Angular Alignment: Ok. dy= " + IntToStr(int(dy)));

            }
         }
         // Shift
         if(cbDirectMove->Checked == true) {
            meany = (RotateLeftYPos + RotateRightYPos) / 2;
            level = shHorizontal->Top;

            // 2016 11 19 - chc minus imCCD->Top
            level -= imCCD->Top;

            fdy = (meany - level) * ccdprecision;
            if(cbCCDYDirection->Checked == true)
               fdy = 0 - fdy;
            msg.sprintf("%.3f",fdy);
            pnlYAltOffset->Caption = msg;

            // 2016 11 19 - chc Y Shift value
            pnlYShift->Caption = msg;

            // Y-Axis - absolute
            axisno = Y_AXIS;
            GetCommand(axisno, &cmd);
            pos = cmd + (fdy / Y_RESOLUTION);
            if(MoveToY(pos) == false) {
               pnlSystemMessage->Caption = "Axis-Y Shift Fail!";
               // Beep
               Beep(500);
               pnlAlarmMessage->Caption = " Y-Axis Move Error!";
            }

            // 2016 11 18a - chc 不需要做X
            /*
            meanx = (RotateLeftXPos + RotateRightXPos) / 2;
            level = shVertical->Left;
            fdx = (meanx - level) * ccdprecision;
            if(cbCCDXDirection->Checked == true)
               fdx = 0 - fdx;
            msg.sprintf("%.3f",fdx);
            pnlXAltOffset->Caption = msg;
            // X-Axis - absolute
            axisno = X_AXIS;
            GetCommand(axisno, &cmd);
            pos = cmd + (fdx / X_RESOLUTION);
            if(MoveToX(pos) == false) {
               pnlSystemMessage->Caption = "Axis-X Shift Fail!";
               // Beep
               Beep(500);
               pnlAlarmMessage->Caption = " X-Axis Move Error!";
            }
            */

         }

         // set to X-Axis
         axisno = X_AXIS;
         combAxis->ItemIndex = axisno;

         msg.sprintf("%d",(int)dy);
         pnlTRemoteOffset->Caption = msg;
         msg.sprintf("%.3f",degree);
         pnlTRemoteDegree->Caption = msg;
         pnlRemoteLeft->Color = clSilver;
         pnlRemoteRight->Color = clSilver;

         // 2016 7 23 - chc Any position
         pnlAssignResult->Color = clSilver;

      }
   }

   // 2016 7 22 - chc Log
   else
      WriteSystemLog(">Can not Do Angular Alignment, Left-Right not define!");

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnServoOnClick(TObject *Sender)
{

   SetServoOn();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnServoOffClick(TObject *Sender)
{

   SetServoOff();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlarmOnClick(TObject *Sender)
{

   SetAlmOn();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlarmOffClick(TObject *Sender)
{

   SetAlmOff();
}
//---------------------------------------------------------------------------
// Y - Forward
void __fastcall TMainForm::btnMoveYClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Y_AXIS;

   // 2021 6 24 - chc 相反
   //btnMoveClick(this);
   btnBackwardClick(this);

}
//---------------------------------------------------------------------------
// Z - Forward
void __fastcall TMainForm::btnMoveZClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Z_AXIS;
   btnMoveClick(this);
}
//---------------------------------------------------------------------------
// T - Forward
void __fastcall TMainForm::btnMoveTClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = T_AXIS;
   btnMoveClick(this);
}
//---------------------------------------------------------------------------
// 2016 4 20 - chc Y 往後
void __fastcall TMainForm::btnBackwardYClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Y_AXIS;

   // 2021 6 24 - chc 相反
   //btnBackwardClick(this);
   btnMoveClick(this);
}
//---------------------------------------------------------------------------
// 2016 4 20 - chc Z 往後
void __fastcall TMainForm::btnBackwardZClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Z_AXIS;
   btnBackwardClick(this);
}
//---------------------------------------------------------------------------
// 2016 4 20 - chc T 往後
void __fastcall TMainForm::btnBackwardTClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = T_AXIS;
   btnBackwardClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnMoveYMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Y_AXIS;

   // 2021 6 24 - chc 相反
   //btnMoveMouseDown(this,Button, Shift, X, Y);
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnMoveZMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Z_AXIS;
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnMoveTMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = T_AXIS;
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnMoveYMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2021 4 21 - chc 立即停止
   pnlAlarmMessage->Caption = "Y軸停止.";
   pnlAlarmMessage->Refresh();
   StopOneAxis(Y_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnMoveZMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnMoveTMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBackwardYMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Y_AXIS;

   // 2021 6 24 - chc 相反
   //btnBackwardMouseDown(this,Button, Shift, X, Y);
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBackwardZMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Z_AXIS;
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBackwardTMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = T_AXIS;
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBackwardYMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2021 4 21 - chc 立即停止
   pnlAlarmMessage->Caption = "Y軸停止.";
   pnlAlarmMessage->Refresh();
   StopOneAxis(Y_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBackwardZMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBackwardTMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------
// 2016 4 21 - chc System Parameter
// 載入參數
void __fastcall TMainForm::LoadSystemParameter()
{
TIniFile *pSystemFile;
AnsiString str;

 // 2016 7 30 - chc try-catch
 try {

   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   // CCD Precision
   CCDPrecision           = pSystemFile->ReadFloat("System Parameter" ,"CCD Precision"          ,1.1);
   str.sprintf("%.4f",CCDPrecision);

   // 2019 10 17 - chc 由參數定義CCD精度
   MotionCCDPrecision = CCDPrecision;
   edCCDPrecision->Text = str;
   pnlLensPrecision->Caption = str;

   // 2020 3 10 - chc L: Up/Down
   LUp           = pSystemFile->ReadInteger("System Parameter" ,L_UP            ,7000);
   edLUp->Text = IntToStr(LUp);
   LDown         = pSystemFile->ReadInteger("System Parameter" ,L_DOWN          ,0);
   edLDown->Text = IntToStr(LDown);

   // 2021 10 28 - chc Log刪除天數
   LogReservedDay = pSystemFile->ReadInteger("System Parameter" ,LOG_RESERVED_DAY ,180);
   edLogReservedDay->Text = IntToStr(LogReservedDay);

   // 2020 7 16 - chc ZLimit, ZOffset
   ZLimit         = pSystemFile->ReadInteger("System Parameter" ,Z_LIMIT        ,62832);
   edZLimit->Text = IntToStr(ZLimit);
   ZOffset         = pSystemFile->ReadInteger("System Parameter" ,Z_OFFSET      ,20);
   edZOffset->Text = IntToStr(ZOffset);

   // 2021 6 9 - chc 加入中心點參數: CenterSize, CenterOffset
   CenterSize = pSystemFile->ReadInteger("System Parameter" ,CENTER_SIZE                    ,100);
   edWaferCenterSize->Text = IntToStr(CenterSize);
   CenterOffset = pSystemFile->ReadInteger("System Parameter" ,CENTER_OFFSET                ,7000);
   edWaferCenterOffset->Text = IntToStr(CenterOffset);
   CenterCnt = pSystemFile->ReadInteger("System Parameter" ,CENTER_CNT                      ,20);
   edWaferCenterCnt->Text = IntToStr(CenterCnt);

   // 2021 9 15 - chc 將灰階量改成參數: WaferEdgeGray
   WaferEdgeGray = pSystemFile->ReadInteger("System Parameter" ,"Wafer Edge Gray"           ,50);
   edWaferEdgeGray->Text = IntToStr(WaferEdgeGray);

   // 2022 5 17 - chc 不是操作員: 固定10秒後切換到操作員等級: edPasswordSwitchSecond
   int ssec = pSystemFile->ReadInteger("System Parameter" ,"PasswordSwitchSecond"           ,100);
   edPasswordSwitchSecond->Text = IntToStr(ssec);

   // 2022 5 19 - chc T到水平/傾斜再確認: cbTCheck->Checked
   bool check = pSystemFile->ReadBool("System Parameter" ,"TCheck"                       ,true);
   cbTCheck->Checked = check;

   // 2020 4 23 - chc 解真空高度
   LVacuumOff    = pSystemFile->ReadInteger("System Parameter" ,L_VACUUM_OFF    ,500);
   edLVacuumOff->Text = IntToStr(LVacuumOff);

   // 2020 5 20 - chc L水平高度
   LLevel    = pSystemFile->ReadInteger("System Parameter" ,L_LEVEL             ,1630);
   edLLevel->Text = IntToStr(LLevel);

   // 2019 10 17 - chc 定義CCDPrecision1
   CCDPrecision1           = pSystemFile->ReadFloat("System Parameter" ,"CCD Precision1"          ,5.38);
   str.sprintf("%.4f",CCDPrecision1);

   edCCDPrecision1->Text = str;

   // 2016 6 3 - chc GetLensPrecision
   CCDPrecision2           = pSystemFile->ReadFloat("System Parameter" ,"CCD Precision2"          ,5.38);
   str.sprintf("%.4f",CCDPrecision2);
   edCCDPrecision2->Text = str;
   CCDPrecision3           = pSystemFile->ReadFloat("System Parameter" ,"CCD Precision3"          ,5.38);
   str.sprintf("%.4f",CCDPrecision3);
   edCCDPrecision3->Text = str;
   CCDPrecision4           = pSystemFile->ReadFloat("System Parameter" ,"CCD Precision4"          ,5.38);
   str.sprintf("%.4f",CCDPrecision4);
   edCCDPrecision4->Text = str;
   CCDPrecision5           = pSystemFile->ReadFloat("System Parameter" ,"CCD Precision5"          ,5.38);
   str.sprintf("%.4f",CCDPrecision5);
   edCCDPrecision5->Text = str;

   // 2016 7 14 - chc sixth lens definition
   CCDPrecision6           = pSystemFile->ReadFloat("System Parameter" ,"CCD Precision6"          ,5.38);
   str.sprintf("%.4f",CCDPrecision6);
   edCCDPrecision6->Text = str;

   // 2016 6 3 - chc MatchNo & LensNo
   MatchNo           = pSystemFile->ReadInteger("System Parameter" ,"Match No"                    ,0);
   cbMatchNo->ItemIndex = MatchNo;
   LensNo           = pSystemFile->ReadInteger("System Parameter" ,"Lens No"                      ,1);

   // 2016 11 9 - chc Sort Mode & Min Score
   double score;
   rgSortMode->ItemIndex = pSystemFile->ReadInteger("System Parameter" ,"Sort Mode"               ,0);
   score = pSystemFile->ReadFloat("System Parameter" ,"Score"                                     ,0.0);
   str.sprintf("%.3f",score);
   edScore->Text = str;

   // 2016 6 13 - chc 顯示精度值
   double ccdprecision = GetLensPrecision();

   // 2016 6 4 - chc GridPixel
   GridPixel = pSystemFile->ReadInteger("System Parameter" ,"Grid Pixel"                         ,40);
   edGridPixel->Text = IntToStr(GridPixel);

   // 2016 6 3 - chc AI Min Vibrate
   AIMinVibrate           = pSystemFile->ReadFloat("System Parameter" ,"AI Min Vibrate"          ,0.5);
   str.sprintf("%.3f",AIMinVibrate);
   edMinVibrate->Text = str;

   // 2016 6 5 - chc Factor of Rotate Within View
   JogFactor = pSystemFile->ReadFloat("System Parameter" ,"Jog Factor"                         ,1.0);
   str.sprintf("%.3f",JogFactor);
   edJogFactor->Text = str;
   ContinueFactor = pSystemFile->ReadFloat("System Parameter" ,"Continue Factor"               ,1.0);
   str.sprintf("%.3f",ContinueFactor);
   edContinueFactor->Text = str;

   // 2016 9 7 - chc Home Method
   AllHomeMethod = pSystemFile->ReadInteger("System Parameter" ,"All Home Method"              ,ALLHOME_MODE9);

   // 2016 10 13 - chc Always assigned to ALLHOME_MODE9
   // 2016 11 25 - chc by select
   //AllHomeMethod = ALLHOME_MODE9;

   rgAllHomeMethod->ItemIndex = AllHomeMethod;

   // Recipe Name
   RecipeName             = pSystemFile->ReadString("System Parameter" ,"Recipe Name"           ,"A");
   cbRecipe->Text = RecipeName;
   // Move to Center
   boolMoveToCenter       = pSystemFile->ReadBool("System Parameter","bool Move to Center"      ,true);
   cbMoveToCenter->Checked = boolMoveToCenter;

   // 2016 5 26 - chc Rotate Before Move
   boolRotateBeforeMove       = pSystemFile->ReadBool("System Parameter","bool Rotate Before Move"   ,false);
   cbRotateBeforeMove->Checked = boolRotateBeforeMove;

   // CCD X Direction
   boolCCDXDirection      = pSystemFile->ReadBool("System Parameter","bool CCD X Direction"     ,false);
   cbCCDXDirection->Checked = boolCCDXDirection;
   // CCD Y Direction
   boolCCDYDirection      = pSystemFile->ReadBool("System Parameter","bool CCD Y Direction"     ,true);
   cbCCDYDirection->Checked = boolCCDYDirection;
   // Rotate Direction
   boolRotateDirection    = pSystemFile->ReadBool("System Parameter","bool Rotate Direction"    ,false);
   cbRotateDirection->Checked = boolRotateDirection;

   // 2016 5 30 - chc 加入旋轉方向
   boolCCDTDirection      = pSystemFile->ReadBool("System Parameter","bool CCD T Direction"     ,true);
   cbCCDTDirection->Checked = boolCCDTDirection;

   // DirectMove
   boolDirectMove         = pSystemFile->ReadBool("System Parameter","bool Direct Move"         ,false);
   cbDirectMove->Checked = boolDirectMove;

   // 2016 5 25 - chc Joystick
   // 2020 1 5 - chc 不用
   //boolJoystick           = pSystemFile->ReadBool("System Parameter","bool Joystick"            ,true);
   //cbJoystick->Checked    = boolJoystick;

   // Continue move
   boolContinueMove       = pSystemFile->ReadBool("System Parameter","bool Continue Move"       ,false);
   cbContinueMove->Checked = boolContinueMove;
   // Speed
   iSpeed                 = pSystemFile->ReadInteger("System Parameter","int Speed"             ,1);
   rgSpeed->ItemIndex = iSpeed;
   // Ruler Color
   iRulerColor            = pSystemFile->ReadInteger("System Parameter","int Ruler Color"       ,0);
   rgRulerColor->ItemIndex = iRulerColor;
   // Cross Mark
   iCrossMark             = pSystemFile->ReadInteger("System Parameter","int Cross Mark"         ,0);
   rgRulerType->ItemIndex = iCrossMark;

   // Basler Shutter & Gain: 等setupsca1300後才能設定
   BaslerShutter          = pSystemFile->ReadInteger("System Parameter","Basler Shutter"         ,6);
   BaslerGain             = pSystemFile->ReadInteger("System Parameter","Basler Gain"            ,300);
   scA1300ShutterAry[0] = BaslerShutter;
   scA1300GainAry[0] = BaslerGain;

   // 2016 11 28 - chc ImagingSource Name: DFK 33GP1300 + 44614266
   ISCCDName              = pSystemFile->ReadString("System Parameter","ImagingSource CCDName"   ,"DFK 33GP1300");
   ISCCDSerialNo          = pSystemFile->ReadString("System Parameter","ImagingSource CCDSerialNo"   ,"44614266");

   // 2019 11 12 - chc Vision64: boolVision64
   boolVision64           = pSystemFile->ReadBool("Vision64","Enabled"                           ,false);
   //if(boolVision64 == false) {
   //   gbOlympus->Caption = "Olympus Controller(Disable)";
   //   gbOlympus->Enabled = boolVision64;
   //}

   // 2020 2 28 - chc CCD
   boolCCD           = pSystemFile->ReadBool("CCD","Enabled"                           ,false);
   if(boolCCD == false) {
      tsCCD->TabVisible = false;
   }

   // 2019 12 7 - chc for test
   boolForTest            = pSystemFile->ReadBool("System Parameter","bool For Test"       ,false);

   // Motion

   // 2019 11 12 - chc 加入RDY
   XRDY                   = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"X_RDY"           ,1);
   YRDY                   = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Y_RDY"           ,1);
   ZRDY                   = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Z_RDY"           ,0);
   // 2019 11 12 - chc 加入Svon
   XSvon                   = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"X_SVON"         ,1);
   YSvon                   = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Y_SVON"         ,1);
   ZSvon                   = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Z_SVON"         ,1);

   XStartVel              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,X_START_VEL       ,50000);
   XMaxVel                = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,X_MAX_VEL         ,1500000);
   XDistance              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,X_DISTANCE        ,500000);
   XTacc                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,X_TACC              ,0.2);
   XTdec                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,X_TDEC              ,0.2);
   XPosition              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,X_POSITION        ,5000);
   XHomeVel               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,X_HOME_VEL        ,10000);
   XReviewVel             = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,X_REVIEW_VEL      ,10000);
   XUpLimit               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,X_UP_LIMIT        ,1500000);
   XLowDistance           = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,X_LOW_DISTANCE    ,5000);
   edStartVelX->Text    = XStartVel;
   edMaxVelX->Text      = XMaxVel;
   edDistanceX->Text    = XDistance;
   edTaccX->Text        = XTacc;
   edTdecX->Text        = XTdec;
   edPositionX->Text    = XPosition;
   edHomeVelX->Text     = XHomeVel;
   edReviewVelX->Text   = XReviewVel;
   edUpLimitX->Text     = XUpLimit;
   edLowDistanceX->Text = XLowDistance;
   // Y
   YStartVel              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Y_START_VEL       ,50000);
   YMaxVel                = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Y_MAX_VEL         ,1500000);
   YDistance              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Y_DISTANCE        ,500000);
   YTacc                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,Y_TACC              ,0.2);
   YTdec                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,Y_TDEC              ,0.2);
   YPosition              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Y_POSITION        ,1000);
   YHomeVel               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Y_HOME_VEL        ,10000);
   YReviewVel             = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Y_REVIEW_VEL      ,10000);
   YUpLimit               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Y_UP_LIMIT        ,1500000);
   YLowDistance           = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Y_LOW_DISTANCE    ,5000);
   edStartVelY->Text    = YStartVel;
   edMaxVelY->Text      = YMaxVel;
   edDistanceY->Text    = YDistance;
   edTaccY->Text        = YTacc;
   edTdecY->Text        = YTdec;
   edPositionY->Text    = YPosition;
   edHomeVelY->Text     = YHomeVel;
   edReviewVelY->Text   = YReviewVel;
   edUpLimitY->Text     = YUpLimit;
   edLowDistanceY->Text = YLowDistance;
   // Z
   ZStartVel             = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Z_START_VEL      ,2000);
   ZMaxVel               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Z_MAX_VEL        ,50000);
   ZDistance             = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Z_DISTANCE       ,100000);
   ZTacc                 = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,Z_TACC             ,0.2);
   ZTdec                 = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,Z_TDEC             ,0.2);
   ZPosition             = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Z_POSITION       ,5000);
   ZHomeVel              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Z_HOME_VEL       ,5000);
   ZReviewVel            = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Z_REVIEW_VEL     ,10000);
   ZUpLimit              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Z_UP_LIMIT       ,50000);
   ZLowDistance          = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,Z_LOW_DISTANCE   ,5000);
   edStartVelZ->Text    = ZStartVel;
   edMaxVelZ->Text      = ZMaxVel;
   edDistanceZ->Text    = ZDistance;
   edTaccZ->Text        = ZTacc;
   edTdecZ->Text        = ZTdec;
   edPositionZ->Text    = ZPosition;
   edHomeVelZ->Text     = ZHomeVel;
   edReviewVelZ->Text   = ZReviewVel;
   edUpLimitZ->Text     = ZUpLimit;
   edLowDistanceZ->Text = ZLowDistance;
   // T
   TStartVel              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,T_START_VEL       ,10000);
   TMaxVel                = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,T_MAX_VEL         ,180000);
   TDistance              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,T_DISTANCE        ,50000);
   TTacc                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,T_TACC              ,0.2);
   TTdec                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,T_TDEC              ,0.2);
   TPosition              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,T_POSITION        ,10000);
   THomeVel               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,T_HOME_VEL        ,200000);
   TReviewVel             = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,T_REVIEW_VEL      ,200000);
   TUpLimit               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,T_UP_LIMIT        ,180000);
   TLowDistance           = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,T_LOW_DISTANCE    ,10000);
   edStartVelT->Text    = TStartVel;
   edMaxVelT->Text      = TMaxVel;
   edDistanceT->Text    = TDistance;
   edTaccT->Text        = TTacc;
   edTdecT->Text        = TTdec;
   edPositionT->Text    = TPosition;
   edHomeVelT->Text     = THomeVel;
   edReviewVelT->Text   = TReviewVel;
   edUpLimitT->Text     = TUpLimit;
   edLowDistanceT->Text = TLowDistance;

   // 2021 4 15 - chc APS
   // L
   LStartVel              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,L_START_VEL       ,5000);
   LMaxVel                = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,L_MAX_VEL         ,100000);
   LDistance              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,L_DISTANCE        ,50000);
   LTacc                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,L_TACC              ,0.3);
   LTdec                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,L_TDEC              ,0.3);
   LPosition              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,L_POSITION        ,10000);
   LHomeVel               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,L_HOME_VEL        ,200000);
   LReviewVel             = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,L_REVIEW_VEL      ,200000);
   LUpLimit               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,L_UP_LIMIT        ,100000);
   LLowDistance           = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,L_LOW_DISTANCE    ,10000);
   edStartVelL->Text    = LStartVel;
   edMaxVelL->Text      = LMaxVel;
   edDistanceL->Text    = LDistance;
   edTaccL->Text        = LTacc;
   edTdecL->Text        = LTdec;
   edPositionL->Text    = LPosition;
   edHomeVelL->Text     = LHomeVel;
   edReviewVelL->Text   = LReviewVel;
   edUpLimitL->Text     = LUpLimit;
   edLowDistanceL->Text = LLowDistance;
   // W
   WStartVel              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,W_START_VEL       ,20000);
   WMaxVel                = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,W_MAX_VEL         ,200000);
   WDistance              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,W_DISTANCE        ,500000);
   WTacc                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,W_TACC              ,0.3);
   WTdec                  = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION,W_TDEC              ,0.3);
   WPosition              = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,W_POSITION        ,10000);
   WHomeVel               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,W_HOME_VEL        ,200000);
   WReviewVel             = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,W_REVIEW_VEL      ,200000);
   WUpLimit               = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,W_UP_LIMIT        ,200000);
   WLowDistance           = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,W_LOW_DISTANCE    ,10000);
   edStartVelW->Text    = WStartVel;
   edMaxVelW->Text      = WMaxVel;
   edDistanceW->Text    = WDistance;
   edTaccW->Text        = WTacc;
   edTdecW->Text        = WTdec;
   edPositionW->Text    = WPosition;
   edHomeVelW->Text     = WHomeVel;
   edReviewVelW->Text   = WReviewVel;
   edUpLimitW->Text     = WUpLimit;
   edLowDistanceW->Text = WLowDistance;

   // 2016 6 3 - chc 加入Position: Center/Unload
   // Center
   CenterX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Center X"               ,10000);
   edAOIX->Text = IntToStr(CenterX);
   CenterY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Center Y"               ,10000);
   edAOIY->Text = IntToStr(CenterY);
   CenterZ = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Center Z"               ,10000);
   edAOIZ->Text = IntToStr(CenterZ);
   CenterT = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Center T"               ,10000);
   edAOIT->Text = IntToStr(CenterT);

   // Load
   LoadX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Load X"                   ,10000);
   edLoadX->Text = IntToStr(LoadX);
   LoadY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Load Y"                   ,10000);
   edLoadY->Text = IntToStr(LoadY);
   LoadZ = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Load Z"                   ,10000);
   edLoadZ->Text = IntToStr(LoadZ);
   LoadT = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Load T"                   ,10000);
   edLoadT->Text = IntToStr(LoadT);

   // Original
   OriginalX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Original X"                   ,10000);
   edOriginalX->Text = IntToStr(OriginalX);
   OriginalY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Original Y"                   ,10000);
   edOriginalY->Text = IntToStr(OriginalY);
   OriginalZ = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Original Z"                   ,10000);
   edOriginalZ->Text = IntToStr(OriginalZ);
   OriginalT = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Original T"                   ,10000);
   edOriginalT->Text = IntToStr(OriginalT);

   // 2019 7 14 - chc CCD Position
   CCDX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"CCD X"                   ,10000);
   edCCDX->Text = IntToStr(CCDX);
   CCDY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"CCD Y"                   ,10000);
   edCCDY->Text = IntToStr(CCDY);
   CCDZ = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"CCD Z"                   ,10000);
   edCCDZ->Text = IntToStr(CCDZ);
   CCDT = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"CCD T"                   ,10000);
   edCCDT->Text = IntToStr(CCDT);

   // 2019 12 5 - chc TXT Position
   // 2019 12 11 - chc 不在這裡做
   //TXTX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"TXT X"                   ,0);
   //edkmfX->Text = IntToStr(TXTX);
   //TXTY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"TXT Y"                   ,0);
   //edkmfY->Text = IntToStr(TXTY);

   // 2019 7 30 - chc Last Position
   LastX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"LAST X"                   ,10000);
   edLastX->Text = IntToStr(LastX);
   LastY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"LAST Y"                   ,10000);
   edLastY->Text = IntToStr(LastY);
   LastZ = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"LAST Z"                   ,10000);
   edLastZ->Text = IntToStr(LastZ);
   LastT = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"LAST T"                   ,10000);
   edLastT->Text = IntToStr(LastT);

   // 2021 5 3 - chc RealCenter Position
   RealCenterX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Real Center X"                   ,10000);
   edRealCenterX->Text = IntToStr(RealCenterX);
   RealCenterY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Real Center Y"                        ,10000);
   edRealCenterY->Text = IntToStr(RealCenterY);
   RealCenterZ = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Real Center Z"                   ,10000);
   edRealCenterZ->Text = IntToStr(RealCenterZ);
   RealCenterT = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Real Center T"                   ,10000);
   edRealCenterT->Text = IntToStr(RealCenterT);

   // 2016 5 30 - chc Lasr Cneter, 1278*958(1100*890)
   // 2016 10 30 - chc to parameter: 1278*958(1100*890 => 1020*810)
   //LaserCenterX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Laser Center X"    ,89);
   //LaserCenterY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Laser Center Y"    ,34);
   LaserCenterX = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Laser Center X"    ,129);
   LaserCenterY = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Laser Center Y"    ,74);

   // 2021 4 21 - chc 指定7/8/9/10何者為Enable/Disable: JoystickEnabledKey, JoystickEnabledMode
   JoystickEnabledMode = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Joystick Enable Mode" ,0);
   JoystickEnabledKey = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Joystick Enable Key"   ,9);
   SetJoystickEnabledName();

   // 2019 7 22 - chc Lasr Cneter: 固定為80,67
   // 2021 4 27 - chc 固定為CCDRangeX,CCDRangeY
   //LaserCenterX = 80;
   //LaserCenterY = 35;
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;

   // 顯示LaserCenter
   pnlLaserCenterPosition->Caption = "(" + IntToStr(LaserCenterX) + "," + IntToStr(LaserCenterY) + ")";

   // 2016 10 30 - chc Display in View Window
   pnlLaserCenterPosition1->Caption = pnlLaserCenterPosition->Caption;

   // 2020 4 25 - chc ComPort設定值
   // Robot: COM1/19200(3/0)
   RobotBaudrate = pSystemFile->ReadInteger(LENS_SECTION,ROBOT_BAUDRATE         ,3);
   combRobotBaudrate->ItemIndex = RobotBaudrate;
   combRobotComport->ItemIndex = RobotComPort;
   // LoadPort: COM3/9600(2/1)
   LoadPortBaudrate = pSystemFile->ReadInteger(LENS_SECTION,LOADPORT_BAUDRATE   ,1);
   combLoadPortBaudrate->ItemIndex = LoadPortBaudrate;
   LoadPortComPort = pSystemFile->ReadInteger(LENS_SECTION,LOADPORT_COM_PORT    ,2);
   combLoadPortComport->ItemIndex = LoadPortComPort;
   // Aligner: COM2/19200(1/3)
   AlignerBaudrate = pSystemFile->ReadInteger(LENS_SECTION,ALIGNER_BAUDRATE     ,3);
   combAlignerBaudrate->ItemIndex = AlignerBaudrate;
   AlignerComPort = pSystemFile->ReadInteger(LENS_SECTION,ALIGNER_COM_PORT      ,1);
   combAlignerComport->ItemIndex = AlignerComPort;

   // 2021 9 23b - chc ButtonDelay: edButtonDelay4->Text
   int delaytime = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Button Delay1"         ,5);
   edButtonDelay1->Text = IntToStr(delaytime);
   delaytime = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Button Delay2"             ,5);
   edButtonDelay2->Text = IntToStr(delaytime);
   delaytime = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Button Delay3"             ,5);
   edButtonDelay3->Text = IntToStr(delaytime);
   delaytime = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Button Delay4"             ,5);
   edButtonDelay4->Text = IntToStr(delaytime);

   // 2021 4 11 - chc Yuanli
   YuanliPort = pSystemFile->ReadInteger("Yuanli","Yuanli Port"                 ,1200);
   RFIDComPort = pSystemFile->ReadInteger("Yuanli","RFID Com Port"              ,10);
   combRFIDComport->ItemIndex = RFIDComPort - 1;
   edYuanliPort->Text = IntToStr(YuanliPort);

   delete pSystemFile;

 // 2016 7 30 - chc try-catch
 }
 catch(Exception &e) {
    WriteSystemLog("LoadSystemParameter() - Error");
    sbSystemMessage->Panels->Items[1]->Text = "LoadSystemParameter() - Error";
 }

}
//---------------------------------------------------------------------------
// 存Configuraiton
void __fastcall TMainForm::btnUpdateSystemParameterClick(TObject *Sender)
{

   btnUpdateMotionClick(this);
}
//---------------------------------------------------------------------------
// 由外部Joystick呼叫
bool __fastcall TMainForm::MoveForwardJoystick()
{
TMouseButton Button;
TShiftState Shift;
int X, Y;
static bool active = false;

   // 2011 10 6 - chc Re-Entrant
   if(active == true)
      return false;
   active = true;

   // 2011 10 3 - chc 區分連動
   if(cbContinueMove->Checked == true)
      btnMoveMouseDown(this,Button,Shift,X,Y);
   else

      btnMoveClick(this);

   // 2011 10 6 - chc Re-Entrant
   active = false;
   return true;
}
//---------------------------------------------------------------------------
// 要放在最後面或單獨的程式, 才不會造成干擾!!!
//using namespace Euresys;
// 由外部Joystick呼叫
bool __fastcall TMainForm::MoveBackwardJoystick()
{
TMouseButton Button;
TShiftState Shift;
int X, Y;
static bool active = false;

   // 2011 10 6 - chc Re-Entrant
   if(active == true)
      return false;
   active = true;

   // 2011 10 3 - chc 區分連動
   if(cbContinueMove->Checked == true)
      btnBackwardMouseDown(this,Button,Shift,X,Y);
   else

      btnBackwardClick(this);

   // 2011 10 6 - chc Re-Entrant
   active = false;
   return true;
}
//---------------------------------------------------------------------------
// Basler Shutter
void __fastcall TMainForm::rgBaslerShutterClick(TObject *Sender)
{
int us;
double dus;

   // 2016 12 8 - chc ImagingSource
   if(pnlISCCDStaus->Color != clLime)
      return;
   us = rgBaslerShutter->ItemIndex;
   if(us == 0)
      us = 1000000 / 15;
   else if(us == 1)
      us = 1000000 / 30;
   else if(us == 2)
      us = 1000000 / 60;
   else if(us == 3)
      us = 1000000 / 100;
   else if(us == 4)
      us = 1000000 / 200;
   else if(us == 5)
      us = 1000000 / 500;
   else if(us == 6)
      us = 1000000 / 1000;
   else if(us == 7)
      us = 1000000 / 2000;
   else if(us == 8)
      us = 1000000 / 4000;
   else if(us == 9)
      us = 1000000 / 6000;
   else if(us == 10)
      us = 1000000 / 8000;
   else if(us == 11)
      us = 1000000 / 10000;
   else if(us == 12)
      us = 1000000 / 12000;
   else if(us == 13)
      us = 1000000 / 15000;
   if(us < 60)
      us = 60;
   else if(us > 81900)
      us = 81900;
   // Set Exposure : us
   ICImagingControl1->Exposure = us;
   return;

   // Shutter
   us = rgBaslerShutter->ItemIndex;
   if(us == 0)
      us = 1000000 / 15;
   else if(us == 1)
      us = 1000000 / 30;
   else if(us == 2)
      us = 1000000 / 60;
   else if(us == 3)
      us = 1000000 / 100;
   else if(us == 4)
      us = 1000000 / 200;
   else if(us == 5)
      us = 1000000 / 500;
   else if(us == 6)
      us = 1000000 / 1000;
   else if(us == 7)
      us = 1000000 / 2000;
   else if(us == 8)
      us = 1000000 / 4000;
   else if(us == 9)
      us = 1000000 / 6000;
   else if(us == 10)
      us = 1000000 / 8000;
   else if(us == 11)
      us = 1000000 / 10000;
   else if(us == 12)
      us = 1000000 / 12000;
   else if(us == 13)
      us = 1000000 / 15000;
   if(us < 60) {
      us = 60;
   }
   else if(us > 81900) {
      us = 81900;
   }
   dus = us;
   int no = 0;
   // hDevGigaAry[baslerccdno]
   //PylonDeviceSetFloatFeature(hDevscA1300, STRING_PAR const char *pName, double value);
   res = PylonDeviceSetFloatFeature( hDevGigaAry[no], "ExposureTimeAbs", dus );
   WriteSystemLog("Set Basler CCD Shutter to " + IntToStr(rgBaslerShutter->ItemIndex));
   pnlSystemMessage->Caption = "Set Basler CCD Shutter to " + IntToStr(rgBaslerShutter->ItemIndex);
   lbGiga->Items->Add("Basler CCD Shutter: " + IntToStr(rgBaslerShutter->ItemIndex));
   scA1300ShutterAry[0] = rgBaslerShutter->ItemIndex;
   BaslerShutter = rgBaslerShutter->ItemIndex;
}
//---------------------------------------------------------------------------
// Basler Gain
void __fastcall TMainForm::tbBaslerGainChange(TObject *Sender)
{
int gain;
double fgain;

   // 2016 12 8 - chc ImagingSource
   if(pnlISCCDStaus->Color != clLime)
      return;
   gain = tbBaslerGain->Position;
   pnlBaslerGain->Caption = IntToStr(gain);

   // 2019 11 28 - chc Gain[175 ~ 1020]
   // 0 - 9.21(0-921 ?)
   try {
      ICImagingControl1->Gain = gain;
      pnlAlarmMessage->Caption = "Gain Changed.";
   }
   catch(Exception &e) {
      MainForm->WriteSystemLog(">>Error(GainChange): " + IntToStr(gain) + "," + e.Message);
      pnlSystemMessage->Caption = "GainChange: " + IntToStr(gain) + "," + e.Message;
   }
   return;

   gain = tbBaslerGain->Position;
   pnlBaslerGain->Caption = gain;
   if(gain < 300) {
      gain = 300;
   }
   else if(gain > 850) {
      gain = 850;
   }

   int no = 0;
   res = PylonDeviceFeatureFromString( hDevGigaAry[no], "GainSelector", "GainSelector_All");
   res = PylonDeviceSetIntegerFeature( hDevGigaAry[no], "GainRaw", gain);
   WriteSystemLog("Set Basler CCD Gain to " + IntToStr(gain));
   pnlSystemMessage->Caption = "Set Basler CCD Gain to " + IntToStr(gain);
   lbGiga->Items->Add("Basler CCD Gain: " + IntToStr(gain));
   scA1300GainAry[0] = gain;
   BaslerGain = gain;

}
//---------------------------------------------------------------------------
// 2016 5 11 - chc 處理黃燈閃爍
void __fastcall TMainForm::tm500msTimer(TObject *Sender)
{

   // 2016 7 24 - chc speedup
   if(pnlStartMessage->Visible == true) {
      if(pnlStartMessage->Font->Color == clBlack)
         pnlStartMessage->Font->Color = clSilver;
      else
         pnlStartMessage->Font->Color = clBlack;
   }

   if(boolMotionState == true) {
   }

   // 2016 7 8 - chc Save Last position
   if(pnl7856Status->Color == clLime) {
      // Last position to save?
      if(boolUpdateLastPosition == true) {
         edLastX->Text = edCommandX->Text;
         edLastY->Text = edCommandY->Text;
         edLastZ->Text = edCommandZ->Text;
         edLastT->Text = edCommandT->Text;
      }
   }

   // Update Z Unit
   pnlZUnit->Caption = edDistanceZ->Text;

   // 2023 1 4 - chc 若SESC未連線, 再連線, 30sec
   static int scnt = 0;
   scnt++;
   if(scnt > 60) {
      scnt = 0;
      if(pnlSECSConnect->Color != clLime) {
         WriteSystemLog("SECS Socket重連線...");
         btnSECSReConnectClick(this);
         WriteSystemLog("SECS Socket重連線.");
      }
   }

}
//---------------------------------------------------------------------------
// 2016 5 20 - chc Load/Unload
void __fastcall TMainForm::btnLoadPositionClick(TObject *Sender)
{

   SetLoadPosition();
}
//---------------------------------------------------------------------------
// 2016 5 20 - chc Load/Unload
void __fastcall TMainForm::btnToLoadPositionClick(TObject *Sender)
{

   pnlToLoadPosition->Color = clSilver;
   pnlZeroPosition->Color = clSilver;
   MotionStatus(false);

   // 2016 7 22 - chc Message
   pnlStartMessage->Caption = "To horizontal measurement point...";
   pnlStartMessage->Visible = true;

   // 2020 11 13 - chc Z先上升1000um
   int cmd,pos;
   double fcmd;
   GetPosition(Z_AXIS, &fcmd);
   cmd = fcmd;
   pos = cmd - (1000.0 / Z_RESOLUTION);
   pnlOperationMessage->Caption = "Z上升1000um...";
   pnlSystemMessage->Caption = "Z上升1000um...";
   pnlOperationMessage->Visible = true;

   // 2021 9 11 - chc 加速: MOVE_WAIT
   //if(MoveToZ(pos) == false) {
   if(MoveToZ(pos,MOVE_WAIT) == false) {

      pnlOperationMessage->Caption = "Z上升1000um Fail!";
      pnlSystemMessage->Caption = "Z上升1000um Fail!";
      pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
      goto err;
   }

   ToLoadPosition();

   pnlOperationMessage->Caption = "Z下降1000um...";
   pnlSystemMessage->Caption = "Z下降1000um...";
   pnlOperationMessage->Visible = true;

   // 2021 9 11 - chc 加速: MOVE_WAIT
   //if(MoveToZ(cmd) == false) {
   if(MoveToZ(cmd,MOVE_WAIT) == false) {

      pnlOperationMessage->Caption = "Z下降1000um Fail!";
      pnlSystemMessage->Caption = "Z下降1000um Fail!";
      pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
      goto err;
   }

err:
   // 2016 7 22 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);

}
//---------------------------------------------------------------------------
// 2016 5 26 - chc 加入記錄: FindObj
//typedef struct
//{
//	int    Width;
//	int    Height;
//	double CX;
//	double CY;
//	double Angle;
//	double Scale;
//	double Score;
//}NCCFind;
void __fastcall TMainForm::AddMatchData(int index)
{

   // 2016 11 15 - chc CX,CY要校正
   //AddsgResult(index,FindObj.Width,FindObj.Height,FindObj.CX,FindObj.CY,FindObj.Angle,FindObj.Scale,FindObj.Score);
   AddsgResult(index,FindObj.Width,FindObj.Height,FindObj.CX+OX,FindObj.CY+OY,FindObj.Angle,FindObj.Scale,FindObj.Score);

}
//---------------------------------------------------------------------------
// 2016 5 26 - chc Display matched data
void __fastcall TMainForm::DisplayMatchData(int index)
{
int x,y;
AnsiString tmp;
double score;

   x = sgResult->Cells[RESULT_FIELD_CX][index].ToInt();
   y = sgResult->Cells[RESULT_FIELD_CY][index].ToInt();
   // 存到Global
   MarkCenterX = x;
   MarkCenterY = y;
   score = sgResult->Cells[RESULT_FIELD_SCORE][index].ToDouble();;
   tmp.sprintf("%.3f",score);
   pnlScore->Caption = tmp;
   // 指向
   shMarkMatch->Width = StdImage.GetWidth();
   shMarkMatch->Height = StdImage.GetHeight();
   shMarkMatch->Top = y + imCCD->Top - shMarkMatch->Height/2;
   shMarkMatch->Left = x + imCCD->Left - shMarkMatch->Width/2;
   shMarkMatch->Visible = true;
   // 角度值
   pnlRotateAngle->Caption = sgResult->Cells[RESULT_FIELD_ANGLE][index];
   if(cbMoveToCenter->Checked == true) {

      // 2016 11 16 - chc 要先回到原Table位置(OTableX,OTableY)再做
      I32 x,y;
      GetCommand(X_AXIS, &x);
      GetCommand(Y_AXIS, &y);
      if(x != OTableX || y != OTableY) {
         // X/Y Axis absolute move
         // 2021 9 11 - chc 加速: MOVE_WAIT
         //MoveToXY(OTableX, OTableY);
         MoveToXY(OTableX, OTableY, MOVE_WAIT);

         Sleep(100);
      }

      // 2016 11 17 - chc 有軸控才移動
      if(pnl7856Status->Color == clLime)

         MoveMatchData();
   }
}
//---------------------------------------------------------------------------
// 2016 5 26 - chc Move to Center
void __fastcall TMainForm::MoveMatchData()
{
int no,cx,cy,mcx,mcy,dx,dy;
bool ret;
double fdy,ccdprecision,fdx;
int axisno,position;
I32 cmd;
AnsiString msg;

   try {
      // MarkCenterX, MarkCenterY, edCCDPrecision

      // 2016 6 3 - chc GetLensPrecision
      //ccdprecision = edCCDPrecision1->Text.ToDouble();
      ccdprecision = GetLensPrecision();

      mcx = MarkCenterX;
      mcy = MarkCenterY;
      cx = imCCD->Width / 2;
      cy = imCCD->Height / 2;

      // 2016 11 6 - chc use shVertical & shHorizontal(imCCD: 1020*810)
      // shVertical->Left = 553
      // imCCD->Left = 43
      // imCCD->Width/2=510
      // shHorizontal->Top = 448
      // imCCD->Top = 42
      // imCCD->Height/2=405
      cx = shVertical->Left - imCCD->Left;
      cy = shHorizontal->Top - imCCD->Top;

      // 2016 8 3 - chc Position decided by Recipe
      if(PatternPosition == POSITION_LEFT_UP) {
         mcx = shMarkMatch->Left + 1 - imCCD->Left;
         mcy = shMarkMatch->Top + 1 - imCCD->Top;
      }
      else if(PatternPosition == POSITION_LEFT_DOWN) {
         mcx = shMarkMatch->Left + 1 - imCCD->Left;
         mcy = shMarkMatch->Top + shMarkMatch->Height - 1 - imCCD->Top;
      }
      else if(PatternPosition == POSITION_RIGHT_UP) {
         mcx = shMarkMatch->Left + shMarkMatch->Width - 1 - imCCD->Left;
         mcy = shMarkMatch->Top + 1 - imCCD->Top;
      }
      else if(PatternPosition == POSITION_RIGHT_DOWN) {
         mcx = shMarkMatch->Left + shMarkMatch->Width - 1 - imCCD->Left;
         mcy = shMarkMatch->Top + shMarkMatch->Height - 1 - imCCD->Top;
      }
      if(AperturePosition == POSITION_LEFT_UP) {
         cx = shLaserShutterInner->Left + 1 - imCCD->Left;
         cy = shLaserShutterInner->Top + 1 - imCCD->Top;
      }
      else if(PatternPosition == POSITION_LEFT_DOWN) {
         mcx = shLaserShutterInner->Left + 1 - imCCD->Left;
         mcy = shLaserShutterInner->Top + shLaserShutterInner->Height - 1 - imCCD->Top;
      }
      else if(PatternPosition == POSITION_RIGHT_UP) {
         mcx = shLaserShutterInner->Left + shLaserShutterInner->Width - 1 - imCCD->Left;
         mcy = shLaserShutterInner->Top + 1 - imCCD->Top;
      }
      else if(PatternPosition == POSITION_RIGHT_DOWN) {
         mcx = shLaserShutterInner->Left + shLaserShutterInner->Width - 1 - imCCD->Left;
         mcy = shLaserShutterInner->Top + shLaserShutterInner->Height - 1 - imCCD->Top;
      }

      // Move to Center
      fdx = (mcx - cx) * ccdprecision;
      fdy = (mcy - cy) * ccdprecision;
      if(cbCCDYDirection->Checked == true)
         fdy = 0 - fdy;
      if(cbCCDXDirection->Checked == true)
         fdx = 0 - fdx;
      msg.sprintf("%.3f",fdx);
      pnlXAltOffset->Caption = msg;
      msg.sprintf("%.3f",fdy);
      pnlYAltOffset->Caption = msg;
      // 移動Y軸 - absolute
      axisno = Y_AXIS;
      GetCommand(axisno, &cmd);
      position = cmd + (fdy / Y_RESOLUTION);
      if(MoveToY(position) == false) {
         pnlSystemMessage->Caption = "MatchMove: YMove Fail!";
         pnlYMove->Color = clRed;
         // Beep聲
         Beep(500);

         // 2016 6 4 - chc Alarm Message
         pnlAlarmMessage->Caption = " Y-Axis Move Error!";

      }
      else {
         pnlYMove->Color = clLime;
         pnlSystemMessage->Caption = "MatchMove: YMove Success";
      }
      // 移動X軸 - absolute
      axisno = X_AXIS;
      GetCommand(axisno, &cmd);
      position = cmd + (fdx / X_RESOLUTION);
      if(MoveToX(position) == false) {
         pnlSystemMessage->Caption = "MatchMove: XMove Fail!";
         pnlXMove->Color = clRed;
         // Beep聲
         Beep(500);

         // 2016 6 4 - chc Alarm Message
         pnlAlarmMessage->Caption = " X-Axis Move Error!";

      }
      else {
         pnlXMove->Color = clLime;
         pnlSystemMessage->Caption = "MatchMove: XMove Success";

         // 2016 5 30 - chc 修正所有的CX,CY
         // (MarkCenterX, MarkCenterY) : 第1個Pattern的位置
         MarkCenterX = cx;
         MarkCenterY = cy;
         // 指向
         shMarkMatch->Top = cy + imCCD->Top - shMarkMatch->Height/2;
         shMarkMatch->Left = cx + imCCD->Left - shMarkMatch->Width/2;

         // 2016 11 16 - chc 不能變動! 每次會先回到原始Table位置後再移動
         /*
         dx = mcx - cx;
         dy = mcy - cy;
         for(int i=0 ; i<pnlMatchedNo->Caption.ToInt() ; i++) {
            sgResult->Cells[RESULT_FIELD_CX][i+1] = IntToStr(sgResult->Cells[RESULT_FIELD_CX][i+1].ToInt() - dx);
            sgResult->Cells[RESULT_FIELD_CY][i+1] = IntToStr(sgResult->Cells[RESULT_FIELD_CY][i+1].ToInt() - dy);
         }
         */

      }
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "MatchMove Error!";
   }

}
//---------------------------------------------------------------------------
// 2016 5 26 - chc Select MatchData
void __fastcall TMainForm::sgResultClick(TObject *Sender)
{
int recno;

   if(sgResult->RowCount <= 2) {
      pnlSystemMessage->Caption = "MatchData: No Data Matched!";
      return;
   }
   recno = sgResult->Row;
   if(recno > 0 && recno < sgResult->RowCount-1)
      DisplayMatchData(recno);
}
//---------------------------------------------------------------------------
// 2016 5 30 - chc Default Laser Center: 1278*958(1100*890)
// 89/34
void __fastcall TMainForm::btnResetLaserCenterClick(TObject *Sender)
{

   // 2019 7 22 - chc Lasr Cneter: 固定為80,67
   // 2021 4 27 - chc 固定為CCDRangeX,CCDRangeY
   //LaserCenterX = 80;
   //LaserCenterY = 35;
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;

   return;

   // 2016 10 30 - chc to parameter: 1278*958(1100*890 => 1020*810)
   //LaserCenterX = 89;
   //LaserCenterY = 34;
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;
   shVertical->Left = pnlLeftWindow->Width/2;
   shHorizontal->Top = pnlLeftWindow->Height/2;

   // 寫入ini檔
   TIniFile *pSystemFile;
   // ini檔名與目錄:
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Laser Center X"     ,LaserCenterX);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Laser Center Y"     ,LaserCenterY);

   // 2016 10 3 - chc Lasr Cneter Of Each Lens
   LensPosition[LensNo-1].LaserX = LaserCenterX;
   LensPosition[LensNo-1].LaserY = LaserCenterY;

   delete pSystemFile;
   // 更新顯示
   // 若沒有Refresh就不會顯示
   int no = 0;
   int width = CCDInfoAry[no].Width;
   int height = CCDInfoAry[no].Height;
   int w = imCCD->Width;
   int h = imCCD->Height;
   int sx = LaserCenterX;
   int sy = LaserCenterY;
   int x,y;
   GetImageXY(width,height,sx,sy,w,h,&x,&y);
   usb_ImageROIAry[no].SetPlacement(x,y,w,h);
   usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
   imCCD->Refresh();
   // 顯示LaserCenter
   pnlLaserCenterPosition->Caption = "(" + IntToStr(LaserCenterX) + "," + IntToStr(LaserCenterY) + ")";

   // 2016 10 30 - chc Display in View Window
   pnlLaserCenterPosition1->Caption = pnlLaserCenterPosition->Caption;

   // 2016 10 23 - chc need to update position of Spot Marker box
   shVertical->Left = pnlLeftWindow->Width/2;
   shHorizontal->Top = pnlLeftWindow->Height/2;

}
//---------------------------------------------------------------------------
// 2016 5 30 - chc Original
void __fastcall TMainForm::btnOriginalPositionClick(TObject *Sender)
{

   // 2016 6 2 - chc 錯了!!
   //SetLoadPosition();
   SetOriginalPosition();
}
//---------------------------------------------------------------------------
// 2016 5 30 - chc Original
void __fastcall TMainForm::btnToOriginalPositionClick(TObject *Sender)
{

   pnlOriginal->Color = clSilver;
   pnlToOriginalPosition->Color = clSilver;
   MotionStatus(false);

   // 2016 7 22 - chc Message
   pnlStartMessage->Caption = "To Load location...";
   WriteSystemLog("移動到入料點...");

   pnlStartMessage->Visible = true;

   ToOriginalPosition();
err:
   // 2016 7 22 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);
}
//---------------------------------------------------------------------------
// 2016 6 2 - chc T移動後自動校正X/Y
void __fastcall TMainForm::tmTMoveTimer(TObject *Sender)
{

   if(MainForm->cbContinueMove->Checked == true && boolTMove == false) {

      // 2016 6 6 - chc Log
      WriteSystemLog("Continue But not Available: tmTMoveTimer");

      return;
   }

   // 2016 8 5 - chc Error, be Check boolTMove == false
   //if(MainForm->cbContinueMove->Checked == false && (boolTMove == true || boolJogMove == true)) {
   if(MainForm->cbContinueMove->Checked == false && (boolTMove == false || boolJogMove == true)) {

      // 2016 6 6 - chc Log
      WriteSystemLog("Jog But not Available: tmTMoveTimer");

      return;
   }

   // 2016 6 6 - chc Log
   WriteSystemLog("Enter: tmTMoveTimer");

   // Jog : do after stop(motion done)
   if(MainForm->cbContinueMove->Checked == false) {

      // 2016 6 6 - chc Set Interval
      tmTMove->Interval = 10000;

      tmTMove->Enabled = false;
      WriteSystemLog("Disable(tmTMoveTimer-Jog): tmTMoveTimer");
      I16 mstatust;
      mstatust = 0;

      // 2021 4 15 - chc 8154 or APS_
      if(MotionMode == MOTION_MODE_APS) {
         I32 done;
         done = APS_motion_status(T_AXIS+StartAxisNo);
         // 看bit 0 : 不等於0(Done)
         if((done & 0x01) == 0)
            mstatust = 1;
      }
      // moving...
      if(mstatust != 0 && mstatust != 17 && mstatust != 18) {

         // 2016 6 6 - chc Set Interval
         tmTMove->Interval = 100;

         return;
      }
      DelayTimeM5(50);
   }
   else {

      // 2016 6 6 - chc Set Interval
      tmTMove->Interval = 10000;

      tmTMove->Enabled = false;
      WriteSystemLog("Disable(tmTMoveTimer): tmTMoveTimer");
   }

   // 2016 7 28 - chc Log
   WriteSystemLog("Do ToAdjustXY() - Last Time");

   // T移動後自動校正X/Y
   ToAdjustXY();

   // Jog : do after stop
   if(MainForm->cbContinueMove->Checked == true) {

      // 2016 6 6 - chc Set Interval
      tmTMove->Interval = 100;

      tmTMove->Enabled = true;
      WriteSystemLog("Enable(tmTMoveTimer): tmTMoveTimer");
   }
}
//---------------------------------------------------------------------------
// 2016 6 3 - chc GetLensPrecision
double __fastcall TMainForm::GetLensPrecision()
{
int no;
double ccdprecision = 5.38;
AnsiString msg;

   no = LensNo;
   switch(no) {
      case 1:
         ccdprecision = edCCDPrecision1->Text.ToDouble();
         break;
      case 2:
         ccdprecision = edCCDPrecision2->Text.ToDouble();
         break;
      case 3:
         ccdprecision = edCCDPrecision3->Text.ToDouble();
         break;
      case 4:
         ccdprecision = edCCDPrecision4->Text.ToDouble();
         break;
      case 5:
         ccdprecision = edCCDPrecision5->Text.ToDouble();
         break;
      case 6:
         ccdprecision = edCCDPrecision6->Text.ToDouble();
         break;
   }

   // 2021 4 27 - chc Olympus CCD Precision
   msg.sprintf("%.4f",ccdprecision);
   pnlOlympusLensPrecision->Caption = msg;

   // 2019 7 15 - chc 固定為單一精度
   ccdprecision = MotionCCDPrecision;

   // 2019 10 17 - chc 定義CCDPrecision參數化
   ccdprecision = edCCDPrecision->Text.ToDouble();

   // 2016 6 13 - chc 加入精度值顯示
   msg.sprintf("%.4f",ccdprecision);
   pnlLensPrecision->Caption = msg;

   // 2016 7 9 - chc 400 Pixel distance
   double dis = pnlWidthValue->Width * ccdprecision;

   // 2021 4 27 - chc CCD full image
   if(cbCCDFullImage->Checked == true) {
      dis = (dis * CCDInfoAry[0].Width) / imCCD->Width;
   }

   msg.sprintf("%.2fum",dis);
   pnlWidthValue->Caption = msg;

   return(ccdprecision);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlAlarmMessageClick(TObject *Sender)
{

   // 2020 5 6 - chc 不動作
   return;

   pnlAlarmMessage->Caption = "";
   MainForm->iAxisMove[X_AXIS] = NO_MOVE;
   MainForm->iAxisMove[Y_AXIS] = NO_MOVE;
   MainForm->iAxisMove[Z_AXIS] = NO_MOVE;
   MainForm->iAxisMove[T_AXIS] = NO_MOVE;

   // 2016 6 6 - chc Set Interval
   tmTMove->Interval = 10000;

   tmTMove->Enabled = false;
}
//---------------------------------------------------------------------------
// 2016 6 16 - chc 加入個別Reset Button
void __fastcall TMainForm::btnResetClick(TObject *Sender)
{

   pnlAlarmMessageClick(this);
   pnlAlarmMessage->Caption = "";

   // 2020 5 6 - chc 強制pcRobot為enable
   pcEFEMH->Enabled = true;
   pcEFEMR->Enabled = true;

   // 2020 5 20a - chc Error Log
   AddErrorLog("[System] Error Reset.");

}
//---------------------------------------------------------------------------
// 2016 7 8 - chc To Last Position
void __fastcall TMainForm::btnToLastPositionClick(TObject *Sender)
{

   pnlToLastPosition->Color = clSilver;
   MotionStatus(false);

   // 2019 7 14 - chc Message
   pnlStartMessage->Caption = "Moving to Last...";
   pnlStartMessage->Visible = true;

   ToLastPosition();

err:
   // 2019 7 14 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);
}
//---------------------------------------------------------------------------
// 2016 7 8 - chc To Last Position
void __fastcall TMainForm::btnLastPositionClick(TObject *Sender)
{

   SetLastPosition();
}
//---------------------------------------------------------------------------
// 2016 7 8 - chc To Last Position
void __fastcall TMainForm::btnToLastNoClick(TObject *Sender)
{

   pnlToLast->Visible = false;

   // 2016 7 9 - chc set Last position to save
   boolUpdateLastPosition = true;
}
//---------------------------------------------------------------------------
// 2016 7 8 - chc To Last Position
void __fastcall TMainForm::btnToLastYesClick(TObject *Sender)
{

   btnToLastPositionClick(this);
   pnlToLast->Visible = false;

   // 2016 7 9 - chc set Last position to save
   boolUpdateLastPosition = true;
}
//---------------------------------------------------------------------------
// CCW 1x
void __fastcall TMainForm::btnCCW1xClick(TObject *Sender)
{

   CWMove(1);
}
//---------------------------------------------------------------------------
// CCW 5x
void __fastcall TMainForm::btnCCW5xClick(TObject *Sender)
{

   CWMove(10);
}
//---------------------------------------------------------------------------
// CCW 10x
void __fastcall TMainForm::btnCCW10xClick(TObject *Sender)
{

   CWMove(100);
}
//---------------------------------------------------------------------------
// CW 10x
void __fastcall TMainForm::btnCW10xClick(TObject *Sender)
{

   CCWMove(100);
}
//---------------------------------------------------------------------------
// CW 5x
void __fastcall TMainForm::btnCW5xClick(TObject *Sender)
{

   CCWMove(10);
}
//---------------------------------------------------------------------------
// CW 1x
void __fastcall TMainForm::btnCW1xClick(TObject *Sender)
{

   CCWMove(1);
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::CWMove(int no)
{
int distance;
bool continuemode;

   continuemode = cbContinueMove->Checked;
   // Set Jog & new Distance
   cbContinueMove->Checked = false;
   distance = edDistanceT->Text.ToInt();
   edDistanceT->Text = IntToStr(distance*no);

   // 2016 7 28 - chc 要Disable所有移動
   ToggleMove(false);

   // Use tr_line3() - do three axises move at same time
   MainForm->CurrentAxisNo = T_AXIS;
   // 是看combAxis->ItemIndex; 不是CurrentAxisNo
   MainForm->combAxis->ItemIndex = T_AXIS;
   btnMoveTClick(this);

   // Restore
   cbContinueMove->Checked = continuemode;
   edDistanceT->Text = IntToStr(distance);

   // 2016 7 28 - chc 要enable所有移動
   ToggleMove(true);
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::CCWMove(int no)
{
int distance;
bool continuemode;

   continuemode = cbContinueMove->Checked;
   // Set Jog & new Distance
   cbContinueMove->Checked = false;
   distance = edDistanceT->Text.ToInt();
   edDistanceT->Text = IntToStr(distance*no);

   // 2016 7 28 - chc 要Disable所有移動
   ToggleMove(false);

   // Use tr_line3() - do three axises move at same time
   MainForm->CurrentAxisNo = T_AXIS;
   // 是看combAxis->ItemIndex; 不是CurrentAxisNo
   MainForm->combAxis->ItemIndex = T_AXIS;
   btnBackwardTClick(this);

   // Restore
   cbContinueMove->Checked = continuemode;
   edDistanceT->Text = IntToStr(distance);

   // 2016 7 28 - chc 要Enable所有移動
   ToggleMove(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLeft10xClick(TObject *Sender)
{

   // 2019 12 18 - chc 方向相反
   //LeftMove(100);
   // 2019 12 23 - chc Table方向
   if(cbTableDirection->Checked == true)
      LeftMove(100);
   else

      RightMove(100);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLeft5xClick(TObject *Sender)
{

   // 2019 12 18 - chc 方向相反
   //LeftMove(10);
   // 2019 12 23 - chc Table方向
   if(cbTableDirection->Checked == true)
      LeftMove(10);
   else

      RightMove(10);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLeft1xClick(TObject *Sender)
{

   // 2019 12 18 - chc 方向相反
   //LeftMove(1);
   // 2019 12 23 - chc Table方向
   if(cbTableDirection->Checked == true)
      LeftMove(1);
   else

      RightMove(1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRight1xClick(TObject *Sender)
{

   // 2019 12 18 - chc 方向相反
   //RightMove(1);
   // 2019 12 23 - chc Table方向
   if(cbTableDirection->Checked == true)
      RightMove(1);
   else

      LeftMove(1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRight5xClick(TObject *Sender)
{

   // 2019 12 18 - chc 方向相反
   //RightMove(10);
   // 2019 12 23 - chc Table方向
   if(cbTableDirection->Checked == true) {

      WriteSystemLog("X 5x: 10");
      RightMove(10);
   }
   else {

      LeftMove(10);
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRight10xClick(TObject *Sender)
{

   // 2019 12 18 - chc 方向相反
   //RightMove(100);
   // 2019 12 23 - chc Table方向
   if(cbTableDirection->Checked == true)
      RightMove(100);
   else

      LeftMove(100);
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::RightMove(int no)
{
int distance;
bool continuemode;

   // 2021 4 21 - chc Log
   WriteSystemLog("RightMove(a) no = " + IntToStr(no));

   // 2019 12 13 - chc 可加速
   if(cbSpeedUp->Checked == true)
      no *= 2;

   // 2021 4 21 - chc Log
   WriteSystemLog("RightMove(b) no = " + IntToStr(no));

   continuemode = cbContinueMove->Checked;
   // Set Jog & new Distance
   cbContinueMove->Checked = false;
   distance = edDistanceX->Text.ToInt();
   edDistanceX->Text = IntToStr(distance*no);

   // 2021 4 21 - chc Log
   WriteSystemLog("RightMove() dis = " + edDistanceX->Text);

   // 2016 7 28 - chc 要Disable所有移動
   ToggleMove(false);

   btnMoveXClick(this);

   // Restore
   cbContinueMove->Checked = continuemode;
   edDistanceX->Text = IntToStr(distance);

   // 2016 7 28 - chc 要Enable所有移動
   ToggleMove(true);
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::LeftMove(int no)
{
int distance;
bool continuemode;

   // 2019 12 13 - chc 可加速
   if(cbSpeedUp->Checked == true)
      no *= 2;

   continuemode = cbContinueMove->Checked;
   // Set Jog & new Distance
   cbContinueMove->Checked = false;
   distance = edDistanceX->Text.ToInt();
   edDistanceX->Text = IntToStr(distance*no);

   // 2016 7 28 - chc 要Disable所有移動
   ToggleMove(false);

   btnBackwardXClick(this);

   // Restore
   cbContinueMove->Checked = continuemode;
   edDistanceX->Text = IntToStr(distance);

   // 2016 7 28 - chc 要Enable所有移動
   ToggleMove(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRear10xClick(TObject *Sender)
{

   FrontMove(100);

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRear5xClick(TObject *Sender)
{

   FrontMove(10);

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRear1xClick(TObject *Sender)
{

   FrontMove(1);

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnFront1xClick(TObject *Sender)
{

   RearMove(1);

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnFront5xClick(TObject *Sender)
{

   RearMove(10);

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnFront10xClick(TObject *Sender)
{

   RearMove(100);

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::FrontMove(int no)
{
int distance;
bool continuemode;

   // 2019 12 13 - chc 可加速
   if(cbSpeedUp->Checked == true)
      no *= 2;

   continuemode = cbContinueMove->Checked;
   // Set Jog & new Distance
   cbContinueMove->Checked = false;
   distance = edDistanceY->Text.ToInt();
   edDistanceY->Text = IntToStr(distance*no);

   // 2016 7 28 - chc 要Disable所有移動
   ToggleMove(false);

   btnMoveYClick(this);

   // Restore
   cbContinueMove->Checked = continuemode;
   edDistanceY->Text = IntToStr(distance);

   // 2016 7 28 - chc 要enable所有移動
   ToggleMove(true);
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::RearMove(int no)
{
int distance;
bool continuemode;

   // 2019 12 13 - chc 可加速
   if(cbSpeedUp->Checked == true)
      no *= 2;

   continuemode = cbContinueMove->Checked;
   // Set Jog & new Distance
   cbContinueMove->Checked = false;
   distance = edDistanceY->Text.ToInt();
   edDistanceY->Text = IntToStr(distance*no);

   // 2016 7 28 - chc 要Disable所有移動
   ToggleMove(false);

   btnBackwardYClick(this);

   // Restore
   cbContinueMove->Checked = continuemode;
   edDistanceY->Text = IntToStr(distance);

   // 2016 7 28 - chc 要Enable所有移動
   ToggleMove(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnUp10xClick(TObject *Sender)
{

   UpMove(100);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnUp5xClick(TObject *Sender)
{

   UpMove(10);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnUp1xClick(TObject *Sender)
{

   UpMove(1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnDown1xClick(TObject *Sender)
{

   DownMove(1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnDown5xClick(TObject *Sender)
{

   DownMove(10);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnDown10xClick(TObject *Sender)
{

   DownMove(100);
}
//---------------------------------------------------------------------------
long ZStartTime = 0;
long ZStopTime;
long ZElapsedms;
short ZStartTick = 0;
short ZStopTick;
void __fastcall TMainForm::UpMove(int no)
{
int distance;
bool continuemode;
AnsiString msg;

   // 2019 12 13 - chc 可加速
   if(cbSpeedUp->Checked == true)
      no *= 2;

   SetZMoveStatus(false);

   continuemode = cbContinueMove->Checked;
   // Set Jog & new Distance
   cbContinueMove->Checked = false;
   distance = edDistanceZ->Text.ToInt();
   edDistanceZ->Text = IntToStr(distance*no);

   // 2021 4 21 - chc 若為Z則要限制下限
   int limit,cmd,epos,offset;
   limit = MainForm->GetZLimit();
   double fcmd;
   GetPosition(Z_AXIS, &fcmd);
   cmd = fcmd;
   epos = cmd + (distance*no);
   if(epos > limit) {
      offset = limit - cmd;
      edDistanceZ->Text = IntToStr(offset);
   }

   // 2016 7 28 - chc 要Disable所有移動
   ToggleMove(false);

   btnBackwardZClick(this);

   // Restore
   cbContinueMove->Checked = continuemode;
   edDistanceZ->Text = IntToStr(distance);

   // 2016 7 28 - chc 要Enable所有移動
   ToggleMove(true);

   // 2019 10 29 - chc 顯示
   SetZMoveStatus(true);

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::DownMove(int no)
{
int distance;
bool continuemode;
AnsiString msg;

   // 2019 12 13 - chc 可加速
   if(cbSpeedUp->Checked == true)
      no *= 2;

   SetZMoveStatus(false);

   continuemode = cbContinueMove->Checked;
   // Set Jog & new Distance
   cbContinueMove->Checked = false;
   distance = edDistanceZ->Text.ToInt();
   edDistanceZ->Text = IntToStr(distance*no);

   // 2016 7 28 - chc 要Disable所有移動
   ToggleMove(false);

   btnMoveZClick(this);

   // Restore
   cbContinueMove->Checked = continuemode;
   edDistanceZ->Text = IntToStr(distance);

   // 2016 7 28 - chc 要Enable所有移動
   ToggleMove(true);

   // 2019 10 29 - chc 顯示
   SetZMoveStatus(true);
   
}
//---------------------------------------------------------------------------
// User Position
void __fastcall TMainForm::btnPos1SetClick(TObject *Sender)
{

   SetUserPosition(1);
}
//---------------------------------------------------------------------------
// User Position
void __fastcall TMainForm::btnPos2SetClick(TObject *Sender)
{

   SetUserPosition(2);
}
//---------------------------------------------------------------------------
// User Position
void __fastcall TMainForm::btnPos3SetClick(TObject *Sender)
{

   SetUserPosition(3);
}
//---------------------------------------------------------------------------
// User Position
void __fastcall TMainForm::btnPos5SetClick(TObject *Sender)
{

   SetUserPosition(5);
}
//---------------------------------------------------------------------------
// 2016 7 9 - chc Position Move
void __fastcall TMainForm::btnPositionSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;

   pnlSystemMessage->Caption = "Update User Parameter...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->UserINIFilename);
   pnlPositionGo->Color = clSilver;

   // 2020 2 8 - chc 改成10點
   //for(int i=0 ; i<5 ; i++) {
   for(int i=0 ; i<10 ; i++) {

      edx = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(i+1) + "X"));
      edy = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(i+1) + "Y"));
      edz = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(i+1) + "Z"));
      edt = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(i+1) + "T"));
      x = edx->Text.ToInt();
      y = edy->Text.ToInt();
      z = edz->Text.ToInt();
      t = edt->Text.ToInt();
      pSystemFile->WriteInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "X"    ,x);
      pSystemFile->WriteInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "Y"    ,y);
      pSystemFile->WriteInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "Z"    ,z);
      pSystemFile->WriteInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "T"    ,t);
   }

   delete pSystemFile;
   pnlSystemMessage->Caption = "Update User Parameter Completed.";
   pnlPositionGo->Color = clLime;

}
//---------------------------------------------------------------------------
// 2016 7 9 - chc Load User Position
void __fastcall TMainForm::LoadUserPosition()
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;

   pnlSystemMessage->Caption = "Update User Parameter...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->UserINIFilename);

 // 2016 7 30 - chc try-catch
 try {

   // 2020 2 8 - chc 改成10點
   //for(int i=0 ; i<5 ; i++) {
   for(int i=0 ; i<10 ; i++) {

      x = pSystemFile->ReadInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "X",0);
      y = pSystemFile->ReadInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "Y",0);
      z = pSystemFile->ReadInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "Z",0);
      t = pSystemFile->ReadInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "T",0);
      edx = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(i+1) + "X"));
      edy = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(i+1) + "Y"));
      edz = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(i+1) + "Z"));
      edt = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(i+1) + "T"));
      edx->Text = IntToStr(x);
      edy->Text = IntToStr(y);
      edz->Text = IntToStr(z);
      edt->Text = IntToStr(t);
   }

 // 2016 7 30 - chc try-catch
 }
 catch(Exception &e) {
    WriteSystemLog("LoadUserPosition() - Error");
    sbSystemMessage->Panels->Items[1]->Text = "LoadUserPosition() - Error";
 }

   delete pSystemFile;
   pnlSystemMessage->Caption = "Update User Parameter Completed.";

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos1GoClick(TObject *Sender)
{
int no;

   no = 1;
   MotionStatus(false);

   // 2016 7 22 - chc Message
   pnlStartMessage->Caption = "To Point 1...";
   pnlStartMessage->Visible = true;

   ToUserPosition(no);

   // 2016 7 22 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos2GoClick(TObject *Sender)
{
int no;

   no = 2;
   MotionStatus(false);

   // 2016 7 22 - chc Message
   pnlStartMessage->Caption = "To Point 2...";
   pnlStartMessage->Visible = true;

   ToUserPosition(no);

   // 2016 7 22 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos3GoClick(TObject *Sender)
{
int no;

   no = 3;
   MotionStatus(false);

   // 2016 7 22 - chc Message
   pnlStartMessage->Caption = "To Point 3...";
   pnlStartMessage->Visible = true;

   ToUserPosition(no);

   // 2016 7 22 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos4GoClick(TObject *Sender)
{
int no;

   no = 4;
   MotionStatus(false);

   // 2016 7 22 - chc Message
   pnlStartMessage->Caption = "To Point 4...";
   pnlStartMessage->Visible = true;

   ToUserPosition(no);

   // 2016 7 22 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos5GoClick(TObject *Sender)
{
int no;

   no = 5;
   MotionStatus(false);

   // 2016 7 22 - chc Message
   pnlStartMessage->Caption = "To Point 5...";
   pnlStartMessage->Visible = true;

   ToUserPosition(no);

   // 2016 7 22 - chc Message
   pnlStartMessage->Visible = false;

   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnUp100xClick(TObject *Sender)
{

   UpMove(1000);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnDown100xClick(TObject *Sender)
{

   DownMove(1000);
}
//---------------------------------------------------------------------------
// Rotate text
void __fastcall TMainForm::pnlSystemClick(TObject *Sender)
{
LOGFONT lf;                             // Windows native font structure

    imCCD->Canvas->Brush->Style = bsClear;     // set the brush style to transparent
    ZeroMemory(&lf, sizeof(LOGFONT));

    lf.lfHeight = 20;
    lf.lfEscapement = 10 * 45;          // degrees to rotate
    lf.lfOrientation = 10 * 45;
    lf.lfCharSet = DEFAULT_CHARSET;
    strcpy(lf.lfFaceName, "Tahoma");

    imCCD->Canvas->Font->Handle = CreateFontIndirect(&lf);
    imCCD->Canvas->TextOut(10, 100, "Rotated text"); // output the rotated font
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlMatchDataCloseClick(TObject *Sender)
{

   gbMatchData->Visible = false;
}
//---------------------------------------------------------------------------
bool boolMatchDataMove = false;
int MatchDataX,MatchDataY;
void __fastcall TMainForm::gbMatchDataMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolMatchDataMove = true;
   MatchDataX = X;
   MatchDataY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::gbMatchDataMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{

   if(boolMatchDataMove == true) {
      gbMatchData->Left += (X - MatchDataX);
      gbMatchData->Top += (Y - MatchDataY);
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::gbMatchDataMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolMatchDataMove = false;
   MatchDataX = X;
   MatchDataY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::shLaserShutterInnerMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy,x,y;

   x = X + shLaserShutterInner->Left - imCCD->Left;
   y = Y + shLaserShutterInner->Top - imCCD->Top;

   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imCCD->Canvas->Pixels[x][y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = x + sx;
   pnlCCDY->Caption = y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",x,y);
   sbSystemMessage->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystemMessage->Panels->Items[4]->Text = str;

   // 2016 10 13 - chc Measurement
   if(MeasureState == 1 && cbMeasure->Checked == true)
      imCCDMouseMove(this,Shift,x, y);

}
//---------------------------------------------------------------------------
// 2016 7 13 - chc Alt-LeftMouse to Center
void __fastcall TMainForm::shLaserShutterInnerMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   imCCDMouseUp(this,Button,Shift,X + shLaserShutterInner->Left - imCCD->Left,Y + shLaserShutterInner->Top - imCCD->Top);
}
//---------------------------------------------------------------------------
// 2016 7 13 - chc Alt-LeftMouse to Center
void __fastcall TMainForm::shLaserShutterOuterMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   imCCDMouseUp(this,Button,Shift,X + shLaserShutterOuter->Left - imCCD->Left,Y + shLaserShutterOuter->Top - imCCD->Top);
}
//---------------------------------------------------------------------------
// 2016 7 13 - chc Vertical or Horizontal
void __fastcall TMainForm::cbAngularHorizontalClick(TObject *Sender)
{

   if(cbAngularHorizontal->Checked == true) {
      laFirst->Caption = "Left";
      laSecond->Caption = "Right";
   }
   else {
      laFirst->Caption = "Up";
      laSecond->Caption = "Down";
   }
}
//---------------------------------------------------------------------------
// Array Left
void __fastcall TMainForm::btnArray1LeftClick(TObject *Sender)
{
double fdx;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // X軸
   fdx = edArray1WidthRecipe->Text.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetCommand(axisno, &cmd);
   position = cmd - (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "Array Left : XMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " X-Axis Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "Array Left : XMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnArray2LeftClick(TObject *Sender)
{
double fdx;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // X軸
   fdx = edArray2WidthRecipe->Text.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetCommand(axisno, &cmd);
   position = cmd - (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "array Left : XMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " X-Axis Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "array Left : XMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnArray1RightClick(TObject *Sender)
{
double fdx;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // X軸
   fdx = edArray1WidthRecipe->Text.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetCommand(axisno, &cmd);
   position = cmd + (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "Array Right : XMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " X-Axis Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "Array Right : XMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnArray2RightClick(TObject *Sender)
{
double fdx;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // X軸
   fdx = edArray2WidthRecipe->Text.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetCommand(axisno, &cmd);
   position = cmd + (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "array Right : XMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " X-Axis Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "array Right : XMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnArray1UpClick(TObject *Sender)
{
double fdy;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // Y軸
   fdy = edArray1HeightRecipe->Text.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetCommand(axisno, &cmd);

   // 2016 7 22 - chc Direction reverse!!
   //position = cmd - (fdy / Y_RESOLUTION);
   position = cmd + (fdy / Y_RESOLUTION);

   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "Array Up : YMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "Array Up : YMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnArray2UpClick(TObject *Sender)
{
double fdy;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // Y軸
   fdy = edArray2HeightRecipe->Text.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetCommand(axisno, &cmd);

   // 2016 7 22 - chc Direction reverse!!
   //position = cmd - (fdy / Y_RESOLUTION);
   position = cmd + (fdy / Y_RESOLUTION);

   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "array Up : YMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "array Up : YMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnArray1DownClick(TObject *Sender)
{
double fdy;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // Y軸
   fdy = edArray1HeightRecipe->Text.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetCommand(axisno, &cmd);

   // 2016 7 22 - chc Direction reverse!!
   //position = cmd + (fdy / Y_RESOLUTION);
   position = cmd - (fdy / Y_RESOLUTION);

   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "Array Down : YMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "Array Down : YMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnArray2DownClick(TObject *Sender)
{
double fdy;
int axisno,position;
I32 cmd;

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = false;

   // Y軸
   fdy = edArray2HeightRecipe->Text.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetCommand(axisno, &cmd);

   // 2016 7 22 - chc Direction reverse!!
   //position = cmd + (fdy / Y_RESOLUTION);
   position = cmd - (fdy / Y_RESOLUTION);

   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "array Down : YMove Fail!";
      // Beep聲
      Beep(500);

      // 2016 6 4 - chc Alarm Message
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";

   }
   else {
      pnlSystemMessage->Caption = "array Down : YMove Success";
   }

   // 2016 7 23 - chc Disable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// 2016 7 18 - chc Backlash control
void __fastcall TMainForm::ResetBacklash()
{

   XLastDir = MOVE_NONE;
   YLastDir = MOVE_NONE;
   XLastPos = edCommandX->Text.ToInt();
   YLastPos = edCommandY->Text.ToInt();
}
//---------------------------------------------------------------------------
// 2016 7 20 - chc for test
void __fastcall TMainForm::pnlRecipeSetClick(TObject *Sender)
{

   if(tsMotion->Enabled == false)
      WriteSystemLog("tsMotion->Enabled == false");
   if(pcMotion->Enabled == false)
      WriteSystemLog("pcMotion->Enabled == false");

   // for test, 正常需要
   tsMotion->Enabled = true;
   pcMotion->Enabled = true;

   // 2020 2 14a - chc 也要啟動pcOP
   pcOP->Enabled = true;

   // 2020 5 12 - chc 也啟動pcRobot
   pcEFEMH->Enabled = true;
   pcEFEMR->Enabled = true;
   pcSystem->Enabled = true;

   return;

   // 測試CSV檔案讀取
   AnsiString visionrecipe = "8um SHS";
   AnsiString databasepath = "F:\\WindowsAP\\Bruker\\Database";
   AnsiString visionrecipefname = databasepath + "\\" + visionrecipe + ".csv";
   if(FileExists(visionrecipefname)) {
      FILE *fp;
      char buf[100];
      int no,len;len = 100;
      int cnt = 0;
      // a. 先備份\Backup\VisionRecipe-yyyymmdd-hhmmss.csv
      // b. 保留10 Rows, 餘刪除
      // c. 量測結束再取回(Copy)檔案
      // 1. TimeStamp,Step Avg,Step Std Dev
      // 2. ,μm,nm
      // 3. R: N/A,R: N/A,R: N/A
      // 4. M: N/A,M: N/A,M: N/A
      // 5. Always,Always,Always
      // 6. Always,Always,Always
      // 7. ,,
      // 8. ,,
      // 9. Meta Data,Step Height,Step Height
      //10.
      //11. 2019/07/16 14:00:02.238,0.00630362959703151,8.62428157006949
      if((fp = fopen(visionrecipefname.c_str(),"rt")) != NULL) {
         while(fgets(buf, 128, fp) != NULL) {
            //fgets會把每一行資訊copy到login_info字元陣列
            cnt++;
         }
      //if(no = fread(buf,sizeof(char),len,fp) != len) {
      //   fclose(fp);
      //}
      }
   }

   return;

   // 2017 12 27 - chc for test: 校正值
   double fx,fy,x1,y1,x2,y2,resolution;
   int cx,cy,x,y;
   x1 = 60000;
   x2 = 60000;
   y1 = 60001;
y1 = 60165;
   y2 = 1859963;
y2 = 55000;
y2 = 1560103;
   x = 446;
   y = 446;
   resolution = GetLensPrecision();
   resolution = 0.48;                                           // 20x => 10x
   cx = shVertical->Left - imCCD->Left;
   cy = shHorizontal->Top - imCCD->Top;
   x1 += ((double)(x-cx)*resolution/X_RESOLUTION);
   y1 += ((double)(y-cy)*resolution/Y_RESOLUTION);
   x2 += ((double)(x-cx)*resolution/X_RESOLUTION);
   y2 += ((double)(y-cy)*resolution/Y_RESOLUTION);
   GetFactor(&fx,&fy,x1,y1,x2,y2);
   double tx,ty;
   tx = x2 - x1;
   ty = y2 - y1;
   tx *= X_RESOLUTION;
   ty *= Y_RESOLUTION;
   tx *= fx;
   ty *= fy;

   // 2018 1 7 - chc 使用fx,fy
   tx = fx * X_RESOLUTION;
   ty = fy * Y_RESOLUTION;

   // for test
   pnlFocusWin->Visible = true;
   return;

   tsMotion->Enabled = true;
   pcMotion->Enabled = true;

   // 2016 10 23 - chc for test
   pnlStartMessage->Visible = false;

}
//---------------------------------------------------------------------------
// 2016 7 22 - chc Backlash Mode
// 2016 7 22 - chc 取消
void __fastcall TMainForm::pnlRemoteLeftClick(TObject *Sender)
{

   pnlRemoteLeft->Color = clSilver;
   
}
//---------------------------------------------------------------------------
// 2016 7 22 - chc 取消
void __fastcall TMainForm::pnlRemoteRightClick(TObject *Sender)
{

   pnlRemoteRight->Color = clSilver;
}
//---------------------------------------------------------------------------
// 2016 7 24 - chc Blinking
void __fastcall TMainForm::tm400msTimer(TObject *Sender)
{

   // 2021 5 5 - chc Motion error
   if(bool_APS_Status == false) {
      pnlHome2->Enabled = false;

      // 2021 10 6 - chc 顯示目前Table所在的Die Col/Row
      if(boolForTest == true)
         UpdateDiePosition();

      return;
   }

   if(boolAllHomeState == true) {
      if(btnHome2->Font->Color == clBlack)
         btnHome2->Font->Color = clSilver;
      else
         btnHome2->Font->Color = clBlack;
   }

   // 2021 10 6 - chc 顯示目前Table所在的Die Col/Row
   UpdateDiePosition();

}
//---------------------------------------------------------------------------
// 2016 7 28 - chc 要Disable所有移動
void __fastcall TMainForm::ToggleMove(bool mode)
{

   pnlMoveTop->Enabled = mode;
   pnlMoveBottom->Enabled = mode;
   pnlMoveLeft->Enabled = mode;
   pnlMoveRight->Enabled = mode;

   btnMoveT1->Enabled = mode;
   btnCCW10x->Enabled = mode;
   btnCCW5x->Enabled = mode;
   btnCCW1x->Enabled = mode;
   btnCW1x->Enabled = mode;
   btnCW5x->Enabled = mode;
   btnCW10x->Enabled = mode;
   btnBackwardT1->Enabled = mode;
}
//---------------------------------------------------------------------------
// 2016 7 29 - chc Pos4: set
void __fastcall TMainForm::btnPos4SetClick(TObject *Sender)
{

   SetUserPosition(4);
}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Set Lens1 Position
void __fastcall TMainForm::btnSetLens1PositionClick(TObject *Sender)
{

   SetLensPosition(1);
}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Set Lens2 Position
void __fastcall TMainForm::btnSetLens2PositionClick(TObject *Sender)
{

   SetLensPosition(2);
}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Set Lens3 Position
void __fastcall TMainForm::btnSetLens3PositionClick(TObject *Sender)
{

   SetLensPosition(3);
}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Set Lens4 Position
void __fastcall TMainForm::btnSetLens4PositionClick(TObject *Sender)
{

   SetLensPosition(4);
}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Set Lens5 Position
void __fastcall TMainForm::btnSetLens5PositionClick(TObject *Sender)
{

   SetLensPosition(5);
}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Set Lens6 Position
void __fastcall TMainForm::btnSetLens6PositionClick(TObject *Sender)
{

   SetLensPosition(6);
}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Go Lens1 Position
// true: 不用移動或已移到SafeZ
void __fastcall TMainForm::btnToLens1PositionClick(TObject *Sender)
{

   pnlToLens1Position->Color = clSilver;
   ToLensPosition(1);

}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Go Lens2 Position
void __fastcall TMainForm::btnToLens2PositionClick(TObject *Sender)
{

   pnlToLens2Position->Color = clSilver;
   ToLensPosition(2);

}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Go Lens3 Position
void __fastcall TMainForm::btnToLens3PositionClick(TObject *Sender)
{

   pnlToLens3Position->Color = clSilver;
   ToLensPosition(3);

}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Go Lens4 Position
void __fastcall TMainForm::btnToLens4PositionClick(TObject *Sender)
{

   pnlToLens4Position->Color = clSilver;
   ToLensPosition(4);

}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Go Lens5 Position
void __fastcall TMainForm::btnToLens5PositionClick(TObject *Sender)
{

   pnlToLens5Position->Color = clSilver;
   ToLensPosition(5);

}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Go Lens6 Position
void __fastcall TMainForm::btnToLens6PositionClick(TObject *Sender)
{

   pnlToLens6Position->Color = clSilver;
   ToLensPosition(6);

}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Save Lens Position
void __fastcall TMainForm::btnSaveLensPositionClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;

// 2016 10 9 - chc add Z Limit
TLMDEdit *edzlimit;
int zlimit;

// 2016 10 12 - chc add LED Illumination
TLMDEdit *edled;
int led;

   // 2016 10 14 - chc Confirm
   if(Application->MessageBox("Save Lens parameter(Center position)?", "Saving Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   pnlSaveLensPosition->Color = clSilver;
   pnlSystemMessage->Caption = "Update Lens Position...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->LensINIFilename);

   for(int i=0 ; i<6 ; i++) {
      edx = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "X"));
      edy = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "Y"));
      edz = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "Z"));
      edt = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "T"));
      x = edx->Text.ToInt();
      y = edy->Text.ToInt();
      z = edz->Text.ToInt();
      t = edt->Text.ToInt();

      LensPosition[i].X = x;
      LensPosition[i].Y = y;
      LensPosition[i].Z = z;
      LensPosition[i].T = t;

      pSystemFile->WriteInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "X"    ,x);
      pSystemFile->WriteInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Y"    ,y);
      pSystemFile->WriteInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Z"    ,z);
      pSystemFile->WriteInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "T"    ,t);

   }

   delete pSystemFile;
   pnlSystemMessage->Caption = "Update Lens Parameter Completed.";
   pnlSaveLensPosition->Color = clLime;

}
//---------------------------------------------------------------------------
// 2016 8 3 - chc Save Current Lens's LED Illumination to WDI.ini
void __fastcall TMainForm::btnSaveIlluminationClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str,fname;
TLMDEdit *edit;

   pnlSystemMessage->Caption = "Update WDI Parameter...";

   // .ini:
   fname = SystemDirectory + "\\WDI.ini";
   pSystemFile = new TIniFile(fname);

   // LED: PWM, LEDPWMLEns
   for(int i=0 ; i<6 ; i++)
      pSystemFile->WriteInteger("WDI Parameter" ,"LED PWM Lens"+IntToStr(i+1)  ,LEDPWMLEns[i]);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2016 8 5 - chc DoubleClick - move to Center
// (X,Y) set by MouseDown Event
// 與cbCCDXDirection/cbCCDYDirection有關
void __fastcall TMainForm::imCCDDblClick(TObject *Sender)
{
int level;
double fdy,ccdprecision,fdx;
int axisno,position;
I32 cmd;
AnsiString msg;
int cx,cy,X,Y;

   // 2023 2 21 - chc 可以移動
   if(boolDBClick == false) {

      // 2023 2 7 - chc Run時不可以DoubleClick
      if(boolInMeasureRun == true) {
         pnlSystemMessage->Caption = "量測作業中, 不可以執行Move!";
         return;
      }
   }

   // 2016 8 7 - chc X/Y position(set by MouseDown Event)
   X = DoubleClickX;
   Y = DoubleClickY;

   cx = imCCD->Width / 2;
   cy = imCCD->Height / 2;

   // 2016 11 6 - chc use shVertical & shHorizontal(imCCD: 1020*810)
   // shVertical->Left = 553
   // imCCD->Left = 43
   // imCCD->Width/2=510
   // shHorizontal->Top = 448
   // imCCD->Top = 42
   // imCCD->Height/2=405
   cx = shVertical->Left - imCCD->Left;
   cy = shHorizontal->Top - imCCD->Top;

   pnlSystemMessage->Caption = "Bouble Click: XYMoving...";
   WriteSystemLog(pnlSystemMessage->Caption);
   // Y軸
   pnlYMove->Color = clSilver;
   level = shHorizontal->Top;                                                   // 488
   ccdprecision = GetLensPrecision();
   /// 983/564 - 560/446
   //2019/10/29 15:16:56:666-Bouble Click: XYMoving...
   //2019/10/29 15:16:56:667-Y,level,top,fy= 564,488,42,120.2420,1.0190
   //2019/10/29 15:16:56:689-X,level,left,fx= 983,603,43,431.0370,1.0190
   fdy = (Y - (level - imCCD->Top)) * ccdprecision;
   msg.sprintf("Y,level,top,fy= %d,%d,%d,%.4f,%.4f",Y,level,imCCD->Top,fdy,ccdprecision);
   WriteSystemLog(msg);

   if(cbCCDYDirection->Checked == true)
      fdy = 0 - fdy;
   msg.sprintf("%.3f",fdy);
   pnlYAltOffset->Caption = msg;
   // Y - absolute
   axisno = Y_AXIS;

   // 2016 12 9 - chc 改成Position
   //GetCommand(axisno, &cmd);
   double fcmd;
   GetPosition(axisno, &fcmd);
   cmd = fcmd;

   position = cmd + (fdy / Y_RESOLUTION);
   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "MouseDoubleClick: YMove Fail!";
      WriteSystemLog(pnlSystemMessage->Caption);
      pnlYMove->Color = clRed;
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";
   }
   else {
      pnlYMove->Color = clLime;
      pnlSystemMessage->Caption = "MouseDoubleClick: YMove Success";
   }
   // X軸
   /// 983/564 - 560/446
   //2019/10/29 15:16:56:666-Bouble Click: XYMoving...
   //2019/10/29 15:16:56:667-Y,level,top,fy= 564,488,42,120.2420,1.0190
   //2019/10/29 15:16:56:689-X,level,left,fx= 983,603,43,431.0370,1.0190
   pnlXMove->Color = clSilver;
   level = shVertical->Left;                                                    // 603
   fdx = (X - (level - imCCD->Left)) * ccdprecision;
   msg.sprintf("X,level,left,fx= %d,%d,%d,%.4f,%.4f",X,level,imCCD->Left,fdx,ccdprecision);
   WriteSystemLog(msg);
   if(cbCCDXDirection->Checked == true)
      fdx = 0 - fdx;
   msg.sprintf("%.3f",fdx);
   pnlXAltOffset->Caption = msg;
   // X - absolute
   axisno = X_AXIS;

   // 2016 12 9 - chc 改成Position
   //GetCommand(axisno, &cmd);
   GetPosition(axisno, &fcmd);
   cmd = fcmd;

   position = cmd + (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "MouseDoubleClick: XMove Fail!";
      WriteSystemLog(pnlSystemMessage->Caption);
      pnlXMove->Color = clRed;
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " X-Axis Move Error!";
   }
   else {
      pnlXMove->Color = clLime;
      pnlSystemMessage->Caption = "MouseDoubleClick: XMove Success";
   }

   // 強制切到X軸
   axisno = X_AXIS;
   combAxis->ItemIndex = axisno;
}
//---------------------------------------------------------------------------
// 2016 8 5 - chc Double Click
void __fastcall TMainForm::imCCDMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //X = 111;
   //Y = 222;
   DoubleClickX = X;
   DoubleClickY = Y;

   // 2016 12 9 - chc Add Measure Item
   if(MeasureState == 1 && cbMeasure->Checked == true) {

      // 2016 10 16 - chc 加入訊息 : AddMeasureMessage, mmMeasure
      AddMeasureMessage(AnsiString("長度: ") + pnlMeasureResult->Caption);

   }

   // 2016 10 12 - chc Measure
   if(!Shift.Contains(ssAlt) && !Shift.Contains(ssCtrl) && Button == mbLeft) {
      if(MeasureState == 0 && cbMeasure->Checked == true) {
         pnlMeasureResult->Caption = "";
         MeasureState = 1;
         Mx1 = X;
         My1 = Y;
         shMeasure->Visible = true;
         shMeasure->Left = X + imCCD->Left;
         shMeasure->Top = Y + imCCD->Top;
         shMeasure->Width = 2;
         shMeasure->Height = 2;
      }
      else if(MeasureState == 1 && cbMeasure->Checked == true) {
         MeasureState = 2;
         Mx2 = X;
         My2 = Y;
         MeasureState = 0;
         double wvalue,hvalue,lvalue,dx;
         AnsiString msg;
         dx = GetLensPrecision();
         // Width
         wvalue = (abs(Mx2 - Mx1)+1) * dx;
         // Height
         hvalue = (abs(My2 - My1)+1) * dx;
         // Length
         lvalue = sqrt((Mx2-Mx1)*(Mx2-Mx1) + (My2-My1)*(My2-My1)) * dx;
         if(pnlUnit->Caption == "um")
            msg.sprintf("(um)W:%.2f  H:%.2f  L:%.2f  A:%.2f  a:%.2f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
         else {
            wvalue /= MM_TO_UM;
            hvalue /= MM_TO_UM;
            lvalue /= MM_TO_UM;
            msg.sprintf("(mm)W:%.3f  H:%.3f  L:%.3f  A:%.4f  a:%.4f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
         }
         pnlMeasureResult->Caption = msg;
         //shMeasure->Visible = false;
         shEllipse->Left = shMeasure->Left;
         shEllipse->Top = shMeasure->Top;
         shEllipse->Width = shMeasure->Width;
         shEllipse->Height = shMeasure->Height;
         shEllipse->Visible = true;
      }
   }
}
//---------------------------------------------------------------------------
// 2016 8 9 - chc
void __fastcall TMainForm::shLaserShutterOuterMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy,x,y;

   x = X + shLaserShutterOuter->Left - imCCD->Left;
   y = Y + shLaserShutterOuter->Top - imCCD->Top;

   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imCCD->Canvas->Pixels[x][y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = x + sx;
   pnlCCDY->Caption = y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",x,y);
   sbSystemMessage->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystemMessage->Panels->Items[4]->Text = str;

   // 2016 10 13 - chc Measurement
   if(MeasureState == 1 && cbMeasure->Checked == true)
      imCCDMouseMove(this,Shift,x, y);
}
//---------------------------------------------------------------------------
// 2016 8 9 - chc Simulate Double Click
void __fastcall TMainForm::shLaserShutterInnerMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
static long StartTime=-1,StopTime,Elapsedms;
static short StartTick,StopTick;

   if(StartTime == -1) {
      GetTimeTic(&StartTime,&StartTick);
   }
   else {
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      // Double Click

      // 2016 10 14 - chc form 250ms to 400ms
      //if(Elapsedms < 250) {
      if(Elapsedms < 400) {

         DoubleClickX = X + shLaserShutterInner->Left - imCCD->Left;
         DoubleClickY = Y + shLaserShutterInner->Top - imCCD->Top;
         imCCDDblClick(this);
      }
      StartTime = StopTime;
      StartTick = StopTick;
   }

   // 2016 10 13 - chc Measurement
   if((MeasureState == 1 || MeasureState == 0) && cbMeasure->Checked == true)
      imCCDMouseDown(this,Button,Shift,X-imCCD->Left+shLaserShutterInner->Left, Y-imCCD->Top+shLaserShutterInner->Top);
}
//---------------------------------------------------------------------------
// 2016 8 9 - chc Simulate Double Click
void __fastcall TMainForm::shLaserShutterOuterMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
static long StartTime=-1,StopTime,Elapsedms;
static short StartTick,StopTick;

   if(StartTime == -1) {
      GetTimeTic(&StartTime,&StartTick);
   }
   else {
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      // Double Click

      // 2016 10 14 - chc form 250ms to 400ms
      //if(Elapsedms < 250) {
      if(Elapsedms < 400) {

         DoubleClickX = X + shLaserShutterInner->Left - imCCD->Left;
         DoubleClickY = Y + shLaserShutterInner->Top - imCCD->Top;
         imCCDDblClick(this);
      }
      StartTime = StopTime;
      StartTick = StopTick;
   }

   // 2016 10 13 - chc Measurement
   if((MeasureState == 1 || MeasureState == 0) && cbMeasure->Checked == true)
      imCCDMouseDown(this,Button,Shift,X-imCCD->Left+shLaserShutterOuter->Left, Y-imCCD->Top+shLaserShutterOuter->Top);
}
//---------------------------------------------------------------------------
// 2016 10 9 - chc Read Lens Center and Laser Center
void __fastcall TMainForm::LoadLaserPosition(int lensno)
{
int no;
TIniFile *pSystemFile;

   // ini檔名與目錄:
   pSystemFile = new TIniFile(MainForm->LaserINIFilename);
   // 6 Lens
   for(no=0 ; no<6 ; no++) {
      // Lasr Cneter, 1278*958(1100*890)

      // 2016 10 30 - chc to parameter: 1278*958(1100*890 => 1020*810)
      //LensPosition[no].LaserX = pSystemFile->ReadInteger(LASER_INFORMATION_SECTION,"Laser Center X" + IntToStr(no+1)  ,89);
      //LensPosition[no].LaserY = pSystemFile->ReadInteger(LASER_INFORMATION_SECTION,"Laser Center Y" + IntToStr(no+1)  ,34);
      LensPosition[no].LaserX = pSystemFile->ReadInteger(LASER_INFORMATION_SECTION,"Laser Center X" + IntToStr(no+1)  ,129);
      LensPosition[no].LaserY = pSystemFile->ReadInteger(LASER_INFORMATION_SECTION,"Laser Center Y" + IntToStr(no+1)  ,74);

   }
   delete pSystemFile;

   // Laser Center
   LaserCenterX = LensPosition[lensno-1].LaserX;
   LaserCenterY = LensPosition[lensno-1].LaserY;
   // 顯示LaserCenter
   pnlLaserCenterPosition->Caption = "(" + IntToStr(LaserCenterX) + "," + IntToStr(LaserCenterY) + ")";

   // 2016 10 30 - chc Display in View Window
   pnlLaserCenterPosition1->Caption = pnlLaserCenterPosition->Caption;

   // 2019 7 22 - chc Lasr Cneter: 固定為80,67
   // 2021 4 27 - chc 固定為CCDRangeX,CCDRangeY
   //LaserCenterX = 80;
   //LaserCenterY = 35;
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;

}
//---------------------------------------------------------------------------
// 2016 10 9 - chc Switch Lens & Laser Position
// to LensNo
void __fastcall TMainForm::SwitchLensLaser()
{

   // Lens Center
   // 2017 1 3 - chc 暫不用
   /*
   MainForm->CenterX = MainForm->LensPosition[LensNo-1].X;
   MainForm->edAOIX->Text = IntToStr(MainForm->CenterX);
   MainForm->CenterY = MainForm->LensPosition[LensNo-1].Y;
   MainForm->edAOIY->Text = IntToStr(MainForm->CenterY);
   MainForm->CenterZ = MainForm->LensPosition[LensNo-1].Z;
   MainForm->edAOIZ->Text = IntToStr(MainForm->CenterZ);
   MainForm->CenterT = MainForm->LensPosition[LensNo-1].T;
   MainForm->edAOIT->Text = IntToStr(MainForm->CenterT);
   */

   // Laser Center
   LaserCenterX = LensPosition[LensNo-1].LaserX;
   LaserCenterY = LensPosition[LensNo-1].LaserY;

   // 2019 7 22 - chc Lasr Cneter: 固定為80,67
   // 2021 4 27 - chc 固定為CCDRangeX,CCDRangeY
   //LaserCenterX = 80;
   //LaserCenterY = 35;
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;

   // 2016 10 30 - chc 不限制在CCD FOV內
   if(LaserCenterX < 0)
      shVertical->Left = pnlLeftWindow->Width/2 + LaserCenterX;
   else if(LaserCenterX > (CCDDx-1))
      shVertical->Left = pnlLeftWindow->Width/2 + (LaserCenterX-(CCDDx-1));
   if(LaserCenterY < 0)
      shHorizontal->Top = pnlLeftWindow->Height/2 + LaserCenterY;
   else if(LaserCenterY > (CCDDy-1)) 
      shHorizontal->Top = pnlLeftWindow->Height/2 + (LaserCenterY-(CCDDy-1));

}
//---------------------------------------------------------------------------
// 2016 10 9 - chc Set Lens1 Z Limit
void __fastcall TMainForm::btnSetLens1ZLimitClick(TObject *Sender)
{

   SetLensZLimit(1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetLens2ZLimitClick(TObject *Sender)
{

   SetLensZLimit(2);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetLens3ZLimitClick(TObject *Sender)
{

   SetLensZLimit(3);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetLens4ZLimitClick(TObject *Sender)
{

   SetLensZLimit(4);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetLens5ZLimitClick(TObject *Sender)
{

   SetLensZLimit(5);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetLens6ZLimitClick(TObject *Sender)
{

   SetLensZLimit(6);
}
//---------------------------------------------------------------------------
// 2016 10 12 - chc Update: edLens1LED
void __fastcall TMainForm::UpdateLensLED(int lensno)
{
TPanel *panel;

   panel = (TPanel*)(FindComponent("pnlLens" + IntToStr(lensno) + "LED"));
   panel->Caption = IntToStr(LEDPWMLEns[lensno-1]);
}
//---------------------------------------------------------------------------
// 2016 10 12 - chc Save Laser Position
void __fastcall TMainForm::SaveLaserPosition(int lensno)
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;

   pnlSystemMessage->Caption = "Update Laser Position...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->LaserINIFilename);
   pSystemFile->WriteInteger(LASER_INFORMATION_SECTION,"Laser Center X" + IntToStr(lensno)  ,LensPosition[lensno-1].LaserX);
   pSystemFile->WriteInteger(LASER_INFORMATION_SECTION,"Laser Center Y" + IntToStr(lensno)  ,LensPosition[lensno-1].LaserY);
   delete pSystemFile;
   pnlSystemMessage->Caption = "Update Laser Position Done.";

}
//---------------------------------------------------------------------------
// 2016 10 13 - chc shMeasure visible
void __fastcall TMainForm::pnlMeasureResultClick(TObject *Sender)
{

   if(shMeasure->Visible == true)
      shMeasure->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::shMeasureMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy,x,y;

   // 2016 10 14 - chc for Move
   x = X + shMeasure->Left - imCCD->Left;
   y = Y + shMeasure->Top - imCCD->Top;
   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imCCD->Canvas->Pixels[x][y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = x + sx;
   pnlCCDY->Caption = y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",x,y);
   sbSystemMessage->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystemMessage->Panels->Items[4]->Text = str;

   if(MeasureState == 1 && cbMeasure->Checked == true)
      imCCDMouseMove(this,Shift,X-imCCD->Left+shMeasure->Left, Y-imCCD->Top+shMeasure->Top);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::shMeasureMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
static long StartTime=-1,StopTime,Elapsedms;
static short StartTick,StopTick;

   // 2016 10 14 - chc for double click
   if(StartTime == -1) {
      GetTimeTic(&StartTime,&StartTick);
   }
   else {
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      // Double Click

      // 2016 10 14 - chc form 250ms to 400ms
      //if(Elapsedms < 250) {
      if(Elapsedms < 400) {

         DoubleClickX = X + shMeasure->Left - imCCD->Left;
         DoubleClickY = Y + shMeasure->Top - imCCD->Top;
         imCCDDblClick(this);
      }
      StartTime = StopTime;
      StartTick = StopTick;
   }

   // 2016 10 13 - chc Measurement
   if(MeasureState == 1 && cbMeasure->Checked == true)
      imCCDMouseDown(this,Button,Shift,X-imCCD->Left+shMeasure->Left, Y-imCCD->Top+shMeasure->Top);
}
//---------------------------------------------------------------------------
// 2016 10 13 - chc Change Measure Mode
void __fastcall TMainForm::pnlMeasureResultDblClick(TObject *Sender)
{

   // 2016 10 13 - chc Always display 3 value
   return;
}
//---------------------------------------------------------------------------
// 2016 10 13 - chc Measure On/Off
void __fastcall TMainForm::cbMeasureClick(TObject *Sender)
{

   if(cbMeasure->Checked == true) {
      pnlMeasureResult->Visible = true;
      shMeasure->Visible = false;
      shEllipse->Visible = false;

      // 2016 10 14 - chc Crosshair
      if(cbCrossHair->Checked == true) {
         shRightPosition->Visible = true;
         shUpPosition->Visible = true;
      }

   }
   else {
      pnlMeasureResult->Visible = false;
      shMeasure->Visible = false;
      shEllipse->Visible = false;

      // 2016 10 14 - chc Crosshair
      shRightPosition->Visible = false;
      shUpPosition->Visible = false;

   }
}
//---------------------------------------------------------------------------


void __fastcall TMainForm::cbCrossHairClick(TObject *Sender)
{

   // 2016 10 14 - chc Crosshair
   if(cbCrossHair->Checked == true && cbMeasure->Checked == true) {
      shRightPosition->Visible = true;
      shUpPosition->Visible = true;
   }
   else {
      shRightPosition->Visible = false;
      shUpPosition->Visible = false;
   }
}
//---------------------------------------------------------------------------
// 2016 10 14 - chc Measurement
void __fastcall TMainForm::shUpPositionMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if((MeasureState == 1 || MeasureState == 0) && cbMeasure->Checked == true)
      imCCDMouseDown(this,Button,Shift,X-imCCD->Left+shLaserShutterInner->Left, Y-imCCD->Top+shLaserShutterInner->Top);
}
//---------------------------------------------------------------------------
// 2016 10 14 - chc Measurement
void __fastcall TMainForm::shRightPositionMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if((MeasureState == 1 || MeasureState == 0) && cbMeasure->Checked == true)
      imCCDMouseDown(this,Button,Shift,X-imCCD->Left+shLaserShutterInner->Left, Y-imCCD->Top+shLaserShutterInner->Top);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::shMeasureMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   imCCDMouseUp(this,Button,Shift,X + shMeasure->Left - imCCD->Left,Y + shMeasure->Top - imCCD->Top);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::edYApertureEnter(TObject *Sender)
{

   boolFromUser = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::edXApertureEnter(TObject *Sender)
{

   boolFromUser = false;
}
//---------------------------------------------------------------------------
// 2016 10 30 - chc Check Range
void __fastcall TMainForm::CheckRange(int *sx, int *sy)
{
bool boolover;

   boolover = false;
   // X
   if(*sx < 0) {
      *sx = 0;
      boolover = true;
   }
   if(*sx > (CCDDx-1)) {
      *sx = CCDDx-1;
      boolover = true;
   }
   // Y
   if(*sy < 0) {
      *sy = 0;
      boolover = true;
   }
   if(*sy > (CCDDy-1)) {
      *sy = CCDDy-1;
      boolover = true;
   }
   // Over
   if(boolover == true) {
      if(pnlLaserCenterPosition1->Color == (TColor)0x003C9F82)
         pnlLaserCenterPosition1->Color = (TColor)0x00FF8080;
   }
   // Fit
   else {
      if(pnlLaserCenterPosition1->Color != (TColor)0x003C9F82)
         pnlLaserCenterPosition1->Color = (TColor)0x003C9F82;
   }

}
//---------------------------------------------------------------------------
// 2016 11 8 - chc Toggle Match box Show or not
void __fastcall TMainForm::bnMatchBoxClick(TObject *Sender)
{

   if(shMarkMatch->Visible == true)
      shMarkMatch->Visible = false;
   else
      shMarkMatch->Visible = true;
}
//---------------------------------------------------------------------------
// 2016 11 8 - chc Hide Match box
void __fastcall TMainForm::shMarkMatchMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   shMarkMatch->Visible = false;
}
//---------------------------------------------------------------------------
// 2016 11 8 - chc Stop Within
void __fastcall TMainForm::btnAbortWithinClick(TObject *Sender)
{

   btnAbortWithin->Visible = false;
}
//---------------------------------------------------------------------------
// 2016 12 15 - chc 點出圓心位置
int CircleCenterX1=-1,CircleCenterY1=-1;
int CirclePointX1=-1, CirclePointY1=-1;
int CircleCenterX2=-1,CircleCenterY2=-1;
int CirclePointX2=-1, CirclePointY2=-1;

// 2016 12 15 - chc 記錄線位置: 相對於原點
int Line1X=-1,Line1Y=-1;
int Line2X=-1,Line2Y=-1;

// 2018 1 7 - chc 移到前面來
// Calibration.ini / CalibrationX.txt / CalibrationY.txt
// 60mm為單位, 由0 ~ ....
#define CALIBRATION_MAX         100
int CalibrationBufferX[CALIBRATION_MAX];
int CalibrationBufferY[CALIBRATION_MAX];
int CalibrationXNo;
int CalibrationYNo;

// 2016 11 16 - chc 更新X/Y/Z/T
void __fastcall TMainForm::tm250msTimer(TObject *Sender)
{
AnsiString msg;
double x,y,z,t,l,w;

   tm250ms->Enabled = false;

   // 2016 12 21 - chc 改成position
   //x = edCommandX->Text.ToInt() * X_RESOLUTION;
   x = edCounterX->Text.ToInt() * X_RESOLUTION;

   if(pnlUnit->Caption == "um")
      msg.sprintf("X=%.1fum",x);
   else
      msg.sprintf("X=%.3fmm",x/MM_TO_UM);

   //---------------------------------------------------------------------------
   // 2018 1 7 - chc 校正值
   // 2019 7 9 - chc 不校正
   /*
   int no,basicvalue;
   double value,newvalue;
   value = edCounterX->Text.ToInt();
   no = floor((double)value / 60000.0);
   basicvalue = 60000.0 * no;
   newvalue = value;
   if(no > 0)
      newvalue = (basicvalue / CalibrationBufferX[no]) * value;
   newvalue *= X_RESOLUTION;
   if(pnlUnit->Caption == "um")
      msg.sprintf("X=%.1fum",newvalue);
   else
      msg.sprintf("X=%.3fmm",newvalue/MM_TO_UM);
   */
   //---------------------------------------------------------------------------

   pnlX->Caption = msg;

   // 2016 12 21 - chc 改成position
   //y = edCommandY->Text.ToInt() * Y_RESOLUTION;
   y = edCounterY->Text.ToInt() * Y_RESOLUTION;
   if(pnlUnit->Caption == "um")
      msg.sprintf("Y=%.1fum",y);
   else
      msg.sprintf("Y=%.3fmm",y/MM_TO_UM);

   //---------------------------------------------------------------------------
   // 2018 1 7 - chc 校正值
   //int no,basicvalue;
   //double value,newvalue;
   // 2019 7 9 - chc 不校正
   /*
   value = edCounterY->Text.ToInt();
   no = floor((double)value / 60000.0);
   basicvalue = 60000.0 * no;
   newvalue = value;
   if(no > 0)
      newvalue = (basicvalue / CalibrationBufferY[no]) * value;
   newvalue *= Y_RESOLUTION;
   if(pnlUnit->Caption == "um")
      msg.sprintf("Y=%.1fum",newvalue);
   else
      msg.sprintf("Y=%.3fmm",newvalue/MM_TO_UM);
   */
   //---------------------------------------------------------------------------

   pnlY->Caption = msg;

   // 2016 12 21 - chc 改成position
   //z = edCommandZ->Text.ToInt() * Z_RESOLUTION;
   z = edCounterZ->Text.ToInt() * Z_RESOLUTION;
   if(pnlUnit->Caption == "um")
      msg.sprintf("Z=%.1fum",z);
   else
      msg.sprintf("Z=%.3fmm",z/MM_TO_UM);
   pnlZ->Caption = msg;

   // 2020 5 20 - chc 平面為1630
   l = edCounterL->Text.ToInt() * L_RESOLUTION;
   int lzero = edLLevel->Text.ToInt();
   l = l - lzero;
   if(pnlUnit->Caption == "um")
      msg.sprintf("L=%.1fum",l);
   else
      msg.sprintf("L=%.3fmm",l/MM_TO_UM);
   //pnlL->Caption = msg;

   // T: T_RESOLUTION(0.0001125/p)
   // 2023 7 25 - chc 不是角度
   //int zero = edLoadT->Text.ToInt();
   t = edCounterT->Text.ToInt();

   // 2023 7 25 - chc 不是角度
   //t = t - zero;

   t *= T_RESOLUTION;
   msg.sprintf("Z1=%.2f",t);
   pnlT->Caption = msg;

   // 2021 12 9 - chc 顯示距離: 上/右為+
   // x/y: um
   // pnlCenterXFind, pnlCenterYFind: pulse
   if(pnlCenterXFind->Caption != "" && pnlCenterXFind->Caption != "0" && pnlCenterYFind->Caption != "" && pnlCenterYFind->Caption != "0") {
      double fx,fy;
      fx = x - pnlCenterXFind->Caption.ToDouble() * X_RESOLUTION;
      fy = y - pnlCenterYFind->Caption.ToDouble() * Y_RESOLUTION;
      fx = 0 - fx;
      msg.sprintf("dX=%.3fmm",fx/MM_TO_UM);
      pnlDX->Caption = msg;
      msg.sprintf("dY=%.3fmm",fy/MM_TO_UM);
      pnlDY->Caption = msg;
   }
   else {
      pnlDX->Caption = "";
      pnlDY->Caption = "";
   }

// 2020 4 16 - chc 不做點位
end:

   tm250ms->Enabled = true;

}
//---------------------------------------------------------------------------
// 2016 11 17 - chc Sleep : for Recipe Run
void __fastcall TMainForm::DelayRecipeRun(int no)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
int cnt = 0;

   GetTimeTic(&starttime,&starttick);
   while(1) {
      Application->ProcessMessages();
      Sleep(1);
      cnt++;
      if(cnt >= 10) {
         cnt = 0;
         GetTimeTic(&stoptime,&stoptick);
         elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
         if(elapsedms > no)
            return;
      }
   }
}
//---------------------------------------------------------------------------
// 2016 8 2 - chc Load Lens Position
void __fastcall TMainForm::LoadLensPosition(int lensno)
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;

// 2016 10 9 - chc add Z Limit
TLMDEdit *edzlimit;
int zlimit;

// 2016 10 12 - chc Lens LED Illumination
TLMDEdit *edled;
int led;

   pnlSystemMessage->Caption = "Load Lens Parameter...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->LensINIFilename);

   // try-catch
   try {
      for(int i=0 ; i<6 ; i++) {
         x = pSystemFile->ReadInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "X",0);
         y = pSystemFile->ReadInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Y",0);
         z = pSystemFile->ReadInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Z",0);
         t = pSystemFile->ReadInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "T",0);

         edx = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "X"));
         edy = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "Y"));
         edz = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "Z"));
         edt = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "T"));
         edx->Text = IntToStr(x);
         edy->Text = IntToStr(y);
         edz->Text = IntToStr(z);
         edt->Text = IntToStr(t);
      }

   }
   catch(Exception &e) {
      WriteSystemLog("LoadLensPosition() - Error");
      sbSystemMessage->Panels->Items[1]->Text = "LoadLensPosition() - Error";
   }
   delete pSystemFile;
   pnlSystemMessage->Caption = "Load Lens Parameter Completed.";

}
//---------------------------------------------------------------------------
// 2016 11 28 - chc Init ImagingSource CCD
void __fastcall TMainForm::MakeDeviceSettings()
{

   // 2021 4 19 - chc Log
   WriteSystemLog("MakeDeviceSettings()...");

   // Set the color format to monochrome
   //ICImagingControl1->MemoryCurrentGrabberColorformat = TIS.Imaging.ICImagingControlColorformats.ICY8;

   // Set the ring buffer size to 5. This ensures that the last 5
   // acquired images are in memory.
   ICImagingControl1->ImageRingBufferSize = 5;

   // LiveCaptureContinuous = True means that every frame is
   // copied to the ring buffer.
   ICImagingControl1->LiveCaptureContinuous = true;

   // Do not save the last image, if liveStop is called
   ICImagingControl1->LiveCaptureLastImage = false;

   // Disable the live display. This allows to display images
   // from the ring buffer in ICImagingControl//s control window.
   ICImagingControl1->LiveDisplay = false;
   ICImagingControl1->LiveDisplayDefault = false;
   ICImagingControl1->LiveShowLastBuffer = false;

   // 2021 4 19 - chc 降至15fps: max 20fps
   //ICImagingControl1->DeviceFrameRate = 22;
   ICImagingControl1->DeviceFrameRate = 15;

   // 2016 12 5 - chc Exposure time(default=100), Move時要調高至1000-8000
   ICImagingControl1->ExposureAuto = false;
   ICImagingControl1->Exposure = 10000;

   // 2016 12 8 - chc Gain(default = 0)
   ICImagingControl1->GainAuto = false;
   //ICImagingControl1->Gain = 0;

   // 2016 12 15 - chc 設定Contrast值(Default = 0): -10 ~ 30(對比度)
   // => 沒用!!
   //ICImagingControl1->Contrast = 0;
   ICImagingControl1->Sharpness = 12;

   try {
      ICImagingControl1->ZoomAuto = false;
   }
   catch(Exception& e) {
      ;
   }
   ICImagingControl1->ScrollbarsEnabled = false;

   // Set the size of ICImagingControl to the width and height
   // of the currently selected video format.
   ICImagingControl1->Width = ICImagingControl1->ImageWidth;
   ICImagingControl1->Height = ICImagingControl1->ImageHeight;

   // 2021 4 19 - chc Log
   WriteSystemLog("MakeDeviceSettings().");

}
//---------------------------------------------------------------------------
// 2016 11 28 - chc ImagingSource CCD Capture
void __fastcall TMainForm::tmISCCDTimer(TObject *Sender)
{

   tmISCCD->Enabled = false;
   pnlISCCDCapture->Color = clLime;
   pnlISCCDCapture->Refresh();

   // Snap an image.
   ICImagingControl1->MemorySnapImage();
   // Copy the last grabbed image to the PictureBox control

   // File Mode
   /*
   AnsiString fname;
   fname = "D:\\test.bmp";
   WideString ws;
   ws = fname;
   ICImagingControl1->ImageActiveBuffer->SaveAsBitmap(ws.c_bstr(),2);
   if(FileExists(fname))
      imCCD->Picture->LoadFromFile(fname);
   tmISCCD->Enabled = true;
   return;
   */

   // Buffer Mode
   //unsigned char r,g,b;
   //color = imCCD->Canvas->Pixels[X][Y];
   //b = (color & 0xff0000) >> 16;
   //g = (color & 0x00ff00) >> 8;
   //r = color & 0x0000ff;
   unsigned char *buffer;
   buffer = (unsigned char *)ICImagingControl1->ImageActiveBuffer->get_ImageDataPtr();
   int bytesperpixel;
   bytesperpixel = ICImagingControl1->ImageBitsPerPixel / 8;

   //===========================
int no;
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;
static bool first = false;

   // Index
   pnlCCDStatus->Color = clSilver;
   no = 0;
   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   //WriteSystemLog("Show-0: " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(CCDInfoAry[no].Type));
   w = imCCD->Width;
   h = imCCD->Height;
   // Lasr Cneter: 固定為80,67
   // 2021 4 27 - chc 固定為CCDRangeX,CCDRangeY
   //LaserCenterX = 80;
   //LaserCenterY = 35;
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;

   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2021 4 27 - chc Log
   //WriteSystemLog("Frame sx,sy= " + IntToStr(sx) + "," + IntToStr(sy));

   // Check Range
   CheckRange(&sx,&sy);
   // 在影像處理中
   boolInGigaBufferAry[no] = true;

   // 2021 4 27 - chc Log
   //WriteSystemLog("Frame sx,sy= " + IntToStr(sx) + "," + IntToStr(sy));

   count++;
   unsigned char *pt,*pt1;
   int i;
   int pointer;
   // 記錄Basler存檔中...
   if(boolInGigaSaveAry[no] == true) {
      lbGiga->Items->Add("In Saving3... Stop Refeshing Image");
      pnlSystemMessage->Caption = "In Saving... Stop Refeshing Image";
      boolInGigaBufferAry[no] = false;
      return;
   }
   pnlCCDStatus->Color = clLime;

   // 2021 4 27 - chc Log
   //WriteSystemLog("Frame width,height,sx,sy,w,h= " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(sx) + "," + IntToStr(sy)+ "," + IntToStr(w) + "," + IntToStr(h));

   // 要顯示在主畫面
   GetImageXY(width,height,sx,sy,w,h,&x,&y);

   // 2021 4 27 - chc Log
   //WriteSystemLog("Frame x,y= " + IntToStr(x) + "," + IntToStr(y));

   //
   //height = 960;
   //WriteSystemLog("Show-1: " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(CCDInfoAry[no].Type));
   if(CCDInfoAry[no].Type == BASLER_CCD_BW)
      scA1300ImageAry[no].SetSize(width,height);
   else
      usb_ImageAry[no].SetSize(width,height);
   //WriteSystemLog("Show-2");

   // BW : scA1300ImageAry
   //CCDInfoAry[no].Type = BASLER_CCD_BW;
   if(CCDInfoAry[no].Type == BASLER_CCD_BW) {

// 2019 11 27 - chc Log
//WriteSystemLog("Show-Gray");

      i = 0;
      for(int row=height-1 ; row>=0 ; row--) {
         pt = (unsigned char *)scA1300ImageAry[no].GetImagePtr(0,row);
         // 由buffer到pt
         memcpy(pt, &buffer[i],width);

         // 2019 11 27 - chc 錯! 是Gray
         //i += width*3;
         i += width;

      }
      //scA1300ImageAry[no].SetPlacement(x,y,w,h);
      //scA1300ImageAry[no].Draw(imCCD->Canvas->Handle);
      //WriteSystemLog("Show-3");
      scA1300ImageROIAry[no].Detach();
      //WriteSystemLog("Show-4");
      scA1300ImageROIAry[no].Attach(&scA1300ImageAry[no]);
      //WriteSystemLog("Show-5");

      // 2021 4 27 - chc Full Image
      //WriteSystemLog("Frame x,y,w,h= " + IntToStr(x) + "," + IntToStr(y) + "," + IntToStr(w) + "," + IntToStr(h));
      if(cbCCDFullImage->Checked == true) {
         imCCD->Picture->Bitmap->Width = width;
         imCCD->Picture->Bitmap->Height = height;
         scA1300ImageROIAry[no].SetPlacement(0,0,width,height);
      }
      else {
         // 要設Size
         imCCD->Picture->Bitmap->Width = w;
         imCCD->Picture->Bitmap->Height = h;

         scA1300ImageROIAry[no].SetPlacement(x,y,w,h);
      }

      //WriteSystemLog("Show-6");
      if(rgCCDSource->ItemIndex == 0)
         scA1300ImageROIAry[no].Draw(imCCD->Canvas->Handle);

      // @#@#@#@#@#
      //else
      //   scA1300ImageROIAry[no].Draw(imVieworks->Canvas->Handle);

      //WriteSystemLog("Show-7");
   }
   else {

      //WriteSystemLog("Show-8");

// 2019 11 27 - chc Log
//WriteSystemLog("Show-Color");

      // Color : usb_ImageAry
      i = 0;
      for(int row=height-1 ; row>=0 ; row--) {
         pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
         // 由buffer到pt
         memcpy(pt, &buffer[i],width*3);
         i += (width*3);
      }

      usb_ImageROIAry[no].Detach();
      usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);

      usb_ImageROIAry[no].SetPlacement(x,y,w,h);
      if(rgCCDSource->ItemIndex == 0)
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
      // @#@#@#@#@#
      //else
      //   scA1300ImageROIAry[no].Draw(imVieworks->Canvas->Handle);

   }
   // 若沒有Refresh就不會顯示
   if(rgCCDSource->ItemIndex == 0)
      imCCD->Refresh();
   // @#@#@#@#@#
   //else
   //   imVieworks->Refresh();

   //WriteSystemLog("Show-9");

   // Basler Pylon GigE CCD
   boolBaslerImageLoadedAry[no] = true;
   BaslerCaptureNoAry[no]++;
   if((count % 5) == 0) {
      GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
      BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
      double ratio;
      AnsiString msg;
      // Devide by zero
      if(BaslerElapsedmsAry[no] != 0) {
         ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
         msg.sprintf("%.1f",ratio);
         pnlCapturedNo->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
   tmISCCD->Enabled = true;
   pnlISCCDCapture->Color = clSilver;
   pnlISCCDCapture->Refresh();

}
//---------------------------------------------------------------------------
// 2016 11 29 - chc Speed Switch
void __fastcall TMainForm::rgSpeedClick(TObject *Sender)
{

   JogSpeed = rgSpeed->ItemIndex;
}
//---------------------------------------------------------------------------
bool boolInRun = false;

// 2016 11 29 - chc Low Speed Light
void __fastcall TMainForm::pnlStageLockClick(TObject *Sender)
{

   WriteSystemLog(">Enter Stage電磁門鎖()...");

   if(bool_IO_Status == false) {
      WriteSystemLog(">bool_IO_Status = false, 不做電磁門鎖檢查...");
      return;
   }
   if(pnlStageLock->Color == clSilver) {
      HSL_IO_OuStatus |= STAGE_LOCK;
      pnlStageLock->Color = clLime;
      WriteSystemLog(">電磁門鎖Bit0 On.");
   }
   else {
      HSL_IO_OuStatus &= ~(STAGE_LOCK);
      pnlStageLock->Color = clSilver;
      WriteSystemLog(">電磁門鎖Bit0 Off.");
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);

}
//---------------------------------------------------------------------------
// 2016 11 29 - chc Middle Speed Light: 8"
void __fastcall TMainForm::pnlStageVacuumClick(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlStageVacuum->Color == clSilver) {
      HSL_IO_OuStatus |= STAGE_VACUUM;
      pnlStageVacuum->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(STAGE_VACUUM);
      pnlStageVacuum->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2016 11 29 - chc High Speed Light
void __fastcall TMainForm::pnlStageBarClick(TObject *Sender)
{

   // 2020 3 6 - chc 不用
   // 2020 6 22 - chc 靜電Bar On/Off
   //return;

   if(bool_IO_Status == false)
      return;
   if(pnlStageBar->Color == clSilver) {
      HSL_IO_OuStatus |= HIGH_SPEED_LIGHT;
      pnlStageBar->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(HIGH_SPEED_LIGHT);
      pnlStageBar->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::rgRulerColor1Click(TObject *Sender)
{

   rgRulerColor->ItemIndex = rgRulerColor1->ItemIndex;
   rgRulerColorClick(this);
}
//---------------------------------------------------------------------------
// 2016 12 14 - chc 計算Factor
void __fastcall TMainForm::btnCalibrationDoneClick(TObject *Sender)
{
double xstd,xvalue,xfactor;
double ystd,yvalue,yfactor;
AnsiString sxfactor,syfactor;

   xstd = edXStd->Text.ToDouble();
   xvalue = edXValue->Text.ToDouble();
   if(xvalue > 0)
      xfactor = xstd / xvalue;
   else
      xfactor = 1.0;
   sxfactor.sprintf("%.8f",xfactor);
   pnlXFactor->Caption = sxfactor;

   ystd = edYStd->Text.ToDouble();
   yvalue = edYValue->Text.ToDouble();
   if(yvalue > 0)
      yfactor = ystd / yvalue;
   else
      yfactor = 1.0;
   syfactor.sprintf("%.8f",yfactor);
   pnlYFactor->Caption = syfactor;

}
//---------------------------------------------------------------------------
// 2016 12 14 - chc Save Factor
// Calibration.ini
void __fastcall TMainForm::btnCalibrationSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString fname;

   // ini檔名與目錄: Calibration.ini
   fname = SystemDirectory + "\\Calibration.ini" ;
   // 刪除
   if(FileExists(fname)) {
      DeleteFile(fname.c_str());
   }
   pSystemFile = new TIniFile(fname);

   pSystemFile->WriteString("Calibration","XFactor"        ,pnlXFactor->Caption);
   pSystemFile->WriteString("Calibration","YFactor"        ,pnlYFactor->Caption);
   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbContrastChange(TObject *Sender)
{
int contrast;

   // ImagingSource
   if(pnlISCCDStaus->Color != clLime)
      return;
   contrast = tbContrast->Position;
   ICImagingControl1->Sharpness = contrast;
   pnlContrast->Caption = IntToStr(contrast);
   return;
}
//---------------------------------------------------------------------------
// 2016 1`2 15 - chc um/mm
int UnitMode;
#define UM_UNIT         1
#define MM_UNIT         2
void __fastcall TMainForm::pnlUnitClick(TObject *Sender)
{

   if(pnlUnit->Caption == "um") {
      pnlUnit->Caption = "mm";
      UnitMode = MM_UNIT;
   }
   else {
      UnitMode = UM_UNIT;
      pnlUnit->Caption = "um";
   }
}
//---------------------------------------------------------------------------
// 2016 10 16 - chc 加入訊息 : mmMeasure
void __fastcall TMainForm::AddMeasureMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmMeasure->Lines->Insert(0,putmsg);
   mmMeasure->Lines->Insert(0,msg);
}
//---------------------------------------------------------------------------
// 2016 12 18 - chc 軌跡作業時禁用/起用Motion
void __fastcall TMainForm::SetMove(bool mode)
{

   // 2020 9 3 - chc for test
   if(boolForTest == false)

      tsMotion->Enabled = mode;
   pnlMoveRight->Enabled = mode;
   pnlMoveBottom->Enabled = mode;
}
//---------------------------------------------------------------------------
// 2016 12 20 - chc 停止軸控(X/Y/Z)
void __fastcall TMainForm::btnStopMotionClick(TObject *Sender)
{

   StopAxis(X_AXIS);
   Sleep(100);
   StopAxis(Y_AXIS);
   Sleep(100);
   StopAxis(Z_AXIS);
   Sleep(100);
}
//---------------------------------------------------------------------------
// 2016 12 21 - chc Clear Message
void __fastcall TMainForm::mnClearClick(TObject *Sender)
{

   mmMeasure->Lines->Clear();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::mnSaveFileClick(TObject *Sender)
{
AnsiString filename;

   spCCDImage->InitialDir = ExportDirectory;
   // 設定filtet
   spCCDImage->Filter = "TXT(*.txt)|*.txt";
   if(spCCDImage->Execute()) {
      // 改變副檔名
      filename = ChangeFileExt(spCCDImage->FileName,".txt");
      mmMeasure->Lines->SaveToFile(filename);
      pnlSystemMessage->Caption = "訊息已存檔.";
   }
}
//---------------------------------------------------------------------------
// 2016 12 22 - chc Load Factor
//
// 2018 1 7 - chc 移到前面去
// Calibration.ini / CalibrationX.txt / CalibrationY.txt
// 60mm為單位, 由0 ~ ....
//#define CALIBRATION_MAX         100
//int CalibrationBufferX[CALIBRATION_MAX];
//int CalibrationBufferY[CALIBRATION_MAX];
//int CalibrationXNo;
//int CalibrationYNo;

void __fastcall TMainForm::LoadCalibrationFactor()
{
TIniFile *pSystemFile;
AnsiString fname,sfx,sfy;

   // ini檔名與目錄: Calibration.ini
   fname = SystemDirectory + "\\Calibration.ini" ;
   // 刪除
   if(FileExists(fname)) {
      DeleteFile(fname.c_str());
   }
   pSystemFile = new TIniFile(fname);

   sfx = pSystemFile->ReadString("Calibration","XFactor"        ,"1.0");
   pnlXFactor->Caption = sfx;
   sfy = pSystemFile->ReadString("Calibration","YFactor"        ,"1.0");
   pnlYFactor->Caption = sfy;
   delete pSystemFile;

   int index;
   fname = SystemDirectory + "\\CalibrationX.txt" ;
   CalibrationXNo = 0;
   if(FileExists(fname)) {
      FILE *fp;
      if((fp = fopen((fname).c_str(),"r")) != NULL) {
         while(1) {
            if(feof(fp))
               break;
            fscanf(fp,"%d %d\n",&index, &CalibrationBufferX[CalibrationXNo++]);
            if(CalibrationXNo >= CALIBRATION_MAX)
               break;
         }
      }
      fclose(fp);
   }
   fname = SystemDirectory + "\\CalibrationY.txt" ;
   CalibrationYNo = 0;
   if(FileExists(fname)) {
      FILE *fp;
      if((fp = fopen((fname).c_str(),"r")) != NULL) {
         while(1) {
            if(feof(fp))
               break;
            fscanf(fp,"%d %d\n",&index, &CalibrationBufferY[CalibrationYNo++]);
            if(CalibrationYNo >= CALIBRATION_MAX)
               break;
         }
      }
      fclose(fp);
   }
}
//---------------------------------------------------------------------------
// 2016 12 22 - chc 取得Factor
void __fastcall TMainForm::GetFactor(double *fx,double *fy,double x1, double y1, double x2, double y2)
{
int min,max,no;
double value,fmin,fmax,factor;
AnsiString msg;

   // 2019 7 8 - chc 固定為1.0
   *fx = 1.0;
   *fy = 1.0;
   return;

//x1 = 20000;
//x2 = 50000;
//y1 = 50000;
//y2 = 180000;

   //---------------------------------------------------------------------------
   // 2018 1 7 - chc 校正
   //ceil(x)返回不小于x的最小整?值（然后???double型）。
   //*floor(x)返回不大于x的最大整?值。
   //round(x)返回x的四舍五入整?值。
   double basicvalue,svalue,evalue;
   // X
   if(x1 > x2) {
      fmin = x2;
      fmax = x1;
   }
   else {
      fmin = x1;
      fmax = x2;
   }
   min = floor(fmin / 60000.0);
   basicvalue = min * 60000.0;
   if(min == 0)
      svalue = fmin;
   else
      svalue = (basicvalue / CalibrationBufferX[min]) * fmin;
   max = floor(fmax / 60000.0);
   basicvalue = max * 60000.0;
   if(max == 0)
      evalue = fmax;
   else
      evalue = (basicvalue / CalibrationBufferX[max]) * fmax;
   *fx = evalue - svalue + 1;
   // Y
   if(y1 > y2) {
      fmin = y2;
      fmax = y1;
   }
   else {
      fmin = y1;
      fmax = y2;
   }
   min = floor(fmin / 60000.0);
   basicvalue = min * 60000.0;
   if(min == 0)
      svalue = fmin;
   else
      svalue = (basicvalue / CalibrationBufferY[min]) * fmin;
   max = floor(fmax / 60000.0);
   basicvalue = max * 60000.0;
   if(max == 0)
      evalue = fmax;
   else
      evalue = (basicvalue / CalibrationBufferY[max]) * fmax;
   *fy = evalue - svalue + 1;
   return;
   //---------------------------------------------------------------------------

   if(x1 > x2) {
      fmin = x2;
      fmax = x1;
   }
   else {
      fmin = x1;
      fmax = x2;
   }

   // 前後段要按比例
   // 2018 1 7 - chc 要用floor
   //min = fmin / 60000.0;
   //max = fmax / 60000.0;
   min = floor(fmin / 60000.0);
   max = floor(fmax / 60000.0);

   if(min < 0)
      min = 0;
   if(max > CALIBRATION_MAX-1)
      max = CALIBRATION_MAX-1;
   value = 0;

   // 2016 12 30 - chc 修正
   //value += (((fmin - min*60000.0) * CalibrationBufferX[min])/60000.0);
   //value += (((fmax - max*60000.0) * CalibrationBufferX[max])/60000.0);
   //for(int i=min+1 ; i<=max ; i++) {
   //   value += CalibrationBufferX[i];
   //}
   //no = max - min + 1;
   if(min == max) {
      value += (((fmax - fmin) * CalibrationBufferX[min])/60000.0);
   }
   else {
      value += ((((min+1)*60000.0 - fmin) * CalibrationBufferX[min])/60000.0);
      value += (((fmax - max*60000.0) * CalibrationBufferX[max])/60000.0);
      for(int i=min+1 ; i<max ; i++) {
         value += CalibrationBufferX[i];
      }
   }

   if((fmax - fmin + value) != 0)
      factor = (fmax - fmin) / (fmax - fmin + value);
   else
      factor = 1.0;
   *fx = factor;

   value = 0;
   if(y1 > y2) {
      fmin = y2;
      fmax = y1;
   }
   else {
      fmin = y1;
      fmax = y2;
   }

   // 2018 1 7 - chc 要用floor
   //min = fmin / 60000.0;
   //max = fmax / 60000.0;
   min = floor(fmin / 60000.0);
   max = floor(fmax / 60000.0);

   if(min < 0)
      min = 0;
   if(max > CALIBRATION_MAX-1)
      max = CALIBRATION_MAX-1;

   // 2016 12 30 - chc 修正
   //value += (((fmin - min*60000.0) * CalibrationBufferY[min])/60000.0);
   //value += (((fmax - max*60000.0) * CalibrationBufferY[max])/60000.0);
   //for(int i=min+1 ; i<=max ; i++) {
   //   value += CalibrationBufferY[i];
   //}
   //no = max - min + 1;
   if(min == max) {
      value += (((fmax - fmin) * CalibrationBufferY[min])/60000.0);
   }
   else {
      value += ((((min+1)*60000.0 - fmin) * CalibrationBufferY[min])/60000.0);
      value += (((fmax - max*60000.0) * CalibrationBufferY[max])/60000.0);
      for(int i=min+1 ; i<max ; i++) {
         value += CalibrationBufferY[i];
      }
   }

   if((fmax - fmin + value) != 0)
      factor = (fmax - fmin) / (fmax - fmin + value);
   else
      factor = 1.0;
   *fy = factor;

   // Log
   msg.sprintf("Factor: %.6f, %.6f",*fx,*fy);

   // 2017 1 4 - chc 不Log
   //WriteSystemLog(msg);

}
//---------------------------------------------------------------------------
// 2016 12 30 - chc Speed Parameter
void __fastcall TMainForm::btnSpeedUpdateClick(TObject *Sender)
{
AnsiString msg;
TIniFile *pSystemFile;

   // 速度切換(低/中/高): 低速(0.5%), 中速(20%), 高速(100%)
   msg.sprintf("Low(%s\%)",edSpeedGeneralLow->Text.c_str());
   rgSpeed->Items->Strings[0] = msg;
   msg.sprintf("Mid(%s\%)",edSpeedGeneralMiddle->Text.c_str());
   rgSpeed->Items->Strings[1] = msg;
   msg.sprintf("High(%s\%)",edSpeedGeneralHigh->Text.c_str());
   rgSpeed->Items->Strings[2] = msg;

   // Write to .ini
   pnlSystemMessage->Caption = "更新速度參數...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->SpeedINIFilename);

   // General
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"General Low"            ,edSpeedGeneralLow->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"General Middle"         ,edSpeedGeneralMiddle->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"General High"           ,edSpeedGeneralHigh->Text);
   // Turbo
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Turbo Low"              ,edSpeedTurboLow->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Turbo Middle"           ,edSpeedTurboMiddle->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Turbo High"             ,edSpeedTurboHigh->Text);
   // Z
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Z Low"                  ,edSpeedZLow->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Z Middle"               ,edSpeedZMiddle->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Z High"                 ,edSpeedZHigh->Text);

   delete pSystemFile;
   pnlSystemMessage->Caption = "更新速度參數完成.";
}
//---------------------------------------------------------------------------
// 2016 12 30 - chc Load Speed Parameter
void __fastcall TMainForm::LoadSpeedParameter()
{
AnsiString msg;
TIniFile *pSystemFile;
AnsiString sgenerallow,sgeneralmiddle,sgeneralhigh,sturbolow,sturbomiddle,sturbohigh,szlow,szmiddle,szhigh;

   // Read .ini
   pnlSystemMessage->Caption = "載入速度參數...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->SpeedINIFilename);

   // General: 0.01,0.1,1
   sgenerallow = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"General Low"            ,"0.01");
   sgeneralmiddle = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"General Middle"      ,"0.1");
   sgeneralhigh = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"General High"          ,"1");
   // Turbo: 0.5,20,100
   sturbolow = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Turbo Low"                ,"0.5");
   sturbomiddle = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Turbo Middle"          ,"20");
   sturbohigh = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Turbo High"              ,"100");
   // Z: 0.3,15,100
   szlow = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Z Low"                        ,"0.3");
   szmiddle = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Z Middle"                  ,"15");
   szhigh = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Z High"                      ,"100");

   delete pSystemFile;

   // 填入元件
   // General
   edSpeedGeneralLow->Text = sgenerallow;
   edSpeedGeneralMiddle->Text = sgeneralmiddle;
   edSpeedGeneralHigh->Text = sgeneralhigh;
   // Turbo
   edSpeedTurboLow->Text = sturbolow;
   edSpeedTurboMiddle->Text = sturbomiddle;
   edSpeedTurboHigh->Text = sturbohigh;
   // Z
   edSpeedZLow->Text = szlow;
   edSpeedZMiddle->Text = szmiddle;
   edSpeedZHigh->Text = szhigh;

   // 速度切換(低/中/高): 低速(0.5%), 中速(20%), 高速(100%)
   msg.sprintf("Low(%s\%)",edSpeedGeneralLow->Text.c_str());
   rgSpeed->Items->Strings[0] = msg;
   msg.sprintf("Mid(%s\%)",edSpeedGeneralMiddle->Text.c_str());
   rgSpeed->Items->Strings[1] = msg;
   msg.sprintf("High(%s\%)",edSpeedGeneralHigh->Text.c_str());
   rgSpeed->Items->Strings[2] = msg;

   pnlSystemMessage->Caption = "載入速度參數完成.";
}
//---------------------------------------------------------------------------
// 2016 12 30 - chc Auto Focus : Sobel
//  目前位置: edAOIZ->Text
//  精度: 0.1um/p
//  影像處理: 小區域Sobel, 再計算亮點(Gray > 30)數量
// Sobel
// 1. 到定位點
// 2. 往上低速移動
// 3. 記錄最亮點, 變暗就停止
// 4. 到定位點
// 5. 往下低速移動
// 6. 記錄最亮點, 變暗就停止
// 7.
void __fastcall TMainForm::btnAutoFocusClick(TObject *Sender)
{
int zpos,offset,speed;
int x1,y1,x2,y2,w,h,cx,cy,row,col,no,upvalue,downvalue;
unsigned char *ptr;
EC24 *cptr;
double zuppos,zdownpos;
I16 status;

// Sobel
int data,std,sum,width;
double xx,yy,zz,amp;
int d[25];
bool boolrobert = true;
EC24 *ptr1,*ptr2,*ptr3;

// 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
unsigned char *ptr1bw,*ptr2bw,*ptr3bw;

static int sx[9] = {-1, 0, 1,
                    -2, 1, 2,
                    -1, 0, 1};
static int sy[9] = {-1,-2,-1,
                     0, 0, 0,
                     1, 2, 1};
// Roberts
static int rx[9] = { 0, 0, 0,
                     0, 1, 0,
                     0, 0,-1};
static int ry[9] = { 0, 0, 0,
                     0, 0, 1,
                     0, -1,0};

// 2019 11 19 - chc 加入各algorithm
int max,min,dcnt;
long mean = 0;
int gap = 50;
int z1,z2,z3,z4,z5,z6,z7,z8,z9,G1,G2;
// Variance分成128上與下
long meanlow = 0;
long meanhigh = 0;
int dcntlow;
int dcnthigh;
long sumlow,sumhigh;
// 差距
int diff1,diff2;
int cnt,oldsum;
double zupposbest,zdownposbest;
int upcount,downcount;
int bestz = 0;
bool boolresult;

   // 2017 2 4 - chc 要設定amp
   amp = 1;
   btnAutoFocus->Enabled = false;
   upcount = 0;
   downcount = 0;

   pnlAutoFocus->Color = clSilver;
   pnlAutoFocus1->Color = clSilver;
   // 到定位點: Z軸absolute移動
   speed = edAutoFocusSpeed->Text.ToInt();
   zpos = edAutoFocus->Text.ToInt();
   WriteSystemLog(">>UpFocus: MoveTo " + IntToStr(zpos) + " ...");

   // 2021 5 9 - chc 改成高速
   //MoveToZ(zpos,speed*10,0);
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //boolresult = MoveToZ(zpos);
   boolresult = MoveToZ(zpos,MOVE_WAIT);

   if(boolresult == false) {
      pnlAutoFocus->Color = clRed;
      pnlAutoFocus1->Color = clRed;
      pnlAlarmMessage->Caption = "Z移動失敗!";
      MainForm->iAxisMove[Z_AXIS] = NO_MOVE;
      WriteSystemLog(">>Focus失敗, Z移動失敗");
      btnAutoFocus->Enabled = true;
      return;
   }

   // 低速往上
   offset = edAutoFocusOffset->Text.ToInt();
   WriteSystemLog(">>UpFocus: MoveTo " + IntToStr(zpos-offset) + " ...");
   MoveToZ(zpos-offset,speed,1);
   no = 0;
   // 中間800*800
   // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
   if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
      w = scA1300ImageAry[0].GetWidth();
      h = scA1300ImageAry[0].GetHeight();
   }
   else {

      w = usb_ImageAry[0].GetWidth();
      h = usb_ImageAry[0].GetHeight();
   }
   cx = w / 2;
   cy = h / 2;
   x1 = cx - 400;
   y1 = cy - 400;
   x2 = x1 + 800;
   y2 = y1 + 800;
   zuppos = -1;
   zdownpos = -1;

   // 2019 11 26 - chc Reset to -1
   zupposbest = -1;
   zdownposbest = -1;

   WriteSystemLog(">>UpFocus do...");
   // Motion Start...
   Sleep(10);
   Application->ProcessMessages();
   int tout = 0;
   while(1) {

      // 2021 4 15 - chc 8154 or APS_
      if(MotionMode == MOTION_MODE_APS) {
         I32 done;
         status = 0;
         done = APS_motion_status(Z_AXIS+StartAxisNo);
         // 看bit 0 : 不等於0(Done)
         if((done & 0x01) == 0)
            status = 1;
      }
      if(status != 0 && status != 17 && status != 18)
         break;
      Sleep(1);
      Application->ProcessMessages();
      tout++;
      if(tout > 20)
         break;
   }

   // 2017 2 4 - chc 仿Laser
   upvalue = 0;
   downvalue = 0;
   pnlUpValue->Caption = IntToStr(upvalue);
   WriteSystemLog(">>UpFocus exe...");

   // 2019 11 19 - chc Algorithm
   pnlSystemMessage->Caption = "Up Focus start...";
   cnt = 0;
   oldsum = 0;

   // 2019 11 26 - chc 記錄是否Z有變動, 若未變動則不做
   double zuppos_old,zdownpos_old;
   zuppos_old = -1;
   zdownpos_old = -1;
   // 白點數量
   int upwhitecnt = 0;
   int downwhitecnt = 0;
   int whiteratio = 10;

   // 2021 4 24 - chc 加入對比量: edDifferenceValue
   whiteratio = edDifferenceRatio->Text.ToInt();
   int whitevalue = 250;
   whitevalue = edDifferenceValue->Text.ToInt();

   while(1) {

      // 2019 11 19 - chc Algorithm
      // 2019 11 27 - chc 有比較才算
      //upcount++;
      //pnlUpZCount->Caption = IntToStr(upcount);

      // Motion done
      // 2021 4 15 - chc 8154 or APS_
      if(MotionMode == MOTION_MODE_APS) {
         I32 done;
         status = 0;

         // 2022 11 14 - chc 寫錯T => Z!
         //done = APS_motion_status(T_AXIS+StartAxisNo);
         done = APS_motion_status(Z_AXIS+StartAxisNo);

         // 看bit 0 : 不等於0(Done)
         if((done & 0x01) == 0)
            status = 1;
      }
      if(status == 0 || status == 17 || status == 18) {
         WriteSystemLog(">>UpFocus Motion done: " + IntToStr(status));
         break;
      }

      //=================================================
      // Sobel: 30
      //
      std = 30;
      width = x2 - x1;
      sum = 0;

      // 2019 11 27 - chc 要Reset
      upwhitecnt = 0;

      // 2019 11 26 - chc 檢測前要先讀取: AUO要改
      GetPosition(Z_AXIS, &zuppos);
      pnlUpZPos->Caption = IntToStr((int)zuppos);
      // 記錄是否Z有變動, 若未變動則不做
      if(zuppos_old == -1) {
         zuppos_old = zuppos;
      }
      else {
         if(zuppos == zuppos_old)
            continue;
         else
            zuppos_old = zuppos;
      }

      // 2019 11 19 - chc Algorithm
      switch(rgFocusAlgorithm->ItemIndex) {
         // 差距總和
         case 0:

            // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
            if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
               for(row=y1+1 ; row<y2 ; row+=1) {
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  ptr2bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row+3);         // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {
                     // 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)

                        upwhitecnt++;
                     diff1 = abs(ptr1bw[col]-ptr1bw[col+3]);
                     diff2 = abs(ptr1bw[col]-ptr2bw[col]);
                     if(diff1 > 5)
                        sum += diff1;
                     else
                        sum += (diff1 / 2);
                     if(diff2 > 5)
                        sum += diff2;
                     else
                        sum += (diff2 / 2);
                  }
               }
            }
            else {

               for(row=y1+1 ; row<y2 ; row+=1) {
                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  ptr2 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row+3);         // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {

                     // 2019 11 26 - chc 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        upwhitecnt++;

                     diff1 = abs(ptr1[col].m_un8C1-ptr1[col+3].m_un8C1);
                     diff2 = abs(ptr1[col].m_un8C1-ptr2[col].m_un8C1);
                     if(diff1 > 5)
                        sum += diff1;
                     else
                        sum += (diff1 / 2);
                     if(diff2 > 5)
                        sum += diff2;
                     else
                        sum += (diff2 / 2);
                  }
               }
            }
            break;

         // Sobel
         case 1:

            for(row=y1+1 ; row<y2 ; row+=2) {
               //ptr  = ProcessImage.GetImagePtr(0,row);                                   // 取得Buffer位置

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row-1);                            // 取得Buffer位置
                  ptr2bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);                              // 取得Buffer位置
                  ptr3bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row+1);                            // 取得Buffer位置
               }
               else {

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row-1);                            // 取得Buffer位置
                  ptr2 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);                              // 取得Buffer位置
                  ptr3 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row+1);                            // 取得Buffer位置
               }
               for(col=1 ; col<width ; col+=2) {

                  // 2019 11 26 - chc 白點數量
                  // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
                  if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        upwhitecnt++;

                     d[0] = ptr1bw[col-1];
                     d[1] = ptr1bw[col];
                     d[2] = ptr1bw[col+1];
                     d[3] = ptr2bw[col-1];
                     d[4] = ptr2bw[col];
                     d[5] = ptr2bw[col+1];
                     d[6] = ptr3bw[col-1];
                     d[7] = ptr3bw[col];
                     d[8] = ptr3bw[col+1];
                     xx = (double)(sx[0]*d[0] + sx[1]*d[1] + sx[2]*d[2]
                              + sx[3]*d[3] + sx[4]*d[4] + sx[5]*d[5]
                              + sx[6]*d[6] + sx[7]*d[7] + sx[8]*d[8]);
                     yy = (double)(sy[0]*d[0] + sy[1]*d[1] + sy[2]*d[2]
                              + sy[3]*d[3] + sy[4]*d[4] + sy[5]*d[5]
                              + sy[6]*d[6] + sy[7]*d[7] + sy[8]*d[8]);
                     zz = (double)(amp*sqrt(xx*xx+yy*yy));
                     data = (int)zz;
                     if(data > 255)
                        data = 255;
                     //ptr[col] = (char)data;
                     if(data > std)
                        sum++;
                  }
                  else {

                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        upwhitecnt++;

                     d[0] = ptr1[col-1].m_un8C1;
                     d[1] = ptr1[col].m_un8C1;
                     d[2] = ptr1[col+1].m_un8C1;
                     d[3] = ptr2[col-1].m_un8C1;
                     d[4] = ptr2[col].m_un8C1;
                     d[5] = ptr2[col+1].m_un8C1;
                     d[6] = ptr3[col-1].m_un8C1;
                     d[7] = ptr3[col].m_un8C1;
                     d[8] = ptr3[col+1].m_un8C1;
                     xx = (double)(sx[0]*d[0] + sx[1]*d[1] + sx[2]*d[2]
                              + sx[3]*d[3] + sx[4]*d[4] + sx[5]*d[5]
                              + sx[6]*d[6] + sx[7]*d[7] + sx[8]*d[8]);
                     yy = (double)(sy[0]*d[0] + sy[1]*d[1] + sy[2]*d[2]
                              + sy[3]*d[3] + sy[4]*d[4] + sy[5]*d[5]
                              + sy[6]*d[6] + sy[7]*d[7] + sy[8]*d[8]);
                     zz = (double)(amp*sqrt(xx*xx+yy*yy));
                     data = (int)zz;
                     if(data > 255)
                        data = 255;
                     //ptr[col] = (char)data;
                     if(data > std)
                        sum++;
                  }
               }
               // 要加入, 否則可能無法做tmMotionPolling!!
               if((row % 50) == 0) {
                  Sleep(1);
                  Application->ProcessMessages();
               }
            }
            WriteSystemLog(">>UpFocus sobel: " + IntToStr(sum));

         // 2019 11 19 - chc Algorithm
            break;
         // Gradient: 最大梯度值
         case 2:
            for(col=1 ; col<width ; col++) {
               for(row=y1+1 ; row<y2 ; row++) {

                  // 2019 11 26 - chc 白點數量
                  // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
                  if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                     ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row-1);                            // 取得Buffer位置
                     ptr2bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);                              // 取得Buffer位置
                     ptr3bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row+1);                            // 取得Buffer位置
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        upwhitecnt++;
                     z1 = ptr1bw[col-1];
                     z2 = ptr2bw[col-1];
                     z3 = ptr3bw[col-1];
                     z4 = ptr1bw[col];
                     z6 = ptr3bw[col];
                     z7 = ptr1bw[col+1];
                     z8 = ptr2bw[col+1];
                     z9 = ptr3bw[col+1];
                     G1 = abs(-z1 - 2*x2 - z3 + z7 + 2*z9 + z9);
                     G2 = abs(-z1 - 2*z4 - z7 + z3 + 2*z6 + z9);
                     sum += G1;
                     sum += G2;
                  }
                  else {

                     ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row-1);                            // 取得Buffer位置
                     ptr2 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);                              // 取得Buffer位置
                     ptr3 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row+1);                            // 取得Buffer位置
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        upwhitecnt++;
                     z1 = ptr1[col-1].m_un8C1;
                     z2 = ptr2[col-1].m_un8C1;
                     z3 = ptr3[col-1].m_un8C1;
                     z4 = ptr1[col].m_un8C1;
                     z6 = ptr3[col].m_un8C1;
                     z7 = ptr1[col+1].m_un8C1;
                     z8 = ptr2[col+1].m_un8C1;
                     z9 = ptr3[col+1].m_un8C1;
                     G1 = abs(-z1 - 2*x2 - z3 + z7 + 2*z9 + z9);
                     G2 = abs(-z1 - 2*z4 - z7 + z3 + 2*z6 + z9);
                     sum += G1;
                     sum += G2;
                  }
               }
            }
            break;
         // Variance
         case 3:
            mean = 0;
            dcnt = 0;
            // 分128上下
            meanlow = 0;
            dcntlow = 0;
            meanhigh = 0;
            dcnthigh = 0;
            sumlow = 0;
            sumhigh = 0;
            sum = 0;
            for(row=y1+1 ; row<y2 ; row+=1) {

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW)
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
               else

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
               for(col=0 ; col<width ; col+=1) {

                  // 2019 11 26 - chc 白點數量
                  // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
                  if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        upwhitecnt++;

                     // 全計
                     if(ptr1bw[col] <= 255) {
                        mean += ptr1bw[col];
                        dcnt++;
                        // 分128上下
                        if(ptr1bw[col] == 255)
                           mean += 10;
                        if(ptr1bw[col] < 128) {
                           meanlow += ptr1bw[col];
                           dcntlow++;
                        }
                        else {
                           meanhigh += ptr1bw[col];
                           dcnthigh++;
                        }
                     }
                  }
                  else {

                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        upwhitecnt++;

                     // 全計
                     if(ptr1[col].m_un8C1 <= 255) {
                        mean += ptr1[col].m_un8C1;
                        dcnt++;
                        // 分128上下
                        if(ptr1[col].m_un8C1 == 255)
                           mean += 10;
                        if(ptr1[col].m_un8C1 < 128) {
                           meanlow += ptr1[col].m_un8C1;
                           dcntlow++;
                        }
                        else {
                           meanhigh += ptr1[col].m_un8C1;
                           dcnthigh++;
                        }
                     }
                  }
               }
            }
            if(dcnt > 0)
               mean = mean / dcnt;
            // 分128上下
            if(dcntlow > 0)
               meanlow = meanlow / dcntlow;
            if(dcnthigh > 0)
               meanhigh = meanhigh / dcnthigh;
            for(row=y1+1 ; row<y2 ; row+=1) {

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {
                     // 全計
                     if(ptr1bw[col] <= 255) {
                        sum += abs(ptr1bw[col]-mean);
                        // 分128上下
                        if(ptr1bw[col] < 128)
                           sumlow += abs(ptr1bw[col]-meanlow);
                        else
                           sumhigh += abs(ptr1bw[col]-meanhigh);
                     }
                  }
               }
               else {

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {
                     // 全計
                     if(ptr1[col].m_un8C1 <= 255) {
                        sum += abs(ptr1[col].m_un8C1-mean);
                        // 分128上下
                        if(ptr1[col].m_un8C1 < 128)
                           sumlow += abs(ptr1[col].m_un8C1-meanlow);
                        else
                           sumhigh += abs(ptr1[col].m_un8C1-meanhigh);
                     }
                  }
               }
            }
            break;
         // Contrast
         case 4:
            for(row=y1+1 ; row<y2 ; row+=1) {

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW)
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
               else

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
               max = 0;
               min = 300;
               dcnt = 0;
               for(col=0 ; col<width ; col+=1) {

                  // 2019 11 26 - chc 白點數量
                  // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
                  if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        upwhitecnt++;

                     // 過亮不計
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] <= 240) {
                     if(ptr1bw[col] <= whitevalue-10) {
                        if(ptr1bw[col] < min)
                           min = ptr1bw[col];
                        if(ptr1bw[col] > max)
                           max = ptr1bw[col];
                        dcnt++;
                        if(dcnt >= gap) {
                           sum += (max - min);
                           max = 0;
                           min = 300;
                           dcnt = 0;
                        }
                     }
                  }
                  else {

                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        upwhitecnt++;

                     // 過亮不計
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 <= 240) {
                     if(ptr1[col].m_un8C1 <= whitevalue-10) {
                        if(ptr1[col].m_un8C1 < min)
                           min = ptr1[col].m_un8C1;
                        if(ptr1[col].m_un8C1 > max)
                           max = ptr1[col].m_un8C1;
                        dcnt++;
                        if(dcnt >= gap) {
                           sum += (max - min);
                           max = 0;
                           min = 300;
                           dcnt = 0;
                        }
                     }
                  }
               }
               // 確認是否有效
               if(max !=0 || min != 300)
                  sum += (max - min);
            }
            break;
      }
      //
      //=================================================

      // 2019 11 26 - chc 白點數量
      sum += (upwhitecnt * whiteratio);

      if(sum > upvalue) {

         // 2019 11 26 - chc 前面已做過: AUO要改
         //GetPosition(Z_AXIS, &zuppos);
         //pnlUpZPos->Caption = IntToStr((int)zuppos);

         WriteSystemLog(">>UpFocus better: " + IntToStr(upvalue) + "," + pnlUpZPos->Caption + "," + IntToStr(upwhitecnt));
         pnlUpZPos->Refresh();
         upvalue = sum;
         pnlSystemMessage->Caption = "Up Focus: " + IntToStr(upvalue) + "," + IntToStr((int)zuppos);
         pnlUpValue->Caption = IntToStr(upvalue);
         pnlUpValue->Refresh();

         // 2019 11 19 - chc Algorithm
         zupposbest = zuppos;
         // 若連續多次變弱就可以停下
         cnt = 0;
         // 要有變化才能比較
         oldsum = sum;

         // 2019 11 27 - chc 有比較才算
         upcount++;
         pnlUpZCount->Caption = IntToStr(upcount);

      }

      // 2019 11 19 - chc Algorithm
      else {
         // 要有變化才能比較, 降低超過1%才算
         // => 用原方式就可以
         if(sum < oldsum) {
         //if(sum < oldsum && (double)(oldsum-sum)/oldsum > 0.01) {
            oldsum = sum;
            // 250以上就算
            if(sum > 250)
               cnt++;

            pnlSystemMessage->Caption = "Up Focus: " + IntToStr(upvalue) + "," + IntToStr((int)zuppos);
            pnlSystemMessage->Refresh();

            // 要顯示zuppos
            WriteSystemLog(">>UpFocus worse: " + IntToStr(sum) + "," + IntToStr((int)zuppos));
            if(cbAIFocus->Checked == true) {
               if(cnt > 4) {

                  // 2021 4 15 - chc 8154 or APS_
                  if(MotionMode == MOTION_MODE_APS)
                     APS_emg_stop(Z_AXIS+StartAxisNo);
                  break;
               }
            }

            // 2019 11 27 - chc 有比較才算
            upcount++;
            pnlUpZCount->Caption = IntToStr(upcount);

         }
      }

      Sleep(1);
      Application->ProcessMessages();
   }

   //===========================
   // 2019 11 26 - chc 要指定為已移動完成
   MainForm->iAxisMove[Z_AXIS] = NO_MOVE;

   // 到定位點: Z軸absolute移動
   WriteSystemLog(">>DownFocus: MoveTo " + IntToStr(zpos) + " ...");
   MoveToZ(zpos,speed*10,0);
   WriteSystemLog(">>DownFocus: MoveTo " + IntToStr(zpos+offset) + " ...");
   MoveToZ(zpos+offset,speed,1);
   WriteSystemLog(">>DownFocus do...");
   // Motion Start...
   Sleep(10);
   Application->ProcessMessages();
   tout = 0;
   while(1) {

      // 2021 4 15 - chc 8154 or APS_
      if(MotionMode == MOTION_MODE_APS) {
         I32 done;
         status = 0;
         done = APS_motion_status(Z_AXIS+StartAxisNo);
         // 看bit 0 : 不等於0(Done)
         if((done & 0x01) == 0)
            status = 1;
      }
      if(status != 0 && status != 17 && status != 18)
         break;
      Sleep(1);
      Application->ProcessMessages();
      tout++;
      if(tout > 20)
         break;
   }

   WriteSystemLog(">>DownFocus exe...");
   pnlDownValue->Caption = IntToStr(downvalue);

   // 2019 11 19 - chc 若連續多次變弱就可以停下
   oldsum = 0;
   cnt = 0;
   pnlSystemMessage->Caption = "Down Focus start...";

   while(1) {

      // 2019 11 19 - chc 若連續多次變弱就可以停下
      // 2019 11 27 - chc 有比較才算
      //downcount++;
      //pnlDownZCount->Caption = IntToStr(downcount);

      // Motion done
      // 2021 4 15 - chc 8154 or APS_
      if(MotionMode == MOTION_MODE_APS) {
         I32 done;
         status = 0;
         done = APS_motion_status(Z_AXIS+StartAxisNo);
         // 看bit 0 : 不等於0(Done)
         if((done & 0x01) == 0)
            status = 1;
      }
      if(status == 0 || status == 17 || status == 18) {
         WriteSystemLog(">>DownFocus Motion done: " + IntToStr(status));
         break;
      }

      //=================================================
      // Sobel: 30
      //
      std = 30;
      width = x2 - x1;
      sum = 0;

      // 2019 11 27 - chc 要Reset
      downwhitecnt = 0;

      // 2019 11 26 - chc 檢測前要先讀取: AUO要改
      GetPosition(Z_AXIS, &zdownpos);
      pnlDownZPos->Caption = IntToStr((int)zdownpos);
      // 記錄是否Z有變動, 若未變動則不做
      if(zdownpos_old == -1) {
         zdownpos_old = zdownpos;
      }
      else {
         if(zdownpos == zdownpos_old)
            continue;
         else
            zdownpos_old = zdownpos;
      }

      // 2019 11 19 - chc Algorithm
      switch(rgFocusAlgorithm->ItemIndex) {
         // 差距總和
         case 0:
            for(row=y1+1 ; row<y2 ; row+=1) {

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  // 小差異不記錄
                  ptr2bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row+3);         // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {
                     // 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        downwhitecnt++;

                     // 小差異不記錄
                     diff1 = abs(ptr1bw[col]-ptr1bw[col+3]);
                     diff2 = abs(ptr1bw[col]-ptr2bw[col]);
                     if(diff1 > 5)
                        sum += diff1;
                     else
                        sum += (diff1 / 2);
                     if(diff2 > 5)
                        sum += diff2;
                     else
                        sum += (diff2 / 2);
                  }
               }
               else {

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  // 小差異不記錄
                  ptr2 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row+3);         // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {

                     // 2019 11 26 - chc 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        downwhitecnt++;

                     // 小差異不記錄
                     diff1 = abs(ptr1[col].m_un8C1-ptr1[col+3].m_un8C1);
                     diff2 = abs(ptr1[col].m_un8C1-ptr2[col].m_un8C1);
                     if(diff1 > 5)
                        sum += diff1;
                     else
                        sum += (diff1 / 2);
                     if(diff2 > 5)
                        sum += diff2;
                     else
                        sum += (diff2 / 2);
                  }
               }
            }
            break;
         // Sobel
         case 1:

            for(row=y1+1 ; row<y2 ; row+=2) {
               //ptr  = ProcessImage.GetImagePtr(0,row);                                   // 取得Buffer位置

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row-1);                            // 取得Buffer位置
                  ptr2bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);                              // 取得Buffer位置
                  ptr3bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row+1);                            // 取得Buffer位置
                  for(col=1 ; col<width ; col+=2) {
                     // 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        downwhitecnt++;

                     d[0] = ptr1bw[col-1];
                     d[1] = ptr1bw[col];
                     d[2] = ptr1bw[col+1];
                     d[3] = ptr2bw[col-1];
                     d[4] = ptr2bw[col];
                     d[5] = ptr2bw[col+1];
                     d[6] = ptr3bw[col-1];
                     d[7] = ptr3bw[col];
                     d[8] = ptr3bw[col+1];
                     xx = (double)(sx[0]*d[0] + sx[1]*d[1] + sx[2]*d[2]
                              + sx[3]*d[3] + sx[4]*d[4] + sx[5]*d[5]
                              + sx[6]*d[6] + sx[7]*d[7] + sx[8]*d[8]);
                     yy = (double)(sy[0]*d[0] + sy[1]*d[1] + sy[2]*d[2]
                              + sy[3]*d[3] + sy[4]*d[4] + sy[5]*d[5]
                              + sy[6]*d[6] + sy[7]*d[7] + sy[8]*d[8]);
                     zz = (double)(amp*sqrt(xx*xx+yy*yy));
                     data = (int)zz;
                     if(data > 255)
                        data = 255;
                     //ptr[col] = (char)data;
                     if(data > std)
                        sum++;
                  }
               }
               else {

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row-1);                            // 取得Buffer位置
                  ptr2 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);                              // 取得Buffer位置
                  ptr3 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row+1);                            // 取得Buffer位置
                  for(col=1 ; col<width ; col+=2) {

                     // 2019 11 26 - chc 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        downwhitecnt++;

                     d[0] = ptr1[col-1].m_un8C1;
                     d[1] = ptr1[col].m_un8C1;
                     d[2] = ptr1[col+1].m_un8C1;
                     d[3] = ptr2[col-1].m_un8C1;
                     d[4] = ptr2[col].m_un8C1;
                     d[5] = ptr2[col+1].m_un8C1;
                     d[6] = ptr3[col-1].m_un8C1;
                     d[7] = ptr3[col].m_un8C1;
                     d[8] = ptr3[col+1].m_un8C1;
                     xx = (double)(sx[0]*d[0] + sx[1]*d[1] + sx[2]*d[2]
                              + sx[3]*d[3] + sx[4]*d[4] + sx[5]*d[5]
                              + sx[6]*d[6] + sx[7]*d[7] + sx[8]*d[8]);
                     yy = (double)(sy[0]*d[0] + sy[1]*d[1] + sy[2]*d[2]
                              + sy[3]*d[3] + sy[4]*d[4] + sy[5]*d[5]
                              + sy[6]*d[6] + sy[7]*d[7] + sy[8]*d[8]);
                     zz = (double)(amp*sqrt(xx*xx+yy*yy));
                     data = (int)zz;
                     if(data > 255)
                        data = 255;
                     //ptr[col] = (char)data;
                     if(data > std)
                        sum++;
                  }
               }

               // 要加入, 否則可能無法做tmMotionPolling!!
               if((row % 50) == 0) {
                  Sleep(1);
                  Application->ProcessMessages();
               }

            }
            WriteSystemLog(">>UpFocus sobel: " + IntToStr(sum));

            // 2019 11 19 - chc Algorithm
            break;
         // Gradient: 最大梯度值
         case 2:
            for(col=1 ; col<width ; col++) {
               for(row=y1+1 ; row<y2 ; row++) {

                  // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
                  if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                     ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row-1);                            // 取得Buffer位置
                     ptr2bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);                              // 取得Buffer位置
                     ptr3bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row+1);                            // 取得Buffer位置
                     // 2019 11 26 - chc 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        downwhitecnt++;
                     z1 = ptr1bw[col-1];
                     z2 = ptr2bw[col-1];
                     z3 = ptr3bw[col-1];
                     z4 = ptr1bw[col];
                     z6 = ptr3bw[col];
                     z7 = ptr1bw[col+1];
                     z8 = ptr2bw[col+1];
                     z9 = ptr3bw[col+1];
                     G1 = abs(-z1 - 2*x2 - z3 + z7 + 2*z9 + z9);
                     G2 = abs(-z1 - 2*z4 - z7 + z3 + 2*z6 + z9);
                     sum += G1;
                     sum += G2;
                  }
                  else {

                     ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row-1);                            // 取得Buffer位置
                     ptr2 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);                              // 取得Buffer位置
                     ptr3 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row+1);                            // 取得Buffer位置
                     // 2019 11 26 - chc 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        downwhitecnt++;
                     z1 = ptr1[col-1].m_un8C1;
                     z2 = ptr2[col-1].m_un8C1;
                     z3 = ptr3[col-1].m_un8C1;
                     z4 = ptr1[col].m_un8C1;
                     z6 = ptr3[col].m_un8C1;
                     z7 = ptr1[col+1].m_un8C1;
                     z8 = ptr2[col+1].m_un8C1;
                     z9 = ptr3[col+1].m_un8C1;
                     G1 = abs(-z1 - 2*x2 - z3 + z7 + 2*z9 + z9);
                     G2 = abs(-z1 - 2*z4 - z7 + z3 + 2*z6 + z9);
                     sum += G1;
                     sum += G2;
                  }
               }
            }
            break;
         // Variance
         case 3:
            mean = 0;
            dcnt = 0;
            // 分128上下
            meanlow = 0;
            dcntlow = 0;
            meanhigh = 0;
            dcnthigh = 0;
            sumlow = 0;
            sumhigh = 0;
            sum = 0;
            for(row=y1+1 ; row<y2 ; row+=1) {

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {
                     // 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        downwhitecnt++;
                     // 全計
                     if(ptr1bw[col] <= 255) {
                        mean += ptr1bw[col];
                        dcnt++;
                        // 分128上下
                        if(ptr1bw[col] == 255)
                           mean += 10;
                        if(ptr1bw[col] < 128) {
                           meanlow += ptr1bw[col];
                           dcntlow++;
                        }
                        else {
                           meanhigh += ptr1bw[col];
                           dcnthigh++;
                        }
                     }
                  }
               }
               else {

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {

                     // 2019 11 26 - chc 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        downwhitecnt++;

                     // 全計
                     if(ptr1[col].m_un8C1 <= 255) {
                        mean += ptr1[col].m_un8C1;
                        dcnt++;
                        // 分128上下
                        if(ptr1[col].m_un8C1 == 255)
                           mean += 10;
                        if(ptr1[col].m_un8C1 < 128) {
                           meanlow += ptr1[col].m_un8C1;
                           dcntlow++;
                        }
                        else {
                           meanhigh += ptr1[col].m_un8C1;
                           dcnthigh++;
                        }
                     }
                  }
               }
            }
            if(dcnt > 0)
               mean = mean / dcnt;
            // 分128上下
            if(dcntlow > 0)
               meanlow = meanlow / dcntlow;
            if(dcnthigh > 0)
               meanhigh = meanhigh / dcnthigh;
            for(row=y1+1 ; row<y2 ; row+=1) {

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {
                     // 全計
                     if(ptr1bw[col] <= 255) {
                        sum += abs(ptr1bw[col]-mean);
                        // 分128上下
                        if(ptr1bw[col] < 128)
                           sumlow += abs(ptr1bw[col]-meanlow);
                        else
                           sumhigh += abs(ptr1bw[col]-meanhigh);
                     }
                  }
               }
               else {

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {
                     // 全計
                     if(ptr1[col].m_un8C1 <= 255) {
                        sum += abs(ptr1[col].m_un8C1-mean);
                        // 分128上下
                        if(ptr1[col].m_un8C1 < 128)
                           sumlow += abs(ptr1[col].m_un8C1-meanlow);
                        else
                           sumhigh += abs(ptr1[col].m_un8C1-meanhigh);
                     }
                  }
               }
            }
            break;
         // Contrast
         case 4:
            for(row=y1+1 ; row<y2 ; row+=1) {
               max = 0;
               min = 300;
               dcnt = 0;

               // 2019 11 27 - chc 是Gray/Color? scA1300ImageAry
               if(CCDInfoAry[no].Type == BASLER_CCD_BW) {
                  ptr1bw = (unsigned char *)scA1300ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {
                     // 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] > 250)
                     if(ptr1bw[col] > whitevalue)
                        downwhitecnt++;
                     // 過亮不計(Up已有)
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1bw[col] <= 240) {
                     if(ptr1bw[col] <= whitevalue-10) {
                        if(ptr1bw[col] < min)
                           min = ptr1bw[col];
                        if(ptr1bw[col] > max)
                           max = ptr1bw[col];
                        dcnt++;
                        if(dcnt >= gap) {
                           sum += (max - min);
                           max = 0;
                           min = 300;
                           dcnt = 0;
                        }
                     }
                  }
               }
               else {

                  ptr1 = (EC24 *)usb_ImageAry[no].GetImagePtr(x1,row);           // 取得Buffer位置
                  for(col=0 ; col<width ; col+=1) {

                     // 2019 11 26 - chc 白點數量
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 > 250)
                     if(ptr1[col].m_un8C1 > whitevalue)
                        downwhitecnt++;

                     // 過亮不計(Up已有)
                     // 2021 4 24 - chc whitevalue
                     //if(ptr1[col].m_un8C1 <= 240) {
                     if(ptr1[col].m_un8C1 <= whitevalue-10) {
                        if(ptr1[col].m_un8C1 < min)
                           min = ptr1[col].m_un8C1;
                        if(ptr1[col].m_un8C1 > max)
                           max = ptr1[col].m_un8C1;
                        dcnt++;
                        if(dcnt >= gap) {
                           sum += (max - min);
                           max = 0;
                           min = 300;
                           dcnt = 0;
                        }
                     }
                  }
               }
               sum += (max - min);
            }
            break;
      }


      // 2019 11 26 - chc 白點數量
      sum += (downwhitecnt * whiteratio);

      if(sum > downvalue) {

         // 2019 11 26 - chc 前面已做過: AUO要改
         //GetPosition(Z_AXIS, &zdownpos);
         //pnlDownZPos->Caption = IntToStr((int)zdownpos);

         WriteSystemLog(">>DownFocus better: " + IntToStr(downvalue) + "," + pnlDownZPos->Caption + "," + IntToStr(downwhitecnt));
         pnlDownZPos->Refresh();
         downvalue = sum;
         pnlSystemMessage->Caption = "Down Focus: " + IntToStr(downvalue) + "," + IntToStr((int)zdownpos);
         pnlDownValue->Caption = IntToStr(downvalue);
         pnlDownValue->Refresh();

         // 2019 11 19 - chc 若連續多次變弱就可以停下
         cnt = 0;
         // 要有變化才能比較
         oldsum = sum;
         zdownposbest = zdownpos;

         // 2019 11 27 - chc 有比較才算
         downcount++;
         pnlDownZCount->Caption = IntToStr(downcount);

      }

      // 2019 11 19 - chc 若連續多次變弱就可以停下
      else {
         // 要有變化才能比較, 降低超過1%才算
         // => 用原方式就可以
         if(sum < oldsum) {
         //if(sum < oldsum && (double)(oldsum-sum)/oldsum > 0.01) {

            oldsum = sum;
            // 250以上就算
            if(sum > 250)
               cnt++;

            pnlSystemMessage->Caption = "Down Focus: " + IntToStr(downvalue) + "," + IntToStr((int)zdownpos);
            pnlSystemMessage->Refresh();

            // 要顯示zdownpos
            WriteSystemLog(">>DownFocus worse: " + IntToStr(sum) + "," + IntToStr((int)zdownpos));
            if(cbAIFocus->Checked == true) {
               if(cnt > 4) {
                  // 2021 4 15 - chc APS
                  if(MotionMode == MOTION_MODE_APS)
                     APS_emg_stop(Z_AXIS);
                  break;
               }
            }

            // 2019 11 27 - chc 有比較才算
            downcount++;
            pnlDownZCount->Caption = IntToStr(downcount);

         }
      }

      Sleep(1);
      Application->ProcessMessages();
   }

   // 找定位
   // 2019 11 26 - chc 錯誤: AUO要改
   /*
   if(zdownpos == -1 && zuppos == -1) {
      pnlAutoFocus->Color = clRed;
      pnlAutoFocus1->Color = clRed;
      pnlSystemMessage->Caption = "Focus Fail!";
   }
   else if(zuppos == -1) {
      MoveToZ(zdownpos,speed*5,0);
      pnlAutoFocus->Color = clLime;
      pnlAutoFocus1->Color = clLime;
      pnlSystemMessage->Caption = "Focus Done: " + IntToStr((int)zdownpos);
   }
   else if(zdownpos == -1) {
      MoveToZ(zuppos,speed*5,0);
      pnlAutoFocus->Color = clLime;
      pnlAutoFocus1->Color = clLime;
      pnlSystemMessage->Caption = "Focus Done: " + IntToStr((int)zuppos);
   }
   else {
      if(upvalue > downvalue) {
         MoveToZ(zuppos,speed*5,0);
         pnlSystemMessage->Caption = "Focus Done: " + IntToStr((int)zuppos);
      }
      else {
         MoveToZ(zdownpos,speed*5,0);
         pnlSystemMessage->Caption = "Focus Done: " + IntToStr((int)zdownpos);
      }
      pnlAutoFocus->Color = clLime;
      pnlAutoFocus1->Color = clLime;
   }
   */
   // 找定位
   boolresult = false;
   if(zdownposbest == -1 && zupposbest == -1) {
      pnlAutoFocus->Color = clRed;
      pnlAutoFocus1->Color = clRed;
      pnlSystemMessage->Caption = "Focus Fail!";
      WriteSystemLog(">>Focus => 失敗");
   }
   else if(zupposbest == -1) {
      MoveToZ(zdownposbest,speed*5,0);
      pnlSystemMessage->Caption = "Focus Done: " + IntToStr((int)zdownposbest);
      WriteSystemLog(">>Focus成功(Down): " + IntToStr((int)zdownposbest));
      bestz = zdownposbest;

      // 加入Loop
      //bestvalue = downvalue;

      // 2021 5 9 - chc 稍晚再變動
      //pnlAutoFocus->Color = clLime;
      //pnlAutoFocus1->Color = clLime;
      boolresult = true;

   }
   else if(zdownposbest == -1) {
      MoveToZ(zupposbest,speed*5,0);
      pnlSystemMessage->Caption = "Focus Done: " + IntToStr((int)zupposbest);
      WriteSystemLog(">>Focus成功(Up): " + IntToStr((int)zupposbest));
      bestz = zupposbest;

      // 加入Loop
      //bestvalue = upvalue;

      // 2021 5 9 - chc 稍晚再變動
      //pnlAutoFocus->Color = clLime;
      //pnlAutoFocus1->Color = clLime;
      boolresult = true;

   }
   else {
      if(upvalue > downvalue) {
         MoveToZ(zupposbest,speed*5,0);
         pnlSystemMessage->Caption = "Focus Done: " + IntToStr((int)zupposbest);
         WriteSystemLog(">>Focus成功(Up): " + IntToStr((int)zupposbest));
         bestz = zupposbest;

         // 加入Loop
         //bestvalue = upvalue;

      }
      else {
         MoveToZ(zdownposbest,speed*5,0);
         pnlSystemMessage->Caption = "Focus Done: " + IntToStr((int)zdownposbest);
         WriteSystemLog(">>Focus成功(Down): " + IntToStr((int)zdownposbest));
         bestz = zdownposbest;

         // 加入Loop
         //bestvalue = downvalue;

      }

      // 2021 5 9 - chc 稍晚再變動
      //pnlAutoFocus->Color = clLime;
      //pnlAutoFocus1->Color = clLime;
      boolresult = true;

   }
   MainForm->iAxisMove[Z_AXIS] = NO_MOVE;
   WriteSystemLog(">>Focus成功, 移動到: " + IntToStr(bestz));
   MoveToZ(bestz,speed*5,0);

   btnAutoFocus->Enabled = true;

   // 2021 5 9 - chc 稍晚再變動
   if(boolresult == true) {
      pnlAutoFocus->Color = clLime;
      pnlAutoFocus1->Color = clLime;
   }
}
//---------------------------------------------------------------------------
// 2017 1 3 - chc focus save
void __fastcall TMainForm::btnUpdateFocusClick(TObject *Sender)
{
AnsiString msg;
TIniFile *pSystemFile;

   // Write to .ini
   pnlSystemMessage->Caption = "更新對焦參數...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->FocusINIFilename);

   // General
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Z"                       ,edAutoFocus->Text);
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Z Offset"                ,edAutoFocusOffset->Text);
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Z Speed"                 ,edAutoFocusSpeed->Text);

   // 2019 11 27 - chc 加入Quick Mode & Algorithm
   pSystemFile->WriteBool(FOCUS_INFORMATION_SECTION,"Z Quick Mode"              ,cbAIFocus->Checked);
   pSystemFile->WriteInteger(FOCUS_INFORMATION_SECTION,"Z Focus Algorithm"      ,rgFocusAlgorithm->ItemIndex);

   // 2021 4 24 - chc 加入對比量: edDifferenceValue
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Difference Value"        ,edDifferenceValue->Text);
   // 加入加權: edDifferenceRatio
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Difference Ratio"        ,edDifferenceRatio->Text);

   delete pSystemFile;
   pnlSystemMessage->Caption = "更新對焦參數完成.";
}
//---------------------------------------------------------------------------
// 2017 1 3 - chc Load Focus Parameter
void __fastcall TMainForm::LoadFocusParameter()
{
AnsiString msg;
TIniFile *pSystemFile;
AnsiString szfocus,szfocusoffset,szfocusspeed;

   // Read .ini
   pnlSystemMessage->Caption = "載入對焦參數...";

   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->FocusINIFilename);
   szfocus = pSystemFile->ReadString(FOCUS_INFORMATION_SECTION,"Z"              ,"51036");
   szfocusoffset = pSystemFile->ReadString(FOCUS_INFORMATION_SECTION,"Z Offset" ,"5000");
   szfocusspeed = pSystemFile->ReadString(FOCUS_INFORMATION_SECTION,"Z Speed"   ,"200");

   // 2019 11 27 - chc 加入Quick Mode & Algorithm
   bool boolquickmode;
   boolquickmode = pSystemFile->ReadBool(FOCUS_INFORMATION_SECTION,"Z Quick Mode"           ,false);
   cbAIFocus->Checked = boolquickmode;
   int ialgorithm;
   ialgorithm = pSystemFile->ReadInteger(FOCUS_INFORMATION_SECTION,"Z Focus Algorithm"      ,0);
   rgFocusAlgorithm->ItemIndex = ialgorithm;

   // 2021 4 24 - chc Focus加入對比量: edDifferenceValue
   int differencevalue;
   differencevalue = pSystemFile->ReadInteger(FOCUS_INFORMATION_SECTION,"Difference Value"        ,250);
   if(differencevalue < 200 || differencevalue > 250)
      differencevalue = 250;
   edDifferenceValue->Text = IntToStr(differencevalue);
   // 加入加權: edDifferenceRatio
   int differenceratio;
   differenceratio = pSystemFile->ReadInteger(FOCUS_INFORMATION_SECTION,"Difference Ratio"        ,10);
   if(differenceratio < 10 || differenceratio > 60)
      differenceratio = 10;
   edDifferenceRatio->Text = IntToStr(differenceratio);

   delete pSystemFile;

   // 填入元件
   edAutoFocus->Text = szfocus;
   edAutoFocusOffset->Text = szfocusoffset;
   edAutoFocusSpeed->Text = szfocusspeed;
   pnlSystemMessage->Caption = "載入對焦參數完成.";
}
//---------------------------------------------------------------------------
// 2017 1 3 - chc Delete recipe
// Recipe.ini & Recipe-Point.txt
void __fastcall TMainForm::btnDeleteRecipeClick(TObject *Sender)
{
AnsiString str,fname,rname;
AnsiString path;
TSearchRec sr;
int iAttributes = 0;
int rno = 0;
int len;

   fname = "確認刪除Recipe: " + combRecipe->Text + " ?";
   if(Application->MessageBox(fname.c_str(), "量測作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   // ini檔名與目錄: Recipe.ini
   try {
      rno = combRecipe->ItemIndex;
      rname = combRecipe->Text;
      fname = RecipeDirectory + "\\" + rname + ".ini";
      pnlSystemMessage->Caption = "刪除: " + fname;
      // 刪除
      if(FileExists(fname)) {
         DeleteFile(fname.c_str());
      }

      // 2019 12 13 - chc 刪除資料夾 & 所有檔案
      path = RecipeDirectory + "\\" + rname;
      if(DirectoryExists(path)) {
         // Delete files
         AnsiString delfname;
         //faReadOnly	  $00000001	  Read-only files
         //faHidden	  $00000002	  Hidden files
         //faSysFile	  $00000004	  System files
         //faVolumeID	  $00000008	  Volume ID files
         //faDirectory  $00000010	  Directory files
         //faArchive	  $00000020	  Archive files
         //faAnyFile	  $0000003F	  Any file
         fname = path + "\\*.*";
         iAttributes |= faArchive;
         if(FindFirst(fname, iAttributes, sr) == 0) {
            do {
               if((sr.Attr & iAttributes) == sr.Attr) {                               // 檔名在sr.Name
                  delfname = path + "\\" + sr.Name;
                  DeleteFile(delfname.c_str());
               }
            } while (FindNext(sr) == 0);
         }
         FindClose(sr);
         RmDir(path);
      }
      // 刪除下拉表單: cbRecipe & combRecipe
      //combRecipe->Items->Delete(rno);
      cbRecipe->Items->Delete(rno);
      combRecipe->Items->Delete(combRecipe->ItemIndex);
      if(combRecipe->ItemIndex == -1) {
         if(rno == 0)
            combRecipe->ItemIndex = 0;
         else
            combRecipe->ItemIndex = rno - 1;
         combRecipeSelect(this);
      }
      if(cbRecipe->ItemIndex == -1) {
         if(rno == 0)
            cbRecipe->ItemIndex = 0;
         else
            cbRecipe->ItemIndex = rno - 1;
         cbRecipeSelect(this);
      }
      // 整理RecipeBuffer: RecipeTotalNo
      for(int i=rno ; i<RecipeTotalNo ; i++) {
         memcpy((char *)&RecipeBuffer[i],(char *)&RecipeBuffer[i+1],sizeof(struct RECIPE_STRU));
      }
      RecipeTotalNo--;

      // 2021 5 4 - chc Create recipe
      edSECSRecipeID->Text = cbRecipe->Text;
      rgSECSRecipe->ItemIndex = RECIPE_DELETE;
      WriteSystemLog("boolSendSCESCommand: 4");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_RCPM - SECS_CMD_STAT_1;

   }
   catch(Exception &e) {
      WriteSystemLog("btnDeleteRecipeClick - Error");
      sbSystemMessage->Panels->Items[1]->Text = "DeleteRecipe - Error";
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::cbLampControl2Click(TObject *Sender)
{

   ActiveLampControl2();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbLED2CH1Change(TObject *Sender)
{

   pnlLED2CH1->Caption = IntToStr(tbLED2CH1->Position);
   LED2CH1Value = tbLED2CH1->Position;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbLED2CH1MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   pnlLED2CH1->Caption = IntToStr(tbLED2CH1->Position);
   LED2CH1Value = tbLED2CH1->Position;
   SetLED2Value(1,LED2CH1Value);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbLED2CH2Change(TObject *Sender)
{

   pnlLED2CH2->Caption = IntToStr(tbLED2CH2->Position);
   LED2CH2Value = tbLED2CH2->Position;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbLED2CH2MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   pnlLED2CH2->Caption = IntToStr(tbLED2CH2->Position);
   LED2CH2Value = tbLED2CH2->Position;
   SetLED2Value(1,LED2CH2Value);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbLED2CH3Change(TObject *Sender)
{

   pnlLED2CH3->Caption = IntToStr(tbLED2CH3->Position);
   LED2CH3Value = tbLED2CH3->Position;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbLED2CH3MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   pnlLED2CH3->Caption = IntToStr(tbLED2CH3->Position);
   LED2CH3Value = tbLED2CH3->Position;
   SetLED2Value(1,LED2CH3Value);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbLED2CH4Change(TObject *Sender)
{

   pnlLED2CH4->Caption = IntToStr(tbLED2CH4->Position);
   LED2CH4Value = tbLED2CH4->Position;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbLED2CH4MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   pnlLED2CH4->Caption = IntToStr(tbLED2CH4->Position);
   LED2CH4Value = tbLED2CH4->Position;
   SetLED2Value(1,LED2CH4Value);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLampControl2Click(TObject *Sender)
{

   try {
      MainForm->ybLampControl2->SettingsDialog(this,true);
      if(LampControlStatus2 == false)
         MainForm->ybLampControl2->Active = true;
      LampControlStatus2 = true;
   }
   catch(Exception &e) {
      ShowMessage("ybLampControl: " + e.Message);
      LampControlStatus2 = false;
      MainForm->pnlSystemMessage->Caption = "COM Port(Lamp) 啟動失敗!";
      MainForm->WriteSystemLog(MainForm->pnlSystemMessage->Caption);
   }
   UpdateLampStatus2();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSaveLED2Click(TObject *Sender)
{

TIniFile *pSystemFile;
AnsiString msg,fname;

   // Write to .ini
   pnlSystemMessage->Caption = "LED1 Parameters Updating...";
   fname = RecipeDirectory + "\\" + RecipeName + LED_INI_FILENAME;

   // 2021 5 9 - chc 若Path尚未建立, 要自動產生
   AnsiString path = RecipeDirectory + "\\" + RecipeName;
   if(!DirectoryExists(path))
      mkdir(path.c_str());

   // ini檔名與目錄
   // 2017 12 18 - chc 用LED Parameter file
   //pSystemFile = new TIniFile(MotionINIFilename);
   pSystemFile = new TIniFile(fname);

   // 2021 5 9 - chc 要取得目前值
   LED2CH1Value = tbLED2CH1->Position;
   LED2CH2Value = tbLED2CH2->Position;
   LED2CH3Value = tbLED2CH3->Position;
   LED2CH4Value = tbLED2CH4->Position;
   WriteSystemLog("LED Save, ch1= " + IntToStr(LED2CH1Value));

   pSystemFile->WriteInteger(LED_PARAMETER_SECTION,LED2_CH1_VALUE     ,LED2CH1Value);
   pSystemFile->WriteInteger(LED_PARAMETER_SECTION,LED2_CH2_VALUE     ,LED2CH2Value);
   pSystemFile->WriteInteger(LED_PARAMETER_SECTION,LED2_CH3_VALUE     ,LED2CH3Value);
   pSystemFile->WriteInteger(LED_PARAMETER_SECTION,LED2_CH4_VALUE     ,LED2CH4Value);

   pSystemFile->UpdateFile();

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2019 6 24 - chc LED Lamp Active
void __fastcall TMainForm::ActiveLampControl2()
{

   if(MainForm->cbLampControl2->Checked == true) {
      MainForm->ybLampControl2->Active = false;
      LampControlStatus2 = false;
      MainForm->pnlSystemMessage->Caption = "COM Port(Lamp) Active!";
      MainForm->WriteSystemLog(MainForm->pnlSystemMessage->Caption);
   }
   else {
      MainForm->ybLampControl2->Active = true;
      LampControlStatus2 = true;
   }
   UpdateLampStatus2();
}
//---------------------------------------------------------------------------
// 2019 6 24 - chc LED Lamp Active
void __fastcall TMainForm::UpdateLampStatus2()
{

   if(LampControlStatus2 == true) {
      pnlLampControl2->Color = clLime;
   }
   else {
      pnlLampControl2->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// 2019 6 24 - chc LED2 設定亮度值
// 0205001F 64 00 00 00 83 00(100%,0,0,0) / 0205001F 00 32 00 00 51 00(0,50%,0,0)
// 02 - Start
// 05 00 - Length(In the sequence of low byte to high byte)
// 1F - Set Brightness Command
// 64 00 00 00 - Set the Brightness Value(0 to 100%) in the order of CH1, 2,3 and4
// 83 00 - Checksum (In the sequence of low byte to high byte), Checksum= CommandText= 1F +64 + 00 + 00 + 00 = 0083H
//
// Omron 溫控器: 010300000002C40B
// Ack: 01 03 04 00 00 03 E8 [FA 8D]
//
// for test
//  chno: 1 - LED(光原) - Nport 5150A RS232/TCP Server(port=4100)
//        2 - 溫控(Omron) - MGate MB3170, Modbus RTU (port=502)
//
//
int NportID;
bool boolNport = false;
void __fastcall TMainForm::SetLED2Value(int chno, int value)
{
int no,len;
unsigned char str[50],code,strtcp[20];
AnsiString msg;
unsigned int checksum;

   // LED
   if(chno == 1) {
      // MGate
      strtcp[0] = 00;
      strtcp[1] = 00;
      strtcp[2] = 00;
      strtcp[3] = 00;
      strtcp[4] = 00;
      strtcp[5] = 0x0A;
      // NPort
      str[0] = 02;
      str[1] = 05;
      str[2] = 00;
      str[3] = 0x1F;
      str[4] = pnlLED2CH1->Caption.ToInt();                                        // Ch1
      str[5] = pnlLED2CH2->Caption.ToInt();                                        // Ch2
      str[6] = pnlLED2CH3->Caption.ToInt();                                        // Ch3
      str[7] = pnlLED2CH4->Caption.ToInt();                                        // Ch4
      checksum = 0;
      for(int i=3 ; i<8 ; i++)
         checksum += str[i];
      str[8] = (checksum & 0x00ff);                                                // CheckSum
      str[9] = ((checksum & 0xff00) >> 8);                                         // CheckSum
      len = 10;
   }
   // 溫控(Reserved: 實際完整碼已刪除)
   else {
      // Omron: 00 00 00 00 00 06 - 01 03 00 00 00 02 - [C40B]
      // Modbus TCP 標準Command格式
      strtcp[0] = 00;
      strtcp[1] = 00;
      strtcp[2] = 00;
      strtcp[3] = 00;
      strtcp[4] = 00;
      strtcp[5] = 06;
      str[0] = 01;
      str[1] = 03;
      str[2] = 00;
      str[3] = 00;
      str[4] = 00;
      str[5] = 02;
      len = 6;
      unsigned int reg_crc = 0xFFFF;
      unsigned char *data;
      data = &str[0];
      while(len--) {
         reg_crc ^= *data++;
         for(int j=0 ; j<8 ; j++) {
            if(reg_crc & 0x01)                                                     // LSB(b0)=1
               reg_crc = (reg_crc>>1) ^ 0xA001;
            else
               reg_crc = reg_crc >>1;
         }
      }
      str[6] = (reg_crc & 0x00ff);
      str[7] = ((reg_crc & 0xff00) >> 8);
      len = 8;
   }

   ybLampControl2->Write(str, len);
}
//---------------------------------------------------------------------------
// 2019 6 24 - chc LED2
void __fastcall TMainForm::InitLampControl2()
{

   ybLampControl2->Active = false;
   Sleep(500);
   LampControlStatus2 = false;

   // 2019 12 13 - chc for test
   if(boolForTest == true)
      return;

   try {
      ybLampControl2->Active = true;
      LampControlStatus2 = true;
   }
   catch(Exception &e) {
      //ShowMessage("ybLampControl: " + e.Message);
      LampControlStatus2 = false;
   }

   if(LampControlStatus2 == false) {
      sbSystemMessage->Panels->Items[1]->Text = "COM-Lamp 啟動失敗!";
      pnlLampControl2->Color = clRed;

      // 2021 9 5 - chc CCD Error
      // Code,Set/Reset,Level,Message
      SetSECSAlarm(16001,1,1,"LED Device Abnormal");

      return;
   }
   pnlLampControl2->Color = clLime;

}
//---------------------------------------------------------------------------
// 2019 6 24 - chc 讀取亮度值
void __fastcall TMainForm::ReadLEDValue()
{
TIniFile *pSystemFile;
AnsiString msg,fname;

   // ini檔名與目錄
   // 用LED Parameter file
   //pSystemFile = new TIniFile(MotionINIFilename);
   pnlSystemMessage->Caption = "LED Parameters Reading...";
   fname = RecipeDirectory + "\\" + RecipeName + LED_INI_FILENAME;
   pSystemFile = new TIniFile(fname);

   LED2CH1Value = pSystemFile->ReadInteger(LED_PARAMETER_SECTION,LED2_CH1_VALUE    ,20);
   LED2CH2Value = pSystemFile->ReadInteger(LED_PARAMETER_SECTION,LED2_CH2_VALUE    ,20);
   LED2CH3Value = pSystemFile->ReadInteger(LED_PARAMETER_SECTION,LED2_CH3_VALUE    ,20);
   LED2CH4Value = pSystemFile->ReadInteger(LED_PARAMETER_SECTION,LED2_CH4_VALUE    ,20);

   pnlLED2CH1->Caption = IntToStr(LED2CH1Value);
   pnlLED2CH2->Caption = IntToStr(LED2CH2Value);
   pnlLED2CH3->Caption = IntToStr(LED2CH3Value);
   pnlLED2CH4->Caption = IntToStr(LED2CH4Value);
   tbLED2CH1->Position = LED2CH1Value;
   tbLED2CH2->Position = LED2CH2Value;
   tbLED2CH3->Position = LED2CH3Value;
   tbLED2CH4->Position = LED2CH4Value;

   // Set LED
   SetLED2Value(1,LED2CH1Value);
   Sleep(200);
   SetLED2Value(1,LED2CH2Value);
   Sleep(200);
   SetLED2Value(1,LED2CH3Value);
   Sleep(200);
   SetLED2Value(1,LED2CH4Value);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
// 2019 7 9 - chc Close all Timer
void __fastcall TMainForm::CloseAllTimer()
{

   WriteSystemLog("Close All Timer...");
   tm250ms->Enabled = false;
   tm400ms->Enabled = false;
   tm500ms->Enabled = false;
   tmBeep->Enabled = false;
   // CCD
   tmISCCD->Enabled = false;
   ICImagingControl1->LiveStop();
   pnlISCCDStaus->Color = clSilver;
   Sleep(100);
   //
   tmMotionPolling->Enabled = false;
   tmSystem->Enabled = false;
   tmTMove->Enabled = false;
   WriteSystemLog("Close All Timer.");
}
//---------------------------------------------------------------------------
// 2019 7 14 - chc CCD Position
void __fastcall TMainForm::btnCCDPositionClick(TObject *Sender)
{

   SetCCDPosition();
}
//---------------------------------------------------------------------------
// 2019 7 14 - chc CCD Position
void __fastcall TMainForm::btnToCCDPositionClick(TObject *Sender)
{

   pnlToCCDPosition->Color = clSilver;
   MotionStatus(false);

   pnlStartMessage->Caption = "Moving to CCD...";
   pnlStartMessage->Visible = true;

   ToCCDPosition();
err:
   pnlStartMessage->Visible = false;
   MotionStatus(true);
}
//---------------------------------------------------------------------------
// 2019 7 14 - chc 移動到目前Lens
// 1. Get Turret
// 2. Goto Center
// 3. Convert to Bruker Lens Position
// Marker: Z=7732.83um
// 2021 7 17 - chc ToLens/ToCCD要互鎖
int ToLensToCCDMode = -1;
#define TOLENS_MODE         1
#define TOCCD_MODE          2
void __fastcall TMainForm::mnToLensClick(TObject *Sender)
{

   // 2021 7 22 - chc UnLock
   if(boolInRun == true)
      ToLensToCCDMode = -1;

   // 2021 7 17 - chc ToLens/ToCCD要互鎖
   if(ToLensToCCDMode == TOLENS_MODE) {
      pnlAlarmMessage->Caption = "不能重複做ToLens!";
      if(pnlMoving->Visible == false) {
         pnlMoving->Caption = "Repeat ToLens!";
         pnlMoving->Visible = true;
         tmAlatm->Enabled = true;
      }
      return;
   }
   ToLensToCCDMode = TOLENS_MODE;

   // 2019 11 14 - chc 是指目前的十字中心: DoubleClickX為imCCD的有效座標, 但shVertical->Left是pnlLeftWindow的座標!
   DoubleClickX = shVertical->Left - imCCD->Left;
   DoubleClickY = shHorizontal->Top - imCCD->Top;

   CCDToLens(LensNo,0);
}
//---------------------------------------------------------------------------
// 2019 7 14 - chc 移動到目前Lens - 只動XY
// 1. Get Turret
// 2. Goto Center
// 3. Convert to Bruker Lens Position
// Marker: Z=7732.83um
// 與cbCCDXDirection/cbCCDYDirection有關
void __fastcall TMainForm::CCDToLens(int lensno, int mode)
{
int level;
double fdy,ccdprecision,fdx;
int axisno,position,xposition,yposition;
I32 cmd;
AnsiString msg;
int cx,cy,X,Y;

   // X/Y position(set by MouseDown Event)
   X = DoubleClickX;
   Y = DoubleClickY;

   cx = imCCD->Width / 2;
   cy = imCCD->Height / 2;

   // use shVertical & shHorizontal(imCCD: 1020*810)
   cx = shVertical->Left - imCCD->Left;
   cy = shHorizontal->Top - imCCD->Top;

   pnlSystemMessage->Caption = "ToLens: XYMoving...";
   WriteSystemLog(pnlSystemMessage->Caption);
   // Y軸
   pnlYMove->Color = clSilver;
   level = shHorizontal->Top;

   // 2019 10 17 - chc 定義CCDPrecision參數化
   //ccdprecision = MotionCCDPrecision;
   ccdprecision = edCCDPrecision->Text.ToDouble();

   fdy = (Y - (level - imCCD->Top)) * ccdprecision;
   msg.sprintf("Y,level,top,fy,precision= %d,%d,%d,%.4f,%.4f",Y,level,imCCD->Top,fdy,ccdprecision);
   WriteSystemLog(msg);

   // ToCCD
   if(mode == 1)
      fdy = 0;

   // 兩個Lens之間的間距: edLens1X
   TLMDEdit *edx,*edy;
   int lensx,lensy;
   int ccdx,ccdy,dx,dy;
   WriteSystemLog("取得Lens Position..." + IntToStr(lensno));
   edx = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "X"));
   edy = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "Y"));
   WriteSystemLog("取得Lens Position..." + edx->Name + "," + edx->Text + "," + edy->Name + "," + edy->Text);
   lensx = edx->Text.ToInt();
   WriteSystemLog("取得Lens PositionX");
   lensy = edy->Text.ToInt();
   WriteSystemLog("取得Lens PositionY");
   ccdx = edCCDX->Text.ToInt();
   ccdy = edCCDY->Text.ToInt();
   WriteSystemLog("取得CCD Position");
   dx = (lensx - ccdx) * X_RESOLUTION;
   dy = (lensy - ccdy) * Y_RESOLUTION;
   // ToCCD
   if(mode == 1) {
      dx = 0 - dx;
      dy = 0 - dy;
   }

   // 2021 4 29 - chc X相反
   dx = 0 - dx;

   fdy += dy;
   WriteSystemLog("取得Lens-CCD位移量.");

   msg.sprintf("lensy(p), ccdy(p), dy(um), fdy(um) = %d,%d,%d,%.4f",lensy,ccdy,dy,fdy);
   WriteSystemLog(msg);

   if(cbCCDYDirection->Checked == false)
      fdy = 0 - fdy;
   msg.sprintf("%.3f",fdy);
   pnlYAltOffset->Caption = msg;
   // Y - absolute
   axisno = Y_AXIS;

   // 2016 12 9 - chc 改成Position
   //GetCommand(axisno, &cmd);
   double fcmd;
   GetPosition(axisno, &fcmd);
   cmd = fcmd;

   position = cmd + (fdy / Y_RESOLUTION);

   // 2019 11 14 - chc XY同動
   /*
   WriteSystemLog("ToLens: ypos = " + IntToStr(position));
   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "ToLens: YMove Fail!";
      WriteSystemLog(pnlSystemMessage->Caption);
      pnlYMove->Color = clRed;
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";
   }
   else {
      pnlYMove->Color = clLime;
      pnlSystemMessage->Caption = "ToLens: YMove Success";
   }
   */
   yposition = position;

   // X軸
   pnlXMove->Color = clSilver;
   level = shVertical->Left;
   fdx = (X - (level - imCCD->Left)) * ccdprecision;
   msg.sprintf("X,level,left,fx= %d,%d,%d,%.4f,%.4f",X,level,imCCD->Left,fdx,ccdprecision);
   WriteSystemLog(msg);

   // ToCCD
   if(mode == 1)
      fdx = 0;

   // 兩個Lens之間的間距: edLens1X
   fdx += dx;

   msg.sprintf("lensx(p), ccdx(p), dx(um), fdx(um) = %d,%d,%d,%.4f",lensx,ccdx,dx,fdx);
   WriteSystemLog(msg);

   if(cbCCDXDirection->Checked == true)
      fdx = 0 - fdx;
   msg.sprintf("%.3f",fdx);
   pnlXAltOffset->Caption = msg;
   // X - absolute
   axisno = X_AXIS;

   // 2016 12 9 - chc 改成Position
   //GetCommand(axisno, &cmd);
   GetPosition(axisno, &fcmd);
   cmd = fcmd;

   position = cmd + (fdx / X_RESOLUTION);

   // 2019 11 14 - chc XY同動
   /*
   WriteSystemLog("ToLens: xpos = " + IntToStr(position));
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "ToLens: XMove Fail!";
      WriteSystemLog(pnlSystemMessage->Caption);
      pnlXMove->Color = clRed;
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " X-Axis Move Error!";
   }
   else {
      pnlXMove->Color = clLime;
      pnlSystemMessage->Caption = "ToLens: XMove Success";
   }
   */
   xposition = position;

   // 2019 11 14 - chc 使用XY同動
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(xposition,yposition);
   MoveToXY(xposition,yposition,MOVE_WAIT);

   Sleep(100);

   // 強制切到X軸
   axisno = X_AXIS;
   combAxis->ItemIndex = axisno;

   // 2019 11 28 - chc 也要做BrukerZ的補償, Calibration中, 不做補償
   // 2021 4 29 - chc @@ 暫不做
   // 2021 5 8 - chc 要做Z補償
   if(cbCalibration->Checked == false){
      // ToLens / ToCCD
      // Z補償值(設定值)
      int sz,dz,czlens;
      sz = edCCDZ->Text.ToInt();
      // 1 ~
      if(LensNo == 1)
         czlens = edLens1Z->Text.ToInt();
      else if(LensNo == 2)
         czlens = edLens2Z->Text.ToInt();
      else if(LensNo == 3)
         czlens = edLens3Z->Text.ToInt();
      else if(LensNo == 4)
         czlens = edLens4Z->Text.ToInt();
      // ToLens
      if(mode == 0) 
         dz = czlens - sz;
      // ToCCD
      else
         dz = sz - czlens;
      msg.sprintf("ToLens: sz,czlens,dz= %d,%d,%d",sz,czlens,dz);
      WriteSystemLog(msg);
      DoRelativeMove(Z_AXIS,dz);
   }

}
//---------------------------------------------------------------------------
// 2019 7 15 - chc GetBrukerLensPrecision
double __fastcall TMainForm::GetOlympusLensPrecision()
{
int no;
double ccdprecision = 5.38;

   no = LensNo;
   switch(no) {
      case 1:
         ccdprecision = edCCDPrecision1->Text.ToDouble();
         break;
      case 2:
         ccdprecision = edCCDPrecision2->Text.ToDouble();
         break;
      case 3:
         ccdprecision = edCCDPrecision3->Text.ToDouble();
         break;
      case 4:
         ccdprecision = edCCDPrecision4->Text.ToDouble();
         break;
      case 5:
         ccdprecision = edCCDPrecision5->Text.ToDouble();
         break;
      case 6:
         ccdprecision = edCCDPrecision6->Text.ToDouble();
         break;
   }

   // 加入精度值顯示
   AnsiString msg;
   msg.sprintf("%.4f",ccdprecision);
   pnlOlympusLensPrecision->Caption = msg;

   return(ccdprecision);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::mnToLens1Click(TObject *Sender)
{

   CCDToLens(1,0);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::mnToLens2Click(TObject *Sender)
{

   CCDToLens(2,0);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::mnToLens3Click(TObject *Sender)
{

   CCDToLens(3,0);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::mnToLens4Click(TObject *Sender)
{

   CCDToLens(4,0);
}
//---------------------------------------------------------------------------
// 2019 7 15 - chc 由Bruker移到Motion CCD
// 1. 先取得目前的Lens
void __fastcall TMainForm::mnToCCDClick(TObject *Sender)
{

   // 2021 7 22 - chc UnLock
   if(boolInRun == true)
      ToLensToCCDMode = -1;

   // 2021 7 17 - chc ToLens/ToCCD要互鎖
   if(ToLensToCCDMode == TOCCD_MODE) {
      pnlAlarmMessage->Caption = "不能重複做ToCCD!";
      if(pnlMoving->Visible == false) {
         pnlMoving->Caption = "Repeat ToCCD!";
         pnlMoving->Visible = true;
         tmAlatm->Enabled = true;
      }
      return;
   }
   ToLensToCCDMode = TOCCD_MODE;

   CCDToLens(LensNo,1);
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::AreaPointTitle()
{

   // Area
   sgArea->Cells[0][0]        = "No";
   sgArea->Cells[1][0]        = "X(um)";
   sgArea->Cells[2][0]        = "Y(um)";
   sgArea->Cells[3][0]        = "Z(um)";

   sgArea->ColWidths[0]       = 40;
   sgArea->ColWidths[1]       = 90;
   sgArea->ColWidths[2]       = 90;
   sgArea->ColWidths[3]       = 90;

   // Dot
   sgDot->Cells[0][0]        = "No";
   sgDot->Cells[1][0]        = "X(um)";
   sgDot->Cells[2][0]        = "Y(um)";
   sgDot->Cells[3][0]        = "Z(um)";
   sgDot->Cells[4][0]        = "Intensity";
   sgDot->Cells[5][0]        = "Recipe";
   sgDot->Cells[6][0]        = "Row";
   sgDot->Cells[7][0]        = "Col";

   sgDot->ColWidths[0]       = 40;
   sgDot->ColWidths[1]       = 80;
   sgDot->ColWidths[2]       = 80;
   sgDot->ColWidths[3]       = 60;
   sgDot->ColWidths[4]       = 65;
   sgDot->ColWidths[5]       = 180;
   sgDot->ColWidths[6]       = 40;
   sgDot->ColWidths[7]       = 40;

   //sgDot->EditorMode = true;

}
//---------------------------------------------------------------------------
// Aera
void __fastcall TMainForm::btnAreaSetClick(TObject *Sender)
{
int no;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   no = edAreaNo->Text.ToInt();

   // Messagebox
   AnsiString msg;
   msg.sprintf("確認要更新區域%d的位置?   ",no);
   if(Application->MessageBox(msg.c_str(), "區域位置更新作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   SetAreaPosition();

   // 2021 10 6 - chc 就combRecipe->ItemIndex才對
   //if(no > RecipeBuffer[RecipeCurNo].AreaNo || no < 1) {
   if(no > RecipeBuffer[combRecipe->ItemIndex].AreaNo || no < 1) {

      pnlAlarmMessage->Caption = "區域編號異常!";
   }
   else {

      // 2021 5 6 - chc 是Center, 及目前Z
      //sgArea->Cells[1][no] = pnlAreaX->Caption;
      //sgArea->Cells[2][no] = pnlAreaY->Caption;
      //sgArea->Cells[3][no] = pnlAreaZ->Caption;
      sgArea->Cells[1][no] = pnlCenterXFind->Caption;
      sgArea->Cells[2][no] = pnlCenterYFind->Caption;
      sgArea->Cells[3][no] = edCounterZ->Text;

   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnDotSetClick(TObject *Sender)
{
int no;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   no = edDotNo->Text.ToInt();

   // Messagebox
   AnsiString msg;
   msg.sprintf("確認要更新點位%d的位置?   ",no);
   if(Application->MessageBox(msg.c_str(), "點位位置更新作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   // 2021 6 16 - chc 計算Die座標
   int x,y,row,col;
   x = pnlDotX->Caption.ToInt();
   y = pnlDotY->Caption.ToInt();
   col = pnlColumSet->Caption.ToInt();
   row = pnlRowSet->Caption.ToInt();
   ComputeRowCol(x,y,&row,&col);
   pnlColumSet->Caption = IntToStr(col);
   pnlRowSet->Caption = IntToStr(row);

   // 2021 5 8 - chc 沒有點位Recipe, 不檢查
   //if(comboOlympusVisionName1->Text == "") {
   //   Application->MessageBox("尚未指定Recipe!   ","點位位置更新作業",MB_ICONINFORMATION|MB_OK);
   //   return;
   //}

   SetDotPosition();

   // 2021 10 6 - chc 就combRecipe->ItemIndex才對
   //if(no > RecipeBuffer[RecipeCurNo].DotNo || no < 1) {
   if(no > RecipeBuffer[combRecipe->ItemIndex].DotNo || no < 1) {

      pnlAlarmMessage->Caption = "點位編號異常!";
   }
   else {
      sgDot->Cells[1][no] = pnlDotX->Caption;
      sgDot->Cells[2][no] = pnlDotY->Caption;
      sgDot->Cells[3][no] = pnlDotZ->Caption;
      sgDot->Cells[4][no] = pnlLED2CH1->Caption;
      sgDot->Cells[5][no] = comboOlympusVisionName1->Text;
      sgDot->Cells[6][no] = pnlColumSet->Caption;
      sgDot->Cells[7][no] = pnlRowSet->Caption;
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBase1SetClick(TObject *Sender)
{

   // Messagebox
   if(Application->MessageBox("確認要更新基準1的位置?   ", "點位位置更新作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   SetBase1Position();

   // 若為kmf則也要同步設區域1
   if(edAreaNo->Text.ToInt() == 1 && edAreaTNo->Text.ToInt() == 1) {
      int areano = edAreaNo->Text.ToInt();
      AnsiString filename,path;
      path = RecipeDirectory + "\\" + combRecipe->Text + "\\";
      filename = combRecipe->Text + "-A" + IntToStr(areano) + ".bmp";
      if(boolForTest == false)
         PatternROI.Save((path+filename).c_str(),E_FILE_FORMAT_GRAY_LEVEL_BMP);
      btnAreaSetClick(this);
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBase2SetClick(TObject *Sender)
{

   // Messagebox
   if(Application->MessageBox("確認要更新基準2的位置?   ", "點位位置更新作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   SetBase2Position();

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::btnAreaToClick(TObject *Sender)
{
bool boolret;

   // 2019 12 3 - chc 先設定位置
   int recno;
   if(sgArea->RowCount < 2) {
      pnlSystemMessage->Caption = "區域: No Data Matched!";
      return;
   }
   recno = edAreaNo->Text.ToInt();
   if(recno > 0 && recno < sgArea->RowCount) {

      // 2019 12 3 - chc 在Run中: OffsetXBase
      if(boolInRun == true) {
         pnlAreaX->Caption = IntToStr(sgArea->Cells[1][recno].ToInt() + OffsetXBase);
         pnlAreaY->Caption = IntToStr(sgArea->Cells[2][recno].ToInt() + OffsetYBase);
      }
      else {

         pnlAreaX->Caption = sgArea->Cells[1][recno];
         pnlAreaY->Caption = sgArea->Cells[2][recno];
      }
      pnlAreaZ->Caption = sgArea->Cells[3][recno];
      sgArea->Row = recno;
   }
   else
      return;

   pnlToAreaPosition->Color = clSilver;
   boolret = ToAreaPosition();
   if(boolret == false) {
      pnlToAreaPosition->Color = clRed;
      return;
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnDotToClick(TObject *Sender)
{
bool boolret;

   pnlToDotPosition->Color = clSilver;
   boolret = ToDotPosition();
   if(boolret == false) {
      pnlToDotPosition->Color = clRed;
      return;
   }
   pnlToDotPosition->Color = clLime;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBase1ToClick(TObject *Sender)
{
bool boolret;

   pnlToBase1Position->Color = clSilver;
   boolret = ToBase1Position();
   if(boolret == false) {
      pnlToBase1Position->Color = clRed;
      return;
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnBase2ToClick(TObject *Sender)
{
bool boolret;

   pnlToBase2Position->Color = clSilver;
   boolret = ToBase2Position();
   if(boolret == false) {
      pnlToBase2Position->Color = clRed;
      return;
   }

}
//---------------------------------------------------------------------------
// Area Click
void __fastcall TMainForm::sgAreaClick(TObject *Sender)
{
int recno;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   if(sgArea->RowCount < 2) {
      pnlSystemMessage->Caption = "區域: No Data Matched!";
      return;
   }
   recno = sgArea->Row;
   if(recno > 0 && recno < sgArea->RowCount) {
      edAreaNo->Text = IntToStr(recno);
      pnlAreaX->Caption = sgArea->Cells[1][recno];
      pnlAreaY->Caption = sgArea->Cells[2][recno];
      pnlAreaZ->Caption = sgArea->Cells[3][recno];
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::sgDotClick(TObject *Sender)
{
int recno;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   if(sgDot->RowCount < 2) {
      pnlSystemMessage->Caption = "點位: No Data Matched!";
      return;
   }
   recno = sgDot->Row;
   if(recno > 0 && recno < sgDot->RowCount) {
      edDotNo->Text = IntToStr(recno);
      pnlDotX->Caption = sgDot->Cells[1][recno];
      pnlDotY->Caption = sgDot->Cells[2][recno];
      pnlDotZ->Caption = sgDot->Cells[3][recno];
      pnlDotIntensity->Caption = sgDot->Cells[4][recno];
      comboOlympusVisionName1->Text = sgDot->Cells[5][recno];
      pnlDotRow->Caption = sgDot->Cells[6][recno];
      pnlDotCol->Caption = sgDot->Cells[7][recno];
   }
}
//---------------------------------------------------------------------------
bool boolTestFocusDone = false;
int TestFocusZ;

// 2019 12 14 - chc MeasureResult: 0/1/2/3/4/5 - Ok/無VisionRecipe/VisionRecipe不存在/VisionRecipe指定失敗/Error/Timeout
int MeasureResult;

// 2019 12 18 - chc 對位失敗!
int MatchProcess = 0;
// Run: 連續單點量測
void __fastcall TMainForm::btnSystemRunClick(TObject *Sender)
{
int areatno,dottno,x,y,z,t,basex,basey,loop,runno,recordno,resultcode;
bool boolret;
AnsiString msg,databasepath,visionrecipe,visionrecipefname;
double intensity;
long starttime,stoptime,elapsedms;
short starttick,stoptick;
bool boolcsv = false;
TLMDEdit *editx,*edity;

// 2019 12 3 - chc  先到點位對焦再量測
int bx,by,ccdz,motionz,dz;

// 2019 12 11 - chc 要做影像對位?
AnsiString recipename,mfname;

// 2019 12 18 - chc Z補償
int a1z,az,dzvalue,ano;

// 2019 12 23 記錄Area1的對焦高度與每次對焦高度
int area1z,areaz;
double fareaz;
int gap;

// 2021 6 9 - chc 回到Z安全高度 & 0度
bool boolrunabort = false;

// 2021 7 19 - chc 是否結束量測?
bool boolEndMeasure = false;

// 2021 6 11 - chc 0度點位存檔
struct BASE_STRU side0pos[MAX_DOT_NO];

// 2021 5 9 - chc 目前作業中的片編號: 1-25
int waferno;
   waferno = 25 - rgWaferNo->ItemIndex;

   // 2021 8 24 - chc 記錄取片中
   if(boolInLoad == true) {
      pnlSystemRun->Caption = "取片中, 不可以執行!";
      return;
   }
   // 記錄退片中
   if(boolInUnLoad == true) {
      pnlSystemRun->Caption = "退片中, 不可以執行!";
      return;
   }

   // 2021 7 22 - chc unlock
   ToLensToCCDMode = -1;

   // 2022 12 8 - chc Disable
   btnSystemRun->Enabled = false;

   // 2023 8 2 - chc LP1/LP2
   int portno;
   portno = rgLoadPortSelect->ItemIndex;
   if(portno < 0) {
      pnlSystemRun->Caption = "port not selected, not executable!";
      return;
   }

   // 2021 9 15 - chc 若為SEC連線則使用下載的Recipe
   if(cbOffLine->Checked == false) {

      // 2023 8 2 - chc LP1/LP2
      //if(WaferBuffer[waferno-1].RecipeName != "") {
      //   cbRecipe->Text = WaferBuffer[waferno-1].RecipeName;
      if(WaferBuffer[portno][waferno-1].RecipeName != "") {
         cbRecipe->Text = WaferBuffer[portno][waferno-1].RecipeName;

         pnlOperationMessage->Caption = "[Run]使用SECS Recipe: " + cbRecipe->Text + ", no= " + IntToStr(waferno);
         WriteSystemLog(pnlOperationMessage->Caption);

         // 2021 10 27a - chc 要更新ItemIndex
         int no;
         no = cbRecipe->Items->IndexOf(cbRecipe->Text);
         if(no >= 0)
            cbRecipe->ItemIndex = no;

         // 2021 10 26 - chc 要呼叫cbRecipeSelect(this);
         cbRecipeSelect(this);

      }
   }

   // 2021 10 25 - chc 離線作業才要問
   if(cbOffLine->Checked == true) {

      // 詢問
      msg.sprintf("確認開始[%s]的量測作業?    ",cbRecipe->Text);
      pnlSystemRun->Caption = "確認開始?";
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlSystemRun->Caption = "放棄執行.";

         // 2022 12 8 - chc Disable
         btnSystemRun->Enabled = true;

         return;
      }
   }

   WriteSystemLog("Recipe Run: 開始...");
   pnlSystemRun->Caption = "Recipe Run: 開始";

   // Chuck With Wafer?
   if(IsChuckWithWafer() == false) {
      WriteSystemLog("Recipe Run: Satge上無Wafer!");
      pnlAlarmMessage->Caption = "Satge上無Wafer!";
      pnlSystemRun->Caption = "Satge上無Wafer!";

      // 2022 12 8 - chc Disable
      btnSystemRun->Enabled = true;

      return;
   }

   // 2021 5 9 - chc Yuanli 是否連線?
   pnlSystemMessage->Caption = "Recipe Run: YuanLi 連線測試...";
   pnlSystemRun->Caption = "YuanLi 連線測試...";
   if(YuanLiConnect() == false) {
      pnlSystemRun->Caption = "YuanLi 連線測試失敗!";
      pnlAlarmMessage->Caption = "YuanLi無法連線(Timeout), 停止執行.";
      pnlSystemMessage->Caption = "";

      // 2022 12 8 - chc Log
      WriteSystemLog("YuanLiConnect() YuanLi 連線測試失敗! 停止Start");
      btnSystemRun->Enabled = true;

      return;
   }
   pnlSystemRun->Caption = "YuanLi 連線測試OK.";

   // 2022 12 8 - chc Delay
   WaitTime(500);

   // Init
   boolTestFocusDone = false;
   WriteSystemLog("Recipe Run: YuanLi Init");
   pnlSystemRun->Caption = "YuanLi Init...";
   pnlSystemMessage->Caption = "Recipe Run: YuanLi Init...";
   if(WaitYuanliCmd(CMD_INIT) != CMD_ACK_E) {
      pnlSystemRun->Caption = "YuanLi Init失敗!";
      pnlAlarmMessage->Caption = "YuanLi Init異常, 停止執行.";
      pnlSystemMessage->Caption = "";

      // 2022 12 8 - chc Log
      WriteSystemLog("YuanLi Init失敗! 停止Start");
      btnSystemRun->Enabled = true;

      return;
   }

   // 2022 12 8 - chc Log
   WriteSystemLog("YuanLi Init OK. 續Start");

   pnlSystemRun->Caption = "YuanLi Init OK.";
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("Yuanli Socket測試: Init ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

         // 2022 12 8 - chc Disable
         btnSystemRun->Enabled = true;

         // 2021 7 19 - chc 改用runabort
         //goto stop;
         goto runabort;

      }
   }

   // 2021 9 25 - chc 量測中
   boolInMeasureRun = true;

   // 2021 11 12 - chc 記錄Load button狀態
   bool boolloadbutton;
   boolloadbutton = btnCassetteLoad->Enabled;
   btnCassetteLoad->Enabled = false;

   // 0 度
   WriteSystemLog("Recipe Run: 0度");
   pnlSystemRun->Caption = "T移到0度...";
   pnlSystemMessage->Caption = "Recipe Run: T移到0度...";
   btnToLoadPositionClick(this);
   if(pnlToLoadPosition->Color != clLime) {
      pnlSystemRun->Caption = "T移到0度失敗!";
      pnlAlarmMessage->Caption = "T移到0度異常, 停止執行.";
      pnlSystemMessage->Caption = "";

      // 2021 9 25 - chc 量測中
      boolInMeasureRun = false;

      // 2021 11 12 - chc 記錄Load button狀態
      btnCassetteLoad->Enabled = boolloadbutton;

      // 2021 9 25 - chc 取消顯示
      pnlMoving->Visible = false;

      // 2022 12 8 - chc Disable
      btnSystemRun->Enabled = true;

      return;
   }
   pnlSystemRun->Caption = "T移到0度OK";
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("Yuanli Socket測試: 0度 ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

         // 2022 12 8 - chc Disable
         btnSystemRun->Enabled = true;

         // 2021 7 19 - chc 改用runabort
         //goto stop;
         goto runabort;

      }
   }

   // 2021 10 21 - chc 不啟動T & Z
   pnlMoveTCounterclockwise->Enabled = false;
   pnlMoveTClockwise->Enabled = false;
   pnlMoveLeft->Enabled = false;

   loop = edRunLoop->Text.ToInt();
   pnlRunDoneNo->Caption = "0";
   pnlOffsetXBase->Caption = "";
   pnlOffsetYBase->Caption = "";

   // 2021 5 8 - chc 不清空, 入料時已更新
   //pnlRotate->Caption = "";
   //pnlOffsetXArea->Caption = "";
   //pnlOffsetYArea->Caption = "";

   runno = 0;

   // 2019 7 19 - chc 量測結果
   gbMatchData->Left = 1117;
   gbMatchData->Top = 508;
   gbMatchData->Caption = "量測結果";
   gbMatchData->Visible = true;
   ResultTitle();
   recordno = 0;

   // 2019 12 3 - chc 在Run中: OffsetXArea
   OffsetXBase = 0;
   OffsetYBase = 0;
   OffsetXArea = 0;
   OffsetYArea = 0;

   // 2019 12 13 - chc 同步系統/Recipe的Recipe
   if(cbRecipe->Text != combRecipe->Text) {

      // 2021 10 15 - chc 不用問直接切換: combRecipeSelect(this)
      //if(Application->MessageBox(("目前顯示的Recipe[" + combRecipe->Text + "]不是系統Recipe, 要同步為: [" + cbRecipe->Text + "]嗎? ").c_str(), "Recipe量測作業作業", MB_YESNO|MB_SYSTEMMODAL) == IDYES) {
      //   pnlSystemRun->Caption = "同步Recipe資訊...";
      //   cbRecipeSelect(this);
      //   DelayTime(2000);
      //}
      combRecipe->Text = cbRecipe->Text;
      combRecipe->ItemIndex = cbRecipe->ItemIndex;
      combRecipeSelect(this);

   }

   // 2019 12 3 - chc Offset & Alignment
   cbMoveToCenterMatched->Checked = true;
   // 2021 5 9 - chc 不做基準點校正
   //if(FindOffsetAlignment() == false) {
   //   pnlSystemRun->Caption = "基準點定位失敗!";
   //   return;
   //}

   // 2021 5 9 - chc 固定為1區
   edAreaTNo->Text = "1";

while(1) {
   boolcsv = false;
   pnlRunRecipe->Caption = cbRecipe->Text;
   pnlRunAreaTNo->Caption = edAreaTNo->Text;
   pnlRunDotTNo->Caption = edDotTNo->Text;
   areatno = edAreaTNo->Text.ToInt();
   dottno = edDotTNo->Text.ToInt();
   pnlAreaNoRun->Caption = "0";
   pnlDotNoRun->Caption = "0";
   pnlDotNoRun1->Caption = "0";
   pnlElapsedTime->Caption = "";
   btnSystemRun->Enabled = false;
   boolInRun = true;

   // 2021 5 9 - chc 不需要, for Bruker
   //btnRunStop->Visible = true;

   // ==========================================================================
   // YuanLi初始
   // to 50x, Wait Focus done
   pnlSystemMessage->Caption = "按下Run開始量測作業";
   pnlSystemRun->Caption = pnlSystemMessage->Caption;
   btnFocusDone->Caption = " Run";
   btnFocusDone->Hint = "按下後開始執行量測作業";
   btnFocusDone->Visible = true;

   // 2021 9 23b - chc 顯示
   pnlDotNoRun1->Visible = true;
   pnlSideNo->Caption = "0度";
   // 21 9 25 - chc 不需要顯示角度
   //pnlSideNo->Visible = true;
   pnlSideNo->Visible = false;

   // 2021 8 13 - chc 操作指示
   pnlFocusDone->Caption = pnlSystemMessage->Caption;
   pnlFocusDone->Visible = true;
   btnFocusDone->Font->Color = (TColor)0x00951106;

   // 2022 1 3 - chc 定義pnlFocusDoneE
   pnlFocusDone->Color = (TColor)0x00951106;
   pnlFocusDoneE->Color = (TColor)0x00951106;
   pnlFocusDoneE->Caption = "Press Run to start the measurement operation";
   pnlFocusDoneE->Visible = true;

   pcSystem->Enabled = false;

   // 2021 7 19 - chc 改用runabort
   WriteSystemLog("關閉作業頁面2. [Run]");

   boolTestFocusDone = false;
   while(1) {
      WaitTime(500);
      if(boolTestFocusDone == true)
         break;
   }
   pcSystem->Enabled = true;
   btnFocusDone->Visible = false;

   // 2021 9 23b - chc 顯示
   pnlSideNo->Visible = false;
   pnlDotNoRun1->Visible = false;

   // 2021 8 13 - chc 操作指示
   pnlFocusDone->Visible = false;

   // 2022 1 3 - chc 定義pnlFocusDoneE
   pnlFocusDoneE->Visible = false;

   // Set Recipe
   edRecipeName->Text = cbRecipe->Text;
   WriteSystemLog("Recipe Run: YuanLi SetRecipe");
   pnlSystemRun->Caption = "YuanLi SetRecipe...";
   // SetRecipe
   pnlSystemMessage->Caption = "Recipe Run: YuanLi SetRecipe...";
   if(WaitYuanliCmd(CMD_SET_RECIPE) != CMD_ACK_E) {
      pnlSystemRun->Caption = "YuanLi SetRecipe失敗!";
      pnlAlarmMessage->Caption = "YuanLi SetRecipe異常, 停止執行.";
      pnlSystemMessage->Caption = "";

      // 2021 9 20a - chc Alarm
      boolrunabort = true;

      goto runabort;
   }
   pnlSystemRun->Caption = "YuanLi SetRecipe OK";
   WriteSystemLog("Recipe Run: YuanLi Start");
   pnlSystemRun->Caption = "YuanLi Start...";
   // Start,N,WaferID
   rgYuanliPoint->ItemIndex = dottno-1;

   // 2023 8 2 - chc LP1/LP2
   //edWaferID->Text = WaferBuffer[waferno-1].ID;
   edWaferID->Text = WaferBuffer[portno][waferno-1].ID;

   // 2021 8 27 - chc 修正總點數: edTotalPoint
   edTotalPoint->Text = IntToStr(dottno);

   pnlSystemMessage->Caption = "Recipe Run: YuanLi Start...";
   if(WaitYuanliCmd(CMD_START) != CMD_ACK_E) {
      pnlSystemRun->Caption = "YuanLi Start失敗!";
      pnlAlarmMessage->Caption = "YuanLi Start異常, 停止執行.";
      pnlSystemMessage->Caption = "";

      // 2021 9 20a - chc Alarm
      boolrunabort = true;

      goto runabort;
   }
   pnlSystemRun->Caption = "YuanLi Start OK";
   WriteSystemLog("Recipe Run: Yuanli Mode");
   // Mode = Top
   rgMode->ItemIndex = 0;
   pnlSystemRun->Caption = "YuanLi Mode.Top...";
   pnlSystemMessage->Caption = "Recipe Run: YuanLi Mode.Top...";
   if(WaitYuanliCmd(CMD_MODE) != CMD_ACK_E) {
      pnlSystemRun->Caption = "YuanLi Mode.Top失敗!";
      pnlAlarmMessage->Caption = "YuanLi Mode.Top異常, 停止執行.";
      pnlSystemMessage->Caption = "";

      // 2021 9 20a - chc Alarm
      boolrunabort = true;

      goto runabort;
   }
   pnlSystemRun->Caption = "YuanLi Mode.Top OK";
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("Yuanli Socket測試: SetRecipe-Mode-Start ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

         // 2021 7 19 - chc 改用runabort
         //goto stop;
         goto runabort;

      }
   }
   // 是否中斷量測作業?
   boolDoMeasure = true;
   btnMeasureStop->Visible = true;
   // 量測中MoveToXYZT()不檢查T(量測點用8 - 不動T)
   boolInMeasure = true;
   // ==========================================================================

   for(int i=0 ; i<areatno ; i++) {
      pnlAreaNoRun->Caption = IntToStr(i+1);

      // 2019 12 3 - chc 到區域點
      // 2021 5 9 - chc 不做區域點校正
      // 2021 6 11 - chc 恢復區域定位
      /* => 中心無Pattern可用
      // 2021 6 11 - chc 要先檢查Pattern是否存在?
      recipename = combRecipe->Text;
      mfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-A" + IntToStr(i+1) + ".bmp";
      if(FileExists(mfname)) {

         rgMatchSource->ItemIndex = 0;
         edAreaNo->Text = IntToStr(i+1);
         pnlSystemRun->Caption = "區域" + IntToStr(i+1) + "移動...";
         btnAreaToClick(this);
         if(pnlToAreaPosition->Color != clLime) {
            pnlSystemMessage->Caption = "區域" + IntToStr(i+1) + "移動失敗!";
            //return false;
         }

         // AutoFocus Base1
         // 2021 6 11 - chc 不做autoFocus
         //if(cbAutoFocus->Checked == true) {
         //   DelayTime(500);
         //   pnlSystemRun->Caption = "區域" + IntToStr(i+1) + "Focus...";
         //   btnAutoFocusClick(this);
         //}
         //DelayTime(500);

         // 2019 12 23 記錄Area1的對焦高度與每次對焦高度
         GetPosition(Z_AXIS, &fareaz);
         if(i == 0)
            area1z = fareaz;
         areaz = fareaz;

         // Match
match0:
         pnlSystemRun->Caption = "區域" + IntToStr(i+1) + "定位...";
         btnAutoMatchClick(this);
         shMarkMatch->Visible = true;
         shMarkMatch->Refresh();

         // 2019 12 18 - chc 對位失敗!
         if(pnlNCC->Color != clLime) {
            pnlSystemRun->Caption = "區域" + IntToStr(i+1) + "對位異常!";
            pnlMatchError->Visible = true;
            pnlMatchErrorMsg->Caption = "區域" + IntToStr(i+1) + "對位異常! 重指定位置?";
            MatchProcess = 0;
            pcSystem->Enabled = false;
            while(1) {
               if(MatchProcess == 1) {
                  pcSystem->Enabled = true;
                  break;
               }
               if(MatchProcess == 2) {
                  pcSystem->Enabled = true;
                  goto match0;
               }
               Sleep(10);
               Application->ProcessMessages();
            }
         }

         // 2021 6 11 - chc 修正中心點
         else {
            double fcmd;
            int pos;
            GetPosition(X_AXIS, &fcmd);
            pos = fcmd;
            pnlCenterXFind->Caption = IntToStr(pos);
            GetPosition(Y_AXIS, &fcmd);
            pos = fcmd;
            pnlCenterYFind->Caption = IntToStr(pos);
         }

         // Delay
         DelayTime(2000);
         pnlPattern->Visible = false;
         shMarkMatch->Visible = false;
      }
      */

      // 2019 12 3 - chc 在Run中: OffsetXArea
      if(boolInRun == true) {
         double fcmd;
         int ox,oy,nx,ny;

         // 2021 5 9 - chc 改以中心點偏移量為偏移值
         //GetPosition(X_AXIS, &fcmd);
         //nx = (int)fcmd;
         //GetPosition(Y_AXIS, &fcmd);
         //ny = (int)fcmd;
         nx = pnlCenterXFind->Caption.ToInt();
         ny = pnlCenterYFind->Caption.ToInt();
         // Area1值為Recipe中心點

         ox = sgArea->Cells[1][i+1].ToInt();
         oy = sgArea->Cells[2][i+1].ToInt();
         OffsetXArea = nx - ox;
         OffsetYArea = ny - oy;
         msg.sprintf("%.1f",(double)OffsetXArea / 10.0);
         pnlOffsetXArea->Caption = msg;
         msg.sprintf("%.1f",(double)OffsetYArea / 10.0);
         pnlOffsetYArea->Caption = msg;
         msg.sprintf("[Run]Area Offset: old,new,off=%d,%d,%d,%d,%d,%d",ox,oy,nx,ny,OffsetXArea,OffsetYArea);
         WriteSystemLog(msg);
      }

      // 2021 5 9 - chc 要做兩次: 0/45度
      for(int side=0 ; side<2 ; side++) {
         if(side == 0) {
            pnlSideNo->Caption = "0度";

            // 2022 1 3 - chc 定義pnlFocusDoneE
            pnlFocusDone->Color = (TColor)0x00951106;
            pnlFocusDoneE->Color = (TColor)0x00951106;

         }
         else {
            pnlSideNo->Caption = "45度";

            // 2022 1 3 - chc 定義pnlFocusDoneE
            pnlFocusDone->Color = clTeal;
            pnlFocusDoneE->Color = clTeal;

         }
         for(int j=0 ; j<dottno ; j++) {

            // 2021 6 11 - chc 0度點位存檔
            if(side == 0) {
               side0pos[j].X = 0;
               side0pos[j].Y = 0;
               side0pos[j].Z = 0;
            }

            // 設定量測點位
            edDotNo->Text = IntToStr(j+1);
            // Pattern Martch是: 量測點
            rgMatchSource->ItemIndex = 3;
            GetTimeTic(&starttime,&starttick);
            resultcode = 0;
            if(StopMeasure() == true) {
               msg.sprintf("Abort: %d-%d",i+1,j+1);
               pnlSystemRun->Caption = msg;
               // 要做處理: Z Up, 0degree, 入料點
               goto runabort;
            }
            pnlDotNoRun->Caption = IntToStr(j+1);
            pnlDotNoRun1->Caption = IntToStr(j+1);
            // X,Y
            x = sgDot->Cells[1][j+1].ToInt();
            y = sgDot->Cells[2][j+1].ToInt();
            z = sgDot->Cells[3][j+1].ToInt();
            t = 0;
            msg.sprintf("[Run]XY X,Yvalue: %d-%d",x,y);
            WriteSystemLog(msg);
            // 偏移校正
            x += OffsetXArea;
            y += OffsetYArea;
            msg.sprintf("[Run]XY X,Yvalue(Adjsted): %d-%d",x,y);
            WriteSystemLog(msg);
            pnlStartMessage->Caption = "To #" + IntToStr(j+1);
            pnlStartMessage->Visible = true;

            // 2021 6 11 - chc Log
            msg.sprintf("[Run]進入量測(side,pt): %d,%d",side+1,j+1);
            WriteSystemLog(msg);

            // 需要到MotionCCD
            if(side == 0 && cbAutoFocus->Checked == true) {
               msg.sprintf("[Run]XY Move(Motion座標): %d-%d, %d-%d",i+1,j+1,x,y);
               WriteSystemLog(msg);
               pnlSystemRun->Caption = "移動到量測點: " + IntToStr(j+1);
               MotionStatus(false);

               // 2021 9 11 - chc 加速: MOVE_WAIT
               //MoveToXY(x,y);
               MoveToXY(x,y,MOVE_WAIT);

               WaitTime(500);

               // 2021 9 11 - chc 加速: MOVE_WAIT
               //if(MoveToZ(z) == false) {
               if(MoveToZ(z,MOVE_WAIT) == false) {

                  WriteSystemLog("移到到Z異常!");
                  pnlSystemRun->Caption = "移到到Z異常!";
                  MotionStatus(true);
                  pnlStartMessage->Visible = false;

                  // 2021 9 20a - chc Alarm
                  boolrunabort = true;

                  goto runabort;
               }
               MotionStatus(true);
               WaitTime(500);
               // 量測點Pattern Match
               recipename = combRecipe->Text;

               // 2021 6 11 - chc 共用影像檔
               if(cbShareImage->Checked == true)
                  mfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-M" + IntToStr(1) + ".bmp";
               else

                  mfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-M" + IntToStr(j+1) + ".bmp";
               if(FileExists(mfname)) {

                  // 2021 6 11 - chc 不autoFocus
                  //DelayTime(500);
                  //pnlSystemRun->Caption = "點位" + IntToStr(i+1) + "Focus...";
                  //btnAutoFocusClick(this);
                  //DelayTime(500);

                  // Match
                  pnlSystemRun->Caption = "點位" + IntToStr(i+1) + "定位...";
                  btnAutoMatchClick(this);

                  // 2023 2 21 - chc Double times
                  Sleep(200);
                  btnAutoMatchClick(this);

                  shMarkMatch->Visible = true;
                  shMarkMatch->Refresh();
                  // Delay
                  DelayTime(2000);
                  pnlPattern->Visible = false;
                  shMarkMatch->Visible = false;
                  // Match ok
                  if(pnlNCC->Color == clLime) {
                     double fcmd;
                     GetPosition(X_AXIS, &fcmd);
                     x = fcmd;
                     GetPosition(Y_AXIS, &fcmd);
                     y = fcmd;
                     msg.sprintf("[Run]XY Move(定位後): %d-%d, %d-%d",i+1,j+1,x,y);
                     WriteSystemLog(msg);

                     // 2021 9 20a - chc alarm
                     if(boolImageRecognitionError == true) {
                        boolImageRecognitionError = false;
                        SetSECSAlarm(44001,0,0,"Image Recognition Failed");
                     }

                  }

                  // 2021 9 20a - chc alarm
                  else {
                     if(boolImageRecognitionError == false) {
                        boolImageRecognitionError = true;
                        SetSECSAlarm(44001,1,0,"Image Recognition Failed");
                     }
                  }

               }
               // ToLens
               mnToLensClick(this);

               // 2021 7 22 - chc unlock
               ToLensToCCDMode = -1;

               // 2021 6 11 - chc 0度點位存檔
               {
                  double fcmd;
                  int pos;
                  GetPosition(X_AXIS, &fcmd);
                  pos = fcmd;
                  side0pos[j].X = pos;
                  GetPosition(Y_AXIS, &fcmd);
                  pos = fcmd;
                  side0pos[j].Y = pos;
                  GetPosition(Z_AXIS, &fcmd);
                  pos = fcmd;
                  side0pos[j].Z = pos;
                  msg.sprintf("[Run]0度點位存檔XYZ(定位後): %d-%d,%d,%d",j+1,side0pos[j].X,side0pos[j].Y,side0pos[j].Z);
                  WriteSystemLog(msg);
               }

            }
            // 直接到ToLens位置
            else {

               // 2021 6 11 - chc Log
               msg.sprintf("[Run]進入45度量測: %d,%d",side+1,j+1);
               WriteSystemLog(msg);

               int dx,dy,dz;
               // Offset
               dx = edLens3X->Text.ToInt() - edCCDX->Text.ToInt();
               dy = edLens3Y->Text.ToInt() - edCCDY->Text.ToInt();
               dz = edLens3Z->Text.ToInt() - edCCDZ->Text.ToInt();
               dx = 0 - dx;
               if(cbCCDXDirection->Checked == true)
                  dx = 0 - dx;
               if(cbCCDYDirection->Checked == false)
                  dy = 0 - dy;
               // Move value
               x = x + dx;
               y = y + dy;
               z = z + dz;

               // 2021 6 11 - chc 0度點位存檔
               if(side == 1) {
                  msg.sprintf("[Run]目標XYZ=%d,%d,%d",x,y,z);
                  WriteSystemLog(msg);
                  if(side == 1 && cbAutoFocus->Checked == true) {
                     if(side0pos[j].X != 0 && side0pos[j].Y != 0 && side0pos[j].Z != 0) {
                        x = side0pos[j].X;
                        y = side0pos[j].Y;
                        z = side0pos[j].Z;
                        msg.sprintf("[Run]使用0度XYZ=%d-%d,%d,%d",j+1,x,y,z);
                        WriteSystemLog(msg);
                     }
                  }
                  // 第1點會做轉45度動作, 那時會校正0/45偏移量
                  if(j != 0) {
                     dx = edAOIX->Text.ToInt() - edLoadX->Text.ToInt();
                     dy = edAOIY->Text.ToInt() - edLoadY->Text.ToInt();
                     dz = edAOIZ->Text.ToInt() - edLoadZ->Text.ToInt();
                     x += dx;
                     y += dy;
                     z += dz;

                     // 2023 1 28 - chc edY45Offset
                     double foffset;
                     int ioffset;
                     foffset = MainForm->edY45Offset->Text.ToDouble();
                     if(foffset != 0) {
                        ioffset = (int)(foffset / Y_RESOLUTION);
                        msg.sprintf("[Run]45度Y,YOffset=%d-%d,%d",j+1,y,ioffset);
                        WriteSystemLog(msg);
                        y -= ioffset;
                     }

                     msg.sprintf("[Run]45度XYZ=%d-%d,%d,%d",j+1,x,y,z);
                     WriteSystemLog(msg);
                  }
               }

               // 量測中MoveToXYZT()不檢查T(量測點用8 - 不動T)
               boolInMeasure = true;
               MotionStatus(false);
               MoveToXYZT(x,y,z,t,8);
               MotionStatus(true);
               boolInMeasure = false;
            }
            if(cbTestStep->Checked == true) {
               if(Application->MessageBox("Yuanli Socket測試: 點移動 ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                  pnlStartMessage->Visible = false;

                  // 2021 7 19 - chc 改用runabort
                  //goto stop;
                  goto runabort;

               }
            }
            pnlStartMessage->Visible = false;
            WaitTime(500);
            if(StopMeasure() == true) {
               msg.sprintf("Abort: %d-%d",i+1,j+1);
               pnlSystemRun->Caption = msg;
               // 要做處理: Z Up, 0degree, 入料點
               goto runabort;
            }
            // 45度第1點
            if(side > 0 && j == 0) {
               // Init
               WriteSystemLog("Recipe Run: Yuanli Init");
               pnlSystemMessage->Caption = "Recipe Run: Yuanli Init...";
               pnlSystemRun->Caption = "YuanLi Init...";
               if(WaitYuanliCmd(CMD_INIT) != CMD_ACK_E) {
                  pnlSystemRun->Caption = "YuanLi Init失敗!";
                  pnlAlarmMessage->Caption = "YuanLi Init異常, 停止執行.";
                  pnlSystemMessage->Caption = "";

                  // 2021 9 20a - chc Alarm
                  boolrunabort = true;

                  goto runabort;
               }
               if(cbTestStep->Checked == true) {
                  if(Application->MessageBox("Yuanli Socket測試: Init ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                     // 2021 7 19 - chc 改用runabort
                     //goto stop;
                     goto runabort;

                  }
               }
            }
            // Z
            if(j > 0) {
               pnlSystemMessage->Caption = "Recipe Run: 到Z對焦點= " + IntToStr(TestFocusZ) + "...";
               pnlSystemRun->Caption = pnlSystemMessage->Caption;

               // 2021 9 11 - chc 加速: MOVE_WAIT
               //if(MoveToZ(TestFocusZ) == false) {
               if(MoveToZ(TestFocusZ,MOVE_WAIT) == false) {

                  pnlSystemRun->Caption = "到Z對焦點失敗!";
                  pnlAlarmMessage->Caption = "到Z對焦點異常, 停止執行.";
                  pnlSystemMessage->Caption = "";

                  // 2021 9 20a - chc Alarm
                  boolrunabort = true;

                  goto runabort;
               }
               if(cbTestStep->Checked == true) {
                  if(Application->MessageBox("Yuanli Socket測試: 到Z對焦點 ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                     // 2021 7 19 - chc 改用runabort
                     //goto stop;
                     goto runabort;

                  }
               }
            }
            // Focus: 第1點
            if(j == 0) {
               // to 50x, Wait Focus done
               if(side == 0) {

                  // 2022 1 3 - chc 改Message
                  //pnlSystemMessage->Caption = "請開始對焦(物鏡切換至50x)，對焦完畢後請按[對焦完成]";
                  //pnlSystemRun->Caption = pnlSystemMessage->Caption;
                  pnlSystemMessage->Caption = "物鏡依序由5x切換至50x並完成對焦，完成後請按[對焦完成]";
                  pnlSystemRun->Caption = "0度 量測前置作業";
                  btnFocusDone->Caption = "對焦完成  Done Focus";

               }
               else {

                  // Mode: Side
                  // 2021 9 30 - chc 於轉45度前先送給YuanLi
                  WriteSystemLog("Recipe Run: Yuanli Mode.Side");
                  rgMode->ItemIndex = 1;
                  pnlSystemMessage->Caption = "Recipe Run: Yuanli Mode.Side...";
                  pnlSystemRun->Caption = pnlSystemMessage->Caption;
                  if(WaitYuanliCmd(CMD_MODE) != CMD_ACK_E) {
                     pnlSystemRun->Caption = "YuanLi Mode.Side失敗!";
                     pnlAlarmMessage->Caption = "YuanLi Mode.Side異常, 停止執行.";
                     pnlSystemMessage->Caption = "";
                     // Alarm
                     boolrunabort = true;
                     goto runabort;
                  }
                  if(cbTestStep->Checked == true) {
                     if(Application->MessageBox("Yuanli Socket測試: Mode.Side ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                        goto runabort;
                     }
                  }

                  // Z Up
                  // 上升1000um
                  WriteSystemLog("Recipe Run: Z上升1000um");
                  pnlSystemMessage->Caption = "Recipe Run: Z上升1000um...";
                  pnlSystemRun->Caption = pnlSystemMessage->Caption;
                  gap = (1000.0 / Z_RESOLUTION);
                  if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
                     WriteSystemLog("Recipe Run: Z上升1000um失敗!");
                     pnlSystemRun->Caption = "Z上升1000um失敗!";
                     pnlAlarmMessage->Caption = "Z上升1000um失敗異常, 停止執行.";
                     pnlSystemMessage->Caption = "";

                     // 2021 9 20a - chc Alarm
                     boolrunabort = true;

                     goto runabort;
                  }
                  if(cbTestStep->Checked == true) {
                     if(Application->MessageBox("Yuanli Socket測試: Z上升1000um ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                        // 2021 7 19 - chc 改用runabort
                        //goto stop;
                        goto runabort;

                     }
                  }
                  // 45
                  WriteSystemLog("Recipe Run: 45度");
                  pnlSystemMessage->Caption = "Recipe Run: Yuanli 45度...";
                  pnlSystemRun->Caption = pnlSystemMessage->Caption;

                  // 2021 9 30 - chc 顯示警示訊息
                  pnlMoving->Caption = "Turn 45 degrees: don't move";

                  btnToAOIPositionClick(this);
                  if(pnlToAOIPosition->Color != clLime) {
                     WriteSystemLog("Recipe Run: T45度異失敗!");
                     pnlSystemRun->Caption = "T45度異失敗!";
                     pnlAlarmMessage->Caption = "T45度異失敗異常, 停止執行.";
                     pnlSystemMessage->Caption = "";

                     // 2021 9 20a - chc Alarm
                     boolrunabort = true;

                     // 2021 9 30 - chc 顯示警示訊息
                     pnlMoving->Caption = "Working...";

                     goto runabort;
                  }

                  // 2023 2 21 - chc yoffset
                  double foffset;
                  int ioffset;
                  foffset = MainForm->edY45Offset->Text.ToDouble();
                  if(foffset != 0) {
                     AnsiString msg;
                     ioffset = (int)(foffset / Y_RESOLUTION);
                     msg.sprintf("[Run-Pt1]45度Y,YOffset=%d",ioffset);
                     MainForm->WriteSystemLog(msg);
                     DoRelativeMove(Y_AXIS, 0-ioffset);
                  }

                  // 2021 9 30 - chc 顯示警示訊息
                  pnlMoving->Caption = "Working...";

                  if(cbTestStep->Checked == true) {
                     if(Application->MessageBox("Yuanli Socket測試: T45度 ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                        // 2021 7 19 - chc 改用runabort
                        //goto stop;
                        goto runabort;

                     }
                  }
                  // 下降1000um
                  WriteSystemLog("Recipe Run: Z下降1000um");
                  pnlSystemMessage->Caption = "Recipe Run: Z下降1000um...";
                  pnlSystemRun->Caption = pnlSystemMessage->Caption;
                  gap = (1000.0 / Z_RESOLUTION);
                  if(MoveToAxisGap(Z_AXIS, gap) == false) {
                     WriteSystemLog("Recipe Run: Z下降1000um失敗!");
                     pnlSystemRun->Caption = "Z下降1000um失敗!";
                     pnlAlarmMessage->Caption = "Z下降1000um失敗異常, 停止執行.";
                     pnlSystemMessage->Caption = "";

                     // 2021 9 20a - chc Alarm
                     boolrunabort = true;

                     goto runabort;
                  }
                  if(cbTestStep->Checked == true) {
                     if(Application->MessageBox("Yuanli Socket測試: Z下降1000um ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                        // 2021 7 19 - chc 改用runabort
                        //goto stop;
                        goto runabort;

                     }
                  }

                  // Mode: Side
                  // 2021 9 30 - chc 於轉45度前先送給YuanLi
                  /*
                  WriteSystemLog("Recipe Run: Yuanli Mode.Side");
                  rgMode->ItemIndex = 1;
                  pnlSystemMessage->Caption = "Recipe Run: Yuanli Mode.Side...";
                  pnlSystemRun->Caption = pnlSystemMessage->Caption;
                  if(WaitYuanliCmd(CMD_MODE) != CMD_ACK_E) {
                     pnlSystemRun->Caption = "YuanLi Mode.Side失敗!";
                     pnlAlarmMessage->Caption = "YuanLi Mode.Side異常, 停止執行.";
                     pnlSystemMessage->Caption = "";

                     // 2021 9 20a - chc Alarm
                     boolrunabort = true;

                     goto runabort;
                  }
                  if(cbTestStep->Checked == true) {
                     if(Application->MessageBox("Yuanli Socket測試: Mode.Side ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                        // 2021 7 19 - chc 改用runabort
                        //goto stop;
                        goto runabort;

                     }
                  }
                  */

                  // LM 50x
                  // 2022 1 3 - chc 改Message
                  //pnlSystemMessage->Caption = "請將物鏡切換至LM 50x, 切換完畢後請按[LM 50x]";
                  //btnFocusDone->Caption = "LM 50x";
                  //pnlSystemRun->Caption = pnlSystemMessage->Caption;
                  pnlSystemMessage->Caption = "物鏡依序由5x切換至LM 50x, 完成請按[完成切換LM50x]";
                  btnFocusDone->Caption = "完成切換LM50x Done LM50x";
                  pnlSystemRun->Caption = "45 量測前置作業";

                  btnFocusDone->Hint = pnlSystemMessage->Caption;
                  btnFocusDone->Visible = true;
                  pcSystem->Enabled = false;

                  // 2021 9 23b - chc 顯示
                  // 21 9 25 - chc 不需要顯示角度
                  //pnlDotNoRun1->Visible = true;
                  //pnlSideNo->Visible = true;
                  pnlDotNoRun1->Visible = false;
                  pnlSideNo->Visible = false;

                  // 2021 8 13 - chc 操作指示
                  pnlFocusDone->Caption = pnlSystemMessage->Caption;
                  pnlFocusDone->Visible = true;

                  // 2022 1 3 - chc 定義pnlFocusDoneE
                  pnlFocusDoneE->Caption = "Switch to LM 50x, Then press [Done LM50x]";
                  pnlFocusDoneE->Visible = true;

                  // 2021 9 23b - chc SetButtonDelay
                  SetButtonDelay(1);

                  // 2021 7 19 - chc 改用runabort
                  WriteSystemLog("關閉作業頁面3. [LM 50x]");

                  boolTestFocusDone = false;
                  while(1) {
                     WaitTime(500);
                     if(boolTestFocusDone == true)
                        break;
                  }
                  btnFocusDone->Visible = false;
                  pcSystem->Enabled = true;
                  //pnlSystemMessage->Caption = "請開始對焦(維持LM 50X物鏡)，對焦完畢後並縮放1.5x請按[對焦完成]";
                  // 2022 1 3 - chc 更新訊息
                  //pnlSystemMessage->Caption = "請對焦(維持LM 50X)對焦完畢並縮放1.5x後請按[對焦完成]";
                  pnlSystemMessage->Caption = "設定縮放1.5x並完成對焦, 完成後請按[對焦完成]";
                  btnFocusDone->Caption = "對焦完成  Done Focus";
                  pnlSystemRun->Caption = "45 量測前置作業";

                  // 2021 9 23b - chc 顯示
                  pnlSideNo->Visible = false;
                  pnlDotNoRun1->Visible = false;

                  // 2021 8 13 - chc 操作指示
                  pnlFocusDone->Visible = false;

                  // 2022 1 3 - chc 定義pnlFocusDoneE
                  pnlFocusDoneE->Visible = false;

               }

               // 2022 1 3 - chc 更新訊息
               //pnlSystemRun->Caption = pnlSystemMessage->Caption;

               btnFocusDone->Hint = pnlSystemMessage->Caption;
               btnFocusDone->Visible = true;
               pcSystem->Enabled = false;

               // 2021 9 23b - chc 顯示
               // 21 9 25 - chc 不需要顯示角度
               //pnlSideNo->Visible = true;
               //pnlDotNoRun1->Visible = true;
               pnlSideNo->Visible = false;
               pnlDotNoRun1->Visible = false;

               // 2021 8 13 - chc 操作指示
               pnlFocusDone->Caption = pnlSystemMessage->Caption;
               pnlFocusDone->Visible = true;

               // 2022 1 3 - chc 定義pnlFocusDoneE
               if(side == 0)
                  pnlFocusDoneE->Caption = "Fr 5x to 50x and focusing, Then press [Done Focus]";
               else
                  pnlFocusDoneE->Caption = "Set zoom to 1.5x and focusing, Then press[Done Focus]";
               pnlFocusDoneE->Visible = true;

               // 2021 9 23b - chc SetButtonDelay
               SetButtonDelay(2);

               // 2021 7 19 - chc 改用runabort
               WriteSystemLog("關閉作業頁面4. [對焦完成]");

               boolTestFocusDone = false;
               while(1) {
                  WaitTime(500);
                  if(boolTestFocusDone == true)
                     break;
               }
               pcSystem->Enabled = true;
               btnFocusDone->Visible = false;

               // 2021 9 23b - chc 顯示
               pnlSideNo->Visible = false;
               pnlDotNoRun1->Visible = false;

               // 2021 8 13 - chc 操作指示
               pnlFocusDone->Visible = false;

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Visible = false;

               TestFocusZ = edCounterZ->Text.ToInt();
               pnlSystemMessage->Caption = "Recipe Run: 設定Z對焦點= " + IntToStr(TestFocusZ);
               pnlSystemRun->Caption = pnlSystemMessage->Caption;
               if(StopMeasure() == true) {
                  msg.sprintf("Abort: %d-%d",i+1,j+1);
                  pnlSystemRun->Caption = msg;
                  // 要做處理: Z Up, 0degree, 入料點
                  goto runabort;
               }
               if(cbTestStep->Checked == true) {
                  if(Application->MessageBox("Yuanli Socket測試: 設定Z對焦點 ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                     // 2021 7 19 - chc 改用runabort
                     //goto stop;
                     goto runabort;

                  }
               }
            }
            // InPos
            WriteSystemLog("Recipe Run: Yuanli InPos");
            rgYuanliPoint->ItemIndex = j;
            pnlSystemMessage->Caption = "Recipe Run: Yuanli InPos...";
            pnlSystemRun->Caption = pnlSystemMessage->Caption;
            if(WaitYuanliCmd(CMD_INPOS) != CMD_ACK_E) {
               pnlSystemRun->Caption = "YuanLi InPos失敗!";
               pnlAlarmMessage->Caption = "YuanLi InPos異常, 停止執行.";
               pnlSystemMessage->Caption = "";

               // 2021 9 20a - chc Alarm
               boolrunabort = true;

               goto runabort;
            }
            if(StopMeasure() == true) {
               msg.sprintf("Abort: %d-%d",i+1,j+1);
               pnlSystemRun->Caption = msg;
               // 要做處理: Z Up, 0degree, 入料點
               goto runabort;
            }
            // Wait Next
            boolTestFocusDone = false;
            if(j == dottno-1 && side == 0) {

               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "45度量測";
               //pnlSystemMessage->Caption = "請開始量測，量測完畢後請按[45度量測]";
               btnFocusDone->Caption = "到45度量測 45Measure";
               pnlSystemMessage->Caption = "目前在點位" + IntToStr(j+1) + ", 量測完請按[到45度量測]";
               pnlSystemRun->Caption = "0 量測[點位" + IntToStr(j+1) + "]";
               pnlFocusDoneE->Caption = "Start measuring point " + IntToStr(j+1) + ", Then press [45Measure]";

            }
            else if(j == dottno-1 && side == 1) {

               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "結束量測";
               //pnlSystemMessage->Caption = "請開始量測，量測完畢後請按[結束量測]";
               btnFocusDone->Caption = "結束量測 EndMeasure";
               pnlSystemMessage->Caption = "目前在點位" + IntToStr(j+1) + ", 量測完請按[結束量測]";
               pnlSystemRun->Caption = "45 量測[點位" + IntToStr(j+1) + "]";
               pnlFocusDoneE->Caption = "Start measuring point " + IntToStr(j+1) + ", Then press [EndMeasure]";

            }
            else {

               // 2021 9 23 - chc 標示下一點的編號
               //btnFocusDone->Caption = "下一點";
               //pnlSystemMessage->Caption = "請開始量測，量測完畢後請按[下一點]";
               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "點位: " + IntToStr(j+2);
               //pnlSystemMessage->Caption = "請開始量測點位" + IntToStr(j+1) + ", 量測完畢後請按[點位: " + IntToStr(j+2) + "]";
               btnFocusDone->Caption = "到點位" + IntToStr(j+2) + " Point: " + IntToStr(j+2);
               pnlSystemMessage->Caption = "目前在點位" + IntToStr(j+1) + ", 量測完請按[到點位: " + IntToStr(j+2) + "]";
               if(side == 0)
                  pnlSystemRun->Caption = "0 量測[點位" + IntToStr(j+1) + "]";
               else
                  pnlSystemRun->Caption = "45 量測[點位" + IntToStr(j+1) + "]";
               pnlFocusDoneE->Caption = "Start measuring point " + IntToStr(j+1) + ", Then press [Point " + IntToStr(j+2) + "]";

            }
            btnFocusDone->Hint = pnlSystemMessage->Caption;

            // 2022 1 3 - chc 定義pnlFocusDoneE
            //pnlSystemRun->Caption = pnlSystemMessage->Caption;

            pcSystem->Enabled = false;

            // 2021 8 13 - chc 操作指示
            pnlFocusDone->Caption = pnlSystemMessage->Caption;
            pnlFocusDone->Visible = true;

            // 2022 1 3 - chc 定義pnlFocusDoneE
            pnlFocusDoneE->Visible = true;

            // 2021 7 19 - chc 改用runabort
            WriteSystemLog("關閉作業頁面5. [" + btnFocusDone->Caption + "]");

            btnFocusDone->Visible = true;

            // 2021 9 23b - chc SetButtonDelay
            SetButtonDelay(3);

            // 2021 9 23b - chc 顯示
            pnlSideNo->Visible = true;
            pnlDotNoRun1->Visible = true;

            while(1) {
               WaitTime(500);
               if(boolTestFocusDone == true)
                  break;
            }
            pcSystem->Enabled = true;
            btnFocusDone->Visible = false;

            // 2021 9 23b - chc 顯示
            pnlSideNo->Visible = false;
            pnlDotNoRun1->Visible = false;

            // 2021 8 13 - chc 操作指示
            pnlFocusDone->Visible = false;

            // 2022 1 3 - chc 定義pnlFocusDoneE
            pnlFocusDoneE->Visible = false;

            // 2021 6 11 - chc 這裡存才對, 0度點位存檔
            if(side == 0) {
               double fcmd;
               int pos;
               GetPosition(X_AXIS, &fcmd);
               pos = fcmd;
               side0pos[j].X = pos;
               GetPosition(Y_AXIS, &fcmd);
               pos = fcmd;
               side0pos[j].Y = pos;
               GetPosition(Z_AXIS, &fcmd);
               pos = fcmd;
               side0pos[j].Z = pos;
               msg.sprintf("[Run]量測後0度點位存檔XYZ(定位後): %d-%d,%d,%d",j+1,x,y,z);
               WriteSystemLog(msg);
            }

            // Z Up
            // 結束: 上升10mm
            if(j == dottno-1 && side == 1) {
               WriteSystemLog("Recipe Run: Z上升10000um");
               pnlSystemMessage->Caption = "Recipe Run: Z上升10000um...";
               pnlSystemRun->Caption = pnlSystemMessage->Caption;
               gap = (10000.0 / Z_RESOLUTION);
               if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
                  WriteSystemLog("Recipe Run: Z上升10000um失敗!");
                  pnlAlarmMessage->Caption = "Recipe Run: Z上升10000um失敗!";
                  pnlSystemRun->Caption = pnlAlarmMessage->Caption;
                  pnlSystemMessage->Caption = "";

                  // 2021 9 20a - chc Alarm
                  boolrunabort = true;

                  goto runabort;
               }
               if(cbTestStep->Checked == true) {
                  if(Application->MessageBox("Yuanli Socket測試: Z上升10000um ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                     // 2021 7 19 - chc 改用runabort
                     //goto stop;
                     goto runabort;

                  }
               }

               // 2021 7 19 - chc 是否結束量測?
               boolEndMeasure = true;

            }
            else {

               // 2021 10 4 - chc side=0, 最後1點不用上升, 改到[切換到5x]後再上升
               if(j != dottno-1 || side != 0) {

                  WriteSystemLog("Recipe Run: Z上升1000um");
                  pnlSystemMessage->Caption = "流程測試: Z上升1000um...";
                  pnlSystemRun->Caption = pnlSystemMessage->Caption;
                  gap = (1000.0 / Z_RESOLUTION);
                  if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
                     WriteSystemLog("Recipe Run: Z上升1000um失敗!");
                     pnlAlarmMessage->Caption = "流程測試: Z上升1000um失敗!";
                     pnlSystemRun->Caption = pnlAlarmMessage->Caption;
                     pnlSystemMessage->Caption = "";

                     // 2021 9 20a - chc Alarm
                     boolrunabort = true;

                     goto runabort;
                  }
                  if(cbTestStep->Checked == true) {
                     if(Application->MessageBox("Yuanli Socket測試: Z上升1000um ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

                        // 2021 7 19 - chc 改用runabort
                        //goto stop;
                        goto runabort;

                     }
                  }

               }

            }
            if(StopMeasure() == true) {
               msg.sprintf("Abort: %d-%d",i+1,j+1);
               pnlSystemRun->Caption = msg;
               // 要做處理: Z Up, 0degree, 入料點
               goto runabort;
            }
            // 提示5x
            if(j == dottno-1 && side == 0) {
               boolTestFocusDone = false;

               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "切換到5x";
               btnFocusDone->Caption = "切換到5x  SwitchTo 5x";

               pnlSystemMessage->Caption = "物鏡請切換至5x，切換完畢後請按[切換到5x]";
               btnFocusDone->Hint = pnlSystemMessage->Caption;
               pnlSystemRun->Caption = pnlSystemMessage->Caption;
               pcSystem->Enabled = false;

               // 2021 8 13 - chc 操作指示
               pnlFocusDone->Caption = pnlSystemMessage->Caption;
               pnlFocusDone->Visible = true;

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Caption = "Switch to 5x, Then press [Switch to 5x]";
               pnlFocusDoneE->Visible = true;

               // 2021 9 23b - chc SetButtonDelay
               SetButtonDelay(4);

               // 2021 7 19 - chc 改用runabort
               WriteSystemLog("關閉作業頁面6. [切換到5x]");

               // 2021 9 23b - chc 顯示
               // 21 9 25 - chc 不需要顯示角度
               //pnlSideNo->Visible = true;
               //pnlDotNoRun1->Visible = true;
               pnlSideNo->Visible = false;
               pnlDotNoRun1->Visible = false;

               btnFocusDone->Visible = true;
               while(1) {
                  WaitTime(500);
                  if(boolTestFocusDone == true)
                     break;
               }
               pcSystem->Enabled = true;
               btnFocusDone->Visible = false;

               // 2021 9 23b - chc 顯示
               pnlSideNo->Visible = false;
               pnlDotNoRun1->Visible = false;

               // 2021 8 13 - chc 操作指示
               pnlFocusDone->Visible = false;

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Visible = false;

               // 2021 10 4 - chc side=0, 最後1點不用上升, 改到[切換到5x]後再上升
               WriteSystemLog("Recipe Run: Z上升1000um");
               pnlSystemMessage->Caption = "流程測試: Z上升1000um...";
               pnlSystemRun->Caption = pnlSystemMessage->Caption;
               gap = (1000.0 / Z_RESOLUTION);
               if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
                  WriteSystemLog("Recipe Run: Z上升1000um失敗!");
                  pnlAlarmMessage->Caption = "流程測試: Z上升1000um失敗!";
                  pnlSystemRun->Caption = pnlAlarmMessage->Caption;
                  pnlSystemMessage->Caption = "";
                  // Alarm
                  boolrunabort = true;
                  goto runabort;
               }
               if(cbTestStep->Checked == true) {
                  if(Application->MessageBox("Yuanli Socket測試: Z上升1000um ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                     goto runabort;
                  }
               }

            }
            WaitTime(1000);
            // 單點量測結束: sgDot->Cells[5][j+1] => Recipe
            recordno++;
            GetTimeTic(&stoptime,&stoptick);
            elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
            pnlElapsedTime->Caption = IntToStr(elapsedms) + "ms";
            if(side == 0)
               AddMeasureData(recordno,i+1,j+1,sgDot->Cells[5][j+1],side,elapsedms);
            else
               AddMeasureData(recordno,i+1,j+1,sgDot->Cells[5][j+1],side,elapsedms);
            WaitRun(1000,0);
            WriteSystemLog("[Run]Next Point");
         }
      }

   // Area結束
   }

   btnRunStop->Visible = false;
   btnSystemRun->Enabled = true;
   pnlSystemRun->Caption = "Completed.";

   runno++;
   pnlRunDoneNo->Caption = IntToStr(runno);
   loop = edRunLoop->Text.ToInt();
   if(runno >= loop)
      break;
   pnlSystemRun->Caption = "Wait 30sec...";
   WaitRun(30000,1);

}

end:
   btnRunStop->Visible = false;
   boolInRun = false;

   // 2021 5 9 - chc 上升, 0 度, 入料點
   boolInMeasure = false;

   // ProcessEnd: 量測完成
   rgSECSStatus->ItemIndex = STATUS_PROCESSEND;
   WriteSystemLog("boolSendSCESCommand: 11-1");
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_PREV - SECS_CMD_STAT_1;
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("Yuanli Socket測試: 送STATUS_PROCESSEND ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {

         // 2021 7 19 - chc 改用runabort
         //goto stop;
         goto runabort;

      }
   }

runabort:

   // 2021 9 20a - chc Alarm
   if(boolrunabort == true) {
      if(boolWorkflowError == false) {
         boolWorkflowError = true;
         SetSECSAlarm(44002,1,0,"Work flow Abnormal");
      }
   }
   else {
      if(boolWorkflowError == true) {
         boolWorkflowError = false;
         SetSECSAlarm(44002,0,0,"Work flow Abnormal");
      }
   }

   // 2021 7 19 - chc 改用runabort
   WriteSystemLog("[中斷量測]3");

   // 2021 7 19 - chc 是否結束量測? Stop
   if(boolEndMeasure == true) {
      WriteSystemLog("Recipe Run: YuanLi Stop");
      pnlSystemRun->Caption = "YuanLi Stop...";
      pnlSystemMessage->Caption = "Recipe Run: YuanLi Stop...";
      if(WaitYuanliCmd(CMD_STOP) != CMD_ACK_E) {
         pnlSystemRun->Caption = "YuanLi Stop失敗!";
         pnlAlarmMessage->Caption = "YuanLi Stop異常, 停止執行.";
         pnlSystemMessage->Caption = "";
         goto stop;
      }
      pnlSystemRun->Caption = "YuanLi Stop OK.";
   }

   // 上-升
   WriteSystemLog("Recipe Run: Z上升10000um");
   pnlSystemMessage->Caption = "Recipe Run: Z上升10000um...";
   gap = (10000.0 / Z_RESOLUTION);
   if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
      WriteSystemLog("Recipe Run: Z上升10000um失敗!");
      pnlAlarmMessage->Caption = "Recipe Run: Z上升10000um失敗!";
      pnlSystemMessage->Caption = "";
      goto stop;
   }
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("Yuanli Socket測試: Z上升10000um ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         goto stop;
      }
   }

   // 2021 7 9 - chc Init
   WriteSystemLog("Recipe Run: YuanLi Init");
   pnlSystemRun->Caption = "YuanLi Init...";
   pnlSystemMessage->Caption = "Recipe Run: YuanLi Init...";
   if(WaitYuanliCmd(CMD_INIT) != CMD_ACK_E) {
      pnlSystemRun->Caption = "YuanLi Init失敗!";
      pnlAlarmMessage->Caption = "YuanLi Init異常, 停止執行.";
      pnlSystemMessage->Caption = "";
      goto stop;
   }
   pnlSystemRun->Caption = "YuanLi Init OK.";

   // 2021 9 30 - chc 顯示警示訊息
   pnlMoving->Caption = "Turn 0 degrees: don't move";

   // 0 度
   WriteSystemLog("Recipe Run: 0度");
   pnlSystemMessage->Caption = "Recipe Run: 0度";
   btnToLoadPositionClick(this);
   if(pnlToLoadPosition->Color != clLime) {
      WriteSystemLog("Recipe Run: 0度失敗!");
      pnlAlarmMessage->Caption = "Recipe Run: 0度失敗!";
      pnlSystemMessage->Caption = "";

      // 2021 9 30 - chc 顯示警示訊息
      pnlMoving->Caption = "Working...";

      goto stop;
   }

   // 2021 9 30 - chc 顯示警示訊息
   pnlMoving->Caption = "Working...";

   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("Yuanli Socket測試: 0度 ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         goto stop;
      }
   }
   // 回到入料點
   pnlSystemRun->Caption = "Done, 到入料點...";
   btnToOriginalPositionClick(this);
   if(pnlToOriginalPosition->Color != clLime) {
      WriteSystemLog("Recipe Run: 到入料點失敗!");
      pnlAlarmMessage->Caption = "Recipe Run: 到入料點失敗!";
      pnlSystemMessage->Caption = "";
      goto stop;
   }
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("Yuanli Socket測試: 到入料點 ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         goto stop;
      }
   }

   // 2021 6 16 - chc 要恢復原狀
   btnSystemRun->Enabled = true;
   btnMeasureStop->Visible = false;
   btnRunStop->Visible = false;
   pcSystem->Enabled = true;

   // 2021 7 19 - chc 改用runabort
   WriteSystemLog("啟動作業頁面1.");

   // 2021 6 9 - chc 回到Z安全高度 & 0度
   // 2021 7 19 - chc 改用runabort
   //if(boolrunabort == true)
   //   return;

   // 2021 7 22 - chc unlock
   ToLensToCCDMode = -1;

   // 恢復為Enable
   pnlSystemRun->Caption = "Completed.";
   btnSystemRun->Enabled = true;
   btnMeasureStop->Visible = false;
   btnRunStop->Visible = false;

   // 2021 9 25 - chc 量測中
   boolInMeasureRun = false;

   // 2021 11 12 - chc 記錄Load button狀態
   btnCassetteLoad->Enabled = boolloadbutton;

   // 2021 9 25 - chc 取消顯示
   pnlMoving->Visible = false;

   // 2021 10 17 - chc SECS連線且自動時自動退片
   // 2021 11 11 - chc 離線也可以
   // => 離線仍由人員手動退片(因可能要重量)
   if(cbOffLine->Checked == false && cbSECSAtuo->Checked == true) {
   //if((cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true)) {

      if(tmAutoUnloadWafer->Enabled == false) {
         pnlSystemMessage->Caption = "量測完成到入料點後: 自動進行Timer退片作業.";
         WriteSystemLog(pnlSystemMessage->Caption);
         tmAutoUnloadWafer->Enabled = true;
         if(btnSystemRun->Enabled == true)
            btnSystemRun->Enabled = false;
      }
   }

   // 2021 10 21 - chc 啟動T & Z
   pnlMoveTCounterclockwise->Enabled = true;
   pnlMoveTClockwise->Enabled = true;
   pnlMoveLeft->Enabled = true;

   return;

stop:
   btnSystemRun->Enabled = true;
   pnlSystemRun->Caption = "Recipe Run未完成!";
   btnMeasureStop->Visible = false;
   btnRunStop->Visible = false;

   // 2021 6 11 - chc 恢復
   pcSystem->Enabled = true;

   // 2021 7 19 - chc 改用runabort
   WriteSystemLog("啟動作業頁面2.");

   // 2021 6 9 - chc 回到Z安全高度 & 0度
   // 2021 7 19 - chc 改用runabort
   //boolrunabort = true;
   //goto runabort;

   // 2021 7 22 - chc unlock
   ToLensToCCDMode = -1;

   // 2021 9 25 - chc 量測中
   boolInMeasureRun = false;

   // 2021 11 12 - chc 記錄Load button狀態
   btnCassetteLoad->Enabled = boolloadbutton;

   // 2021 9 25 - chc 取消顯示
   pnlMoving->Visible = false;

   // 2021 10 21 - chc 啟動T & Z
   pnlMoveTCounterclockwise->Enabled = true;
   pnlMoveTClockwise->Enabled = true;
   pnlMoveLeft->Enabled = true;

}
//---------------------------------------------------------------------------
// 2019 7 16 - chc Stop Run
void __fastcall TMainForm::btnRunStopClick(TObject *Sender)
{

   boolInRun = false;
}
//---------------------------------------------------------------------------

// 2019 8 18 - chc 重建StringGrid(Area/Dot)
void __fastcall TMainForm::btnReBuildClick(TObject *Sender)
{
int areatno,dottno,recipeno;
AnsiString msg;

   // 2021 10 4 - chc 是combRecipe->ItemIndex; 才對
   //recipeno = 0;
   recipeno = combRecipe->ItemIndex;

   // Area
   areatno = edAreaTNo->Text.ToInt();
   if(areatno < 1)
      areatno = 1;
   if(areatno > MAX_AREA_NO)
      areatno = MAX_AREA_NO;

   // 清空Area Buffer
   for(int i=0 ; i<MAX_AREA_NO ; i++) {
      RecipeBuffer[recipeno].AreaBuf[i].X = 0;
      RecipeBuffer[recipeno].AreaBuf[i].Y = 0;

      // 2019 12 13 - chc 要設定Motion Z, 用原點Z
      //RecipeBuffer[recipeno].AreaBuf[i].Z = 0;
      RecipeBuffer[recipeno].AreaBuf[i].Z = edCCDZ->Text.ToInt();

   }
   // 清空Dot Buffer
   for(int i=0 ; i<MAX_DOT_NO ; i++) {
      RecipeBuffer[recipeno].DotBuf[i].X = 0;
      RecipeBuffer[recipeno].DotBuf[i].Y = 0;
      RecipeBuffer[recipeno].DotBuf[i].Z = 0;
      RecipeBuffer[recipeno].DotBuf[i].Intensity = 5.0;
      RecipeBuffer[recipeno].DotBuf[i].Recipe = "NA";
      RecipeBuffer[recipeno].DotBuf[i].Row = 0;
      RecipeBuffer[recipeno].DotBuf[i].Col = 1;
   }

   // Grid全部存到Buffer
   RecipeBuffer[recipeno].AreaNo = areatno;

   // 2019 12 13 - chc 要-2
   //for(int i=1 ; i<=sgArea->RowCount-1 ; i++) {
   for(int i=1 ; i<=sgArea->RowCount-2 ; i++) {

      RecipeBuffer[recipeno].AreaBuf[i].X = sgArea->Cells[1][i].ToInt();
      RecipeBuffer[recipeno].AreaBuf[i].Y = sgArea->Cells[2][i].ToInt();
      RecipeBuffer[recipeno].AreaBuf[i].Z = sgArea->Cells[3][i].ToInt();
   }

   // 2019 12 13 - chc 要加2
   //sgArea->RowCount = areatno + 1;
   sgArea->RowCount = areatno + 2;

   // 重新顯示Grid
   for(int i=1 ; i<=areatno ; i++) {

      // 2019 12 13 - chc 加入編號
      sgArea->Cells[0][i] = IntToStr(i);

      sgArea->Cells[1][i] = IntToStr(RecipeBuffer[recipeno].AreaBuf[i].X);
      sgArea->Cells[2][i] = IntToStr(RecipeBuffer[recipeno].AreaBuf[i].Y);
      sgArea->Cells[3][i] = IntToStr(RecipeBuffer[recipeno].AreaBuf[i].Z);
   }

   // 2019 12 13 - chc 清除最後一Row
   for(int i=0 ; i<4 ; i++)
      sgArea->Cells[i][sgArea->RowCount-1] = "";

   // Dot
   dottno = edDotTNo->Text.ToInt();
   if(dottno < 1)
      dottno = 1;
   if(dottno > MAX_DOT_NO)
      dottno = MAX_DOT_NO;
   // 全部物存到Buffer
   RecipeBuffer[recipeno].DotNo = dottno;

   // 2019 12 13 - chc 要-2
   //for(int i=1 ; i<=sgDot->RowCount-1 ; i++) {
   for(int i=1 ; i<=sgDot->RowCount-2 ; i++) {

      RecipeBuffer[recipeno].DotBuf[i].X = sgDot->Cells[1][i].ToInt();
      RecipeBuffer[recipeno].DotBuf[i].Y = sgDot->Cells[2][i].ToInt();
      RecipeBuffer[recipeno].DotBuf[i].Z = sgDot->Cells[3][i].ToInt();
      RecipeBuffer[recipeno].DotBuf[i].Intensity = sgDot->Cells[4][i].ToDouble();
      RecipeBuffer[recipeno].DotBuf[i].Recipe = sgDot->Cells[5][i];
      RecipeBuffer[recipeno].DotBuf[i].Row = sgDot->Cells[6][i].ToInt();
      RecipeBuffer[recipeno].DotBuf[i].Col = sgDot->Cells[7][i].ToInt();

   }

   // 2019 12 13 - chc 要加2
   //sgDot->RowCount = dottno + 1;
   sgDot->RowCount = dottno + 2;

   // 重新顯示Grid
   for(int i=1 ; i<=dottno ; i++) {

      // 2019 12 13 - chc 加入編號
      sgDot->Cells[0][i] = IntToStr(i);

      sgDot->Cells[1][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].X);
      sgDot->Cells[2][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].Y);
      sgDot->Cells[3][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].Z);
      msg.sprintf("%.2f",RecipeBuffer[recipeno].DotBuf[i].Intensity);
      sgDot->Cells[4][i] = msg;
      sgDot->Cells[5][i] = RecipeBuffer[recipeno].DotBuf[i].Recipe;
      sgDot->Cells[6][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].Row);
      sgDot->Cells[7][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].Col);

   }

   // 2019 12 13 - chc 清除最後一Row
   for(int i=0 ; i<8 ; i++)
      sgDot->Cells[i][sgDot->RowCount-1] = "";

}
//---------------------------------------------------------------------------
// mode 0- none
//      1- Message
void __fastcall TMainForm::WaitRun(int sleepno, int mode)
{
int cnt,no,secno;

   cnt = sleepno / 10 + 1;
   secno = sleepno / 1000;
   no = 0;
   for(int i=0 ; i<cnt ; i++) {
      Sleep(10);
      Application->ProcessMessages();
      no++;
      if(no >= 100) {
         no = 0;
         secno--;
         pnlSystemRun->Caption = "Wait " + IntToStr(secno) + "sec...";
      }
   }
}
//---------------------------------------------------------------------------
// 2019 7 19 - chc 加入結果: resultcode 1-Z, 2-Intensity, 3-Measurement, 0-ok
//#define RESULT_FIELD_INDEX                0               // index
//#define RESULT_FIELD_AREA                 1
//#define RESULT_FIELD_DOT                  2
//#define RESULT_FIELD_VISIONRECIPE         3
//#define RESULT_FIELD_RESULT               4
void __fastcall TMainForm::AddMeasureData(int recordno,int areano, int dotno, AnsiString visionrecipe, int resultcode, long elapsedms)
{
AnsiString str;

   // Add
   MainForm->sgResult->Cells[RESULT_FIELD_INDEX][MainForm->sgResult->RowCount-1]        = recordno;
   MainForm->sgResult->Cells[RESULT_FIELD_AREA][MainForm->sgResult->RowCount-1]         = areano;
   MainForm->sgResult->Cells[RESULT_FIELD_DOT][MainForm->sgResult->RowCount-1]          = dotno;
   MainForm->sgResult->Cells[RESULT_FIELD_VISIONRECIPE][MainForm->sgResult->RowCount-1] = visionrecipe;
   str.sprintf("%.2f",(double)elapsedms/1000.0);
   MainForm->sgResult->Cells[RESULT_FIELD_TIME][MainForm->sgResult->RowCount-1]         = str;

   /*
   if(resultcode == 0)
      str = "Done";
   else if(resultcode == 1)
      str = "Z Error";
   else if(resultcode == 2)
      str = "Intensity Error";
   // MeasureResult: 0/1/2/3/4/5 - Ok/無VisionRecipe/VisionRecipe不存在/VisionRecipe指定失敗/Error/Timeout
   else if(resultcode == 3)
      str = "未指定VisionRecipe";
   else if(resultcode == 4)
      str = "VisionRecipe不存在";
   else if(resultcode == 5)
      str = "VisionRecipe設定失敗";
   else if(resultcode == 6)
      str = "Measure Error";
   else if(resultcode == 7)
      str = "Measure Timeout";
   */
   if(resultcode == 0)
      str = "Ok-Top";
   else if(resultcode == 1)
      str = "Ok-Side";

   MainForm->sgResult->Cells[RESULT_FIELD_RESULT][MainForm->sgResult->RowCount-1]       = str;
   MainForm->sgResult->RowCount++;

   // 清除最後一Row
   MainForm->sgResult->Cells[RESULT_FIELD_INDEX][MainForm->sgResult->RowCount-1]        = "";
   MainForm->sgResult->Cells[RESULT_FIELD_AREA][MainForm->sgResult->RowCount-1]         = "";
   MainForm->sgResult->Cells[RESULT_FIELD_DOT][MainForm->sgResult->RowCount-1]          = "";
   MainForm->sgResult->Cells[RESULT_FIELD_VISIONRECIPE][MainForm->sgResult->RowCount-1] = "";
   MainForm->sgResult->Cells[RESULT_FIELD_RESULT][MainForm->sgResult->RowCount-1]       = "";
   MainForm->sgResult->Cells[RESULT_FIELD_TIME][MainForm->sgResult->RowCount-1]         = "";

   // 指到最後一筆
   MainForm->sgResult->Row = MainForm->sgResult->RowCount-1;
}
//---------------------------------------------------------------------------
// 取消對位框
void __fastcall TMainForm::btnEraseMatchBoxClick(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   shMarkMatch->Visible = false;
}
//---------------------------------------------------------------------------
// 2019 7 22 - chc 保留總點數, 但將設定值設為0
void __fastcall TMainForm::btnRecipeResetClick(TObject *Sender)
{
int areatno,dottno,recipeno;
AnsiString msg;

   if(Application->MessageBox("重設Recipe設定值(保留總數, 其餘參數設為0)?      ", "Recipe參數設定", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   // 2021 10 4 - chc 是combRecipe->ItemIndex; 才對
   //recipeno = 0;
   recipeno = combRecipe->ItemIndex;

   // Area
   areatno = edAreaTNo->Text.ToInt();
   if(areatno < 1)
      areatno = 1;
   if(areatno > MAX_AREA_NO)
      areatno = MAX_AREA_NO;
   // Grid全部存到Buffer
   RecipeBuffer[recipeno].AreaNo = areatno;
   for(int i=1 ; i<=sgArea->RowCount-1 ; i++) {
      RecipeBuffer[recipeno].AreaBuf[i].X = 0;
      RecipeBuffer[recipeno].AreaBuf[i].Y = 0;

      // 2019 12 13 - chc 要設定Motion Z, 用原點Z
      //RecipeBuffer[recipeno].AreaBuf[i].Z = 0;
      RecipeBuffer[recipeno].AreaBuf[i].Z = edCCDZ->Text.ToInt();

   }

   // 2019 12 13 - chc
   sgArea->RowCount = areatno + 2;
   // 重新顯示Grid
   for(int i=1 ; i<=areatno ; i++) {

      // 2019 12 13 - chc 加入編號
      sgArea->Cells[0][i] = IntToStr(i);

      sgArea->Cells[1][i] = IntToStr(RecipeBuffer[recipeno].AreaBuf[i].X);
      sgArea->Cells[2][i] = IntToStr(RecipeBuffer[recipeno].AreaBuf[i].Y);
      sgArea->Cells[3][i] = IntToStr(RecipeBuffer[recipeno].AreaBuf[i].Z);
   }
   // 清除最後一Row
   for(int i=0 ; i<4 ; i++)
      sgArea->Cells[i][sgArea->RowCount-1] = "";

   // Dot
   dottno = edDotTNo->Text.ToInt();
   if(dottno < 1)
      dottno = 1;
   if(dottno > MAX_DOT_NO)
      dottno = MAX_DOT_NO;
   // 全部物存到Buffer
   RecipeBuffer[recipeno].DotNo = dottno;
   for(int i=1 ; i<=sgDot->RowCount-1 ; i++) {
      RecipeBuffer[recipeno].DotBuf[i].X = 0;
      RecipeBuffer[recipeno].DotBuf[i].Y = 0;
      RecipeBuffer[recipeno].DotBuf[i].Z = 0;
      RecipeBuffer[recipeno].DotBuf[i].Intensity = 0;
      RecipeBuffer[recipeno].DotBuf[i].Recipe = "NA";
      RecipeBuffer[recipeno].DotBuf[i].Row = 32;
      RecipeBuffer[recipeno].DotBuf[i].Col = 32;

   }
   sgDot->RowCount = dottno + 2;
   // 重新顯示Grid
   for(int i=1 ; i<=dottno ; i++) {

      // 2019 12 13 - chc 加入編號
      sgDot->Cells[0][i] = IntToStr(i);

      sgDot->Cells[1][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].X);
      sgDot->Cells[2][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].Y);
      sgDot->Cells[3][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].Z);
      msg.sprintf("%.2f",RecipeBuffer[recipeno].DotBuf[i].Intensity);
      sgDot->Cells[4][i] = msg;
      sgDot->Cells[5][i] = RecipeBuffer[recipeno].DotBuf[i].Recipe;
      sgDot->Cells[6][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].Row);
      sgDot->Cells[7][i] = IntToStr(RecipeBuffer[recipeno].DotBuf[i].Col);

   }

   // 2019 12 13 - chc 清除最後一Row
   for(int i=0 ; i<8 ; i++)
      sgDot->Cells[i][sgDot->RowCount-1] = "";

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::imPatternClick(TObject *Sender)
{

   pnlPattern->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlPatternClick(TObject *Sender)
{

   pnlPattern->Visible = false;
}
//---------------------------------------------------------------------------
// 2019 7 24 - chc 設定Z Button Status
void __fastcall TMainForm::SetZMoveStatus(bool mode)
{

   btnUp1x->Enabled = mode;
   btnUp5x->Enabled = mode;
   btnUp10x->Enabled = mode;
   btnUp100x->Enabled = mode;
   btnDown1x->Enabled = mode;
   btnDown5x->Enabled = mode;
   btnDown10x->Enabled = mode;
   btnDown100x->Enabled = mode;
   btnBackwardZ1->Enabled = mode;
   btnMoveZ1->Enabled = mode;
}
//---------------------------------------------------------------------------
// 2019 11 18 - chc 也顯示在軸控頁面, 也要切換顯示值
void __fastcall TMainForm::DisplayLensPosition()
{
TLMDEdit *edx,*edy,*edz,*edt,*edzlimit;
int x,y,z,t,zlimit;

   for(int i=0 ; i<6 ; i++) {
      edx = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "X"));
      edy = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "Y"));
      edz = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "Z"));
      edt = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "T"));
      edzlimit = (TLMDEdit *)(MainForm->FindComponent("edLens" + IntToStr(i+1) + "ZLimit"));

      WriteSystemLog(">>DisplayLensPosition() : 1X");
      x = LensPosition[i].X;
      y = LensPosition[i].Y;
      z = LensPosition[i].Z;
      t = LensPosition[i].T;
      zlimit = LensPosition[i].ZLimit;

      edx->Text = IntToStr(x);
      edy->Text = IntToStr(y);
      edz->Text = IntToStr(z);
      edt->Text = IntToStr(t);
      edzlimit->Text = IntToStr(zlimit);
   }
}
//---------------------------------------------------------------------------
// 2019 11 19 - chc 到原點
void __fastcall TMainForm::btnToOriginalClick(TObject *Sender)
{

   btnToOriginalPositionClick(this);
}
//---------------------------------------------------------------------------
// 2019 11 19 - chc 到入料點
void __fastcall TMainForm::btnToInputClick(TObject *Sender)
{

   // 2020 4 21 - chc Log
   WriteSystemLog("btnToLoadPositionClick: btnToInputClick()");

   btnToLoadPositionClick(this);
}
//---------------------------------------------------------------------------
// 2019 11 26 - chc 自動對焦
void __fastcall TMainForm::btnFindFocusClick(TObject *Sender)
{

   btnAutoFocusClick(this);
}
//---------------------------------------------------------------------------
// 2019 11 28 - chc 真空Toggle
void __fastcall TMainForm::btnVacuumClick(TObject *Sender)
{

   btnVacuum->Enabled = false;
   // 8"
   pnlStageVacuumClick(this);

   // 2021 7 17 - chc 12"同步
   if(pnlStageVacuum->Color == clLime && pnlStageVacuum1->Color != clLime)
      pnlStageVacuum1Click(this);
   else if(pnlStageVacuum->Color != clLime && pnlStageVacuum1->Color == clLime)
      pnlStageVacuum1Click(this);

   btnVacuum->Enabled = true;
}
//---------------------------------------------------------------------------
// 2019 11 29 - chc Save Pattern File
void __fastcall TMainForm::btnSavePatternClick(TObject *Sender)
{
AnsiString filename,path,msg,name;
int left,top,width,height,ccdno,no,areano;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   ccdno = 0;
   areano = edAreaNo->Text.ToInt();

   // 2019 12 11 - chc 量測點: 若未指定框, 直接設為中心1/5 - 4/5
   bool boolset = false;
   if(rgMatchSource->ItemIndex == 3) {
      if(shCenter->Visible == false) {
         boolset = true;
         cbStdPattern->Checked = true;
         int x1,y1,w,h;
         w = imCCD->Width;
         h = imCCD->Height;
         x1 = w / 5;
         y1 = h / 5;
         x1 += imCCD->Left;
         y1 += imCCD->Top;
         shCenter->Left = x1;
         shCenter->Top = y1;
         shCenter->Width = (w*3) / 5;
         shCenter->Height = (h*3) / 5;
         cbStdPatternClick(this);
      }
   }

   if(shCenter->Visible == true) {
      left = shCenter->Left;
      top = shCenter->Top;
      width = shCenter->Width;
      height = shCenter->Height;
      msg.sprintf("Save: X,Y,W,H-CX,CY-L,T=%d,%d,%d,%d-%d,%d-%d,%d",left,top,width,height,LaserCenterX,LaserCenterY,imCCD->Left,imCCD->Top);
      WriteSystemLog(msg);
      left -= imCCD->Left;
      top -= imCCD->Top;
      left += LaserCenterX;
      top += LaserCenterY;
      PatternROI.Detach();
      // 灰階

      // 2019 12 11 - chc for test
      if(boolForTest == false) {
         PatternROI.Attach(&scA1300ImageAry[ccdno]);
         PatternROI.SetPlacement(left,top,width,height);
      }

      // By Recipe: combRecipe->Text
      no = combRecipe->ItemIndex;
      if(no < 0) {
         no = 0;
         combRecipe->ItemIndex = 0;
      }

      // 2021 5 9 - chc 若Path尚未建立, 要自動產生
      path = RecipeDirectory + "\\" + RecipeBuffer[no].Name;
      if(!DirectoryExists(path))
         mkdir(path.c_str());

      path = RecipeDirectory + "\\" + RecipeBuffer[no].Name + "\\";
      // 區域
      if(rgMatchSource->ItemIndex == 0) {
         filename = RecipeBuffer[no].Name + "-A" + IntToStr(areano) + ".bmp";
         name = "區域" + IntToStr(areano);
         boolset = true;
      }
      // 基1
      else if(rgMatchSource->ItemIndex == 1) {
         filename = RecipeBuffer[no].Name + "-B1.bmp";
         name = "基準1";
         boolset = true;
      }
      // 基2
      else if(rgMatchSource->ItemIndex == 2) {
         filename = RecipeBuffer[no].Name + "-B2.bmp";
         name = "基準2";
         boolset = true;
      }
      // 量測
      else if(rgMatchSource->ItemIndex == 3) {
         int mno;
         mno = edDotNo->Text.ToInt();
         filename = RecipeBuffer[no].Name + "-M" + IntToStr(mno) + ".bmp";
         name = "量測" + IntToStr(mno);
      }

      // 2019 12 3 - chc 詢問是否存檔?
      if(Application->MessageBox(("確認儲存[" + name + "]的標準影像? ").c_str(), "標準影像檔儲存作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }

      // 2019 12 11 - chc for test
      if(boolForTest == false)
         PatternROI.Save((path+filename).c_str(),E_FILE_FORMAT_GRAY_LEVEL_BMP);

      pnlSystemMessage->Caption = filename + " 存檔完成.";
      WriteSystemLog("Save Pattern: " + path + filename);

      // 2019 12 11 - chc 直接設定
      // 區域
      if(rgMatchSource->ItemIndex == 0) {
         btnAreaSetClick(this);
      }
      // 基1
      else if(rgMatchSource->ItemIndex == 1) {
         btnBase1SetClick(this);
      }
      // 基2
      else if(rgMatchSource->ItemIndex == 2) {
         btnBase2SetClick(this);
      }

      // 2019 12 11 - chc 取消顯示
      if(boolset == true)
         cbStdPattern->Checked = false;
      if(rgMatchSource->ItemIndex == 3) {
         if(comboPattern->Items->IndexOf(filename) == -1 && filename != "") {
            comboPattern->Items->Append(filename);
         }
      }

   }
}
//---------------------------------------------------------------------------
// 2019 12 3 - chc 也取消顯示
void __fastcall TMainForm::DisVisibleLensData(int lensno)
{
TLMDEdit *edx,*edy,*edz,*edt,*edzlimit;
TLMDButton *buttonset,*buttonto,*buttonzlimitset;
TPanel *pnllensled,*pnllensposition;

   edx = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "X"));
   edy = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "Y"));
   edz = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "Z"));
   edt = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "T"));
   edzlimit = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "ZLimit"));
   buttonset = (TLMDButton*)(FindComponent("btnSetLens" + IntToStr(lensno) + "Position"));
   buttonto = (TLMDButton*)(FindComponent("btnToLens" + IntToStr(lensno) + "Position"));
   buttonzlimitset = (TLMDButton*)(FindComponent("btnSetLens" + IntToStr(lensno) + "ZLimit"));
   pnllensled = (TPanel*)(FindComponent("pnlLens" + IntToStr(lensno) + "LED"));
   pnllensposition = (TPanel*)(FindComponent("pnlToLens" + IntToStr(lensno) + "Position"));

   edx->Visible = false;
   edy->Visible = false;
   edz->Visible = false;
   edt->Visible = false;
   edzlimit->Visible = false;
   buttonset->Visible = false;
   buttonto->Visible = false;
   buttonzlimitset->Visible = false;
   pnllensled->Visible = false;
   pnllensposition->Visible = false;
}
//---------------------------------------------------------------------------
// 2019 12 3 - chc Z移動
void __fastcall TMainForm::btnMoveZ1Click(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Z_AXIS;

   // 2021 6 11 - chc 方向相反
   //btnBackwardClick(this);
   btnMoveClick(this);
}
//---------------------------------------------------------------------------
// 2019 12 3 - chc Z移動
void __fastcall TMainForm::btnMoveZ1MouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Z_AXIS;
   //btnMoveMouseDown(this,Button, Shift, X, Y);

   // 2021 6 11 - chc 方向相反
   //btnBackwardMouseDown(this,Button, Shift, X, Y);
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2019 12 3 - chc Z移動
void __fastcall TMainForm::btnMoveZ1MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2021 4 21 - chc 立即停止
   pnlAlarmMessage->Caption = "Z軸停止.";
   pnlAlarmMessage->Refresh();
   StopOneAxis(Z_AXIS);
}
//---------------------------------------------------------------------------
// 2019 12 3 - chc Z移動
void __fastcall TMainForm::btnBackwardZ1Click(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Z_AXIS;

   // 2021 6 11 - chc 方向相反
   //btnMoveClick(this);
   btnBackwardClick(this);

}
//---------------------------------------------------------------------------
// 2019 12 3 - chc Z移動
void __fastcall TMainForm::btnBackwardZ1MouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Z_AXIS;
   //btnBackwardMouseDown(this,Button, Shift, X, Y);

   // 2021 6 11 - chc 方向相反
   //btnMoveMouseDown(this,Button, Shift, X, Y);
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2019 12 3 - chc Z移動
void __fastcall TMainForm::btnBackwardZ1MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2021 4 21 - chc 立即停止
   pnlAlarmMessage->Caption = "Z軸停止.";
   pnlAlarmMessage->Refresh();
   StopOneAxis(Z_AXIS);

}
//---------------------------------------------------------------------------
// 2019 12 3 - chc Offset & Alignment
bool __fastcall TMainForm::FindOffsetAlignment()
{
int bx1,by1,bz1,bx2,by2,bz2;
int nbx1,nby1,nbx2,nby2,offsetx,offsety;
double fcmd,theta,ntheta,fdx,fdy,value,degree,ndegree;
AnsiString msg;

   // Base1
   bx1 = pnlBase1X->Caption.ToInt();
   by1 = pnlBase1Y->Caption.ToInt();
   bz1 = pnlBase1Z->Caption.ToInt();
   // Base2
   bx2 = pnlBase2X->Caption.ToInt();
   by2 = pnlBase2Y->Caption.ToInt();
   bz2 = pnlBase2Z->Caption.ToInt();
   // 移動Base1
   rgMatchSource->ItemIndex = 1;
   pnlSystemRun->Caption = "基準點1移動...";
   btnBase1ToClick(this);
   if(pnlToBase1Position->Color != clLime) {
      pnlSystemMessage->Caption = "基準點1移動失敗!";
      return false;
   }
   // AutoFocus Base1
   if(cbAutoFocus->Checked == true) {
      DelayTime(500);
      pnlSystemRun->Caption = "基準點1Focus...";
      btnAutoFocusClick(this);
   }
   DelayTime(500);
   // Match
match1:
   pnlSystemRun->Caption = "基準點1定位...";
   btnAutoMatchClick(this);
   shMarkMatch->Visible = true;
   shMarkMatch->Refresh();

   // 2019 12 18 - chc 對位失敗!
   if(pnlNCC->Color != clLime) {
      pnlSystemRun->Caption = "基準點1對位異常!";
      pnlMatchError->Visible = true;
      pnlMatchErrorMsg->Caption = "Base1 Alignment error! Redesignate the position?";
      MatchProcess = 0;
      pcSystem->Enabled = false;

      // 2021 7 19 - chc 改用runabort
      WriteSystemLog("關閉作業頁面7. 基準點1定位");

      while(1) {
         if(MatchProcess == 1) {
            pcSystem->Enabled = true;
            return false;
         }
         if(MatchProcess == 2) {
            pcSystem->Enabled = true;
            goto match1;
         }
         Sleep(10);
         Application->ProcessMessages();
      }
   }

   // Position Base1
   GetPosition(X_AXIS, &fcmd);
   nbx1 = fcmd;
   GetPosition(Y_AXIS, &fcmd);
   nby1 = fcmd;

   // 2019 12 18 - chc 校正
   int ox2,oy2,nx2,ny2;
   ox2 = pnlBase2X->Caption.ToInt();
   oy2 = pnlBase2Y->Caption.ToInt();
   nx2 = ox2 + (nbx1 - bx1);
   ny2 = oy2 + (nby1 - by1);
   pnlBase2X->Caption = IntToStr(nx2);
   pnlBase2Y->Caption = IntToStr(ny2);

   // Delay
   DelayTime(2000);
   pnlPattern->Visible = false;
   shMarkMatch->Visible = false;
   // 移動Base2
   rgMatchSource->ItemIndex = 2;
   pnlSystemRun->Caption = "基準點2移動...";
   btnBase2ToClick(this);
   if(pnlToBase2Position->Color != clLime) {
      pnlSystemMessage->Caption = "基準點2移動失敗!";
      return false;
   }
   // AutoFocus Base2
   if(cbAutoFocus->Checked == true) {
      DelayTime(500);
      pnlSystemRun->Caption = "基準點2Focus...";
      btnAutoFocusClick(this);
   }
   DelayTime(500);

   // 2019 12 18 - chc 校正還原
   pnlBase2X->Caption = IntToStr(ox2);
   pnlBase2Y->Caption = IntToStr(oy2);

   // Match
match2:
   pnlSystemRun->Caption = "基準點2定位...";
   btnAutoMatchClick(this);
   shMarkMatch->Visible = true;
   shMarkMatch->Refresh();

   // 2019 12 18 - chc 對位失敗!
   if(pnlNCC->Color != clLime) {
      pnlSystemRun->Caption = "基準點2對位異常!";
      pnlMatchError->Visible = true;
      pnlMatchErrorMsg->Caption = "Base2 Alignment error! Redesignate the position?";
      MatchProcess = 0;
      pcSystem->Enabled = false;

      // 2021 7 19 - chc 改用runabort
      WriteSystemLog("關閉作業頁面8. 基準點2定位");

      while(1) {
         if(MatchProcess == 1) {
            pcSystem->Enabled = true;
            return false;
         }
         if(MatchProcess == 2) {
            pcSystem->Enabled = true;
            goto match2;
         }
         Sleep(10);
         Application->ProcessMessages();
      }
   }

   // Position Base2
   GetPosition(X_AXIS, &fcmd);
   nbx2 = fcmd;
   GetPosition(Y_AXIS, &fcmd);
   nby2 = fcmd;
   // Offset
   offsetx = nbx1 - bx1;
   offsety = nby1 - by1;
   OffsetXBase = offsetx;
   OffsetYBase = offsety;
   msg.sprintf("%.1f",(double)offsetx / 10.0);
   pnlOffsetXBase->Caption = msg;
   msg.sprintf("%.1f",(double)offsety / 10.0);
   pnlOffsetYBase->Caption = msg;
   // Alignment
   fdx = bx2 - bx1;
   fdy = by2 - by1;
   if(fdx == 0 || fdy == 0)
      degree = 0;
   else {
      value = fdx / fdy;
      // radian
      degree = atan(value);
      // degree
      degree = (360 * degree) / (2*M_PI);
   }
   fdx = nbx2 - nbx1;
   fdy = nby2 - nby1;
   if(fdx == 0 || fdy == 0)
      ndegree = 0;
   else {
      value = fdx / fdy;
      // radian
      ndegree = atan(value);
      // degree
      ndegree = (360 * ndegree) / (2*M_PI);
   }
   msg.sprintf("%.4f",ndegree - degree);
   pnlRotate->Caption = msg;
   // Delay
   DelayTime(2000);
   pnlPattern->Visible = false;
   shMarkMatch->Visible = false;

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::DelayTime(no)
{
int cnt;

   cnt = no / 100;
   for(int i=0 ; i<cnt ; i++) {
      Sleep(100);
      Application->ProcessMessages();
   }
}
//---------------------------------------------------------------------------
// 2019 12 5 - chc TXT設定原點
void __fastcall TMainForm::btnkmfPositionClick(TObject *Sender)
{

   // 2020 1 21 - chc for test
   if(boolForTest == false)

      SetTXTPosition();

   // 2020 1 21 - chc 強制為true
   cbkmfDirection->Checked = true;

   // 決定方向
   if(cbkmfDirection->Checked == true) {
      int std = 4000000;
      int vx,vy;
      vx = edkmfX->Text.ToInt();
      vy = edkmfY->Text.ToInt();

      if(vx < std && vy < std)
         rgkmfDirection->ItemIndex = 0;
      else if(vx < std && vy > std)
         rgkmfDirection->ItemIndex = 1;
      else if(vx > std && vy < std)
         rgkmfDirection->ItemIndex = 2;
      else if(vx > std && vy > std)
         rgkmfDirection->ItemIndex = 3;

   }

}
//---------------------------------------------------------------------------
// 2019 12 5 - chc TXT到原點
void __fastcall TMainForm::btnTokmfPositionClick(TObject *Sender)
{

   pnlToTXTPosition->Color = clSilver;
   MotionStatus(false);

   pnlStartMessage->Caption = "Moving to (0,0)...";
   pnlStartMessage->Visible = true;

   ToTXTPosition();
err:
   pnlStartMessage->Visible = false;
   MotionStatus(true);
}
//---------------------------------------------------------------------------
// 2019 12 5 - chc Read kmf
/*
M48
T01C.0100
T02C.0500
%
M71
G93X0.0000Y0.0000
T01
X0.0000Y0.0000
X398.7900Y478.0000
T02
X9.9168Y9.8312
X15.2320Y11.6486
X105.8968Y109.5812
X111.2120Y111.3986
X285.7268Y109.5812
X291.0420Y111.3986
X381.7068Y9.8312
X387.0220Y11.6486
X9.9168Y477.7812
X15.2320Y479.5986
X105.8968Y378.0312
X111.2120Y379.8486
X212.2268Y259.8312
X217.5420Y261.6486
X285.7268Y378.0312
X291.0420Y379.8486
X381.7068Y477.7812
X387.0220Y479.5986
M30
*/
// M: M48/M71/M30
// T: T01/T02
// %
// G: G93
// X
// Y
bool boolLoadkmf = false;

// 2019 12 13 - chc 設定為是否已讀取?
bool boolkmfLoaded = false;

void __fastcall TMainForm::btnReadkmfClick(TObject *Sender)
{
AnsiString filename,str,sx,sy,snx,sny,pointname;
char buf[256],leadcode;
FILE *fp;
int cnt,pos,len,nx,ny,value,vx,vy,pointtype,pointno;
double fvaluex,fx,fy,fnx,fny,fvaluey;

   boolLoadkmf = true;

   sgkmf->RowCount = 2;
   sgkmf->ColCount = 6;
   sgkmf->Cells[KMF_FIELD_INDEX][0]       = "編號";
   sgkmf->Cells[KMF_FIELD_ITEM][0]        = "項目";
   sgkmf->Cells[KMF_FIELD_X][0]           = "X";
   sgkmf->Cells[KMF_FIELD_Y][0]           = "Y";
   sgkmf->Cells[KMF_FIELD_NX][0]          = "nX";
   sgkmf->Cells[KMF_FIELD_NY][0]          = "nY";
   // 寬度
   sgkmf->ColWidths[KMF_FIELD_INDEX]      = 60;
   sgkmf->ColWidths[KMF_FIELD_ITEM]       = 80;
   sgkmf->ColWidths[KMF_FIELD_X]          = 90;
   sgkmf->ColWidths[KMF_FIELD_Y]          = 90;
   sgkmf->ColWidths[KMF_FIELD_NX]         = 90;
   sgkmf->ColWidths[KMF_FIELD_NY]         = 90;
   // 清除最後一Row
   sgkmf->Cells[KMF_FIELD_INDEX][sgkmf->RowCount-1] = "";
   sgkmf->Cells[KMF_FIELD_ITEM][sgkmf->RowCount-1] = "";
   sgkmf->Cells[KMF_FIELD_X][sgkmf->RowCount-1] = "";
   sgkmf->Cells[KMF_FIELD_Y][sgkmf->RowCount-1] = "";
   sgkmf->Cells[KMF_FIELD_NX][sgkmf->RowCount-1] = "";
   sgkmf->Cells[KMF_FIELD_NY][sgkmf->RowCount-1] = "";

   pnlReadkmf->Color = clSilver;
   filename = edkmfPath->Text + "\\" + edkmfFilename->Text;
   if(!FileExists(filename)) {
      pnlReadkmf->Color = clRed;
      boolLoadkmf = false;
      return;
   }
   pointname = "點";
   pointtype = 0;
   pointno = 1;
   pnlkmfTNo->Caption = "0";
   // 讀取kmf
   if((fp = fopen(filename.c_str(),"rt")) != NULL) {
      cnt = 0;
      while(fgets(buf, 200, fp) != NULL) {
         cnt++;
         leadcode = buf[0];
         // M: M48/M71/M30
         // T: T01/T02
         // %
         // G: G93
         // X
         switch(leadcode) {
            case 'M':
               break;
            case '%':
               break;
            case 'G':
               break;
            case 'T':
               str = buf;
               len = str.Length();
               str = str.SubString(1,len-1);
               if(str == "T01") {
                  pointtype = 1;
                  pointname = "基準1";
               }
               if(str == "T02") {
                  pointtype = 3;
                  pointname = "點";
               }
               break;
            case 'X':
               // X387.0220Y479.5986
               // 12345678901234567890
               str = buf;
               len = str.Length();
               pos = str.Pos("Y");
               if(pos > 0) {
                  sx = str.SubString(2,pos-2);
                  sy = str.SubString(pos+1,len-pos-1);
                  fx = sx.ToDouble();
                  fy = sy.ToDouble();

                  // 2019 12 6 - chc 轉正
                  // 2020 1 21 - chc 有正負值, 不必轉正
                  //if(fx < 0)
                  //   fx = 0 - fx;
                  //if(fy < 0)
                  //   fy = 0 - fy;

                  // nx
                  value = edkmfX->Text.ToInt();
                  // mm
                  if(rgkmfUnit->ItemIndex == 0)
                     fvaluex = (double)(value  * X_RESOLUTION) / 1000.0;
                  // cm
                  else if(rgkmfUnit->ItemIndex == 1)
                     fvaluex = (double)(value  * X_RESOLUTION) / 10000.0;
                  // um
                  else if(rgkmfUnit->ItemIndex == 2)
                     fvaluex = (double)(value  * X_RESOLUTION);
                  fnx = fx + fvaluex;
                  snx.sprintf("%.4f",fnx);

                  // ny
                  value = edkmfY->Text.ToInt();
                  // mm
                  if(rgkmfUnit->ItemIndex == 0)
                     fvaluey = (double)(value  * Y_RESOLUTION) / 1000.0;
                  // cm
                  else if(rgkmfUnit->ItemIndex == 1)
                     fvaluey = (double)(value  * Y_RESOLUTION) / 10000.0;
                  // um
                  else if(rgkmfUnit->ItemIndex == 2)
                     fvaluey = (double)(value  * Y_RESOLUTION);
                  fny = fy + fvaluey;
                  sny.sprintf("%.4f",fny);

                  // 方向
                  // 左上
                  if(rgkmfDirection->ItemIndex == 0) {
                  }
                  // 左下
                  else if(rgkmfDirection->ItemIndex == 1) {
                     fny = fvaluey - fy;
                     sny.sprintf("%.4f",fny);
                  }
                  // 右上
                  else if(rgkmfDirection->ItemIndex == 2) {
                     fnx = fvaluex - fx;
                     snx.sprintf("%.4f",fnx);
                  }
                  // 右下
                  else if(rgkmfDirection->ItemIndex == 3) {
                     fnx = fvaluex - fx;
                     snx.sprintf("%.4f",fnx);
                     fny = fvaluey - fy;
                     sny.sprintf("%.4f",fny);
                  }

                  sgkmf->Cells[KMF_FIELD_INDEX][sgkmf->RowCount-1] = sgkmf->RowCount-1;
                  if(pointtype == 3) {
                     pointname = "點" + IntToStr(pointno);
                     pnlkmfTNo->Caption = IntToStr(pointno);
                     pointno++;
                  }
                  sgkmf->Cells[KMF_FIELD_ITEM][sgkmf->RowCount-1]  = pointname;
                  sgkmf->Cells[KMF_FIELD_X][sgkmf->RowCount-1]     = sx;
                  sgkmf->Cells[KMF_FIELD_Y][sgkmf->RowCount-1]     = sy;
                  sgkmf->Cells[KMF_FIELD_NX][sgkmf->RowCount-1]    = snx;
                  sgkmf->Cells[KMF_FIELD_NY][sgkmf->RowCount-1]    = sny;
                  sgkmf->RowCount++;
                  // 清除最後一Row
                  sgkmf->Cells[KMF_FIELD_INDEX][sgkmf->RowCount-1] = "";
                  sgkmf->Cells[KMF_FIELD_ITEM][sgkmf->RowCount-1]  = "";
                  sgkmf->Cells[KMF_FIELD_X][sgkmf->RowCount-1]     = "";
                  sgkmf->Cells[KMF_FIELD_Y][sgkmf->RowCount-1]     = "";
                  sgkmf->Cells[KMF_FIELD_NX][sgkmf->RowCount-1]    = "";
                  sgkmf->Cells[KMF_FIELD_NY][sgkmf->RowCount-1]    = "";
                  // 指到最後一筆
                  sgkmf->Row = sgkmf->RowCount-1;
                  if(pointtype == 1) {
                     pointtype = 2;
                     pointname = "基準2";
                  }

               }
               break;
         }
      }
      fclose(fp);
   }

   pnlReadkmf->Color = clLime;
   boolLoadkmf = false;

   // 2019 12 13 - chc 設定為是否已讀取?
   boolkmfLoaded = true;

}
//---------------------------------------------------------------------------
// 2019 12 5 - chc Browse kmf file
void __fastcall TMainForm::pnlkmfFileClick(TObject *Sender)
{

   opkmfFile->InitialDir = edkmfPath->Text;
   if(opkmfFile->Execute()) {
      edkmfFilename->Text = ExtractFileName(opkmfFile->FileName);
   }
}
//---------------------------------------------------------------------------
// 2019 12 5 - chc 點選測試移動
void __fastcall TMainForm::sgkmfClick(TObject *Sender)
{
int recno;
AnsiString sx,sy;
double fx,fy;

   // 讀取中
   if(boolLoadkmf == true)
      return;

   if(sgkmf->RowCount < 2) {
      pnlSystemMessage->Caption = "座標: No Data Matched!";
      return;
   }
   recno = sgkmf->Row;
   if(recno > 0 && recno < sgkmf->RowCount) {
      pnlkmfNo->Caption = IntToStr(recno);
      pnlkmfTypeName->Caption = sgkmf->Cells[1][recno];
      sx = sgkmf->Cells[4][recno];
      sy = sgkmf->Cells[5][recno];
      fx = sx.ToDouble();
      fy = sy.ToDouble();
      // mm => um
      if(rgkmfUnit->ItemIndex == 0) {
         fx = fx * 1000.0;
         fy = fy * 1000.0;
         // um => pulse
         fx /= X_RESOLUTION;
         fy /= Y_RESOLUTION;
      }
      // cm => um
      else if(rgkmfUnit->ItemIndex == 1) {
         fx = fx * 10000.0;
         fy = fy * 10000.0;
         // um => pulse
         fx /= X_RESOLUTION;
         fy /= Y_RESOLUTION;
      }
      // um => um
      else if(rgkmfUnit->ItemIndex == 2) {
         // um => pulse
         fx /= X_RESOLUTION;
         fy /= Y_RESOLUTION;
      }
      pnlkmfX->Caption = IntToStr((int)fx);
      pnlkmfY->Caption = IntToStr((int)fy);
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnTokmfClick(TObject *Sender)
{

   pnlTokmf->Color = clSilver;
   MotionStatus(false);

   pnlStartMessage->Caption = "Moving to ..." + pnlkmfNo->Caption;
   pnlStartMessage->Visible = true;

   TokmfPosition();
err:
   pnlStartMessage->Visible = false;
   MotionStatus(true);

   pnlTokmf->Color = clLime;
}
//---------------------------------------------------------------------------
// 2019 12 7 - chc 複製資料夾: pnlRecipeTypeRecipe to combRecipe->Text
void __fastcall TMainForm::CopyRecipeFile()
{
AnsiString spath,dpath,orecipename,nrecipename,scode,scode1;
TSearchRec sr;
int iAttributes = 0;
int rno = 0;
int len;

// 2022 1 3 - chc 大於9個量測點
int pos,apos,mpos,acnt,mcnt;
AnsiString tbuf;

   orecipename = pnlRecipeTypeRecipe->Caption;
   nrecipename = combRecipe->Text;
   spath = RecipeDirectory + "\\" + pnlRecipeTypeRecipe->Caption;
   dpath = RecipeDirectory + "\\" + combRecipe->Text;
   if(!DirectoryExists(spath)) {
      pnlSystemMessage->Caption = "舊Recipe資料夾: " + spath + "不存在, 無法產生新Recipe!";
      return;
   }
   if(!DirectoryExists(dpath))
      mkdir(dpath.c_str());
   if(!DirectoryExists(dpath)) {
      pnlSystemMessage->Caption = "新Recipe資料夾: " + dpath + "不存在, 無法產生新Recipe!";
      return;
   }
   // Copy files
   AnsiString sfname,dfname;
   //faReadOnly	  $00000001	  Read-only files
   //faHidden	  $00000002	  Hidden files
   //faSysFile	  $00000004	  System files
   //faVolumeID	  $00000008	  Volume ID files
   //faDirectory  $00000010	  Directory files
   //faArchive	  $00000020	  Archive files
   //faAnyFile	  $0000003F	  Any file
   sfname = spath + "\\*.*";
   iAttributes |= faArchive;
   if(FindFirst(sfname, iAttributes, sr) == 0) {
      do {
         if((sr.Attr & iAttributes) == sr.Attr) {                               // 檔名在sr.Name
            sfname = spath + "\\" + sr.Name;
            dfname = dpath + "\\" + sr.Name;
            len = sr.Name.Length();
            if(len > 5) {
               scode1 = sr.Name.SubString(1,3);

               // 2022 1 3 - chc 大於9個量測點
               //scode = sr.Name.SubString(len-5,1);
               //if(scode == "A" || scode == "M" || scode == "B") {
               //   dfname = dpath + "\\" + nrecipename + "-" + sr.Name.SubString(len-5,6);
               //   CopyFile(sfname.c_str(),dfname.c_str(),false);
               //}
               pos = sr.Name.Pos(".bmp");
               if(pos > 0) {
                  // Base
                  tbuf = sr.Name;
                  acnt = 0;
                  // 1211-A1-A10.bmp
                  // 12345678901234567890
                  while(1) {
                     apos = tbuf.Pos("-B");
                     if(apos > 0) {
                        tbuf = tbuf.Delete(1,pos+1);
                        acnt += (apos+1);
                     }
                     else
                        break;
                  }
                  // 有-A
                  // acnt = 7
                  // 1211-1-A10.bmp
                  // 123456789012345
                  // len = 14
                  if(acnt > 0) {
                     scode = "B";
                     dfname = dpath + "\\" + nrecipename + "-" + sr.Name.SubString(acnt,len-acnt+1);
                  }
                  // Area
                  tbuf = sr.Name;
                  acnt = 0;
                  // 1211-A1-A10.bmp
                  // 12345678901234567890
                  while(1) {
                     apos = tbuf.Pos("-A");
                     if(apos > 0) {
                        tbuf = tbuf.Delete(1,pos+1);
                        acnt += (apos+1);
                     }
                     else
                        break;
                  }
                  // 有-A
                  // acnt = 7
                  // 1211-1-A10.bmp
                  // 123456789012345
                  // len = 14
                  if(acnt > 0) {
                     scode = "A";
                     dfname = dpath + "\\" + nrecipename + "-" + sr.Name.SubString(acnt,len-acnt+1);
                  }
                  // Dot
                  tbuf = sr.Name;
                  acnt = 0;
                  // 1211-A1-A10.bmp
                  // 12345678901234567890
                  while(1) {
                     apos = tbuf.Pos("-M");
                     if(apos > 0) {
                        tbuf = tbuf.Delete(1,pos+1);
                        acnt += (apos+1);
                     }
                     else
                        break;
                  }
                  // 有-A
                  // acnt = 7
                  // 1211-1-A10.bmp
                  // 123456789012345
                  // len = 14
                  if(acnt > 0) {
                     scode = "M";
                     dfname = dpath + "\\" + nrecipename + "-" + sr.Name.SubString(acnt,len-acnt+1);
                  }
               }
               if(scode == "A" || scode == "M" || scode == "B") {
                  CopyFile(sfname.c_str(),dfname.c_str(),false);
               }

               // 2021 5 9 - chc LEDParameter.ini
               else if(scode1 == "LED") {
                  dfname = dpath + "\\" + sr.Name;
                  CopyFile(sfname.c_str(),dfname.c_str(),false);
               }
            }
         }
      } while (FindNext(sr) == 0);
   }
   FindClose(sr);

}
//---------------------------------------------------------------------------
// 2019 12 9 - chc 自動取得VisionRecipe List
void __fastcall TMainForm::comboOlympusVisionName1Click(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   if(comboOlympusVisionName1->Items->Count == 0) {
   }
}
//---------------------------------------------------------------------------
// 2019 12 9 - chc 自動取得VisionRecipe List
void __fastcall TMainForm::comboOlympusVisionName1DropDown(TObject *Sender)
{

   if(comboOlympusVisionName1->Items->Count == 0) {
   }
}
//---------------------------------------------------------------------------
// 2019 12 9 - chc 加入: 儲存座標檔參數: 路徑, 檔名, 原點座標, 單位, 方向.
//      #define KMF_PATH                  "kmf Path"
//      #define KMF_FILENAME              "kmf Filename"
//      #define KMF_X                     "kmf X"
//      #define KMF_Y                     "kmf Y"
//      #define KMF_UNIT                  "kmf Unit"
//      #define KMF_DIRECTION             "kmf Direction"
//      #define KMF_BOOL_DIRECTION        "kmf Bool Direction"
//      AnsiString kmfPath,kmfFilename;
//      int kmfX,kmfY,kmfUnit,kmfDirection;
//      bool boolkmfDirection;
void __fastcall TMainForm::btnSavekmfParameterClick(TObject *Sender)
{
int no;
AnsiString str;

   no = combRecipe->ItemIndex;
   if(no < 0) {
      no = 0;
      combRecipe->ItemIndex = 0;
   }
   RecipeBuffer[no].Name                = combRecipe->Text;

   // Write .ini
   TIniFile *pSystemFile;
   AnsiString fname;
   // ini檔名與目錄: BiSSMotion.ini
   fname = RecipeDirectory + "\\" + RecipeBuffer[no].Name + ".ini";
   pSystemFile = new TIniFile(fname);

   RecipeBuffer[no].kmfPath = edkmfPath->Text;
   pSystemFile->WriteString(RECIPE_INFORMATION_SECTION,KMF_PATH                 ,RecipeBuffer[no].kmfPath);
   RecipeBuffer[no].kmfFilename = edkmfFilename->Text;
   pSystemFile->WriteString(RECIPE_INFORMATION_SECTION,KMF_FILENAME             ,RecipeBuffer[no].kmfFilename);
   RecipeBuffer[no].kmfX = edkmfX->Text.ToInt();
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,KMF_X                   ,RecipeBuffer[no].kmfX);
   RecipeBuffer[no].kmfY = edkmfY->Text.ToInt();
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,KMF_Y                   ,RecipeBuffer[no].kmfY);
   RecipeBuffer[no].kmfUnit = rgkmfUnit->ItemIndex;
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,KMF_UNIT                ,RecipeBuffer[no].kmfUnit);
   RecipeBuffer[no].kmfDirection = rgkmfDirection->ItemIndex;
   pSystemFile->WriteInteger(RECIPE_INFORMATION_SECTION,KMF_DIRECTION           ,RecipeBuffer[no].kmfDirection);

   // 2020 1 21 - chc 強制為true
   cbkmfDirection->Checked = true;

   RecipeBuffer[no].boolkmfDirection = cbkmfDirection->Checked;
   pSystemFile->WriteBool(RECIPE_INFORMATION_SECTION,KMF_BOOL_DIRECTION         ,RecipeBuffer[no].boolkmfDirection);

   delete pSystemFile;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnReadkmfToPointClick(TObject *Sender)
{
int tno,x,y;
double ratiox,ratioy;      

   // mm
   if(rgkmfUnit->ItemIndex == 0)
      ratiox = 1000;
   // cm
   else if(rgkmfUnit->ItemIndex == 1)
      ratiox = 10000;
   // um
   else if(rgkmfUnit->ItemIndex == 2)
      ratiox = 1;
   ratioy = ratiox;
   ratiox /= X_RESOLUTION;
   ratioy /= Y_RESOLUTION;

   // 2019 12 13 - chc 若已讀過就不再重讀一次
   if(boolkmfLoaded == false)

      btnReadkmfClick(this);

   // 將kmf轉成量測點位: 基準1, 基準2, 量測點
   // 總量測點數
   tno = sgkmf->RowCount - 4;
   // 基準點
   pnlBase1X->Caption = IntToStr(int(sgkmf->Cells[KMF_FIELD_NX][1].ToDouble() * ratiox));
   pnlBase1Y->Caption = IntToStr(int(sgkmf->Cells[KMF_FIELD_NY][1].ToDouble() * ratioy));
   pnlBase2X->Caption = IntToStr(int(sgkmf->Cells[KMF_FIELD_NX][2].ToDouble() * ratiox));
   pnlBase2Y->Caption = IntToStr(int(sgkmf->Cells[KMF_FIELD_NY][2].ToDouble() * ratioy));

   // 2019 12 13 - chc 要設定Motion Z, 用原點Z
   pnlBase1Z->Caption = edCCDZ->Text;
   pnlBase2Z->Caption = edCCDZ->Text;

   // 設定區域點位數
   edAreaNo->Text = "1";
   edAreaTNo->Text = "1";
   // 設定量測點位數
   edDotNo->Text = "1";
   edDotTNo->Text = IntToStr(tno);
   // Clear區域
   ClearAreaArray();
   // Clear點位
   ClearDotArray();
   // 設定Area1
   sgArea->Cells[0][sgArea->RowCount-1] = IntToStr(sgArea->RowCount-1);
   sgArea->Cells[1][sgArea->RowCount-1] = IntToStr(int(sgkmf->Cells[KMF_FIELD_NX][1].ToDouble() * ratiox));
   sgArea->Cells[2][sgArea->RowCount-1] = IntToStr(int(sgkmf->Cells[KMF_FIELD_NY][1].ToDouble() * ratioy));

   // 2019 12 13 - chc 要設定Motion Z, 用原點Z
   sgArea->Cells[3][sgArea->RowCount-1] = edCCDZ->Text;

   sgArea->RowCount++;
   // 清除最後一Row
   for(int i=0 ; i<4 ; i++)
      sgArea->Cells[i][sgArea->RowCount-1] = "";
   // 設定各量測點位的Std Pattern
   //sgDot->Cells[0][0]        = "No";
   //sgDot->Cells[1][0]        = "X(um)";
   //sgDot->Cells[2][0]        = "Y(um)";
   //sgDot->Cells[3][0]        = "Z(um)";
   //sgDot->Cells[4][0]        = "Intensity";
   //sgDot->Cells[5][0]        = "Recipe";
   //sgDot->Cells[6][0]        = "Row";
   //sgDot->Cells[7][0]        = "Col";
   for(int i=0 ; i<tno ; i++) {
      x = sgkmf->Cells[KMF_FIELD_NX][i+3].ToDouble() * ratiox;
      y = sgkmf->Cells[KMF_FIELD_NY][i+3].ToDouble() * ratioy;
      sgDot->Cells[0][sgDot->RowCount-1] = IntToStr(sgDot->RowCount-1);
      sgDot->Cells[1][sgDot->RowCount-1] = IntToStr(x);
      sgDot->Cells[2][sgDot->RowCount-1] = IntToStr(y);

      // 2019 12 13 - chc 使用Lens1的BrukerZ: edLens1BrukerZ
      sgDot->Cells[3][sgDot->RowCount-1] = "0";

      sgDot->Cells[4][sgDot->RowCount-1] = "5.0";
      sgDot->Cells[5][sgDot->RowCount-1] = "NA";
      sgDot->Cells[6][sgDot->RowCount-1] = "0";
      sgDot->Cells[7][sgDot->RowCount-1] = "1";
      sgDot->RowCount++;
   }
   // 清除最後一Row
   for(int i=0 ; i<6 ; i++)

      // 2020 1 21 - chc 寫錯
      //sgDot->Cells[i][sgkmf->RowCount-1] = "";
      sgDot->Cells[i][sgDot->RowCount-1] = "";
   //
}
//---------------------------------------------------------------------------
// 2019 12 11 - chc 清除點位數據表
void __fastcall TMainForm::ClearDotArray()
{

   sgDot->RowCount = 2;
   sgDot->ColCount = 8;
   // 清除最後一Row
   for(int i=0 ; i<8 ; i++)
      sgDot->Cells[i][sgDot->RowCount-1] = "";
}
//---------------------------------------------------------------------------
// 2019 12 11 - chc 清除點位數據表
void __fastcall TMainForm::ClearAreaArray()
{

   sgArea->RowCount = 2;
   sgArea->ColCount = 4;
   // 清除最後一Row
   for(int i=0 ; i<4 ; i++)
      sgArea->Cells[i][sgArea->RowCount-1] = "";
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::comboPatternChange(TObject *Sender)
{
AnsiString mfname,recipename;
int stdwidth,stdheight;

   if(pnlPattern->Visible == false)
      pnlPattern->Visible = true;
   recipename = combRecipe->Text;
   mfname = RecipeDirectory + "\\" + recipename + "\\" + comboPattern->Text;
   StdImage.Load(mfname.c_str());
   stdheight = StdImage.GetHeight();
   stdwidth = StdImage.GetWidth();
   imPattern->Picture->Bitmap->Width = stdwidth;
   imPattern->Picture->Bitmap->Height = stdheight;
   imPattern->Width = stdwidth;
   imPattern->Height = stdheight;
   pnlPattern->Width = imPattern->Width + 10;
   pnlPattern->Height = imPattern->Height + 10;
   imPattern->Top = 5;
   imPattern->Left = 5;
   imPattern->Picture->LoadFromFile(mfname);

}
//---------------------------------------------------------------------------
// 2019 12 11 - chc 指定Pattern檔
void __fastcall TMainForm::btnAssignPatternClick(TObject *Sender)
{
AnsiString filename,name,sfname,dfname,recipename;

   if(rgMatchSource->ItemIndex != 3) {
      btnAssignPattern->Font->Color = clRed;
      return;
   }

   int mno;
   mno = edDotNo->Text.ToInt();
   recipename = combRecipe->Text;
   filename = recipename + "-M" + IntToStr(mno) + ".bmp";
      name = "量測" + IntToStr(mno);
   // 詢問是否存檔?
   if(Application->MessageBox(("確認複製[" + name + "]的標準影像? ").c_str(), "標準影像檔儲存作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   sfname = RecipeDirectory + "\\" + recipename + "\\" + comboPattern->Text;
   dfname = RecipeDirectory + "\\" + recipename + "\\" + filename;
   CopyFile(sfname.c_str(),dfname.c_str(),false);
   pnlSystemMessage->Caption = filename + " 存檔完成.";
   WriteSystemLog("Save Pattern: " + dfname);
   btnAssignPattern->Font->Color = clNavy;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::rgMatchSourceChange(TObject *Sender,
      int ButtonIndex)
{

   if(rgMatchSource->ItemIndex == 3)
      btnAssignPattern->Enabled = true;
   else
      btnAssignPattern->Enabled = false;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetkmfClick(TObject *Sender)
{
int no,x,y,cx,cy,value,ox,oy;
double fx,fy,fnx,fny;
AnsiString msg;
double fvaluex,fvaluey;

   no = sgkmf->Row;
   if(no == 0)
      return;
   // nx = x + ox
   // nx = cx, ny = cy
   // x = nx - ox, y = ny - oy
   double fcmd;
   GetPosition(X_AXIS, &fcmd);
   cx = fcmd;
   GetPosition(Y_AXIS, &fcmd);
   cy = fcmd;
   ox = edkmfX->Text.ToInt();
   oy = edkmfY->Text.ToInt();
   x = cx - ox;
   y = cy - oy;
   // mm
   if(rgkmfUnit->ItemIndex == 0) {
      fnx = cx * X_RESOLUTION / 1000.0;
      fny = cx * X_RESOLUTION / 1000.0;
      fx = x * X_RESOLUTION / 1000.0;
      fy = x * X_RESOLUTION / 1000.0;
   }
   // cm
   else if(rgkmfUnit->ItemIndex == 1) {
      fnx = cx * X_RESOLUTION / 10000.0;
      fny = cx * X_RESOLUTION / 10000.0;
      fx = x * X_RESOLUTION / 10000.0;
      fy = x * X_RESOLUTION / 10000.0;
   }
   // um
   else if(rgkmfUnit->ItemIndex == 2) {
      fnx = cx * X_RESOLUTION;
      fny = cx * X_RESOLUTION;
      fx = x * X_RESOLUTION;
      fy = x * X_RESOLUTION;
   }
   msg.sprintf("%.4f",fx);
   sgkmf->Cells[KMF_FIELD_X][no] = msg;
   msg.sprintf("%.4f",fy);
   sgkmf->Cells[KMF_FIELD_Y][no] = msg;
   msg.sprintf("%.4f",fnx);
   sgkmf->Cells[KMF_FIELD_NX][no] = msg;
   msg.sprintf("%.4f",fny);
   sgkmf->Cells[KMF_FIELD_NY][no] = msg;
   pnlkmfX->Caption = IntToStr(cx);
   pnlkmfY->Caption = IntToStr(cy);
}
//---------------------------------------------------------------------------
// 2019 12 11 - chc 移動到點位
void __fastcall TMainForm::sgDotDblClick(TObject *Sender)
{
int recno;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   if(sgDot->RowCount < 2) {
      pnlSystemMessage->Caption = "點位: No Data Matched!";
      return;
   }
   recno = sgDot->Row;
   if(recno > 0 && recno < sgDot->RowCount) {
      edDotNo->Text = IntToStr(recno);
      pnlDotX->Caption = sgDot->Cells[1][recno];
      pnlDotY->Caption = sgDot->Cells[2][recno];
      pnlDotZ->Caption = sgDot->Cells[3][recno];
      pnlDotIntensity->Caption = sgDot->Cells[4][recno];
      comboOlympusVisionName1->Text = sgDot->Cells[5][recno];
      pnlDotRow->Caption = sgDot->Cells[6][recno];
      pnlDotCol->Caption = sgDot->Cells[7][recno];
      btnDotToClick(this);
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::sgkmfDblClick(TObject *Sender)
{
int recno;
AnsiString sx,sy;
double fx,fy;

   // 讀取中
   if(boolLoadkmf == true)
      return;

   if(sgkmf->RowCount < 2) {
      pnlSystemMessage->Caption = "座標: No Data Matched!";
      return;
   }
   recno = sgkmf->Row;
   if(recno > 0 && recno < sgkmf->RowCount) {
      pnlkmfNo->Caption = IntToStr(recno);
      pnlkmfTypeName->Caption = sgkmf->Cells[1][recno];
      sx = sgkmf->Cells[4][recno];
      sy = sgkmf->Cells[5][recno];
      fx = sx.ToDouble();
      fy = sy.ToDouble();
      // mm => um
      if(rgkmfUnit->ItemIndex == 0) {
         fx = fx * 1000.0;
         fy = fy * 1000.0;
         // um => pulse
         fx /= X_RESOLUTION;
         fy /= Y_RESOLUTION;
      }
      // cm => um
      else if(rgkmfUnit->ItemIndex == 1) {
         fx = fx * 10000.0;
         fy = fy * 10000.0;
         // um => pulse
         fx /= X_RESOLUTION;
         fy /= Y_RESOLUTION;
      }
      // um => um
      else if(rgkmfUnit->ItemIndex == 2) {
         // um => pulse
         fx /= X_RESOLUTION;
         fy /= Y_RESOLUTION;
      }
      pnlkmfX->Caption = IntToStr((int)fx);
      pnlkmfY->Caption = IntToStr((int)fy);

      btnTokmfClick(this);
   }

}
//---------------------------------------------------------------------------
// 2019 12 11 - chc 開啟Recipe
void __fastcall TMainForm::pnlRecipeClick(TObject *Sender)
{
AnsiString filename;
int len;

   opkmfFile->InitialDir = RecipeDirectory;
   if(opkmfFile->Execute()) {
      filename = ExtractFileName(opkmfFile->FileName);
      len = filename.Length();
      filename = filename.SubString(1,len-4);
      cbRecipe->Text = filename;
      cbRecipeSelect(this);
   }
}
//---------------------------------------------------------------------------
// 2019 12 11 - chc 開啟Recipe
void __fastcall TMainForm::pnlRecipeLabelClick(TObject *Sender)
{
AnsiString filename;
int len;

   opkmfFile->InitialDir = RecipeDirectory;
   if(opkmfFile->Execute()) {
      filename = ExtractFileName(opkmfFile->FileName);
      len = filename.Length();
      filename = filename.SubString(1,len-4);
      combRecipe->Text = filename;
      combRecipeSelect(this);
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::sgAreaDblClick(TObject *Sender)
{
int recno;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   if(sgArea->RowCount < 2) {
      pnlSystemMessage->Caption = "區域: No Data Matched!";
      return;
   }
   recno = sgArea->Row;
   if(recno > 0 && recno < sgArea->RowCount) {
      edAreaNo->Text = IntToStr(recno);
      pnlAreaX->Caption = sgArea->Cells[1][recno];
      pnlAreaY->Caption = sgArea->Cells[2][recno];
      pnlAreaZ->Caption = sgArea->Cells[3][recno];
   }
   btnAreaToClick(this);
}
//---------------------------------------------------------------------------
// 2019 12 12 - chc 指定點位(用來被複製)
void __fastcall TMainForm::btnDotSelectClick(TObject *Sender)
{
int recno;

   if(sgDot->RowCount < 2) {
      pnlSystemMessage->Caption = "點位: No Data Matched!";
      return;
   }
   recno = sgDot->Row;
   if(recno > 0 && recno < sgDot->RowCount) {
      pnlDotSelect->Caption = IntToStr(recno);
   }
}
//---------------------------------------------------------------------------
// 2019 12 12 - chc 套用指定點位(用來被複製)的資訊: (影像檔/Z/Intensity/Lens/MMD)
void __fastcall TMainForm::btnDotApplyClick(TObject *Sender)
{
int recno,selectno;
AnsiString sfname,dfname,recipename;

   if(sgDot->RowCount < 2) {
      pnlSystemMessage->Caption = "點位: No Data Matched!";
      return;
   }
   recno = sgDot->Row;
   selectno = pnlDotSelect->Caption.ToInt();
   if(recno > 0 && recno < sgDot->RowCount && selectno != recno) {
      // selectno To recno
      // Messagebox
      AnsiString msg;
      msg.sprintf("確認要更新點位%d的資訊?   ",recno);
      if(Application->MessageBox(msg.c_str(), "點位資訊更新作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      recipename = combRecipe->Text;
      // 3/4/5/6/7/ImageFile - Z/Intensity/VisionRecipe/Lens/MMD
      for(int i=3 ; i<=7 ; i++)
         sgDot->Cells[i][recno] = sgDot->Cells[i][selectno];
      sgDot->Refresh();
      // Copy ImageFile(Pattern: -Mx.bmp)
      sfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-M" + IntToStr(selectno) + ".bmp";
      dfname = RecipeDirectory + "\\" + recipename + "\\" + recipename + "-M" + IntToStr(recno) + ".bmp";
      if(FileExists(sfname))
         CopyFile(sfname.c_str(),dfname.c_str(),false);
   }
}
//---------------------------------------------------------------------------
// 2019 12 13 - chc 奇偶不同色
void __fastcall TMainForm::sgkmfDrawCell(TObject *Sender, int ACol,
      int ARow, TRect &Rect, TGridDrawState State)
{
AnsiString Str=" ";
TColor fontcolor;
bool boolbold;

// 區分大小來源
TStringGrid *stringgrid;
stringgrid = (TStringGrid*)Sender;

   ((TStringGrid*)Sender)->Canvas->Font = ((TStringGrid*)Sender)->Font;
   for(int i=0 ; i<((TStringGrid*)Sender)->RowCount ; i++){
      if(((TStringGrid*)Sender)->Cells[ACol][i].Length() > Str.Length())
         Str = ((TStringGrid*)Sender)->Cells[ACol][i];

   }
   int colWidth = ((TStringGrid*)Sender)->Canvas->TextWidth(Str)+4;
   if(colWidth > ((TStringGrid*)Sender)->ColWidths[ACol])
      ((TStringGrid*)Sender)->ColWidths[ACol] = colWidth;
   fontcolor = clBlack;

   if(ARow != 0) {
      // 項目加上顏色
      if(ACol == KMF_FIELD_ITEM) {
         boolbold = true;
         ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x00FFDDDD;
      }
      else {
         fontcolor = clBlack;
         // 奇偶數不同顏色
         if((ARow % 2) != 0)
            ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x0093F4F2;
         else
             ((TStringGrid*)Sender)->Canvas->Brush->Color = clWhite;
      }
   }

   ((TStringGrid*)Sender)->Canvas->FillRect(Rect);
   DrawText(((TStringGrid*)Sender)->Canvas->Handle,((TStringGrid*)Sender)->Cells[ACol][ARow].c_str(),-1,(RECT*)&Rect,DT_SINGLELINE|DT_VCENTER|DT_CENTER);

}
//---------------------------------------------------------------------------
// 2019 12 13 - chc 奇偶不同色
void __fastcall TMainForm::sgDotDrawCell(TObject *Sender, int ACol,
      int ARow, TRect &Rect, TGridDrawState State)
{
AnsiString Str=" ";
TColor fontcolor;
bool boolbold;

// 區分大小來源
TStringGrid *stringgrid;
stringgrid = (TStringGrid*)Sender;

   ((TStringGrid*)Sender)->Canvas->Font = ((TStringGrid*)Sender)->Font;
   for(int i=0 ; i<((TStringGrid*)Sender)->RowCount ; i++){
      if(((TStringGrid*)Sender)->Cells[ACol][i].Length() > Str.Length())
         Str = ((TStringGrid*)Sender)->Cells[ACol][i];

   }
   int colWidth = ((TStringGrid*)Sender)->Canvas->TextWidth(Str)+4;
   if(colWidth > ((TStringGrid*)Sender)->ColWidths[ACol])
      ((TStringGrid*)Sender)->ColWidths[ACol] = colWidth;
   fontcolor = clBlack;

   if(ARow != 0) {
      // 項目加上顏色
      if(ACol == DOT_FIELD_VISIONRECIPE) {
         boolbold = true;
         ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x00FFDDDD;
      }
      else {
         fontcolor = clBlack;
         // 奇偶數不同顏色
         if((ARow % 2) != 0)
            ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x0093F4F2;
         else
             ((TStringGrid*)Sender)->Canvas->Brush->Color = clWhite;
      }
   }

   ((TStringGrid*)Sender)->Canvas->FillRect(Rect);
   DrawText(((TStringGrid*)Sender)->Canvas->Handle,((TStringGrid*)Sender)->Cells[ACol][ARow].c_str(),-1,(RECT*)&Rect,DT_SINGLELINE|DT_VCENTER|DT_CENTER);

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::sgAreaDrawCell(TObject *Sender, int ACol,
      int ARow, TRect &Rect, TGridDrawState State)
{
AnsiString Str=" ";
TColor fontcolor;
bool boolbold;

// 區分大小來源
TStringGrid *stringgrid;
stringgrid = (TStringGrid*)Sender;

   ((TStringGrid*)Sender)->Canvas->Font = ((TStringGrid*)Sender)->Font;
   for(int i=0 ; i<((TStringGrid*)Sender)->RowCount ; i++){
      if(((TStringGrid*)Sender)->Cells[ACol][i].Length() > Str.Length())
         Str = ((TStringGrid*)Sender)->Cells[ACol][i];

   }
   int colWidth = ((TStringGrid*)Sender)->Canvas->TextWidth(Str)+4;
   if(colWidth > ((TStringGrid*)Sender)->ColWidths[ACol])
      ((TStringGrid*)Sender)->ColWidths[ACol] = colWidth;
   fontcolor = clBlack;

   if(ARow != 0) {
      fontcolor = clBlack;
      // 奇偶數不同顏色
      if((ARow % 2) != 0)
         ((TStringGrid*)Sender)->Canvas->Brush->Color = (TColor)0x0093F4F2;
      else
          ((TStringGrid*)Sender)->Canvas->Brush->Color = clWhite;
   }

   ((TStringGrid*)Sender)->Canvas->FillRect(Rect);
   DrawText(((TStringGrid*)Sender)->Canvas->Handle,((TStringGrid*)Sender)->Cells[ACol][ARow].c_str(),-1,(RECT*)&Rect,DT_SINGLELINE|DT_VCENTER|DT_CENTER);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::Panel39Click(TObject *Sender)
{
int no;
AnsiString name;
char dibuf[20];

   // aSTG1.GPIO:007F00204E161570/0003FC001E0000E1              => Stage
   // aSTG1.GPIO:000100204E161570/0003FC000E0000A9              => remove cassette
   // aSTG1.GPIO:000100204E011570/0003FC000E0000A9              => remove carrier

   // aSTG2.GPIO:000100205E1EDA30/000000001F000081              => Loaded
   // aSTG2.GPIO:000100204E1D1570/000000001C000081              => Unloaded(Stage)
   // aSTG2.GPIO:000100204E011570/000000000C000081              => 取出Carrier
   for(no=1 ; no<=6 ; no++) {
      if(no == 1) {
         sprintf(dibuf,"007F00204E161570");
         name = "LP1-Stage";
      }
      else if(no == 2) {
         sprintf(dibuf,"000100204E161570");
         name = "LP1-RemoveCassette";
      }
      else if(no == 3) {
         sprintf(dibuf,"000100204E011570");
         name = "LP1-RemoveCarrier";
      }
      else if(no == 4) {
         sprintf(dibuf,"000100205E1EDA30");
         name = "LP2-Loaded";
      }
      else if(no == 5) {
         sprintf(dibuf,"000100204E1D1570");
         name = "LP2-Unloaded(Stage)";
      }
      else if(no == 6) {
         sprintf(dibuf,"000100204E011570");
         name = "LP2-RemoveCarrier";
      }
      AnsiString msg;
      msg.sprintf("LoadPort%d Status: %s - [%s]",no,dibuf,name.c_str());
      WriteSystemLog(msg);
      for(int i=0 ; i<16 ; i++) {
         if(dibuf[i] >= '0' && dibuf[i] <= '9')
            dibuf[i] -= '0';
         else {
            dibuf[i] -= 'A';
            dibuf[i] += 10;
         }
      }
      LogInStatus(no,dibuf);
   }
   return;

   // 2021 4 23 - chc 大影像檔
   //LoadFromFile();
   DrawBigImage();

   //no = cbRecipe->Items->Count;
   //cbRecipe->Items->Delete(3);
   //no = cbRecipe->Items->Count;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnReMatchClick(TObject *Sender)
{

   MatchProcess = 2;
   pnlMatchError->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnExitMatchClick(TObject *Sender)
{

   MatchProcess = 1;
   pnlMatchError->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnDisplayResultClick(TObject *Sender)
{

   if(gbMatchData->Visible == true)
      gbMatchData->Visible = false;
   else
      gbMatchData->Visible = true;
}
//---------------------------------------------------------------------------
// 2019 12 18 - chc 將取像框移到十字中心
void __fastcall TMainForm::btnMatchToCenterClick(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   if(shCenter->Visible == false)
      return;

   shCenter->Left = shVertical->Left - shCenter->Width/2;
   shCenter->Top = shHorizontal->Top - shCenter->Height/2;
   UpdateCenterDotPosition();
}
//---------------------------------------------------------------------------
// 2020 1 5 - chc joystick
void __fastcall TMainForm::tmJoystickTimer(TObject *Sender)
{
static int scnt = 0;

   tmJoystick->Enabled = false;

 // 2023 7 24a - chc try-catch
 try {

   // 2020 2 12 - chc 不用Handle
   //UpdateJoystick(Handle);
   UpdateJoystick();

   if(tmJoystick->Interval == 500) {
      tmTrigger->Enabled = true;

      // 2020 4 16 - chc Log -> Timer問題
      WriteSystemLog(">>[Timer]: tmTrigger");

   }
   tmJoystick->Interval = 50;
   tmJoystick->Enabled = true;

 // 2023 7 24a - chc try-catch
 }
 catch(Exception &e) {
    WriteSystemLog("tmJoystickTimer(Error)" + e.Message);
 }

   // 2020 4 16 - chc Log -> Timer問題
   // 2021 4 18 - chc 不Log
   //WriteSystemLog(">>[Timer]: tmJoystick - 2");

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmTriggerTimer(TObject *Sender)
{

   tmTrigger->Enabled = false;
   Application->ProcessMessages();
   PostMessage(MainForm->Handle, WM_LBUTTONDOWN, 0, 0);

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tmTrigger done.");

   // 2020 2 14a - chc 先不顯示原點復歸
   // 2021 5 6 - chc 不顯示
   //pnlHome2->Visible = true;
   //pnlStartMessage->Caption = "請執行原點復歸...";

}
//---------------------------------------------------------------------------
// 2020 1 21 - chc 將Operator/SheetNo加入CSV
// 單獨0d, 0a的後面
//   databasename = edLotNo->Text + "-" + temp + ".csv";
//   DatabaseNameSave = databasename;
//   不含副檔名
//   DatabaseNameSaveMain = edLotNo->Text + "-" + temp;
void __fastcall TMainForm::AddItemToCSV()
{
AnsiString spath,sfname,dpath,dfname;
FILE *sfp,*dfp;
char sbuf[1024],dbuf[1024];
int rno,pos,len,lineno;
AnsiString soperator,ssheetno,asbuf,adbuf,rbuf,hbuf,slotno,spartno;

   if(boolForTest == true) {
      DatabaseNameSave = "Test.csv";
      DatabaseNameSaveMain = "Test";
   }

   WriteSystemLog("轉換CSV...");
   dpath = SystemDirectory + "\\CSV";
   sfname = dpath + "\\" + DatabaseNameSave;
   dfname = dpath + "\\" + DatabaseNameSaveMain + "-N.csv";
   slotno = edLotNo->Text;
   spartno = cbType->Text;
   soperator = cbOperator->Text;
   ssheetno = edBoxNo->Text;

   // 是否存在?
   if(FileExists(sfname)) {
      sfp = fopen(sfname.c_str(),"r");
      dfp = fopen(dfname.c_str(),"w+t");
      if(sfp == NULL) {
         WriteSystemLog("原始CSV開啟失敗!" + sfname);
         return;
      }
      if(dfp == NULL) {
         WriteSystemLog("目的CSV開啟失敗!" + dfname);
         return;
      }
      bool boolcheck = false;
      lineno = 1;
      while(1) {
         if(fgets(sbuf,1000,sfp) == NULL)
            break;
         /*
         // 直接複製
         if(boolcheck == false) {
            fputs(sbuf,dfp);
            //if(sbuf[0] == 0x0d && sbuf[1] == 0x0a) {
            if(sbuf[0] == 0x0a) {
               boolcheck = true;
            }
         }
         // 加入Operator/Sheetno
         //1/20/2020,5:33:12 PM,6.3614559419134,12.4986957160778,6.78348286588426,25.1379039579163,-12.6392082418385,24.2872336624374,0.0807963431639409,19.5536308288574,15.5107755661011,22.7444591522217,17.0878391265869,15.2987060546875,24.9783782958984
         else {
            asbuf.sprintf("%s",sbuf);
            pos = asbuf.Pos(",");
            if(pos == 0) {
               fputs(sbuf,dfp);
            }
            else {
               len = asbuf.Length();
               rbuf = asbuf.SubString(pos,len-pos+1);
               hbuf = asbuf.SubString(1,pos-1);
               hbuf = hbuf + "-" + soperator + "-" + ssheetno;
               adbuf = hbuf + rbuf;
               fputs(adbuf.c_str(),dfp);
            }
         }
         */
         asbuf.sprintf("%s",sbuf);
         if(lineno == 1) {
            len = asbuf.Length();
            adbuf = asbuf.SubString(1,3) + "LotNo,PartNo,Operator,SheetNo," + asbuf.SubString(4,len-3);
         }
         else if(lineno == 2 || lineno == 7 || lineno == 8) {
            adbuf = ",,,," + asbuf;
         }
         else if(lineno == 3) {
            adbuf = "R: N/A,R: N/A,R: N/A,R: N/A," + asbuf;
         }
         else if(lineno == 4) {
            adbuf = "M: N/A,M: N/A,M: N/A,M: N/A," + asbuf;
         }
         else if(lineno == 5 || lineno == 6) {
            adbuf = "Always,Always,Always,Always," + asbuf;
         }
         else if(lineno == 9) {
            adbuf = "Meta Data,Meta Data,Meta Data,Meta Data," + asbuf;
         }
         else if(lineno == 10) {
            adbuf = asbuf;
         }
         else {
            adbuf = slotno + "," + spartno + "," + soperator + "," + ssheetno + "," + asbuf;
         }
         fputs(adbuf.c_str(),dfp);
         lineno++;
      }
      fclose(sfp);
      fclose(dfp);
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos6SetClick(TObject *Sender)
{

   SetUserPosition(6);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos7SetClick(TObject *Sender)
{

   SetUserPosition(7);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos8SetClick(TObject *Sender)
{

   SetUserPosition(8);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos9SetClick(TObject *Sender)
{

   SetUserPosition(9);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos10SetClick(TObject *Sender)
{

   SetUserPosition(10);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos6GoClick(TObject *Sender)
{
int no;

   no = 6;
   MotionStatus(false);

   pnlStartMessage->Caption = "To Point 6...";
   pnlStartMessage->Visible = true;
   ToUserPosition(no);

   pnlStartMessage->Visible = false;
   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos7GoClick(TObject *Sender)
{
int no;

   no = 7;
   MotionStatus(false);

   pnlStartMessage->Caption = "To Point 7...";
   pnlStartMessage->Visible = true;
   ToUserPosition(no);

   pnlStartMessage->Visible = false;
   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos8GoClick(TObject *Sender)
{
int no;

   no = 8;
   MotionStatus(false);

   pnlStartMessage->Caption = "To Point 8...";
   pnlStartMessage->Visible = true;
   ToUserPosition(no);

   pnlStartMessage->Visible = false;
   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos9GoClick(TObject *Sender)
{
int no;

   no = 9;
   MotionStatus(false);

   pnlStartMessage->Caption = "To Point 9...";
   pnlStartMessage->Visible = true;
   ToUserPosition(no);

   pnlStartMessage->Visible = false;
   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnPos10GoClick(TObject *Sender)
{
int no;

   no = 10;
   MotionStatus(false);

   if(boolInMeasure == true)
      pnlStartMessage->Caption = "#" + IntToStr(SimulatePoint) + " Moving...";
   else

      pnlStartMessage->Caption = "To Point 10...";
   pnlStartMessage->Visible = true;
   ToUserPosition(no);

   pnlStartMessage->Visible = false;
   MotionStatus(true);
}
//---------------------------------------------------------------------------
// 2020 2 11 - chc 基準點相對移動
// 2020 2 11 - chc 基準點相對移動
void __fastcall TMainForm::btnMoveBaseSetClick(TObject *Sender)
{

   SetMoveBasePosition();
}
//---------------------------------------------------------------------------
// 2020 2 11 - chc 基準點相對移動
void __fastcall TMainForm::btnMoveBaseGoClick(TObject *Sender)
{

bool boolret;

   pnlToMoveBasePosition->Color = clSilver;
   boolret = ToMoveBasePosition();
   if(boolret == false) {
      pnlToMoveBasePosition->Color = clRed;
      return;
   }
}
//---------------------------------------------------------------------------
// 2020 2 11 - chc 基準點相對移動
void __fastcall TMainForm::btnMoveBaseMoveClick(TObject *Sender)
{
F64 pos,x,y;

   MainForm->pnlMoveBaseMove->Color = clSilver;
   // mm => pulse
   x = (MainForm->edMoveBaseX->Text.ToInt() * 1000) / X_RESOLUTION;
   y = (MainForm->edMoveBaseY->Text.ToInt() * 1000) / Y_RESOLUTION;

   int basex,basey;
   basex = pnlMoveBaseX->Caption.ToInt();
   basey = pnlMoveBaseY->Caption.ToInt();
   x = x + basex;
   y = y - basey;

   // From Relative Move
   if(MainForm->boolRelativeMove == true) {
      x += MainForm->RelativeMoveX;
      y += MainForm->RelativeMoveY;
   }

   // Check moving?
   if(MainForm->iAxisMove[X_AXIS] != NO_MOVE || MainForm->iAxisMove[Y_AXIS] != NO_MOVE) {
      return;
   }

   MainForm->iAxisMove[X_AXIS] = FORWARD_MOVE;
   MainForm->iAxisMove[Y_AXIS] = FORWARD_MOVE;

   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   Sleep(100);

   if(WaitMotionXYDone(20000) == false) {
      MainForm->pnlSystemMessage->Caption = "BaseRel Point Move Fail!";
      MainForm->pnlMoveBaseMove->Color = clRed;
   }
   else {
      MainForm->pnlSystemMessage->Caption = "BaseRel Point Move Completed.";
      MainForm->pnlMoveBaseMove->Color = clLime;
   }

   // 記錄各軸是否運作中
   MainForm->iAxisMove[X_AXIS] = NO_MOVE;
   MainForm->iAxisMove[Y_AXIS] = NO_MOVE;

}
//---------------------------------------------------------------------------
// 2020 2 12 - chc Joystick Active
void __fastcall TMainForm::SetJoystickActive(bool flag)
{

   if(flag == true) {
      pnlJoystickActive->Color = clLime;
      pnlSpeed->Color = clTeal;
   }
   else {
      pnlJoystickActive->Color = clSilver;
      pnlSpeed->Color = clGray;
   }
   rgJoystickSpeed->ItemIndex = 0;
   pnlSpeed->Caption = "Low";
}
//---------------------------------------------------------------------------
// 2020 2 12 - chc Joystick Active
int XMode;
void __fastcall TMainForm::DoMoveX()
{

   XMode = 1;
   tmX->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tmX, DoMoveX()");

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::DoBackwardX()
{

   XMode = 2;
   tmX->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tmX, DoMoveX()");

}
//---------------------------------------------------------------------------
// 2020 2 12 - chc Joystick Active
int YMode;
void __fastcall TMainForm::DoMoveY()
{

   YMode = 1;
   tmY->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tmY - 1");

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::DoBackwardY()
{

   YMode = 2;
   tmY->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tmY - 2");

}
//---------------------------------------------------------------------------
// 2020 2 12 - chc Joystick Active
int ZMode;
void __fastcall TMainForm::DoMoveZ()
{

   ZMode = 1;
   tmZ->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tmZ - 1");

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::DoBackwardZ()
{

   ZMode = 2;
   tmZ->Enabled = true;

   // 2020 4 16 - chc Log -> Timer問題
   WriteSystemLog(">>[Timer]: tmZ - 2");

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmXTimer(TObject *Sender)
{

   tmX->Enabled = false;
   if(XMode == 1) {
      WriteSystemLog(">>Joystick: DoMoveX()...");
      // 指定軸
      combAxis->ItemIndex = X_AXIS;
      // Table方向
      if(cbTableDirection->Checked == true) {
         // 指定Axis
         CurrentAxisNo = combAxis->ItemIndex;
         if(cbContinueMove->Checked == false)
            return;
         // 記錄在move中, 不可以同時Continue move
         if(boolInAxisMove == false) {
            boolJogMove = true;
            AxisMove(0,0);
         }
      }
      else {
         // 指定Axis
         CurrentAxisNo = combAxis->ItemIndex;
         if(cbContinueMove->Checked == false)
            return;
         // 記錄在move中, 不可以同時Continue move
         if(boolInAxisMove == false) {
            boolJogMove = true;
            AxisMove(1,0);
         }
      }
      WriteSystemLog(">>Joystick: DoMoveX().");
   }
   else {
      WriteSystemLog(">>Joystick: DoBackwardX()...");
      // 指定軸
      combAxis->ItemIndex = X_AXIS;
      if(cbTableDirection->Checked == true) {
         // 指定Axis
         CurrentAxisNo = combAxis->ItemIndex;
         if(cbContinueMove->Checked == false)
            return;
         // 記錄在move中, 不可以同時Continue move
         if(boolInAxisMove == false) {
            boolJogMove = true;
            AxisMove(1,0);
         }
      }
      else {
         // 指定Axis
         CurrentAxisNo = combAxis->ItemIndex;
         if(cbContinueMove->Checked == false)
            return;
         // 記錄在move中, 不可以同時Continue move
         if(boolInAxisMove == false) {
            boolJogMove = true;
            AxisMove(0,0);
         }
      }
      WriteSystemLog(">>Joystick: DoBackwardX().");
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmYTimer(TObject *Sender)
{

   tmY->Enabled = false;
   if(YMode == 1) {
      combAxis->ItemIndex = Y_AXIS;
      // 指定Axis
      CurrentAxisNo = combAxis->ItemIndex;
      if(cbContinueMove->Checked == false)
         return;
      // 記錄在move中, 不可以同時Continue move
      if(boolInAxisMove == false) {
         boolJogMove = true;
         AxisMove(0,0);
      }
   }
   else {
      combAxis->ItemIndex = Y_AXIS;
      // 指定Axis
      CurrentAxisNo = combAxis->ItemIndex;
      if(cbContinueMove->Checked == false)
         return;
      // 記錄在move中, 不可以同時Continue move
      if(boolInAxisMove == false) {
         boolJogMove = true;
         AxisMove(1,0);
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmZTimer(TObject *Sender)
{

   tmZ->Enabled = false;
   if(ZMode == 1) {
      combAxis->ItemIndex = Z_AXIS;
      // 指定Axis
      CurrentAxisNo = combAxis->ItemIndex;
      if(cbContinueMove->Checked == false)
         return;
      // 記錄在move中, 不可以同時Continue move
      if(boolInAxisMove == false) {
         boolJogMove = true;
         AxisMove(0,0);
      }
   }
   else {
      combAxis->ItemIndex = Z_AXIS;
      // 指定Axis
      CurrentAxisNo = combAxis->ItemIndex;
      if(cbContinueMove->Checked == false)
         return;
      // 記錄在move中, 不可以同時Continue move
      if(boolInAxisMove == false) {
         boolJogMove = true;
         AxisMove(1,0);
      }
   }
}
//---------------------------------------------------------------------------
// 2020 1 12 - chc Joystick刻度定義
void __fastcall TMainForm::btnJoystickSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   JoystickStart = edJoystickStart->Text.ToInt();
   JoystickStop = edJoystickStop->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,JOYSTICK_START                 ,JoystickStart);
   pSystemFile->WriteInteger("System Parameter" ,JOYSTICK_STOP                  ,JoystickStop);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2020 2 12 - chc Joystick參數儲存
void __fastcall TMainForm::LoadJoystick()
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   JoystickStart = pSystemFile->ReadInteger("System Parameter" ,JOYSTICK_START  ,900);
   JoystickStop = pSystemFile->ReadInteger("System Parameter" ,JOYSTICK_STOP    ,100);
   edJoystickStart->Text = IntToStr(JoystickStart);
   edJoystickStop->Text = IntToStr(JoystickStop);

   // 2021 5 26 - chc 漏AI
   AISpeedStart = pSystemFile->ReadInteger("System Parameter" ,AISPEED_START    ,150);
   AISpeedChange = pSystemFile->ReadInteger("System Parameter" ,AISPEED_CHANGE  ,50);
   edAISpeedStart->Text = IntToStr(AISpeedStart);
   edAISpeedChange->Text = IntToStr(AISpeedChange);
   boolAISpeed = pSystemFile->ReadBool("System Parameter" ,BOOL_AISPEED         ,false);
   cbAISpeed->Checked = boolAISpeed;

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2020 2 14a - chc ServoOn
void __fastcall TMainForm::btnSvonClick(TObject *Sender)
{

   if(pnlBit1->Color == clLime) {

      // 2021 6 3 - chc 全SVON
      //ServoOn();
      int rdycnt = 0;
      if(bool_APS_Status == true) {
         for(int axisno=0 ; axisno<MAX_AXIS_NO ; axisno++) {
            if(DOServoOnOff(axisno,3) == true)
               rdycnt++;
         }
      }
      if(rdycnt >= MAX_AXIS_NO) {
         // 先等候SVON才做Home
         btnHome->Enabled = true;
         pnlStartMessage->Visible = true;
         pnlStartMessage->Caption = "Please execute homing...";
      }
      else {
         btnHome->Enabled = false;
         pnlAxisError->Caption = "軸控異常(無法SVON)! 請重新啟動系統.";
         pnlAxisError->Visible = true;
         pnlSystemMessage->Caption = pnlAxisError->Caption;
      }


      boolMotionPowerOff = false;

      // 2020 2 17 - chc Alarm Message
      MainForm->pnlAlarmMessage->Caption = "";
      if(MainForm->pnlAxisError->Visible == true)
         MainForm->pnlAxisError->Visible = false;

   }
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnFrontOutClick(TObject *Sender)
{

   SetSaveProtect(1);
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnFrontInClick(TObject *Sender)
{

   SetSaveProtect(2);
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnRightOutClick(TObject *Sender)
{

   SetSaveProtect(3);
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnRightInClick(TObject *Sender)
{

   SetSaveProtect(4);
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnRearOutClick(TObject *Sender)
{

   SetSaveProtect(5);
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnRearInClick(TObject *Sender)
{

   SetSaveProtect(6);
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnLeftOutClick(TObject *Sender)
{

   SetSaveProtect(7);
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnLeftInClick(TObject *Sender)
{

   SetSaveProtect(8);
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::btnSafeSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   SafeFrontOut = pnlFrontOut->Caption.ToInt();
   SafeFrontIn = pnlFrontIn->Caption.ToInt();
   SafeRightOut = pnlRightOut->Caption.ToInt();
   SafeRightIn = pnlRightIn->Caption.ToInt();
   SafeRearOut = pnlRearOut->Caption.ToInt();
   SafeRearIn = pnlRearIn->Caption.ToInt();
   SafeLeftOut = pnlLeftOut->Caption.ToInt();
   SafeLeftIn = pnlLeftIn->Caption.ToInt();

   pSystemFile->WriteInteger("System Parameter" ,SAFE_FRONT_OUT                 ,SafeFrontOut);
   pSystemFile->WriteInteger("System Parameter" ,SAFE_FRONT_IN                  ,SafeFrontIn);
   pSystemFile->WriteInteger("System Parameter" ,SAFE_RIGHT_OUT                 ,SafeRightOut);
   pSystemFile->WriteInteger("System Parameter" ,SAFE_RIGHT_IN                  ,SafeRightIn);
   pSystemFile->WriteInteger("System Parameter" ,SAFE_REAR_OUT                  ,SafeRearOut);
   pSystemFile->WriteInteger("System Parameter" ,SAFE_REAR_IN                   ,SafeRearIn);
   pSystemFile->WriteInteger("System Parameter" ,SAFE_LEFT_OUT                  ,SafeLeftOut);
   pSystemFile->WriteInteger("System Parameter" ,SAFE_LEFT_IN                   ,SafeLeftIn);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2020 2 16 - chc Save Protect
void __fastcall TMainForm::LoadSafe()
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   SafeFrontOut = pSystemFile->ReadInteger("System Parameter" ,SAFE_FRONT_OUT   ,0);
   SafeFrontIn = pSystemFile->ReadInteger("System Parameter" ,SAFE_FRONT_IN     ,0);
   SafeRightOut = pSystemFile->ReadInteger("System Parameter" ,SAFE_RIGHT_OUT   ,0);
   SafeRightIn = pSystemFile->ReadInteger("System Parameter" ,SAFE_RIGHT_IN     ,0);
   SafeRearOut = pSystemFile->ReadInteger("System Parameter" ,SAFE_REAR_OUT     ,0);
   SafeRearIn = pSystemFile->ReadInteger("System Parameter" ,SAFE_REAR_IN       ,0);
   SafeLeftOut = pSystemFile->ReadInteger("System Parameter" ,SAFE_LEFT_OUT     ,0);
   SafeLeftIn = pSystemFile->ReadInteger("System Parameter" ,SAFE_LEFT_IN       ,0);

   pnlFrontOut->Caption = IntToStr(SafeFrontOut);
   pnlFrontIn->Caption = IntToStr(SafeFrontIn);
   pnlRightOut->Caption = IntToStr(SafeRightOut);
   pnlRightIn->Caption = IntToStr(SafeRightIn);
   pnlRearOut->Caption = IntToStr(SafeRearOut);
   pnlRearIn->Caption = IntToStr(SafeRearIn);
   pnlLeftOut->Caption = IntToStr(SafeLeftOut);
   pnlLeftIn->Caption = IntToStr(SafeLeftIn);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2020 2 28 - chc 取消不顯示
void __fastcall TMainForm::NonVisible()
{

   gbRelativeBase->Visible = false;

   // 2021 4 11 - chc 要作動
   //tsParameter->TabVisible = false;
   //tsCCD->TabVisible = false;
   //tsOlympus->TabVisible = false;
   //tsFocus->TabVisible = false;
   //tsJoystick->TabVisible = false;
   //rgCCDPosition->Visible = false;
   //pnlClip->Visible = false;
   //pnlISCCDInfo->Visible = false;
   //shHorizontal->Visible = false;
   //shVertical->Visible = false;
   //imCCD->Visible = false;
   //cbCrossHair->Visible = false;
   //cbMeasure->Visible = false;
   //cbUnitMove->Visible = false;
   //btnFindFocus->Visible = false;
   //pnlAutoFocus1->Visible = false;
   //pnlWidthValue->Visible = false;
   //pnlUnit->Visible = false;
   //tsMark->TabVisible = false;
   //tsMatch->TabVisible = false;
   //pnlISCCDStaus->Visible = false;
   //pnlISCCDCapture->Visible = false;
   //tsRun->TabVisible = false;
   //tsArrayDieMove->TabVisible = false;
   //Label41->Visible = false;
   //Label302->Visible = false;
   //pnlPositionLength->Visible = false;
   //pnlRecipeSet->Visible = false;
   //tsLens->TabVisible = false;
   //tsMove->TabVisible = false;
   //gbSubstrate->Visible = false;
   //pcOP->Visible = false;
   imCCD->Width = 1120;
   imCCD->Height = 834;
   imCCD->Left = 43;
   imCCD->Top = 42;

   tsSafe->TabVisible = false;
   mmMeasure->Visible = false;

   // 2021 4 11 - chc 不要改變
   //rgSpeed->Top = pnlClip->Top;
   //rgSpeed->Left = pnlClip->Left;
   //rgSpeed->Height += 12;
   //rgSpeed->Width += 5;
   //pnlCurrentSpeed->Top = pnlClip->Top;
   //pnlMessage->Height = gbSystemCommand->Height;
   //pnlMessage->Top = gbSystemCommand->Top;

}
//---------------------------------------------------------------------------
// 2020 3 4 - chc Wheel Up
void __fastcall TMainForm::FormMouseWheelUp(TObject *Sender,
      TShiftState Shift, TPoint &MousePos, bool &Handled)
{
int x,y,w,h,dh;
int z1x,z1y,z10x,z10y,z100x,z100y,z1000x,z1000y;
bool booldo = false;

   // 2021 4 27 - chc Scroll
   if(cbWaferMap->Checked == true) {
      int factor;
      factor = tbZoom->Position;
      if(rgWheelDirection->ItemIndex == 0)
         sbWaferMap->VertScrollBar->Position -= (5*factor);
      else
         sbWaferMap->HorzScrollBar->Position += (5*factor);
   }

   // 2020 11 13 - chc OP可操作
   //if(PriorityLevel < PRIORITY_PE)
   //   return;

   // 2021 4 23 - chc 不啟動
   return;

   dh = 30;
   x = MousePos.x;
   y = MousePos.y;

   // 2020 3 6 - chc 對應到Form上
   int fx = MainForm->Left;
   int fy = MainForm->Top;
   x -= fx;
   y -= fy;

   // Z-
   w = btnUp1x->Width;
   h = btnUp1x->Height;
   z1x = btnUp1x->Left + pnlLeftWindow->Left;
   z1y = btnUp1x->Top + pnlLeftWindow->Top + dh;
   z10x = btnUp5x->Left + pnlLeftWindow->Left;
   z10y = btnUp5x->Top + pnlLeftWindow->Top + dh;
   z100x = btnUp10x->Left + pnlLeftWindow->Left;
   z100y = btnUp10x->Top + pnlLeftWindow->Top + dh;
   z1000x = btnUp100x->Left + pnlLeftWindow->Left;
   z1000y = btnUp100x->Top + pnlLeftWindow->Top + dh;
   if((x >= z1x && x <= (z1x+w)) && (y >= z1y && y <= (z1y+h))) {
      btnUp1xClick(this);
      booldo = true;
   }
   else if((x >= z10x && x <= (z10x+w)) && (y >= z10y && y <= (z10y+h))) {
      btnUp5xClick(this);
      booldo = true;
   }
   else if((x >= z100x && x <= (z100x+w)) && (y >= z100y && y <= (z100y+h))) {
      btnUp10xClick(this);
      booldo = true;
   }
   else if((x >= z1000x && x <= (z1000x+w)) && (y >= z1000y && y <= (z1000y+h))) {
      btnUp100xClick(this);
      booldo = true;
   }

   // T-
   //x = MousePos.x;
   //y = MousePos.y;
   w = btnCW1x->Width;
   h = btnCW1x->Height;
   z1x = btnCW1x->Left + pnlLeftWindow->Left;
   z1y = btnCW1x->Top + pnlLeftWindow->Top + dh;
   z10x = btnCW5x->Left + pnlLeftWindow->Left;
   z10y = btnCW5x->Top + pnlLeftWindow->Top + dh;
   z100x = btnCW10x->Left + pnlLeftWindow->Left;
   z100y = btnCW10x->Top + pnlLeftWindow->Top + dh;
   if((x >= z1x && x <= (z1x+w)) && (y >= z1y && y <= (z1y+h))) {
      btnCW1xClick(this);
      booldo = true;
   }
   else if((x >= z10x && x <= (z10x+w)) && (y >= z10y && y <= (z10y+h))) {
      btnCW5xClick(this);
      booldo = true;
   }
   else if((x >= z100x && x <= (z100x+w)) && (y >= z100y && y <= (z100y+h))) {
      btnCW10xClick(this);
      booldo = true;
   }

   // Z+
   //x = MousePos.x;
   //y = MousePos.y;
   w = btnDown1x->Width;
   h = btnDown1x->Height;
   z1x = btnDown1x->Left + pnlLeftWindow->Left;
   z1y = btnDown1x->Top + pnlLeftWindow->Top + dh;
   z10x = btnDown5x->Left + pnlLeftWindow->Left;
   z10y = btnDown5x->Top + pnlLeftWindow->Top + dh;
   z100x = btnDown10x->Left + pnlLeftWindow->Left;
   z100y = btnDown10x->Top + pnlLeftWindow->Top + dh;
   z1000x = btnDown100x->Left + pnlLeftWindow->Left;
   z1000y = btnDown100x->Top + pnlLeftWindow->Top + dh;
   if((x >= z1x && x <= (z1x+w)) && (y >= z1y && y <= (z1y+h))) {
      // => Up就是往上
      //btnDown1xClick(this);
      btnUp1xClick(this);
      booldo = true;
   }
   else if((x >= z10x && x <= (z10x+w)) && (y >= z10y && y <= (z10y+h))) {
      // => Up就是往上
      //btnDown5xClick(this);
      btnUp5xClick(this);
      booldo = true;
   }
   else if((x >= z100x && x <= (z100x+w)) && (y >= z100y && y <= (z100y+h))) {
      // => Up就是往上
      //btnDown10xClick(this);
      btnUp10xClick(this);
      booldo = true;
   }
   else if((x >= z1000x && x <= (z1000x+w)) && (y >= z1000y && y <= (z1000y+h))) {
      // => Up就是往上
      //btnDown100xClick(this);
      btnUp100xClick(this);
      booldo = true;
   }
   // T+
   //x = MousePos.x;
   //y = MousePos.y;
   w = btnCCW1x->Width;
   h = btnCCW1x->Height;
   z1x = btnCCW1x->Left + pnlLeftWindow->Left;
   z1y = btnCCW1x->Top + pnlLeftWindow->Top + dh;
   z10x = btnCCW5x->Left + pnlLeftWindow->Left;
   z10y = btnCCW5x->Top + pnlLeftWindow->Top + dh;
   z100x = btnCCW10x->Left + pnlLeftWindow->Left;
   z100y = btnCCW10x->Top + pnlLeftWindow->Top + dh;
   if((x >= z1x && x <= (z1x+w)) && (y >= z1y && y <= (z1y+h))) {
      // => Up就是往上
      //btnCCW1xClick(this);
      btnCW1xClick(this);
      booldo = true;
   }
   else if((x >= z10x && x <= (z10x+w)) && (y >= z10y && y <= (z10y+h))) {
      // => Up就是往上
      //btnCCW5xClick(this);
      btnCW5xClick(this);
      booldo = true;
   }
   else if((x >= z100x && x <= (z100x+w)) && (y >= z100y && y <= (z100y+h))) {
      // => Up就是往上
      //btnCCW10xClick(this);
      btnCW10xClick(this);
      booldo = true;
   }

   // 固定為Z Down方向
   if(booldo == false) {
      btnDown1xClick(this);
   }

}
//---------------------------------------------------------------------------
// 2020 3 4 - chc Wheel down
void __fastcall TMainForm::FormMouseWheelDown(TObject *Sender,
      TShiftState Shift, TPoint &MousePos, bool &Handled)
{
int x,y,w,h,dh;
int z1x,z1y,z10x,z10y,z100x,z100y,z1000x,z1000y;
bool booldo = false;

   // 2021 4 27 - chc Scroll
   if(cbWaferMap->Checked == true) {
      int factor;
      factor = tbZoom->Position;
      if(rgWheelDirection->ItemIndex == 0)
         sbWaferMap->VertScrollBar->Position += (5*factor);
      else
         sbWaferMap->HorzScrollBar->Position -= (5*factor);
   }

   // 2020 11 13 - chc OP可操作
   //if(PriorityLevel < PRIORITY_PE)
   //   return;

   // 2021 4 23 - chc 不啟動
   return;

   dh = 30;

   x = MousePos.x;
   y = MousePos.y;

   // 2020 3 6 - chc 對應到Form上
   int fx = MainForm->Left;
   int fy = MainForm->Top;
   x -= fx;
   y -= fy;

   // Z-
   w = btnUp1x->Width;
   h = btnUp1x->Height;
   z1x = btnUp1x->Left + pnlLeftWindow->Left;
   z1y = btnUp1x->Top + pnlLeftWindow->Top + dh;
   z10x = btnUp5x->Left + pnlLeftWindow->Left;
   z10y = btnUp5x->Top + pnlLeftWindow->Top + dh;
   z100x = btnUp10x->Left + pnlLeftWindow->Left;
   z100y = btnUp10x->Top + pnlLeftWindow->Top + dh;
   z1000x = btnUp100x->Left + pnlLeftWindow->Left;
   z1000y = btnUp100x->Top + pnlLeftWindow->Top + dh;
   if((x >= z1x && x <= (z1x+w)) && (y >= z1y && y <= (z1y+h))) {
      // => Down就是往下
      //btnUp1xClick(this);
      btnDown1xClick(this);
      booldo = true;
   }
   else if((x >= z10x && x <= (z10x+w)) && (y >= z10y && y <= (z10y+h))) {
      // => Down就是往下
      //btnUp5xClick(this);
      btnDown5xClick(this);
      booldo = true;
   }
   else if((x >= z100x && x <= (z100x+w)) && (y >= z100y && y <= (z100y+h))) {
      // => Down就是往下
      //btnUp10xClick(this);
      btnDown10xClick(this);
      booldo = true;
   }
   else if((x >= z1000x && x <= (z1000x+w)) && (y >= z1000y && y <= (z1000y+h))) {
      // => Down就是往下
      //btnUp100xClick(this);
      btnDown100xClick(this);
      booldo = true;
   }

   // T-
   //x = MousePos.x;
   //y = MousePos.y;
   w = btnCW1x->Width;
   h = btnCW1x->Height;
   z1x = btnCW1x->Left + pnlLeftWindow->Left;
   z1y = btnCW1x->Top + pnlLeftWindow->Top + dh;
   z10x = btnCW5x->Left + pnlLeftWindow->Left;
   z10y = btnCW5x->Top + pnlLeftWindow->Top + dh;
   z100x = btnCW10x->Left + pnlLeftWindow->Left;
   z100y = btnCW10x->Top + pnlLeftWindow->Top + dh;
   if((x >= z1x && x <= (z1x+w)) && (y >= z1y && y <= (z1y+h))) {
      // => Down就是往下
      //btnCW1xClick(this);
      btnCCW1xClick(this);
      booldo = true;
   }
   else if((x >= z10x && x <= (z10x+w)) && (y >= z10y && y <= (z10y+h))) {
      // => Down就是往下
      //btnCW5xClick(this);
      btnCCW5xClick(this);
      booldo = true;
   }
   else if((x >= z100x && x <= (z100x+w)) && (y >= z100y && y <= (z100y+h))) {
      // => Down就是往下
      //btnCW10xClick(this);
      btnCCW10xClick(this);
      booldo = true;
   }

   // Z+
   //x = MousePos.x;
   //y = MousePos.y;
   w = btnDown1x->Width;
   h = btnDown1x->Height;
   z1x = btnDown1x->Left + pnlLeftWindow->Left;
   z1y = btnDown1x->Top + pnlLeftWindow->Top + dh;
   z10x = btnDown5x->Left + pnlLeftWindow->Left;
   z10y = btnDown5x->Top + pnlLeftWindow->Top + dh;
   z100x = btnDown10x->Left + pnlLeftWindow->Left;
   z100y = btnDown10x->Top + pnlLeftWindow->Top + dh;
   z1000x = btnDown100x->Left + pnlLeftWindow->Left;
   z1000y = btnDown100x->Top + pnlLeftWindow->Top + dh;
   if((x >= z1x && x <= (z1x+w)) && (y >= z1y && y <= (z1y+h))) {
      btnDown1xClick(this);
      booldo = true;
   }
   else if((x >= z10x && x <= (z10x+w)) && (y >= z10y && y <= (z10y+h))) {
      btnDown5xClick(this);
      booldo = true;
   }
   else if((x >= z100x && x <= (z100x+w)) && (y >= z100y && y <= (z100y+h))) {
      btnDown10xClick(this);
      booldo = true;
   }
   else if((x >= z1000x && x <= (z1000x+w)) && (y >= z1000y && y <= (z1000y+h))) {
      btnDown100xClick(this);
      booldo = true;
   }
   // T+
   //x = MousePos.x;
   //y = MousePos.y;
   w = btnCCW1x->Width;
   h = btnCCW1x->Height;
   z1x = btnCCW1x->Left + pnlLeftWindow->Left;
   z1y = btnCCW1x->Top + pnlLeftWindow->Top + dh;
   z10x = btnCCW5x->Left + pnlLeftWindow->Left;
   z10y = btnCCW5x->Top + pnlLeftWindow->Top + dh;
   z100x = btnCCW10x->Left + pnlLeftWindow->Left;
   z100y = btnCCW10x->Top + pnlLeftWindow->Top + dh;
   if((x >= z1x && x <= (z1x+w)) && (y >= z1y && y <= (z1y+h))) {
      btnCCW1xClick(this);
      booldo = true;
   }
   else if((x >= z10x && x <= (z10x+w)) && (y >= z10y && y <= (z10y+h))) {
      btnCCW5xClick(this);
      booldo = true;
   }
   else if((x >= z100x && x <= (z100x+w)) && (y >= z100y && y <= (z100y+h))) {
      btnCCW10xClick(this);
      booldo = true;
   }

   // 固定為Z Up方向
   if(booldo == false) {
      btnUp1xClick(this);
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlMoveTopClick(TObject *Sender)
{

   if(PriorityLevel >= PRIORITY_PE) {
      tsMotion->Enabled = true;
      pcMotion->Enabled = true;
      pcOP->Enabled = true;
   }
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc 42 度量測點
void __fastcall TMainForm::btnToCenterClick(TObject *Sender)
{

   btnToAOIPositionClick(this);
}
//---------------------------------------------------------------------------
// 2020 6 22 - chc 維修燈
void __fastcall TMainForm::pnlDOMaintenanceLightClick(TObject *Sender)
{

   // 2020 3 6 - chc 不用
   // 2020 6 22 - chc 維修燈
   //return;
   if(bool_IO_Status == false)
      return;
   if(pnlDOMaintenanceLight->Color == clSilver) {
      HSL_IO_OuStatus |= MAINTENANCE_LIGHT;
      pnlDOMaintenanceLight->Color = clLime;
      pnlMaintenanceLight->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(MAINTENANCE_LIGHT);
      pnlDOMaintenanceLight->Color = clSilver;
      pnlMaintenanceLight->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);

}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit4
void __fastcall TMainForm::pnlDOCDAClick(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDOCDA->Color == clSilver) {

      // 要DI06 On才能做, 要先將Z/T移到原點
      // 2021 4 30 - chc off才能做
      //if(pnlBit6->Color == clLime) {
      if(pnlBit6->Color == clSilver) {

         // 2020 4 21 - chc 有歸過home才要做
         if(MainForm->boolHomeDone == true)

            // 2020 5 21 - chc 進入Maintenance Mode時由水平改到原點
            //btnToInputClick(this);
            btnToOriginalClick(this);

         HSL_IO_OuStatus |= 0x10;
         pnlDOCDA->Color = clLime;

         // 2020 5 20 - chc 要看DI Bit6
         //pnlEFEMMaintenanceMode->Color = clLime;

         // 2021 4 30 - chc 在這裡做, 由DO4決定
         MainForm->pnlEFEMKey->Color = clRed;
         MainForm->pnlEFEMMaintenanceMode->Color = clLime;
         // EMEM Status
         if(EFEMStatus == 0) {
            MainForm->AddErrorLog("[System] 進入EFEM Maintenance Mode.");
         }
         EFEMStatus = 1;

      }
      else {
         pnlSystemMessage->Caption = "以Key啟動後才能進入維修模式.";
      }
   }
   else {
      HSL_IO_OuStatus &= ~(0x10);
      pnlDOCDA->Color = clSilver;

      // 2020 5 20 - chc 要看DI Bit6
      //pnlEFEMMaintenanceMode->Color = clSilver;

      // 2021 4 30 - chc 關Maintenance mode
      MainForm->pnlEFEMKey->Color = clSilver;
      MainForm->pnlEFEMMaintenanceMode->Color = clSilver;
      // EMEM Status
      if(EFEMStatus == 1) {
         MainForm->AddErrorLog("[System] 結束EFEM Maintenance Mode.");
      }   
      EFEMStatus = 0;

   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);

}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit5: EFEM FFU
void __fastcall TMainForm::pnlDOEFEMFFUClick(TObject *Sender)
{

   // 2021 6 11 - chc 不作動
   // 2021 6 16 - chc 恢復: Wafer偏移與此無關
   //return;

   if(bool_IO_Status == false)
      return;

   // FFU
   if(pnlDOEFEMFFU->Color == clSilver) {
      HSL_IO_OuStatus |= 0x20;
      pnlDOEFEMFFU->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x20);
      pnlDOEFEMFFU->Color = clSilver;
   }

   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit6: Stage
void __fastcall TMainForm::pnlDOStageFFUClick(TObject *Sender)
{

   // 2021 6 11 - chc 不作動
   // 2021 6 16 - chc 恢復: Wafer偏移與此無關
   //return;

   // 2020 6 22 - chc Stage FFU On/Off
   //return;
   if(bool_IO_Status == false)
      return;

   // FFU
   if(pnlDOStageFFU->Color == clSilver) {
      HSL_IO_OuStatus |= 0x40;
      pnlDOStageFFU->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x40);
      pnlDOStageFFU->Color = clSilver;
   }

   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit7 - 12"
void __fastcall TMainForm::pnlStageVacuum1Click(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlStageVacuum1->Color == clSilver) {
      HSL_IO_OuStatus |= STAGE_VACUUM1;
      pnlStageVacuum1->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(STAGE_VACUUM1);
      pnlStageVacuum1->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit8
void __fastcall TMainForm::pnlDOReserved8Click(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDOReserved8->Color == clSilver) {
      HSL_IO_OuStatus |= 0x100;
      pnlDOReserved8->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x100);
      pnlDOReserved8->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit9
void __fastcall TMainForm::pnlDOReserved9Click(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDOReserved9->Color == clSilver) {
      HSL_IO_OuStatus |= 0x200;
      pnlDOReserved9->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x200);
      pnlDOReserved9->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit10
void __fastcall TMainForm::pnlDOPolarizerClick(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDOReserved9->Color == clSilver) {
      HSL_IO_OuStatus |= 0x400;
      pnlDOReserved9->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x400);
      pnlDOReserved9->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit11
void __fastcall TMainForm::pnlDORedLampClick(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDORedLamp->Color == clSilver) {
      HSL_IO_OuStatus |= 0x800;
      pnlDORedLamp->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x800);
      pnlDORedLamp->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit12
void __fastcall TMainForm::pnlDOYellowLampClick(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDOYellowLamp->Color == clSilver) {
      HSL_IO_OuStatus |= 0x1000;
      pnlDOYellowLamp->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x1000);
      pnlDOYellowLamp->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit13
void __fastcall TMainForm::pnlDOGreenLampClick(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDOGreenLamp->Color == clSilver) {
      HSL_IO_OuStatus |= 0x2000;
      pnlDOGreenLamp->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x2000);
      pnlDOGreenLamp->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit14
void __fastcall TMainForm::pnlDOBlueLampClick(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDOBlueLamp->Color == clSilver) {
      HSL_IO_OuStatus |= 0x4000;
      pnlDOBlueLamp->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x4000);
      pnlDOBlueLamp->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------
// 2020 3 6 - chc Bit15
void __fastcall TMainForm::pnlDOBuzzerClick(TObject *Sender)
{

   if(bool_IO_Status == false)
      return;
   if(pnlDOBuzzer->Color == clSilver) {
      HSL_IO_OuStatus |= 0x8000;
      pnlDOBuzzer->Color = clLime;
   }
   else {
      HSL_IO_OuStatus &= ~(0x8000);
      pnlDOBuzzer->Color = clSilver;
   }
   APS_set_field_bus_d_output(BoardHSL, HSL_BUS, IO1_ID, HSL_IO_OuStatus);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnEFEMMaintenanceModeClick(TObject *Sender)
{

   pnlDOCDAClick(this);
}
//---------------------------------------------------------------------------
// 2020 3 7 - chc 到原點
void __fastcall TMainForm::btnOriginalClick(TObject *Sender)
{

   // 2020 5 6 - chc 先Disable: pcRobot
   pcEFEMH->Enabled = false;
   pcEFEMR->Enabled = false;

   btnToOriginalPositionClick(this);

   // 2020 5 6 - chc 先Disable: pcRobot
   pcEFEMH->Enabled = true;
   pcEFEMR->Enabled = true;

}
//---------------------------------------------------------------------------
// 2020 3 7 - chc 到0度點
void __fastcall TMainForm::btnZeroPositionClick(TObject *Sender)
{

   // 2020 4 21 - chc Log
   WriteSystemLog("btnToLoadPositionClick: btnZeroPositionClick()");

   // 2020 5 6 - chc 先Disable: pcRobot
   pcEFEMH->Enabled = false;
   pcEFEMR->Enabled = false;

   btnToLoadPositionClick(this);

   // 2020 5 6 - chc 先Disable: pcRobot
   pcEFEMH->Enabled = true;
   pcEFEMR->Enabled = true;

}
//---------------------------------------------------------------------------
// 2020 3 7 - chc 到42度點
void __fastcall TMainForm::btnTargetPositionClick(TObject *Sender)
{

   // 2020 5 6 - chc 先Disable: pcRobot
   pcEFEMH->Enabled = false;
   pcEFEMR->Enabled = false;

   btnToAOIPositionClick(this);

   // 2020 5 6 - chc 先Disable: pcRobot
   pcEFEMH->Enabled = true;
   pcEFEMR->Enabled = true;

}
//---------------------------------------------------------------------------
bool boolMapping = false;
bool boolAlignerORGN = false;

// 2020 5 14 - chc 記錄為Load後的第一片
bool boolFirstAfterLoad = false;

// 2020 7 17 - chc Set Mapping Status
bool boolMappingStatus = true;

// 2020 7 17 - chc LF Up
bool boolLFUpState = false;

// 2020 3 7 - chc Load Wafer(取片)
void __fastcall TMainForm::btnLoadWaferClick(TObject *Sender)
{
int no,timeout;
TPanel *panel,*panel1;
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int cnt = 0;

   // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   boolInLoadWafer = true;

   // 2021 10 17a - chc 取片: 不可用Start - Run
   btnSystemRun->Enabled = false;

   // 2021 7 22 - chc Reset ToLens/ToCCD動作
   ToLensToCCDMode = -1;

   // 2021 10 15 - chc Message
   pnlOperationMessage->Caption = "取片...";

   // 2021 7 17 - chc for test
   if(boolForTest == true) {
      if(boolFirstAfterLoad == true)
         SetFristWafer();
      no = 25 - rgWaferNo->ItemIndex;
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
      // 要看Select
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
      if(panel->Color != clLime || panel1->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: 指定位置無Wafer!";
         WriteSystemLog(pnlOperationMessage->Caption);

         // 2021 9 20a - chc Alarm
         if(boolCSTWithoutWafer == false) {
            boolCSTWithoutWafer = true;
            SetSECSAlarm(41001,1,0,"CST Without Wafer");
         }

         // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
         boolInLoadWafer = false;

         return;
      }
      // 2021 9 20a - chc Alarm
      if(boolCSTWithoutWafer == true) {
         boolCSTWithoutWafer = false;
         SetSECSAlarm(41001,0,0,"CST Without Wafer");
      }

      panel->Color = clOlive;
      panel1->Color = clOlive;
      btnUnloadWafer->Enabled = true;
      // 記錄為Load後的第一片
      boolFirstAfterLoad = false;

      // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
      boolInLoadWafer = false;

      return;
   }

   // 2021 11 12 - chc 關閉UI
   pcSystem->Enabled = false;

   // 2021 8 24 - chc 啟動Start
   tsRun->Enabled = false;
   btnMeasure->Enabled = false;

   // 2021 11 9 - chc 記錄Load button狀態
   bool boolloadbutton;
   boolloadbutton = btnCassetteLoad->Enabled;
   btnCassetteLoad->Enabled = false;

   // 2020 7 17 - chc Mapping Error
   if(boolMappingStatus == false) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "無法取片: Cassette Mapping Error!";
      WriteSystemLog(pnlOperationMessage->Caption);

      // 2021 9 20a - chc Alarm
      if(boolWaferNotSpecified == false) {
         boolWaferNotSpecified = true;
         SetSECSAlarm(41006,1,0,"Wafer not Specified");
      }

      goto error;
   }

   // 2021 9 20a - chc Alarm
   if(boolWaferNotSpecified == true) {
      boolWaferNotSpecified = false;
      SetSECSAlarm(41006,0,0,"Wafer not Specified");
   }

   // 2020 6 22 - chc 記錄取片中
   boolInLoad = true;

   // 2020 5 6 - chc 先Disable: pcRobot
   pcEFEMH->Enabled = false;
   pcEFEMR->Enabled = false;
   pnlCassetteStatus->Enabled = false;

   // 2020 5 14 - chc 記錄為Load後的第一片
   if(boolFirstAfterLoad == true) {
      SetFristWafer();
   }

   pnlLoadWafer->Color = clSilver;
   // 1. 確認LoadPort是否已Load?
   // 2. 確認LoadPort是否已Mapping?
   // 3. 確認Aligner是否Ready? 且無片?
   // 4. 確認Robot是否Ready?
   // 5. 確認Chuck是否無片? 且在Home位置?
   // 6. 確認指定Tray是否有片?
   // 7. 執行Cassette取片, 更新Cassette狀態
   // 8. 執行Aligner放片
   // 9. 執行Aligner Alignment(設定角度)
   // 10. 執行Aligner取片
   // 11. LF上升
   // 12. 執行Chuck放片
   // 13. Chuck Vacuum On
   // 14. LF下降
   // 15. 確認Chuck有Wafer

   //===========================================================================
   // 1. 確認LoadPort是否已Load?
   pnlOperationMessage->Caption = "檢查Cassette...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
      if(pnlLoadPort1CLMP->Color != clLime) {
         pnlOperationMessage->Caption = "取片失敗: LP1 Carrier尚未Load!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   else if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
      if(pnlLoadPort2CLMP->Color != clLime) {
         pnlOperationMessage->Caption = "取片失敗: LP2 Carrier尚未Load!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   // 2. 確認LoadPort是否已Mapping?
   pnlOperationMessage->Caption = "檢查Mapping...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
      if(boolLP1CassetteMapping == false) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: LP1 Carrier尚未Mapping!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   else if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
      if(boolLP2CassetteMapping == false) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: LP2 Carrier尚未Mapping!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   // 3. 確認Aligner是否Ready? 且無片?
   pnlOperationMessage->Caption = "檢查Aligner...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(IsAlignerWithWafer() == true) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner上有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);

      // 2021 9 20a - chc Alarm
      if(boolAlignerWithWafer == false) {
         boolAlignerWithWafer = true;
         SetSECSAlarm(42003,1,0,"Aligner with Wafer");
      }

      goto error;
   }

   // 2021 9 20a - chc Alarm
   if(boolAlignerWithWafer == true) {
      boolAlignerWithWafer = false;
      SetSECSAlarm(42003,0,0,"Aligner with Wafer");
   }

   if(pnlAlignerErrorCode1->Caption != "") {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 2021 9 11a - chc 於robot取Cassette時就做Aligner的入料點動作
   WriteSystemLog("由Timer啟動Aligner到入料點");
   tmAlignerToInPosition->Enabled = true;

   // 4. 確認Robot是否Ready?
   pnlOperationMessage->Caption = "檢查Robot...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(IsRobotWithWafer() == true) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Robot上有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // 2021 5 9 - chc 暫不檢查! @@@
   //if(pnlRobotErrorCode1->Caption != "" && pnlRobotErrorCode1->Caption != "00") {
   //   pnlLoadWafer->Color = clRed;
   //   pnlOperationMessage->Caption = "取片失敗: Robot異常!";
   //   WriteSystemLog(pnlOperationMessage->Caption);
   //   goto error;
   //}
   // 5. 確認Chuck是否有片?
   pnlOperationMessage->Caption = "檢查Chuck...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(IsChuckWithWafer() == true) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Stage有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);

      // 2021 9 20a - chc Alarm
      if(boolChuckWithWaferError == false) {
         boolChuckWithWaferError = true;
         SetSECSAlarm(42002,1,0,"Chuck with Wafer");
      }

      goto error;
   }

   // 2021 9 20a - chc Alarm
   if(boolChuckWithWaferError == true) {
      boolChuckWithWaferError = false;
      SetSECSAlarm(42002,0,0,"Chuck with Wafer");
   }

   // 6. 確認指定Tray是否有片?
   // pnlTray1
   pnlOperationMessage->Caption = "檢查Carrier...";
   WriteSystemLog(pnlOperationMessage->Caption);
   no = 25 - rgWaferNo->ItemIndex;
   panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
   // 要看Select
   panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
   if(panel->Color != clLime || panel1->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: 指定位置無Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);

      // 2021 9 20a - chc Alarm
      if(boolWaferNotSpecified == false) {
         boolWaferNotSpecified = true;
         SetSECSAlarm(41006,1,0,"Wafer not Specified");
      }

      goto error;
   }

   // 2021 9 20a - chc Alarm
   if(boolWaferNotSpecified == true) {
      boolWaferNotSpecified = false;
      SetSECSAlarm(41006,0,0,"Wafer not Specified");
   }

   // 7. W軸移動
   // 2021 6 30c - chc 不必做
   /*
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
      btnToWPosition1Click(this);
   else
      btnToWPosition2Click(this);
   Sleep(100);
   if(pnlToWStatus->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: W軸移動失敗!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   */

   // Load...
   pnlStartMessage->Caption = "Get slot" + IntToStr(no) + "...";
   pnlStartMessage->Visible = true;

   // 在LoopTest中則不做
   // 2021 10 17 - chc 在連線及自動時不問
   //if(btnLoopTestStop->Visible == false) {
   // 2021 11 11 - chc 離線也可以
   //if(btnLoopTestStop->Visible == false && (cbOffLine->Checked == true || cbSECSAtuo->Checked == false)) {
   if(btnLoopTestStop->Visible == false && ((cbOffLine->Checked == false && cbSECSAtuo->Checked == false) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == false))) {

      if(Application->MessageBox(("準備由Carrier取第" + IntToStr(no) + "片?      ").c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }
   }

   // 2021 9 15 - chc 若為SEC連線則使用下載的Recipe
   if(cbOffLine->Checked == false) {
      if(WaferBuffer[no-1].RecipeName != "") {
         cbRecipe->Text = WaferBuffer[no-1].RecipeName;
         pnlOperationMessage->Caption = "[取片]使用SECS Recipe: " + cbRecipe->Text + ", no= " + IntToStr(no);
         WriteSystemLog(pnlOperationMessage->Caption);

         // 2021 10 26 - chc 要呼叫cbRecipeSelect(this);
         cbRecipeSelect(this);

      }
   }

   // 由Cassette取片
   // Slot
   combRobotSlot->ItemIndex = no-1;
   combRobotSlot->Text = IntToStr(no);
   // Stage & Arm
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
      rgRobotStage->ItemIndex = ROBOT_STAGE_LP1;
      rgRobotArm->ItemIndex = ROBOT_ARM_UP;
   }
   else {
      rgRobotStage->ItemIndex = ROBOT_STAGE_LP2;
      rgRobotArm->ItemIndex = ROBOT_ARM_LOW;
   }
   // Get
   rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
   btnRorzeRobotGetClick(this);
   if(pnlRorzeRobotGet->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Robot取片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 2021 10 15 - chc 有片進入Run
   // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause
   //rgEQStatus->ItemIndex = EQ_STATUS_RUN;
   // 2021 10 27 - chc Load後就為EXECUTING, 故不用強制切換
   if(rgEQStatus->ItemIndex != EQ_STATUS_EXECUTING)

      SendSECSStatus(EQ_STATUS_EXECUTING);

   panel->Color = clOlive;
   panel1->Color = clOlive;
   // 8. 執行Aligner放片
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備將Wafer放到Aligner?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }
   }

   // 2021 6 16 - chc 頂Pin上升
   tmPinLiftUp->Enabled = true;

   pnlOperationMessage->Caption = "Aligner放片...";
   WriteSystemLog(pnlOperationMessage->Caption);
   rgRobotStage->ItemIndex = ROBOT_STAGE_ALIGNER;
   // 8"/12"
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
      rgWaferSize->ItemIndex = WAFER_SIZE_8;
   else
      rgWaferSize->ItemIndex = WAFER_SIZE_12;

   // 入料點: 要先設WaferSize
   // 2021 9 11a - chc 於Robot取Cassette時就做Aligner的入料點動作
   //btnInputClick(this);

   if(pnlInput->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner入料點移動失敗!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片: Aligner到入料點.");

   WriteSystemLog("取片: Robot放片到Aligner...");
   // Put
   rgRobotOperation->ItemIndex = ROBOT_HOME_PUT;
   // 確認
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備放片到Aligner?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Robot放片到Aligner, 放棄!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   // Do
   btnRorzeRobotPutClick(this);
   if(pnlRorzeRobotPut->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Robot放片到Aligner異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片: Robot放片到Aligner.");
   // 9. 執行Aligner Alignment
   WriteSystemLog("取片: Aligner do Alignment...");
   // Alignment
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備進行Wafer轉正?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         pnlOperationMessage->Caption = "取片失敗: Aligner對位, 放棄!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   btnAlignerDoClick(this);
   if(pnlAlignerDo->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner對位異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 2021 9 11a - chc 改等指令完成: boolAlignerComplete = false
   boolAlignerComplete = false;

   // 2021 6 30 - chc 先移動c到入料點 => 未移到入料點!!!!
   // 入料點: 要先設WaferSize
   // Clamp
   btnAlignerCLMPClick(this);

   // 2021 9 11a - chc 改等指令完成: boolAlignerComplete = false
   //WaitDelayTime(1000);
   // 2021 9 20a - chc 會有Timeout問題, 先改回用WaitDelayTime(), 但將時間縮為800ms
   // 2021 9 23a - chc final版寫法
   ret = WaitAlignerComplete(6,5000);
   if(ret != 0) {
      pnlOperationMessage->Caption = "Aligner: Clamp Timeout!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // 2021 9 23 - chc 回到1000ms
   //WaitDelayTime(800);
   //WaitDelayTime(1000);

   btnInputClick(this);
   if(pnlInput->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner入料點移動失敗!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 2021 9 30 - chc 改成200ms
   //WaitDelayTime(1000);
   WaitDelayTime(200);

   // 2021 9 11a - chc 改等指令完成: boolAlignerComplete = false
   boolAlignerComplete = false;

   // UnClamp
   // 2021 9 30 - chc 到入料點最後會做UCLM, 故不用做
   /*
   btnAlignerUCLMClick(this);

   // 2021 9 11a - chc 改等指令完成: boolAlignerComplete = false
   //WaitDelayTime(1000);
   // 2021 9 20a - chc 會有Timeout問題, 先改回用WaitDelayTime(), 但將時間縮為800ms
   // 2021 9 23a - chc final版寫法
   ret = WaitAlignerComplete(5,5000);
   if(ret != 0) {
      pnlOperationMessage->Caption = "Aligner: UnClamp Timeout!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // 2021 9 23 - chc 回到1000ms
   //WaitDelayTime(800);
   //WaitDelayTime(1000);
   */

   WriteSystemLog("取片: Aligner do Alignment.");
   // 10. Aligner取片
   WriteSystemLog("取片: Robot由Aligner取片...");
   rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
   rgRobotStage->ItemIndex = ROBOT_STAGE_ALIGNER;
   // Do
   btnRorzeRobotGetClick(this);
   if(pnlRorzeRobotGet->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Robot由Aligner取片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片: Robot由Aligner取片.");
   // 11.
   WriteSystemLog("取片: Stage移動到入料點...");
   // 點位: Stage
   rgRobotStage->ItemIndex = ROBOT_STAGE_STAGE;
   // Stage到入料點
   btnToOriginalPositionClick(this);
   if(pnlToOriginalPosition->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Stage移動到入料點異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片: Robot Stage放片...");
   // Put
   rgRobotOperation->ItemIndex = ROBOT_HOME_PUT;
   // 確認
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備放片到Stage?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         pnlOperationMessage->Caption = "取片失敗: Robot Stage放片, 放棄!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   // 要開靜電Bar及FFU
   StageBar(true);
   // Do
   btnRorzeRobotPutClick(this);
   if(pnlRorzeRobotPut->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Robot Stage放片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片: Robot Stage放片.");
   // 要關靜電Bar
   StageBar(false);
   StageFFU(false);
   // 11.檢查Chuck
   pnlOperationMessage->Caption = "檢查Chuck...";
   if(IsChuckWithWafer() == false) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Stage無Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // Completed
   pnlLoadWafer->Color = clLime;
   pnlOperationMessage->Caption = "取片完成.";
   WriteSystemLog(pnlOperationMessage->Caption);
   btnUnloadWafer->Enabled = true;
   btnLoadWafer->Enabled = false;
   // 記錄為Load後的第一片
   if(boolFirstAfterLoad == true) {
      boolFirstAfterLoad = false;
   }
   pnlOperationMessage->Caption = "";

   // 設定Limit
   btnSetLimit->Visible = true;
   pnlSetLimit->Visible = true;
   pnlSetLimit->Caption = "20000.0";
   pnlSetLimit->Color = (TColor)0x00FFAAAA;
   btnTargetPosition->Visible = false;
   pnlTargetPosition->Visible = false;
   btnMeasure->Enabled = true;

   // 2021 10 17a - chc 若取片為Ok, 則可用Start - Run
   btnSystemRun->Enabled = true;

   // 2021 10 20 - chc 自動Start
   // 2021 11 11 - chc 離線也可以自動作業
   // => 離線仍由人員手動Start(因要選Recipe)
   if(cbOffLine->Checked == false && cbSECSAtuo->Checked == true) {
   //if((cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true)) {

      if(tmAutoStart->Enabled == false)
         tmAutoStart->Enabled = true;
   }

   // 2021 11 9 - chc 設為false
   boolloadbutton = false;

error:

   // 2021 8 24 - chc 啟動Start
   tsRun->Enabled = true;

   // 2021 9 25 - chc 取消顯示
   pnlMoving->Visible = false;

   // 記錄取片中
   boolInLoad = false;
   // Enable: pcRobot
   pcEFEMH->Enabled = true;
   pcEFEMR->Enabled = true;
   pnlCassetteStatus->Enabled = true;
   // 取片...
   pnlStartMessage->Visible = false;

   // 2021 11 9 - chc 記錄Load button狀態
   btnCassetteLoad->Enabled = boolloadbutton;

   // 2021 11 12 - chc 關閉UI
   pcSystem->Enabled = true;

   // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   boolInLoadWafer = false;

   return;
}
//---------------------------------------------------------------------------

// 2020 7 17 - chc LF Down
bool boolLFDownState = false;

// 2020 3 7 - chc UnLoad Wafer
void __fastcall TMainForm::btnUnloadWaferClick(TObject *Sender)
{
int no,timeout;
TPanel *panel,*panel1;
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int cnt = 0;

// 2021 10 17 - chc 記錄為最後一片完成退片
bool boollastwafer = false;

   // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   boolInUnloadWafer = true;

   // 2021 7 22 - chc Reset ToLens/ToCCD動作
   ToLensToCCDMode = -1;

   // 2021 10 15 - chc Message
   pnlOperationMessage->Caption = "退片...";

   // 2021 10 17a - chc 退片要禁用Start - Run
   if(btnSystemRun->Enabled == true)
      btnSystemRun->Enabled = false;

   // 2021 7 17 - chc for test
   if(boolForTest == true) {
      no = 25 - rgWaferNo->ItemIndex;
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
      // 要看Select
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
      if(panel->Color == clLime || panel1->Color == clLime) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: 指定位置有Wafer!";
         WriteSystemLog(pnlOperationMessage->Caption);

         // 2021 9 20a - chc Alarm
         if(boolCSTWithWafer == false) {
            boolCSTWithWafer = true;
            SetSECSAlarm(42001,1,0,"CST with Wafer");
         }

         // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
         boolInUnloadWafer = false;

         return;
      }

      // 2021 9 20a - chc Alarm
      if(boolCSTWithWafer == true) {
         boolCSTWithWafer = false;
         SetSECSAlarm(42001,0,0,"CST with Wafer");
      }

      panel->Color = clLime;
      panel1->Color = clLime;
      // AutoLoad時指到下一片
      if(cbAutoLoad->Checked == true) {
         int outno = ToNextWafer(no);
         if(outno != -1) {
            rgWaferNo->ItemIndex = 25 - outno;
            // 已做完最後一片!
            pnlOperationMessage->Caption = "下一片作業編號: " + IntToStr(outno);
         }
         // 已做完最後一片!
         else {
            pnlOperationMessage->Caption = "已完成最後一片的取退片作業.";
         }
      }
      btnLoadWafer->Enabled = true;

      // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
      boolInUnloadWafer = false;

      return;
   }

   // 2021 11 12 - chc 關閉UI
   pcSystem->Enabled = false;

   // 2021 11 9 - chc 記錄Load button狀態
   bool boolloadbutton;
   boolloadbutton = btnCassetteLoad->Enabled;
   btnCassetteLoad->Enabled = false;

   // 記錄退片中
   boolInUnLoad = true;

   // 先Disable: pcRobot
   pcEFEMH->Enabled = false;
   pcEFEMR->Enabled = false;
   pnlCassetteStatus->Enabled = false;
   pnlUnloadWafer->Color = clSilver;

   // 先到入料點
   WriteSystemLog("退片: Stage到入料點...");
   // Stage到入料點
   btnToOriginalPositionClick(this);
   if(pnlToOriginalPosition->Color != clLime) {
      pnlUnloadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: Stage入料點移動失敗!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("退片: Stage到入料點.");
   //===========================================================================
   // 1. 確認LoadPort是否已Load?
   // 2. 確認LoadPort是否已Mapping?
   // 3. 確認Robot是否Ready? 且無片
   // 4. 確認Chuck是否有片? 且在Home位置?
   // 5. 確認指定Tray是否無片?
   // 6. 執行Chuck取片, LF下降
   // 7. 執行Aligner放片
   // 8. 執行Aligner Alignment(設定角度)
   // 9. 執行Aligner取片
   // 7. 執行Cassette放片
   // 8. 更新Cassette狀態
   // 1. 確認LoadPort是否已Load?
   pnlOperationMessage->Caption = "檢查Carrier...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
      if(pnlLoadPort1Load->Color == clSilver) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: LP1 Carrier尚未Load!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   else {
      if(pnlLoadPort2Load->Color == clSilver) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: LP2 Carrier尚未Load!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   // 2. 確認LoadPort是否已Mapping?
   pnlOperationMessage->Caption = "檢查Mapping...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
      if(boolLP1CassetteMapping == false) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: LP1 Carrier尚未Mapping!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   else if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
      if(boolLP2CassetteMapping == false) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: LP2 Carrier尚未Mapping!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   // (3). 確認Aligner是否Ready? 且無片?
   // => 退片不會經過Aligner
   //pnlOperationMessage->Caption = "檢查Aligner...";
   //WriteSystemLog(pnlOperationMessage->Caption);
   //if(IsAlignerWithWafer() == true) {
   //   pnlLoadWafer->Color = clRed;
   //   pnlOperationMessage->Caption = "退片失敗: Aligner上有Wafer!";
   //   WriteSystemLog(pnlOperationMessage->Caption);
   //   goto error;
   //}
   //if(pnlAlignerErrorCode1->Caption != "") {
   //   pnlLoadWafer->Color = clRed;
   //   pnlOperationMessage->Caption = "退片失敗: Aligner異常!";
   //   WriteSystemLog(pnlOperationMessage->Caption);
   //   goto error;
   //}

   // 3. 確認Robot是否Ready?
   pnlOperationMessage->Caption = "檢查Robot...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(IsRobotWithWafer() == true) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: Robot上有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // 2021 5 9 - chc 暫不檢查! @@@
   //if(pnlRobotErrorCode1->Caption != "" && pnlRobotErrorCode1->Caption != "00") {
   //   pnlLoadWafer->Color = clRed;
   //   pnlOperationMessage->Caption = "退片失敗: Robot異常!";
   //   WriteSystemLog(pnlOperationMessage->Caption);
   //   goto error;
   //}
   // 4. 確認Chuck是否有片? 且在Home位置?
   pnlOperationMessage->Caption = "檢查Chuck...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(IsChuckWithWafer() == false) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: Stage無Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // 5. 確認指定Tray是否無片?
   // pnlTray1
   pnlOperationMessage->Caption = "檢查Carrier...";
   WriteSystemLog(pnlOperationMessage->Caption);
   no = 25 - rgWaferNo->ItemIndex;
   panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
   // 看Select
   panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
   if(panel->Color == clLime || panel1->Color == clLime) {
      pnlUnloadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: 指定位置有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 7. W軸移動
   // 2021 6 30c - chc 不必要做
   //if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
   //   btnToWPosition1Click(this);
   //else
   //   btnToWPosition2Click(this);
   //Sleep(100);
   //if(pnlToWStatus->Color != clLime) {
   //   pnlLoadWafer->Color = clRed;
   //   pnlOperationMessage->Caption = "退片失敗: W軸移動失敗!";
   //   WriteSystemLog(pnlOperationMessage->Caption);
   //   goto error;
   //}

   // Stage & Arm
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
      rgRobotArm->ItemIndex = ROBOT_ARM_UP;
   }
   else {
      rgRobotArm->ItemIndex = ROBOT_ARM_LOW;
   }
   // 退片...
   pnlStartMessage->Caption = "Put slot" + IntToStr(no) + "...";
   pnlStartMessage->Visible = true;
   // 在LoopTest中則不做
   // 2021 10 17 - chc 在連線及自動時不問
   //if(btnLoopTestStop->Visible == false) {
   // 2021 11 11 - chc 離線也可以
   //if(btnLoopTestStop->Visible == false && (cbOffLine->Checked == true || cbSECSAtuo->Checked == false)) {
   if(btnLoopTestStop->Visible == false && ((cbOffLine->Checked == false && cbSECSAtuo->Checked == false) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == false))) {

      if(Application->MessageBox(("準備由Chuck退第" + IntToStr(no) + "片?      ").c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlUnloadWafer->Color = clPurple;
         pnlOperationMessage->Caption = "退片失敗: Robot Stage取片, 放棄!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   pnlOperationMessage->Caption = "Stage取片...";
   WriteSystemLog(pnlOperationMessage->Caption);
   // Get
   rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
   // 點位: Stage
   rgRobotStage->ItemIndex = ROBOT_STAGE_STAGE;
   // Do
   btnRorzeRobotGetClick(this);
   if(pnlRorzeRobotGet->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: Robot由Stage取片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      StageBar(false);
      StageFFU(true);
      goto error;
   }

   WriteSystemLog("退片: Robot由Stage取片.");
   StageBar(true);
   StageFFU(true);
   // 放到Cassette
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
      rgRobotStage->ItemIndex = ROBOT_STAGE_LP1;
   else
      rgRobotStage->ItemIndex = ROBOT_STAGE_LP2;
   // Put
   rgRobotOperation->ItemIndex = ROBOT_HOME_PUT;
   no = 25 - rgWaferNo->ItemIndex;
   // Slot
   combRobotSlot->ItemIndex = no-1;
   combRobotSlot->Text = IntToStr(no);
   // 確認
   WriteSystemLog("退片: Robot 放片到Carrier...");
   if(cbPause->Checked == true) {
      AnsiString msg;
      msg.sprintf("準備放第%d片到Carrier?    ",no);
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlUnloadWafer->Color = clPurple;
         pnlOperationMessage->Caption = "退片失敗: Robot Carrier放片, 放棄!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }

   // Do
   btnRorzeRobotPutClick(this);
   if(pnlRorzeRobotPut->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: Carrier放片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("退片: Robot 放片到Carrier.");
   // 8. 更新Cassette狀態
   panel->Color = clLime;
   panel1->Color = clLime;
   // Completed
   pnlUnloadWafer->Color = clLime;
   pnlOperationMessage->Caption = "退片完成.";
   WriteSystemLog(pnlOperationMessage->Caption);
   btnUnloadWafer->Enabled = false;
   btnLoadWafer->Enabled = true;
   pnlOperationMessage->Caption = "";
   // AutoLoad時指到下一片
   if(cbAutoLoad->Checked == true) {
      int outno = ToNextWafer(no);
      if(outno != -1) {
         rgWaferNo->ItemIndex = 25 - outno;
         // 已做完最後一片!
         pnlOperationMessage->Caption = "下一片作業編號: " + IntToStr(outno);
      }
      // 已做完最後一片!
      else {
         pnlOperationMessage->Caption = "已完成最後一片的取退片作業.";

         // 2021 10 17 - chc 記錄為最後一片完成退片
         boollastwafer = true;

      }
   }

   // 更新pbWafer
   UpdateProgress(no);
   // 設定Limit
   btnSetLimit->Visible = false;
   pnlSetLimit->Visible = false;
   pnlSetLimit->Color = (TColor)0x00FFAAAA;
   btnTargetPosition->Visible = false;
   pnlTargetPosition->Visible = false;
   btnMeasure->Enabled = false;

   // 2021 10 15 - chc 無片進入Idle
   // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause
   //rgEQStatus->ItemIndex = EQ_STATUS_IDLE;
   // 2021 10 27 - chc 不切換狀態, 仍為EXECUTING
   //SendSECSStatus(EQ_STATUS_IDLE);

   // 2021 11 9 - chc 設為true
   boolloadbutton = true;

error:

   // 2021 10 17a - chc 若退片為失敗, 則可用Start - Run
   if(pnlUnloadWafer->Color != clLime)
      btnSystemRun->Enabled = true;

   // 2021 9 25 - chc 取消顯示
   pnlMoving->Visible = false;

   // 記錄退片中
   boolInUnLoad = false;
   // Enable: pcRobot
   pcEFEMH->Enabled = true;
   pcEFEMR->Enabled = true;
   pnlCassetteStatus->Enabled = true;
   // 退片...
   pnlStartMessage->Visible = false;

   // 2021 10 17 - chc 記錄為最後一片完成退片 => UnLoad
   // 2021 11 11 - chc 離線也可以
   //if(boollastwafer == true && cbOffLine->Checked == false && cbSECSAtuo->Checked == true) {
   // 2021 11 15 - chc 寫錯!
   //if(boollastwafer == true && (cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true)) {
   if(boollastwafer == true && ((cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true))) {

      if(tmAutoUnload->Enabled == false) {
         pnlSystemMessage->Caption = "最後一片退片後: 自動進行Timer UnLoad作業.";
         WriteSystemLog(pnlSystemMessage->Caption);
         tmAutoUnload->Enabled = true;
      }
   }

   // 2022 2 13 - chc RCMD: 1-Cancel, 2-Abort SECSRemoteCommand
   else if(SECSRemoteCommand == SECS_REMOTE_CANCEL) {
      pnlSystemMessage->Caption = "退片後處理Cancel: 自動進行Timer UnLoad作業.";
      WriteSystemLog(pnlSystemMessage->Caption);
      tmAutoUnload->Enabled = true;
   }

   // 2021 10 17a - chc 自動取片
   // 2021 11 11 - chc 離線也可以
   //else if(boollastwafer == false && cbOffLine->Checked == false && cbSECSAtuo->Checked == true) {
   // 2021 11 15 - chc 寫錯!
   //else if(boollastwafer == false && (cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true)) {
   else if(boollastwafer == false && ((cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true))) {

      if(tmAutoLoadWafer->Enabled == false) {
         pnlSystemMessage->Caption = "退片後: 自動進行Timer取片作業.";
         WriteSystemLog(pnlSystemMessage->Caption);
         Sleep(1000);
         tmAutoLoadWafer->Enabled = true;
      }
   }

   // 2021 11 9 - chc 記錄Load button狀態
   btnCassetteLoad->Enabled = boolloadbutton;

   // 2021 11 12 - chc 關閉UI
   pcSystem->Enabled = true;

   // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   boolInUnloadWafer = false;

   return;
}
//---------------------------------------------------------------------------
// 2020 3 19 - chc Robot
unsigned char RobotBuffer[500];
int RobotBufferLength = 0;
AnsiString ReplyStrRobot = "";
#define STX             0x02
#define ETX             0x03
// Send: STX-001- LR-ETX-LRC
// Recv: STX-001 X Y Z W-L-0x0-ETX-LRC
// Recv: STX-001 E-Status-ETX-LRC
#define ROBOT_CMD_NONE          0
#define ROBOT_CMD_LR            1
#define ROBOT_CMD_GP            2
#define ROBOT_CMD_LS            3
#define ROBOT_CMD_VACUUM        4
int RobotCmd = ROBOT_CMD_NONE;

#define ROBOT_CMD_STATE_NONE            0
#define ROBOT_CMD_STATE_SENT            1                                       // 4401
#define ROBOT_CMD_STATE_DONE            2                                       // 0601
#define ROBOT_CMD_STATE_TIMEOUT         3
int RobotCmdState = ROBOT_CMD_STATE_NONE;

unsigned char RobotStatus[12];                                                   // 4401 or 0601

bool boolRobotLRCommand = false;
int RobotXPosition;
// Robot是一個命令一個回覆
void __fastcall TMainForm::ybRobotCommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[8192+1];
AnsiString msg;
int len,pos,n;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = ybRobot->Read(Buf,8192);
      if(n > 0) {
         Buf[n] = 0;
         for(int i=0 ; i<n ; i++) {
            // 0x03
            if(Buf[i] == ETX) {
               // Display
               AddRobotRecvMessage(ReplyStrRobot);
               // Recv: @001 0601# (0601 = 完成)
               if(ReplyStrRobot.Pos("0601") > 0) {

                  // 2020 4 27 - chc 若是GP Command則不可以設為None
                  if(RobotCmd != ROBOT_CMD_GP) {

                     RobotCmd = ROBOT_CMD_NONE;

                     // 2020 5 6 - chc Log
                     WriteSystemLog("RobotCmd-1 = ROBOT_CMD_NONE");

                  }
                  RobotCmdState = ROBOT_CMD_STATE_DONE;
                  pnlRobotOperation->Caption = "Ready";
                  pnlRobot->Enabled = true;

                  // 2020 5 6 - chc Log
                  WriteSystemLog("RobotCmdState-1 = ROBOT_CMD_STATE_DONE");

                  // 2020 4 27 - chc Log
                  WriteSystemLog("Robot收到0601");

                  // 2020 5 20 - chc Clear Error Code & Msg
                  boolclearerrorcode = true;

                  // 2020 5 21 - chc Status: S4S3S2S1
                  // 0601
                  sprintf(RobotStatus,"0601");
                  UpdateRobotStatus_1(0);

               }
               else if(ReplyStrRobot.Pos("4401") > 0) {
                  RobotCmdState = ROBOT_CMD_STATE_SENT;
                  pnlRobotOperation->Caption = "Run";

                  // 2020 5 6 - chc Log
                  WriteSystemLog("RobotCmdState-2 = ROBOT_CMD_STATE_SENT");

                  // 2020 4 27 - chc Robot是否已動作?
                  boolRobot4401 = true;
                  // 2020 4 27 - chc Log
                  WriteSystemLog("Robot收到4401");

                  // 2020 5 20 - chc Clear Error Code & Msg
                  boolclearerrorcode = true;

                  // 2020 5 21 - chc Status: S4S3S2S1
                  // 0601
                  sprintf(RobotStatus,"4401");
                  UpdateRobotStatus_1(0);

               }
               // Recv: @001 E0601EE...
               //        12345678901234567890
               else if(ReplyStrRobot.Pos("001 E") > 0) {
                  RobotCmd = ROBOT_CMD_NONE;

                  // 2020 5 6 - chc Log
                  WriteSystemLog("RobotCmd-2 = ROBOT_CMD_NONE");

                  RobotCmdState = ROBOT_CMD_STATE_DONE;

                  // 2020 5 6 - chc Log
                  WriteSystemLog("RobotCmdState-3 = ROBOT_CMD_STATE_DONE");

                  pos = ReplyStrRobot.Pos("001 E");
                  pnlRobotOperation->Caption = "Error";
                  pnlRobotErrorCode->Caption = ReplyStrRobot.SubString(pos+9,2);
                  pnlRobotErrorCode1->Caption = ReplyStrRobot.SubString(pos+9,2);
                  // 060262000000
                  sprintf(RobotStatus,"%s",ReplyStrRobot.SubString(pos+5,12).c_str());
                  pnlRobot->Enabled = true;
                  UpdateRobotStatus_1(1);

                  // 2020 5 14 - chc Error Code
                  PutRobotErrorCodeMsg();

               }
               // 處理DI: 001 0 0x03 LRC
               else if(ReplyStrRobot.Pos("001 ") > 0) {
                  pos = ReplyStrRobot.Pos("001 ");
                  len = ReplyStrRobot.Length();

                  // 2020 5 4 - chc LR
                  // LR: 取得位置 GP 881 ( 0 0 20 0) => 001 677.9 0 82 270.26L 0        => pos=1
                  //                                    123456789012345678901234        => 24
                  //                                        677.9 0 82 270.26L 0
                  //                                        12345678901234567890
                  if(boolRobotLRCommand == true) {
                     WriteSystemLog("boolRobotLRCommand = true, len= " + IntToStr(len));
                     if(len > 12) {
                        WriteSystemLog("len > 12, 進行X 解碼...");
                        AnsiString temp;
                        temp = ReplyStrRobot.SubString(pos+4,len-4);
                        WriteSystemLog("len > 12, 進行X 解碼: " + temp);
                        int pos1 = temp.Pos(" ");
                        int len1 = temp.Length();
                        boolRobotLRCommand = false;
                        RobotXPosition = (int)(temp.SubString(1,pos1-1).ToDouble());
                        pnlRobotXPosition->Caption = IntToStr(RobotXPosition);
                        pnlRobot->Enabled = true;
                        WriteSystemLog("len > 12, 進行X 解碼完成: " + IntToStr(RobotXPosition));

                        // 2020 5 6 - chc 要設Ready!
                        pnlRobotOperation->Caption = "Ready";

                     }
                  }

                  // LID0: 0-Yes, 1-No
                  if(pos == len-4) {
                     RobotCmd = ROBOT_CMD_NONE;

                     // 2020 5 6 - chc Log
                     WriteSystemLog("RobotCmd-3 = ROBOT_CMD_NONE");

                     RobotCmdState = ROBOT_CMD_STATE_DONE;

                     // 2020 5 6 - chc Log
                     WriteSystemLog("RobotCmdState-4 = ROBOT_CMD_STATE_DONE");

                     pnlRobotOperation->Caption = "Ready";
                     pnlRobot->Enabled = true;
                     if(ReplyStrRobot.SubString(len,1) == "0") {
                        pnlRobotWithWafer->Color = clLime;
                        RobotWithWafer = ROBOT_WAFER_YES;
                     }
                     else {
                        pnlRobotWithWafer->Color = clSilver;
                        RobotWithWafer = ROBOT_WAFER_NO;
                     }
                  }

                  // 2020 5 20 - chc Clear Error Code & Msg
                  boolclearerrorcode = true;

               }

               // 2020 5 20 - chc Clear Error Code & Msg
               if(boolclearerrorcode == true) {
                  pnlRobotErrorCode->Caption = "";
                  pnlRobotErrorCode1->Caption = "";
                  pnlRobotErrorMsg->Caption = "";
                  pnlRobotE2->Caption = "";
                  pnlRobotE1->Caption = "";
               }

               // Clear
               ReplyStrRobot = "";
               // Ignore LRC
               i++;
            }
            else {
               if(Buf[i] == STX)
                  ReplyStrRobot += "<";
               else
                  ReplyStrRobot += Buf[i];
            }
         }
      }

   // 先不管
   //}

   if(pnlRobot->Enabled == true) {
      btnRobotEnable->Visible = false;
   }

/*
               // 處理命令
               if(RobotCmd == ROBOT_CMD_GP || RobotCmd == ROBOT_CMD_LS) {
                  if(msg.SubString(1,3) == "001") {
                     if(msg.SubString(5,4) == "0601") {
                        RobotCmdState = ROBOT_CMD_STATE_DONE;
                     }
                     if(msg.SubString(5,4) == "4401") {
                        RobotCmdState = ROBOT_CMD_STATE_SENT;
                     }
                  }
               }
               // 處理命令
               else if(RobotCmd == ROBOT_CMD_LR) {
                  // Error(10碼): Robotstatus(4 character; S4S3S2S1) + Errorcode(2 characters; E2E1) + ErrorAxisInformation(4 characters - XYZW)
                  // S1: 0- 1：ON-LINE MODE
                  //     1- 1：MANUAL MODE
                  //     2- 1：AUTO MODE
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // MANUAL MODE is the switch to enable the automatic operation of the controller.
                  // When MANUAL is selected, the teach pendant is in one of KEY-IN,
                  // TEACH, and CHECK mode.i
                  // S1=“0”=0x30 ........................ After ON-LINE mode, and switches the key switch to the MANUAL
                  // S1=“1”=0x31 ............................. ON-LINE mode
                  // S1=“2”=0x32 ............................. MANUAL mode
                  // S1=“4”=0x34 ............................. AUTO mode
                  // S2: 0- 0：Fixed
                  //     1- 1：STOP signal ON / 0: STOP signal OF
                  //     2- 1：in ES (emergency stop) / 0: not in ES
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // STOP signal is turned ON in operation prohibited status due to GD(operation prohibiting) command.
                  // S2=“1”＝0x31............................ Not in ES and STOP signal is not ON.
                  // S2=“2”＝0x32............................ STOP signal is ON.
                  // S2=“4”＝0x34............................ in ES
                  // S2=“6”＝0x36............................ In ES and STOP signal is ON.
                  // S3: 0- 0：Z-axis zone output (SAFTY ZONE)
                  //     1- 1：Positioning completed / 0: not completed
                  //     2- 1：A-CAL completed / 0: not completed
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // Z-axis zone outputi is set to "1" when the following condition is satisfied.
                  // The Z-axis coordinate is located at a higher position (smaller value)
                  //      than the value set in System Parameter → [RESPONSE] →[RESPONCE] → [SAFE. ZONE].
                  // S3=“0”＝0x30: Neither A-CAL nor positioning has been completed.
                  // S3=“2”＝0x32: Positioning has been completed.
                  // S3=“4”＝0x34: A-CAL has been completed but positioning has not.
                  // S3=“6”＝0x36: Both A-CAL and positioning have been completed.
                  // S4: 0- 0：Fixed
                  //     1- 0：Fixed
                  //     2- 1：Executing action command 0: End
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // When the robot is being operated by GP and GZ commands, S4 character is "1".
                  // Therefore, “S4+S3+S2+S1”＝[0x30][0x36][0x30][0x31]=“0601” shows that the
                  // robot is in the following status.
                  //      ◆ In ON-LINE MODE
                  //      ◆ A-CAL completed
                  //      ◆ Positioning completed
                  // E2 E1 Error Description
                  //      00 Normal status (no error)
                  //      09 Positioning error (Refer to error axis information.)
                  //      10 Emergency stop state
                  //      20 A-CAL does not end normally. (Refer to error axis information.)
                  //      30 The address is out of the limit.
                  //      31 The robot was tried to be moved to the END(??) point.
                  //      32 FAN alarm status (When FAN alarm function is active.)
                  //      40 The position data is out of the limited area. (Refer to error axis information.)
                  //      51 The robot is in overrun status. (Refer to error axis information.)
                  //      61 Communication command error
                  //      62 A command which could not be executed in the current mode was received.
                  //      63 System data (SG, SP) is corrupted.
                  //      64 The position data cannot be read from the memory card.
                  //      67 Servo parameter is corrupted.
                  //      70 Low encoder battery
                  //      80 The robot received another command during command processing.
                  //      82 Sensor input does not turn ON. (When sensor stop function is active.)
                  //      84 The measurement result is out of the range. (When glass alignment function is active.)
                  //      90 The robot was tried to be operated before A-CAL had been completed.
                  //      95 Coordinate transformation error: The specified position data is invalid.
                  //      A0 Driver error (Refer to error axis information.)
                  //      B0 Servo lock does not work.
                  //      C0 Program error (When HARL-U2 is in use.)
                  //      D0 Aligner error: The line sensor cannot be initialized.
                  //      D1 Aligner error: The wafer edge cannot be detected.
                  //      D3 Aligner error: Too much scans
                  //      D5 Aligner error: The pivot axis rotation frequency is not sufficient.
                  //      D7 Aligner error: The correction amount exceeds the set value.
                  //      D8 Aligner error: Wrong transfer robot is specified.
                  //      D9 Aligner error: Wrong axis is specified for correction output.
                  //      DA Aligner error: Wrong address is specified for correction output.
                  //      DB Aligner error: Wrong direction is specified for motor rotation.
                  //      DC Aligner error: Wrong parameter is specified.
                  //      E0 Axis interlock (When axis interlock function is active.)
                  //      E1, E2=“0”∼“9”(0x30∼0x39): “A”∼“F”(0x41∼0x46)
                  // Axis-Error
                  //      When a positioning error (09)
                  //        0: Normal
                  //        1: Abnormal
                  //      When an A-CAL error (20)
                  //        0: Normal
                  //        1: Abnormal
                  //      When an overrun error (51) has occurred
                  //        0: Normal
                  //        1: Origin side
                  //        2: Overrun side
                  //        3: Both sides
                  //      When a position data outside limited area error (40) has occurred
                  //        0: Normal
                  //        1: Lower limit side
                  //        2: Upper limit side
                  //      When a driver error (A0) has occurred
                  //        0: Normal
                  //        1: Abnormal
                  // 10碼: ErrorCode
*/
}
//---------------------------------------------------------------------------
// 2020 3 10 - chc 頂Pin上升
void __fastcall TMainForm::btnDemoLFUpClick(TObject *Sender)
{
int lvalue;
bool ret;

   // 2020 3 10 - chc 頂Pin上升
   boolLFUpState = false;

   lvalue = edLUp->Text.ToInt();

   // 2021 9 11 - chc 是否加速
   //ret = MoveToL(lvalue);
   ret = MoveToL(lvalue,true);

   // 2020 3 10 - chc 頂Pin上升
   boolLFUpState = ret;

}
//---------------------------------------------------------------------------
// 2020 3 10 - chc 頂Pin下降
void __fastcall TMainForm::btnDemoLFDownClick(TObject *Sender)
{
int lvalue;
bool ret;

   // 2020 3 10 - chc 頂Pin上升
   boolLFDownState = false;

   lvalue = edLDown->Text.ToInt();

   // 2021 9 11 - chc 是否加速
   //ret = MoveToL(lvalue);
   ret = MoveToL(lvalue,true);

   // 2020 3 10 - chc 頂Pin上升
   boolLFDownState = ret;

}
//---------------------------------------------------------------------------
// 2020 3 17 - chc EFEM
bool __fastcall TMainForm::SetupEFEM()
{
bool status = true;

   // 2021 5 5 - chc 作業中訊息
   // 2023 8 2 - chc 不顯示
   //if(pnlMoving->Visible == false) {
   //   pnlMoving->Visible = true;
   //   pnlMoving->Caption = "Working...";
   //}

   // 確認Z/T是否到-EL @@暫
   //if(Application->MessageBox("準備做EFEM初始(Socket,有無wafer...), 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
   //   status = false;
   //   goto end;
   //}

   // 2020 5 21 - chc EFEM Setup Message
   pnlStartMessage->Caption = "EFEM Initialization...";
   pnlStartMessage->Visible = true;

   WriteSystemLog("SetupEFEM() Enter...");
   RobotWithWafer = ROBOT_WAFER_UNKOWN;

   // 2021 4 11 - chc SetupEFEMSocket
   if(EFEMMode == EFEM_RORZE) {

      // 2023 8 2 - chc Init Start
      pnlEFEMUnit->Caption = "Sockeet Checking...";

      WriteSystemLog("SetupEFEM() Rorze...");
      pnlSystemMessage->Caption = "EFEM Init: Socket Connect...";
      SetupEFEMSocket();
      WriteSystemLog("SetupEFEM() Rorze.");
      WaitTime(1000);

      // 2023 8 2 - chc Init Start
      pnlSECSUnit->Caption = "Initialize...";

      // 202 10 21 - chc 做SECS Init
      bool boolsecs;
      WriteSystemLog("SetupEFEM(): SECS Socket Connect...");
      boolsecs = SECSConnect();
      if(boolsecs == false) {
         pnlAlarmMessage->Caption = "SECS Disconnect(Timeout)!";
         pnlStartMessage->Caption = "SECS Disconnected!";

         // 2023 2 21 - chc SECS異常 => SECS未連線
         //pnlMoving->Caption = "SECS異常";
         // 2023 8 2 - chc 不顯示
         //pnlMoving->Caption = "SECS Disconnected!";

         // 2023 8 2 - chc Init Start
         pnlSECSUnit->Caption = "Disconnected!";
         pnlSECSUnit->Font->Color = clRed;

      }
      else {
         WriteSystemLog("SetupEFEM(): SECS Socket ok.");
         // 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause
         SendSECSStatus(EQ_STATUS_INIT);

         // 2023 8 2 - chc Init Start
         pnlSECSUnit->Caption = "Connected.";

      }

      WriteSystemLog("SetupEFEM() Check Socket and COM Port Result...");
      // 檢查Socket / COMPort是否開啟成功?
      if(pnlAlignerReady->Color == clLime && pnlRobotReady->Color == clLime &&
         pnlLoadPort1Ready->Color == clLime && pnlLoadPort2Ready->Color == clLime &&
         pnlRFID18->Color == clLime && pnlRFID112->Color == clLime &&
         pnlRFID28->Color == clLime && pnlRFID212->Color == clLime) {
         WriteSystemLog("SetupEFEM() Socket, Com ok.");
         pnlSystemMessage->Caption = "EFEM初始: Aligner上是否有Wafer?";

         // 2023 8 2 - chc Init Start
         pnlEFEMUnit->Caption = "Wafer Checking...";

         // 2021 4 26 - chc Robot上是否有Wafer?
         if(IsEFEMCDAVacuumError() == true) {
            WriteSystemLog("SetupEFEM(Err) CDA or Vacuum Error!");
            pnlAlarmMessage->Caption = "EFEM CDA or Vacuum Error!";
            //AddAlarmLog(pnlAlarmMessage->Caption);
            status = false;

            // 2023 8 2 - chc Init Start
            pnlEFEMUnit->Caption = "CDA,Vacuum Fail!";
            pnlEFEMUnit->Font->Color = clRed;

            goto end;
         }

         // Aligner上是否有Wafer?
         if(IsAlignerWithWafer() == true) {
            WriteSystemLog("SetupEFEM(Err) Aligner with wafer!");
            pnlAlarmMessage->Caption = "Aligner with Wafer!";
            //AddAlarmLog(pnlAlarmMessage->Caption);
            status = false;

            // 2023 8 2 - chc Init Start
            pnlEFEMUnit->Caption = "Aligner has wafer!";

            goto end;
         }

         // Check上是否有Wafer
         // 2021 7 17 - chc EFEM Setup不檢察Stage
         //pnlSystemMessage->Caption = "EFEM初始: Stage上是否有Wafer?";
         //if(IsChuckWithWafer() == true) {
         //   WriteSystemLog("SetupEFEM() Chuck with wafer!");
         //   pnlAlarmMessage->Caption = "Chuck上有Wafer!";
         //   status = false;
         //   goto end;
         //}

         // Robot上是否有Wafer
         pnlSystemMessage->Caption = "EFEM初始: Robot上是否有Wafer?";
         if(IsRobotWithWafer() == true) {
            WriteSystemLog("SetupEFEM(Err) Robot with wafer!");
            pnlAlarmMessage->Caption = "Robot with Wafer!";
            //AddAlarmLog(pnlAlarmMessage->Caption);
            status = false;

            // 2023 8 2 - chc Init Start
            pnlEFEMUnit->Caption = "Robot has wafer!";

            goto end;
         }
         else {

            // 2021 9 15a - chc 先做RSTA, 不知原因, 重開程式做Robot ORGN會有0003(急停)Error!
            btnRobotRSTAClick(this);
            Sleep(500);

            // 確認Z/T是否到-EL @@暫
            //if(Application->MessageBox("準備做EFEM Setup(Robot ORGN), 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            //   status = false;
            //}
            //else {
               // Robot要做ORGN
               pnlSystemMessage->Caption = "EFEM Init: Robot Homing...";
               btnRobotORGNClick(this);
               if(pnlRobotORGNStatus->Color != clLime) {
                  WriteSystemLog("SetupEFEM(Err) Robot ORGN Fail");
                  pnlAlarmMessage->Caption = "Robot ORGN Fail!";
                  //AddAlarmLog(pnlAlarmMessage->Caption);
                  status = false;

                  // 2023 8 2 - chc Init Start
                  pnlEFEMUnit->Caption = "Robot ORGN Fail";

                  goto end;
               }
               // Set Speed
               else {
                  rgRobotSpeed->ItemIndex = 2;
                  rgRobotSpeedClick(this);
               }
            //}
         }

         // 2023 8 2 - chc Init Start
         pnlEFEMUnit->Caption = "LoadPort Homing...";

         // 2021 4 30 - chc 兩個LoadPort改用Timer同時作業
         tmLoadPort1ORGN->Enabled = true;
         tmLoadPort2ORGN->Enabled = true;
         tmAlignerORGN->Enabled = true;
         long StartTime,StopTime,Elapsedms;
         short StartTick,StopTick;
         GetTimeTic(&StartTime,&StartTick);
         pnlAlignerORGN1->Color = clSilver;
         pnlLoadPort1ORGN->Color = clSilver;
         pnlLoadPort2ORGN->Color = clSilver;
         // 等Aligner/LoadPort1/LoadPort2完成ORGN: 60sec
         int cnt = 0;
         while(1) {
            Application->ProcessMessages();
            Sleep(50);
            cnt++;
            if(cnt >= 10) {
               cnt = 0;
               GetTimeTic(&StopTime,&StopTick);
               Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
               if(Elapsedms > 60000) {
                  WriteSystemLog("SetupEFEM(Err) Aligner,LP1,LP2 ORGN Timeout!");
                  pnlAlarmMessage->Caption = "SetupEFEM() Aligner,LP1,LP2 ORGN Timeout!";
                  //AddAlarmLog(pnlAlarmMessage->Caption);
                  status = false;

                  // 2023 8 2 - chc Init Start
                  pnlEFEMUnit->Caption = "LoadPort Fail!";
                  pnlEFEMUnit->Font->Color = clRed;

                  goto end;
               }
            }
            // 彰化
            // 2023 8 1 - chc LP2
            //if(pnlAlignerORGN1->Color != clSilver && pnlLoadPort1ORGN->Color != clSilver && pnlLoadPort1ORGN->Color != clSilver) {
            if(pnlAlignerORGN1->Color != clSilver && pnlLoadPort1ORGN->Color != clSilver && pnlLoadPort2ORGN->Color != clSilver) {

               break;
            }
         }
         // 彰化
         // 2023 8 1 - chc LP2
         //if(pnlAlignerORGN1->Color == clRed || pnlLoadPort1ORGN->Color == clRed || pnlLoadPort1ORGN->Color == clRed) {
         if(pnlAlignerORGN1->Color == clRed || pnlLoadPort1ORGN->Color == clRed || pnlLoadPort2ORGN->Color == clRed) {

            WriteSystemLog("SetupEFEM(Err) Aligner or LP1 or LP2 ORGN Fail");
            status = false;

            // 2023 8 2 - chc Init Start
            pnlEFEMUnit->Caption = "Aligner or LoadPort Fail!";

            goto end;
         }

         // 2021 4 30 - chc Aligner & 兩個LoadPort改用Timer同時作業
         // Aligner ORGN, Loadport Init....
         //pnlSystemMessage->Caption = "EFEM初始: Aligner原點復歸...";
         //btnRorzeAlignerORGNClick(this);
         //if(pnlAlignerORGN1->Color != clLime) {
         //   WriteSystemLog("SetupEFEM() Aligner ORGN Fail");
         //   pnlAlarmMessage->Caption = "Aligner原點復歸失敗!";
         //   status = false;
         //   goto end;
         //}
         //pnlSystemMessage->Caption = "EFEM初始: LoadPort1原點復歸...";
         //btnLoadPort1ORGNClick(this);
         //if(pnlLoadPort1ORGN->Color != clLime) {
         //   WriteSystemLog("SetupEFEM() LoadPort1 ORGN Fail");
         //   pnlAlarmMessage->Caption = "LoadPort1原點復歸失敗!";
         //   status = false;
         //   goto end;
         //}
         //pnlSystemMessage->Caption = "EFEM初始: LoadPort2原點復歸...";
         //btnLoadPort2ORGNClick(this);
         //if(pnlLoadPort2ORGN->Color != clLime) {
         //   WriteSystemLog("SetupEFEM() LoadPort2 ORGN Fail");
         //   pnlAlarmMessage->Caption = "LoadPort2原點復歸失敗!";
         //   status = false;
         //   goto end;
         //}

         pnlStartMessage->Caption = "EFEM Init: succ.";
      }
      else {
         WriteSystemLog("SetupEFEM(Err) Socket or COM port異常!");
         //AddAlarmLog("SetupEFEM() Socket or COM port Error!");
         status = false;

         // 2023 8 2 - chc Init Start
         pnlEFEMUnit->Caption = "Socket or COM Fail!";

      }
   }
   else {
      WriteSystemLog("SetupEFEM() Hirata...");

      // init Com Port
      boolRobotStatus = true;
      RobotButton();
      boolLoadPortStatus = true;
      LoadPortButton(0);
      boolAlignerStatus = true;
      AlignerButton();
      InitRobotCom();
      WaitTime(500);
      InitLoadPortCom();
      WaitTime(500);
      InitAlignerCom();

      WaitTime(1000);
      WriteSystemLog("SetupEFEM() COM init.");

      // Robot ORGN
      if(boolRobotStatus == true)
         btnRobotOriginalClick(this);
      else
         status = false;

      WaitTime(1000);
      WriteSystemLog("SetupEFEM() Robot ORGN.");

      // LoadPort GetStatus
      if(boolLoadPortStatus == true)
         btnLoadPortStasClick(this);
      else
         status = false;

      WaitTime(1000);
      WriteSystemLog("SetupEFEM() LoadPort STAS.");

      // 2020 5 4 - chc 檢查pnlLoadPortS3是否為2(Load)
      if(pnlLoadPortS3->Caption == "2")
         btnCassetteLoad->Caption = "UnLoad";
      else
         btnCassetteLoad->Caption = "Load";

      // 2020 5 6 - chc 要做Unload
      btnLoadPortUnLoadClick(this);

      // Aligner ORGN
      if(boolAlignerStatus == true)
         btnAlignerORGNClick(this);
      else
         status = false;

      // 檢查
      WaitTime(2000);
      WriteSystemLog("SetupEFEM() Aligner ORGN.");

      if(pnlRobotOriginal->Color != clLime || pnlRobotOperation->Caption != "Ready") {
         status = false;
         pnlRobotReady->Color = clRed;

         // 2020 5 6 - chc Log
         if(pnlRobotOriginal->Color != clLime)
            WriteSystemLog("#pnlRobotOriginal->Color != clLime");
         else
            WriteSystemLog("#pnlRobotOperation->Caption != Ready");

      }
      if(pnlAlignerORGN->Color != clLime || pnlLoadPortOperation->Caption != "Ready") {
         status = false;
         pnlAlignerReady->Color = clRed;
         pnlAlignerReady1->Color = clRed;
      }
      if(pnlLoadPortOperation->Caption != "Ready") {
         status = false;
         pnlLoadPortReady->Color = clRed;
      }

      // 2020 7 14 - chc 設為enable
      else {
         btnCassetteLoad->Enabled = true;

         // 2021 11 12 - ch cog
         WriteSystemLog("SetupEFEM() - 啟動Load Button");

      }

      // 2020 5 21 - chc EFEM Setup Message
      pnlStartMessage->Visible = false;
   }
end:

   if(status == false) {
      pnlStartMessage->Caption = "EFEM initial failure!";
      //AddAlarmLog(pnlStartMessage->Caption);
      pnlMoving->Caption = "Restart the System.";

      // 2023 8 2 - chc Init Start
      //pnlEFEMUnit->Caption = "Fail";
      pnlEFEMUnit->Font->Color = clRed;

   }
   else {

      // 2021 5 5 - chc 作業中訊息
      pnlMoving->Visible = false;

      // 2023 8 2 - chc Init Start
      pnlEFEMUnit->Caption = "Completed.";

   }

   WriteSystemLog("SetupEFEM() Leave.");
   return status;
}
//---------------------------------------------------------------------------
// 2020 3 7 - chc Robot
void __fastcall TMainForm::btnRobotConnectClick(TObject *Sender)
{

   try {
      MainForm->ybRobot->SettingsDialog(this,true);
      if(boolRobotStatus == false)
         MainForm->ybRobot->Active = true;
      boolRobotStatus = true;
      RobotButton();
   }
   catch(Exception &e) {
      ShowMessage("ybRobot: " + e.Message);
      boolRobotStatus = false;
      RobotButton();
      MainForm->pnlSystemMessage->Caption = "COM Port(Robot) 啟動失敗!";
      MainForm->WriteSystemLog(MainForm->pnlSystemMessage->Caption);
   }
   UpdateRobotStatus();
}
//---------------------------------------------------------------------------
// 2020 3 17 - chc Robot Active
void __fastcall TMainForm::UpdateRobotStatus()
{

   if(boolRobotStatus == true) {
      pnlRobotStatus->Color = clLime;
      pnlRobotReady->Color = clLime;
   }
   else {
      pnlRobotStatus->Color = clRed;
      pnlRobotReady->Color = clRed;

      // 2020 5 6 - chc Log
      if(pnlRobotOriginal->Color != clLime)
         WriteSystemLog("#UpdateRobotStatus(): boolRobotStatus為false!");

   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortConnectClick(TObject *Sender)
{

   try {
      MainForm->ybLoadPort->SettingsDialog(this,true);
      if(boolLoadPortStatus == false)
         MainForm->ybLoadPort->Active = true;
      boolLoadPortStatus = true;
      LoadPortButton(1);
   }
   catch(Exception &e) {
      ShowMessage("ybLoadPort: " + e.Message);
      boolLoadPortStatus = false;
      LoadPortButton(0);
      MainForm->pnlSystemMessage->Caption = "COM Port(LoadPort) 啟動失敗!";
      MainForm->WriteSystemLog(MainForm->pnlSystemMessage->Caption);
   }
   UpdateLoadPortStatus();
}
//---------------------------------------------------------------------------
// 2020 3 17 - chc LoadPort Active
void __fastcall TMainForm::UpdateLoadPortStatus()
{

   if(boolLoadPortStatus == true) {
      pnlLoadPortStatus->Color = clLime;
      pnlLoadPortReady->Color = clLime;
   }
   else {
      pnlLoadPortStatus->Color = clRed;
      pnlLoadPortReady->Color = clRed;
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlignerConnectClick(TObject *Sender)
{

   try {
      MainForm->ybAligner->SettingsDialog(this,true);
      if(boolAlignerStatus == false)
         MainForm->ybAligner->Active = true;
      boolAlignerStatus = true;
      AlignerButton();
   }
   catch(Exception &e) {
      ShowMessage("ybAligner: " + e.Message);
      boolAlignerStatus = false;
      AlignerButton();
      MainForm->pnlSystemMessage->Caption = "COM Port(Aligner) 啟動失敗!";
      MainForm->WriteSystemLog(MainForm->pnlSystemMessage->Caption);
   }
   UpdateAlignerStatus();
}
//---------------------------------------------------------------------------
// 2020 3 17 - chc Aligner Active
void __fastcall TMainForm::UpdateAlignerStatus()
{

   if(boolAlignerStatus == true) {
      pnlAlignerStatus->Color = clLime;
      pnlAlignerReady->Color = clLime;
      pnlAlignerReady1->Color = clLime;
   }
   else {
      pnlAlignerStatus->Color = clRed;
      pnlAlignerReady->Color = clRed;
      pnlAlignerReady1->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// 2020 3 19 - chc SET
void __fastcall TMainForm::btnAlignerSetClick(TObject *Sender)
{
char command[100];

   // RSET: Error reset
   if(rgAlignerSet->ItemIndex == 0)
      sprintf(command,"SET:RSET;");
   // OFSE: 1/10度, 0000~3600
   else if(rgAlignerSet->ItemIndex == 1)
      sprintf(command,"SET:OFSE%04d;",edAlignerDegree->Text.ToInt());
   // OFS2: 1/10度, 0000~3600
   else if(rgAlignerSet->ItemIndex == 2)
      sprintf(command,"SET:OFS2%04d;",edAlignerDegree->Text.ToInt());
   // SPED: 0000~0100(100%)
   else if(rgAlignerSet->ItemIndex == 3)
      sprintf(command,"SET:SPED%04d;",edAlignerSpeed->Text.ToInt());
   // TYPE: 00~06
   //   00 （06-orientation flat * standard setting)
   //   01 (08-orientation flat * standard setting)
   //   02 (* For enhancement)
   //   03（06-notch * standard setting)
   //   04 (08-notch * standard setting)
   //   05 (12-notch * standard setting)
   //   06 (18-notch * stnadrad setting)
   else if(rgAlignerSet->ItemIndex == 4)
      sprintf(command,"SET:TYPE%02d;",edAlignerType->Text.ToInt());

   edAlignerCmd->Text = command;
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlignerGetClick(TObject *Sender)
{
char command[100];

   // STAS
   if(rgAlignerSet->ItemIndex == 0)
      sprintf(command,"GET:STAS;");
   // OFSE
   else if(rgAlignerSet->ItemIndex == 1)
      sprintf(command,"GET:OFSE;");
   // OFS2
   else if(rgAlignerSet->ItemIndex == 2)
      sprintf(command,"GET:OFS2;");
   // SPED
   else if(rgAlignerSet->ItemIndex == 3)
      sprintf(command,"GET:SPED;");
   // TYPE
   else if(rgAlignerSet->ItemIndex == 4)
      sprintf(command,"GET:TYPE;");

   edAlignerCmd->Text = command;
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------
// Send: 0000MOV:ARLD;
// Recv:
// Recv:
// 結束碼: CR(0x0d)
// 開始碼: 0x01

// Aligner正常Log
// 2019-12-10 15:03:33.723   Aligner : D > A : ~0000SET:OFSE;4E*
// 2019-12-10 15:03:33.887   Aligner : D > A : ~0000INF:OFSE;3F*  (INF = 完成)
// Aligner error log:
// 2020-03-26 20:01:00.191   Aligner2 : A > D : Align : 0000MOV:ARLD;
// 2020-03-26 20:01:00.553   Aligner2 : D > A : ~0000MOV:ARLD;4A*
// 2020-03-26 20:01:37.424   Aligner2 : D > A : ~0000ABS:ARLD/D1;D2* (ABS=有error, D1=error code)

AnsiString ReplyStrAligner = "";
unsigned char AlignerBuffer[500];
int AlignerBufferLength = 0;
unsigned char AlignerStatus[15];
int LoadUnloadState;
// 0-None, 1-OK, 2-NG
int AlignerOFSEState = 0;

void __fastcall TMainForm::ybAlignerCommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[8192+1];
AnsiString msg;
int len,pos,n;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = ybAligner->Read(Buf,8192);
      if(n > 0) {
         Buf[n] = 0;
         for(int i=0 ; i<n ; i++) {
            if(Buf[i] == 0x0d) {
               // Display
               AddAlignerRecvMessage(ReplyStrAligner);
               // Recv: 0000INF:FPML;41* (INF = 完成)
               if(ReplyStrAligner.Pos("INF") > 0) {
                  pnlAlignerOperation->Caption = "Ready";
                  pnlAligner->Enabled = true;
                  boolclearerrorcode = true;
                  // ORGN加做STAS
                  if(ReplyStrAligner.Pos("ORGN") > 0) {
                     boolstas = true;
                     boolAlignerORGN = true;
                     pnlAlignerORGN->Color = clLime;
                     pnlAlignerORGN1->Color = clLime;

                     // 2020 7 17 - chc 是ORGN, 加做STAT
                     WriteSystemLog("Aligner: 是ORGN, 加做STAS...");

                  }
                  if(ReplyStrAligner.Pos("ARLD") > 0) {
                     pnlAlignerAlignment->Color = clLime;
                  }
                  if(ReplyStrAligner.Pos("ACOP") > 0) {
                     pnlAlignerVacuumOff->Color = clLime;
                  }
                  if(ReplyStrAligner.Pos("RSET") > 0) {
                     pnlAlignerReset->Color = clSilver;
                  }

                  // 2020 5 4 - chc 角度設定是否正確?
                  if(ReplyStrAligner.Pos("OFSE") > 0) {
                     AlignerOFSEState = 1;
                  }

               }
               // 0000ABS:FPML/16;D0* (ABS=有error, 16=error code)
               // 12345678901234567890
               else if(ReplyStrAligner.Pos("ABS") > 0) {
                  pos = ReplyStrAligner.Pos("ABS");
                  pnlAlignerOperation->Caption = "Error";
                  pnlAlignerErrorCode->Caption = ReplyStrAligner.SubString(pos+9,2);
                  pnlAlignerErrorCode1->Caption = ReplyStrAligner.SubString(pos+9,2);

                  // 2020 5 14 - chc Error Code
                  PutAlignerCodeMsg();

                  pnlAligner->Enabled = true;
                  if(ReplyStrAligner.Pos("ORGN") > 0) {
                     pnlAlignerORGN->Color = clRed;
                     pnlAlignerORGN1->Color = clRed;
                  }
                  if(ReplyStrAligner.Pos("ARLD") > 0) {
                     pnlAlignerAlignment->Color = clRed;
                  }
                  if(ReplyStrAligner.Pos("ACOP") > 0) {
                     pnlAlignerVacuumOff->Color = clRed;
                  }

                  // 2020 5 4 - chc 角度設定是否正確?
                  if(ReplyStrAligner.Pos("OFSE") > 0) {
                     AlignerOFSEState = 2;
                  }

               }
               else if(ReplyStrAligner.Pos("GET:STAS") > 0) {
                  pos = ReplyStrAligner.Pos("STAS/");
                  pnlAlignerOperation->Caption = "Ready";
                  pnlAligner->Enabled = true;
                  sprintf(AlignerStatus,"%s",ReplyStrAligner.SubString(pos+5,15).c_str());
                  UpdateAlignerStatus_1();
               }
               // 取回設定值: Offset/Speed/Type
               else if(ReplyStrAligner.Pos("GET:") > 0 && ReplyStrAligner.Pos("/") > 0) {
                  pos = ReplyStrAligner.Pos("/");
                  int pos1 = ReplyStrAligner.Pos(";");
                  int len = pos1 - pos - 1;
                  pnlAlignerOperation->Caption = "Ready";
                  pnlAligner->Enabled = true;
                  AnsiString recv;
                  // 0000GET:OFSE/1800;A1
                  // 0000GET:SPED/100;01
                  // 0000GET:TYPE/5;B8
                  //             123456
                  if(ReplyStrAligner.Pos("OFSE") > 0) {
                     recv = ReplyStrAligner.SubString(pos+1,len);
                     edAlignerDegree->Text = recv;
                  }
                  else if(ReplyStrAligner.Pos("OFS2") > 0) {
                     recv = ReplyStrAligner.SubString(pos+1,len);
                     edAlignerDegree->Text = recv;
                  }
                  else if(ReplyStrAligner.Pos("SPED") > 0) {
                     recv = ReplyStrAligner.SubString(pos+1,len);
                     edAlignerSpeed->Text = recv;
                  }
                  else if(ReplyStrAligner.Pos("TYPE") > 0) {
                     recv = ReplyStrAligner.SubString(pos+1,len);
                     edAlignerType->Text = recv;
                  }
               }

               // 2020 5 20 - chc Clear Error Code & Msg
               if(boolclearerrorcode == true) {
                  // Error code
                  pnlAlignerErrorCode->Caption = "";
                  pnlAlignerErrorCode1->Caption = "";
                  pnlAlignerErrorMsg->Caption = "";
               }

               // Clear
               ReplyStrAligner = "";
            }
            else {
               if(Buf[i] == 0x01)
                  ReplyStrAligner += "<";
               else
                  ReplyStrAligner += Buf[i];
            }
         }
      }

   // 先不管
   //}

   if(pnlAligner->Enabled == true) {
      btnAlignerEnable->Visible = false;
      if(boolstas == true) {

         // 2020 7 17 - chc 是ORGN, 改由Timer加做STAT
         WriteSystemLog("Aligner: 是ORGN, 執行GetStas...");
         btnAlignerStasClick(this);
         //WriteSystemLog("Aligner: 是ORGN, 設定timer執行GetStas...");
         //tmAlignerStas->Enabled = true;

      }
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRobotCMDClick(TObject *Sender)
{
unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
char checksum;

// 使用或不使用unsigned均一樣的結果GP 880 ( 0 0 40 0)
unsigned char checksum1;

   if(boolRobotStatus == false) {
      pnlRobotMessage->Caption = "未連線!";

      // 2020 5 6 - chc Log
      WriteSystemLog("btnRobotCMDClick: Robot尚未連線!");

      return;
   }

   // robot
   if(cbRobot->Checked == true)
      sprintf(command,"001 %s%c",edRobotCmd->Text,0x03);
   else
      // Aligner
      sprintf(command,"0000%s",edRobotCmd->Text);

   len = strlen(command);
   checksum = 0;
   checksum1 = 0;
   for(int i=0 ; i<len ; i++) {

      // Robot
      if(cbRobot->Checked == true) {
         checksum ^= command[i];
         checksum1 ^= command[i];
      }
      else
         // Aligner
         checksum += command[i];
   }

   // Robot
   // Robot
   if(cbRobot->Checked == true) {
      sprintf(buf,"%c%s",0x02,command);
      len = strlen(buf);
      sprintf(buf,"%c%s%c",0x02,command,checksum);
      len++;
      buf[len] = 0x0;
   }
   else {

      // Aligner
      int c1,c2;
      c1 = checksum & 0xf0;
      c1 = c1 >> 4;
      c2 = checksum & 0x0f;
      if(c1 < 10)
         c1 = c1 + '0';
      else
         c1 = c1 - 10 + 'A';
      if(c2 < 10)
         c2 = c2 + '0';
      else
         c2 = c2 - 10 + 'A';
      sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);
      len = strlen(buf);
      buf[len] = 0x0;
   }

   // 2020 5 6 - chc Log
   WriteSystemLog("btnRobotCMDClick: run...");

   ybRobot->Write(buf,len);
   pnlRobotOperation->Caption = "Busy";
   pnlRobot->Enabled = false;
   btnRobotEnable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   // 2020 5 6 - chc 不能有Sleep, 會卡住!
   //Sleep(100);

   AddRobotSendMessage(msg);
   pnlRobotMessage->Caption = msg;

   // 2020 5 6 - chc Log
   WriteSystemLog("btnRobotCMDClick: edRobotCmd= " + edRobotCmd->Text);

   // 2020 5 4 - chc GP要WaitRobotDone
   if(edRobotCmd->Text.SubString(1,2) == "GP") {
      bool ret;
      RobotCmdState = ROBOT_CMD_STATE_NONE;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmdState-5 = ROBOT_CMD_STATE_NONE");

      RobotCmd = ROBOT_CMD_GP;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-4 = ROBOT_CMD_GP");

      // Robot是否已動作?
      boolRobot4401 = false;
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = edRobotCmd->Text + ": Timeout!";
         return;
      }
   }

}
//---------------------------------------------------------------------------
// Hirata
// 放片: 180/181/182/183
// rgWaferLocation: LoadPort(680/681/682/683), Aligner(610/611/612/613), Chuck(1610/1611/1612/1613)
void __fastcall TMainForm::btnRobotPutClick(TObject *Sender)
{
bool ret;
int no,zvalue,waferno;
AnsiString msg,offsetstr,name;
TPanel *panel;

   // 2020 4 23 - chc LoadPort
   pnlRobotPut->Color = clSilver;
   // 確認是否已Load?
   if(rgWaferLocation->ItemIndex == 0) {
      btnLoadPortStasClick(this);
      ret = WaitLoadPortDone(5000);
      if(ret == false) {
         pnlRobotMessage->Caption = "LoadPort: Timeout!";
         pnlRobotPut->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      if(pnlLoadPortS3->Caption != "2") {
         pnlRobotMessage->Caption = "LoadPort: 動作中!";
         pnlRobotPut->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
   }

   // 2020 4 23 - chc LoadPort
   offsetstr.sprintf(" ( 0 0 0 0)");
   waferno = combRobotTrayNo->Text.ToInt();

   // 點位
   if(rgWaferLocation->ItemIndex == 0) {
      name = "Cassette";
      no = 680;

      // 2020 4 23 - chc LoadPort
      // 2020 4 27 - chc 降1mm
      offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10);
      //offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10-1);

   }
   else if(rgWaferLocation->ItemIndex == 1) {
      name = "Aligner";
      no = 610;
   }
   else if(rgWaferLocation->ItemIndex == 2) {
      name = "Chuck";
      no = 1610;
   }

   // 2020 4 23 - chc LoadPort, pnlTray1
   if(rgWaferLocation->ItemIndex == 0) {
      msg.sprintf("GP %d%s",no,offsetstr);
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(waferno)));
   }
   else

      msg.sprintf("GP %d",no);
   edRobotCmd->Text = msg;

   // 2020 4 23 - chc Log
   WriteSystemLog("Robot放片1: " + msg);

   // 2020 4 23 - chc LoadPort
   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-1準備由" + name + "放第" + IntToStr(waferno) + "片? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotPut->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-6 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-5 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotPut->Color = clRed;
      return;
   }

   no++;

   // 點位
   // LoadPort
   if(rgWaferLocation->ItemIndex == 0)
      msg.sprintf("GP %d%s",no,offsetstr);
   else

      msg.sprintf("GP %d",no);
   edRobotCmd->Text = msg;

   // 2020 4 23 - chc Log
   WriteSystemLog("Robot放片2: " + msg);

   // 2020 4 23 - chc LoadPort
   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-2準備由" + name + "放第" + IntToStr(waferno) + "片? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotPut->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-7 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-6 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotPut->Color = clRed;
      return;
   }

   // 放真空
   RobotCmd = ROBOT_CMD_VACUUM;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-7 = ROBOT_CMD_VACUUM");

   btnRobotVacuumOffClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = "Vacuum Off: Timeout!";
      pnlRobotPut->Color = clRed;
      return;
   }

   no++;

   // LoadPort
   if(rgWaferLocation->ItemIndex == 0)
      msg.sprintf("GP %d%s",no,offsetstr);
   else

      msg.sprintf("GP %d",no);
   edRobotCmd->Text = msg;

   // 2020 4 23 - chc Log
   WriteSystemLog("Robot放片3: " + msg);

   // 2020 4 23 - chc LoadPort
   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-3準備由" + name + "放第" + IntToStr(waferno) + "片? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotPut->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-8 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-8 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotPut->Color = clRed;
      return;
   }

   MainForm->pnlWaferRobotInformation->Color = (TColor)0x0068C6AA;
   MainForm->pnlWaferRobotInformation1->Color = clSilver;
   MainForm->pnlWaferRobotInformation2->Color = clSilver;
   MainForm->pnlWaferRobotInformation->Refresh();
   MainForm->pnlWaferRobotInformation1->Refresh();
   MainForm->pnlWaferRobotInformation2->Refresh();
   if(rgWaferLocation->ItemIndex == 1) {
      MainForm->pnlWaferAlignerInformation->Color = clLime;
      MainForm->pnlWaferAlignerInformation1->Color = clLime;
      MainForm->pnlWaferAlignerInformation2->Color = clLime;
      MainForm->pnlWaferAlignerInformation->Refresh();
      MainForm->pnlWaferAlignerInformation1->Refresh();
      MainForm->pnlWaferAlignerInformation2->Refresh();
   }
   else if(rgWaferLocation->ItemIndex == 0)
      panel->Color = clLime;

   no++;

   // LoadPort
   if(rgWaferLocation->ItemIndex == 0)
      msg.sprintf("GP %d%s",no,offsetstr);
   else

      msg.sprintf("GP %d",no);
   edRobotCmd->Text = msg;

   // 2020 4 23 - chc Log
   WriteSystemLog("Robot放片4: " + msg);

   // 2020 4 23 - chc LoadPort
   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-4準備由" + name + "放第" + IntToStr(waferno) + "片? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotPut->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-9 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-9 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotPut->Color = clRed;
      return;
   }
   pnlRobotMessage->Caption = "PUT: Succ.";
   pnlRobotPut->Color = clLime;

}
//---------------------------------------------------------------------------
// Hirata
// 取片:
// rgWaferLocatino: LoadPort(880/881/882/883), Aligner(810/811/812/813), Chuck(1810/1811/1812/1813)
void __fastcall TMainForm::btnRobotGetClick(TObject *Sender)
{
bool ret;
int no,zvalue,waferno;
AnsiString msg,offsetstr,name;
TPanel *panel;

// 2021 12 15a - chc 先不用
/*
   pnlRobotGet->Color = clSilver;
   // 確認是否已Load?
   if(rgWaferLocation->ItemIndex == 0) {
      btnLoadPortStasClick(this);
      ret = WaitLoadPortDone(5000);
      if(ret == false) {
         pnlRobotMessage->Caption = "LoadPort: Timeout!";
         pnlRobotGet->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      if(pnlLoadPortS3->Caption != "2") {
         pnlRobotMessage->Caption = "LoadPort: 動作中!";
         pnlRobotGet->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
   }

   offsetstr.sprintf(" (0 0 0 0)");
   waferno = combRobotTrayNo->Text.ToInt();
   // 點位
   if(rgWaferLocation->ItemIndex == 0) {
      no = 880;
      // 2020 4 27 - chc 降1mm
      offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10);
      //offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10-1);
      name = "Cassette";
   }
   else if(rgWaferLocation->ItemIndex == 1) {
      no = 810;
      name = "Aligner";
   }
   else if(rgWaferLocation->ItemIndex == 2) {
      no = 1810;
      name = "Chuck";
   }

   // 2020 4 21 - chc LoadPort
   // 880
   if(rgWaferLocation->ItemIndex == 0) {
      msg.sprintf("GP %d%s",no,offsetstr);
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(waferno)));
   }
   else

      msg.sprintf("GP %d",no);
   edRobotCmd->Text = msg;

   // 2020 4 23 - chc Log
   WriteSystemLog("Robot取片1: " + msg);

   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-1準備由" + name + "取第" + IntToStr(waferno) + "片? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotGet->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-10 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-10 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotGet->Color = clRed;
      return;
   }

   no++;
   // LoadPort
   // 881
   if(rgWaferLocation->ItemIndex == 0)
      msg.sprintf("GP %d%s",no,offsetstr);
   else

      msg.sprintf("GP %d",no);
   edRobotCmd->Text = msg;

   // 2020 4 23 - chc Log
   WriteSystemLog("Robot取片2: " + msg);

   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-2準備由" + name + "取第" + IntToStr(waferno) + "片? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotGet->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-11 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-11 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotGet->Color = clRed;
      return;
   }

   // 開真空
   RobotCmd = ROBOT_CMD_VACUUM;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-12 = ROBOT_CMD_VACUUM");

   btnRobotVacuumOnClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = "Vacuum On: Timeout!";
      pnlRobotGet->Color = clRed;
      return;
   }

   no++;
   // 2020 4 21 - chc LoadPort
   // 882
   if(rgWaferLocation->ItemIndex == 0)
      msg.sprintf("GP %d%s",no,offsetstr);
   else

      msg.sprintf("GP %d",no);
   edRobotCmd->Text = msg;

   // 2020 4 23 - chc Log
   WriteSystemLog("Robot取片3: " + msg);

   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-3準備由" + name + "取第" + IntToStr(waferno) + "片? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotGet->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-12 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-13 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotGet->Color = clRed;
      return;
   }
   MainForm->pnlWaferRobotInformation->Color = clLime;
   MainForm->pnlWaferRobotInformation1->Color = clLime;
   MainForm->pnlWaferRobotInformation2->Color = clLime;
   MainForm->pnlWaferRobotInformation->Refresh();
   MainForm->pnlWaferRobotInformation1->Refresh();
   MainForm->pnlWaferRobotInformation2->Refresh();

   if(rgWaferLocation->ItemIndex == 1) {
      MainForm->pnlWaferAlignerInformation->Color = (TColor)0x0068C6AA;
      MainForm->pnlWaferAlignerInformation1->Color = clSilver;
      MainForm->pnlWaferAlignerInformation2->Color = clSilver;
      MainForm->pnlWaferAlignerInformation->Refresh();
      MainForm->pnlWaferAlignerInformation1->Refresh();
      MainForm->pnlWaferAlignerInformation2->Refresh();
   }
   else if(rgWaferLocation->ItemIndex == 0)
      panel->Color = (TColor)0x0068C6AA;

   // 2020 5 21 - chc 確認是否有真空(有片)?
   btnRobotWithWaferClick(this);
   // 等待
   int timecnt = 0;
   int timemax = 5000;
   while(1) {
      if(RobotWithWafer == ROBOT_WAFER_YES)
         break;
      WaitTime(100);
      timecnt += 100;
      if(timecnt > timemax) {
         pnlRobotMessage->Caption = IntToStr(no) + ": 無片!";
         pnlOperationMessage->Caption = "異常: Robot取片後Fork上無片!";
         pnlRobotGet->Color = clRed;
         return;
      }
   }

   no++;
   // 2020 4 21 - chc LoadPort
   // 883
   if(rgWaferLocation->ItemIndex == 0)
      msg.sprintf("GP %d%s",no,offsetstr);
   else

      msg.sprintf("GP %d",no);
   edRobotCmd->Text = msg;

   // 2020 4 23 - chc Log
   WriteSystemLog("Robot取片4: " + msg);

   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-4準備由" + name + "取第" + IntToStr(waferno) + "片? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotGet->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-13 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-14 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotGet->Color = clRed;
      return;
   }
   pnlRobotMessage->Caption = "GET: Succ.";
   pnlRobotGet->Color = clLime;

   // 2020 4 27 - chc 若為Aligner, 取片後要做ORGN
   if(rgWaferLocation->ItemIndex == 1) {

      // 2020 8 12 - chc TSMC修改: 改用timer
      //long StartTime,StopTime,Elapsedms;
      //short StartTick,StopTick;
      //int timeout = 10000;
      //boolAlignerORGN = false;
      //btnAlignerORGNClick(this);
      //WriteSystemLog("Wait... Aligner ORGN");
      //GetTimeTic(&StartTime,&StartTick);
      //while(1) {
      //   if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime)
      //      break;
      //   Sleep(1);
      //   Application->ProcessMessages();
      //   GetTimeTic(&StopTime,&StopTick);
      //   Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      //   if(Elapsedms > timeout) {
      //      pnlRobotGet->Color = clRed;
      //      pnlOperationMessage->Caption = "取片失敗: Aligner取片後歸Home異常!";
      //      WriteSystemLog(pnlOperationMessage->Caption);
      //     return;
      //   }
      //}

      tmAlignerORG->Enabled = true;

   }
*/
}
//---------------------------------------------------------------------------
// Robot Send
void __fastcall TMainForm::AddRobotSendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmRobotMsg->Lines->Insert(0,putmsg);
   //if(mmRobotMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmRobotMsg->Lines->Count ; i++)
   //      mmRobotMsg->Lines->Delete(i);
   //}

   putmsg = ">" + msg;
   mmRobotMsg->Lines->Insert(0,putmsg);
   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmRobotMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// Robot Recv
void __fastcall TMainForm::AddRobotRecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmRobotMsg->Lines->Insert(0,putmsg);
   //if(mmRobotMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmRobotMsg->Lines->Count ; i++)
   //      mmRobotMsg->Lines->Delete(i);
   //}

   //putmsg = "<" + msg;
   putmsg = msg;
   mmRobotMsg->Lines->Insert(0,putmsg);
   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmRobotMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// LS Command
// OK: STX-001 S4S3S2S1-ETX-LRC
// => 完成的Status?
// NG: STX-001 E-S4S3S2S1E2E1-X-Y-Z-W-ETX-LRC
bool __fastcall TMainForm::WaitRobotDone(timems)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;

// 2020 4 27 - chc 記錄State : 下完Command, 等0.1sec才進來 WaitRobotDone()
int state = 0;

   GetTimeTic(&starttime,&starttick);
   while(1) {

      // 2020 5 6 - chc Log
      WriteSystemLog("WaitRobotDone: 1");

      // 2020 4 27 - chc 由100ms改成200ms
      //Sleep(100);
      Sleep(200);

      // 2020 5 6 - chc Log
      WriteSystemLog("WaitRobotDone: 2");

      Application->ProcessMessages();

      // 2020 5 6 - chc Log
      WriteSystemLog("WaitRobotDone: 3");

      GetTimeTic(&stoptime,&stoptick);
      elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
      if(elapsedms > timems) {
         WriteSystemLog("WaitRobotDone: Timeout!");
         return false;
      }

      // 2020 5 6 - chc Log
      WriteSystemLog("WaitRobotDone: 4, " + IntToStr(RobotCmdState) + "," + IntToStr(RobotCmd));
      if(RobotCmdState == ROBOT_CMD_STATE_SENT && RobotCmd == ROBOT_CMD_GP)
         WriteSystemLog("WaitRobotDone: 5");

      // 2020 4 27 - chc GP Cmd下完要等回覆4401才能下LS
      //if(RobotCmdState == ROBOT_CMD_STATE_NONE || RobotCmdState == ROBOT_CMD_STATE_SENT) {
      if((RobotCmdState == ROBOT_CMD_STATE_NONE && RobotCmd != ROBOT_CMD_GP) ||
         (RobotCmdState == ROBOT_CMD_STATE_SENT && RobotCmd == ROBOT_CMD_GP)) {

         // 2020 5 6 - chc Log
         WriteSystemLog("WaitRobotDone: 6");

         if(RobotCmdState == ROBOT_CMD_STATE_SENT && RobotCmd == ROBOT_CMD_GP) {
            WriteSystemLog("是Robot GP命令, 已收到4401, 再送出LS!");
         }

         // 2020 4 27 - chc 不可以變更狀態
         //RobotCmd = ROBOT_CMD_LS;

         edRobotCmd->Text = "LS";
         btnRobotCMDClick(this);
      }

      if(RobotCmdState == ROBOT_CMD_STATE_NONE && RobotCmd == ROBOT_CMD_GP) {
         WriteSystemLog("是Robot GP命令, 但尚未收到4401!");
      }

      if(RobotCmdState == ROBOT_CMD_STATE_DONE) {

         // 2020 4 27 - chc 要檢查是否已有作動
         if(RobotCmd == ROBOT_CMD_GP) {
            // Robot是否已動作?
            if(boolRobot4401 == false) {
               WriteSystemLog("是Robot GP命令, 已結束(0601)但未收到4401!");

               // 2020 5 21 - chc 不中斷, 再送出LS, 繼續等到Timeout
               //return false;
               edRobotCmd->Text = "LS";
               btnRobotCMDClick(this);
               continue;

            }
         }

         RobotCmd = ROBOT_CMD_NONE;

         // 2020 5 6 - chc Log
         WriteSystemLog("RobotCmd-15 = ROBOT_CMD_NONE");

         return true;
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortMapClick(TObject *Sender)
{

   edLoadPortCmd->Text = "GET:MAPR;";                                           // 1 ~ 25
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortOpenClick(TObject *Sender)
{
int no;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortCloseClick(TObject *Sender)
{
int no;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortClampClick(TObject *Sender)
{
int no;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortVacuumClick(TObject *Sender)
{
int no;

}
//---------------------------------------------------------------------------
// Hirata
// MOV:FPML;
// Load And Mapping(開門, 進入, Mapping) 11sec
void __fastcall TMainForm::btnLoadPortLoadClick(TObject *Sender)
{

   // 2020 5 4 - chc 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPortCmd->Text = "MOV:FPML;";
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortUnLoadClick(TObject *Sender)
{

   // 2020 5 4 - chc 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPortCmd->Text = "MOV:ORGN;";
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlStartMessageClick(TObject *Sender)
{

   pnlStartMessage->Visible = false;
}
//---------------------------------------------------------------------------
// 2020 4 14 - chc 原點
// GP 1 / GP 0
void __fastcall TMainForm::btnRobotOriginalClick(TObject *Sender)
{

   pnlRobotOriginal->Color = clSilver;
   if(SendRobotPosCMD(1) == false) {
      pnlRobotOriginal->Color = clRed;
      return;
   }

   // 2020 4 27 - chc 等待
   WaitTime(1000);

   if(SendRobotPosCMD(0) == false) {
      pnlRobotOriginal->Color = clRed;
      return;
   }
   pnlRobotOriginal->Color = clLime;
}
//---------------------------------------------------------------------------
// 2020 4 14 - chc Robot點位
bool __fastcall TMainForm::SendRobotPosCMD(int position)
{
bool ret;

   if(RobotCmd != ROBOT_CMD_NONE) {
      return false;
   }
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-14 = ROBOT_CMD_STATE_NONE");

   RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-16 = ROBOT_CMD_GP");

   edRobotCmd->Text = "GP " + IntToStr(position);

   // 2020 5 6 - chc 要Refresh
   edRobotCmd->Refresh();

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == true)
      return true;
   return false;
}
//---------------------------------------------------------------------------
// 2020 4 14 - chc Robot點位
void __fastcall TMainForm::btnRobotPosClick(TObject *Sender)
{
int pos;

   pos = edRobotPos->Text.ToInt();
   pnlRobotPos->Color = clSilver;
   if(SendRobotPosCMD(pos) == false)
      pnlRobotPos->Color = clRed;
   else
      pnlRobotPos->Color = clLime;

}
//---------------------------------------------------------------------------
// 2020 4 14 - chc LoadPort
// GET:MAPR;
// 0000GET:MDAT/0000000000000000000000000;1A*( bottem to top)
void __fastcall TMainForm::btnLoadPortCMDClick(TObject *Sender)
{
unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
unsigned char checksum;

   if(boolLoadPortStatus == false) {
      pnlLoadPortMessage->Caption = "未連線!";
      return;
   }


   sprintf(command,"0000%s",edLoadPortCmd->Text);
   len = strlen(command);
   checksum = 0;
   for(int i=0 ; i<len ; i++) {
      checksum += command[i];
   }

   // LoadPort
   int c1,c2;
   c1 = checksum & 0xf0;
   c1 = c1 >> 4;
   c2 = checksum & 0x0f;
   if(c1 < 10)
      c1 = c1 + '0';
   else
      c1 = c1 - 10 + 'A';
   if(c2 < 10)
      c2 = c2 + '0';
   else
      c2 = c2 - 10 + 'A';
   sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);

   len = strlen(buf);
   buf[len] = 0x0;
   ybLoadPort->Write(buf,len);
   pnlLoadPortOperation->Caption = "Busy";
   pnlLoadPort->Enabled = false;
   btnLoadPortEnable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   // 2020 5 6 - chc 不能有Sleep, 會卡住!
   //Sleep(100);

   AddLoadPortSendMessage(msg);
   pnlLoadPortMessage->Caption = msg;
}
//---------------------------------------------------------------------------
// 2020 4 14 - chc Aligner
void __fastcall TMainForm::btnAlignerCMDClick(TObject *Sender)
{
unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
unsigned char checksum;

   if(boolAlignerStatus == false) {
      pnlAlignerMessage->Caption = "未連線!";
      return;
   }

   // Aligner
   sprintf(command,"0000%s",edAlignerCmd->Text);

   len = strlen(command);
   checksum = 0;
   for(int i=0 ; i<len ; i++) {
      checksum += command[i];
   }

   int c1,c2;
   c1 = checksum & 0xf0;
   c1 = c1 >> 4;
   c2 = checksum & 0x0f;
   if(c1 < 10)
      c1 = c1 + '0';
   else
      c1 = c1 - 10 + 'A';
   if(c2 < 10)
      c2 = c2 + '0';
   else
      c2 = c2 - 10 + 'A';
   sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);

   len = strlen(buf);
   buf[len] = 0x0;
   ybAligner->Write(buf,len);
   pnlAlignerOperation->Caption = "Busy";
   pnlAligner->Enabled = false;
   btnAlignerEnable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   // 2020 5 6 - chc 不能有Sleep, 會卡住!
   //Sleep(100);

   AddAlignerSendMessage(msg);
   pnlAlignerMessage->Caption = msg;
}
//---------------------------------------------------------------------------
// LoadPort Send
void __fastcall TMainForm::AddLoadPortSendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmLoadPortMsg->Lines->Insert(0,putmsg);
   //if(mmLoadPortMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmLoadPortMsg->Lines->Count ; i++)
   //      mmLoadPortMsg->Lines->Delete(i);
   //}

   putmsg = ">" + msg;
   mmLoadPortMsg->Lines->Insert(0,putmsg);
   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmLoadPortMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// LoadPort Recv
void __fastcall TMainForm::AddLoadPortRecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmLoadPortMsg->Lines->Insert(0,putmsg);
   //if(mmLoadPortMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmLoadPortMsg->Lines->Count ; i++)
   //      mmLoadPortMsg->Lines->Delete(i);
   //}

   //putmsg = "<" + msg;
   putmsg = msg;
   mmLoadPortMsg->Lines->Insert(0,putmsg);
   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmLoadPortMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// Aliger Send
void __fastcall TMainForm::AddAlignerSendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmAligerMsg->Lines->Insert(0,putmsg);
   //if(mmAligerMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmAligerMsg->Lines->Count ; i++)
   //      mmAligerMsg->Lines->Delete(i);
   //}

   putmsg = ">" + msg;
   mmAlignerMsg->Lines->Insert(0,putmsg);
   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmAligerMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// mmAligerMsg Recv
void __fastcall TMainForm::AddAlignerRecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmAlignerMsg->Lines->Insert(0,putmsg);
   //if(mmAlignerMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmAlignerMsg->Lines->Count ; i++)
   //      mmAlignerMsg->Lines->Delete(i);
   //}

   //putmsg = "<" + msg;
   putmsg = msg;
   mmAlignerMsg->Lines->Insert(0,putmsg);
   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmAlignerMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// Send: 0000MOV:FPML;
// Recv: 0000MOV:FPML;56*
// Recv: 0000INF:FPML;41* (INF = 完成)
// 結束碼: CR(0x0d)
// 開始碼: 0x01
//
// Loaf port 正常log:
// 2020-03-09 09:01:15.357   P2 : A > D : Load : 0000MOV:FPML;
// 2020-03-09 09:01:15.465   P2 : D > A : ~0000MOV:FPML;56*
// 2020-03-09 09:01:27.352   P2 : D > A : ~0000INF:FPML;41* (INF = 完成)
// Loaf port error log
// 2020-03-09 08:59:53.632   P2 : A > D : Load : 0000MOV:FPML;
// 2020-03-09 08:59:53.739   P2 : D > A : ~0000MOV:FPML;56*
// 2020-03-09 09:00:18.186   P2 : D > A : ~0000ABS:FPML/16;D0* (ABS=有error, 16=error code)

// Mapping
//0000GET:MAPR/0000000000000000000000000;1A*( bottem to top)
// Hirata
AnsiString ReplyStrLoadPort = "";
unsigned char LoadPortBuffer[500];
int LoadPortBufferLength = 0;

// 2023 8 2 - chc LP1/LP2
//char CassetteBuffer[30];                                               // 各Wafer的Mapping Status
char CassetteBuffer[2][30];                                               // 各Wafer的Mapping Status

unsigned char LoadPortStatus[30];
unsigned char LoadPortLED[8];
char WorkingBuffer[30];                                               // 各Wafer的Mapping Status

void __fastcall TMainForm::ybLoadPortCommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[8192+1];
AnsiString msg;
int len,pos,n;
bool boolmap = false;
bool boolstas = false;
// Load/Unload LoadUnloadState = 1/2;
bool boollpld = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      // 2020 4 20 - chc 有通訊則Power為On
      pnlLoadPortPower->Color = clLime;
      pnlLoadPortKWF->Color = clLime;

      n = ybLoadPort->Read(Buf,8192);
      if(n > 0) {
         Buf[n] = 0;
         for(int i=0 ; i<n ; i++) {
            if(Buf[i] == 0x0d) {
               // Display
               AddLoadPortRecvMessage(ReplyStrLoadPort);
               // Recv: 0000INF:FPML;41* (INF = 完成)
               if(ReplyStrLoadPort.Pos("INF") > 0) {
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;

                  // 2020 5 20 - chc Clear Error Code & Msg
                  boolclearerrorcode = true;

                  // 2020 5 14 - chc Reset Error Code
                  pnlLoadPortErrorCode1->Caption = "";
                  pnlLoadPortErrorMsg->Caption = "";

                  // FPML
                  if(ReplyStrLoadPort.Pos("FPML") > 0) {
                     boolmap = true;
                     pnlEFEMCassette->Color = clLime;
                     pnlLoadPortLoad->Color = clLime;
                     pnlLoadPortUnLoad->Color = clSilver;
                     btnCassetteLoad->Caption = "UnLoad";
                     LoadUnloadState = 1;
                     boolMapping = true;
                     boollpld = true;

                     // 2020 5 21 - chc 可以取片
                     btnLoadWafer->Enabled = true;

                     // 2020 5 4 - chc 已完成
                     boolLoadUnloadStatus = true;

                     // 2020 5 14 - chc 記錄為Load後的第一片
                     boolFirstAfterLoad = true;

                     // 2020 5 12 - chc 綠燈
                     GreenLamp(true);
                     YellowLamp(false);

                  }
                  else if(ReplyStrLoadPort.Pos("ORGN") > 0) {
                     pnlEFEMCassette->Color = clSilver;
                     pnlLoadPortLoad->Color = clSilver;
                     pnlLoadPortUnLoad->Color = clLime;
                     btnCassetteLoad->Caption = "Load";
                     LoadUnloadState = 2;
                     boollpld = true;

                     // 2023 8 2 - chc LP1/LP2
                     //UpdateCassetteState(0);
                     UpdateCassetteState(LOADPORT_1,0);

                     boolMapping = false;

                     // 2020 5 21 - chc 不可以取片
                     btnLoadWafer->Enabled = false;

                     // 2020 5 4 - chc 已完成
                     boolLoadUnloadStatus = true;

                     // 2020 5 14 - chc 記錄為Load後的第一片
                     boolFirstAfterLoad = false;

                     // 2020 5 12 - chc 綠燈
                     GreenLamp(false);
                     YellowLamp(true);

                  }

                  // 2020 4 29 - chc Mapping
                  else if(ReplyStrLoadPort.Pos("MAPP") > 0) {
                     boolmap = true;
                     LoadUnloadState = 1;
                     boolMapping = true;
                  }

                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPortAlarm->Color = clSilver;
                  pnlLoadPortInterLockCode->Caption = "";
                  pnlLoadPortInterLockCode1->Caption = "";
                  PutLoadPortInterLockMsg();

                  // 2020 4 27 - chc
                  // Power On: PWON, PDON: Normal Mount Status, PDOF: Load sensors and mount are all OFF
                  if(ReplyStrLoadPort.Pos("PWON") > 0) {
                  }
                  if(ReplyStrLoadPort.Pos("PDON") > 0) {
                  }
                  if(ReplyStrLoadPort.Pos("PDOF") > 0) {
                  }

               }
               // 0000GET:STAS/02100010101000000000;45*
               // 12345678901234567890
               else if(ReplyStrLoadPort.Pos("GET:STAS") > 0) {
                  pos = ReplyStrLoadPort.Pos("STAS/");
                  sprintf(LoadPortStatus,"%s",ReplyStrLoadPort.SubString(pos+5,20).c_str());
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  UpdateLoadPortStatus_1();
                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPortAlarm->Color = clSilver;
               }
               // InterLockCode: pnlLoadPortInterLockCode
               // MOV:FPML/19;F3
               // 12345678901234567890
               // Error
               else if(ReplyStrLoadPort.Pos("MOV:FPML/") > 0) {
                  pos = ReplyStrLoadPort.Pos("FPML/");
                  pnlLoadPortInterLockCode->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  pnlLoadPortInterLockCode1->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  PutLoadPortInterLockMsg();
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  pnlLoadPortAlarm->Color = clLime;
                  boolMapping = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // Error
               else if(ReplyStrLoadPort.Pos("MOV:ORGN/") > 0) {
                  pos = ReplyStrLoadPort.Pos("ORGN/");
                  pnlLoadPortInterLockCode->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  pnlLoadPortInterLockCode1->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  PutLoadPortInterLockMsg();
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  pnlLoadPortAlarm->Color = clLime;
                  boolMapping = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // 0000GET:LEST/abcdefgh;45*
               // 12345678901234567890
               else if(ReplyStrLoadPort.Pos("GET:LEST") > 0) {
                  pos = ReplyStrLoadPort.Pos("LEST/");
                  sprintf(LoadPortLED,"%s",ReplyStrLoadPort.SubString(pos+5,8).c_str());
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  UpdateLoadPortLED_1();
                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPortAlarm->Color = clSilver;
               }
               // 0000ABS:FPML/16;D0* (ABS=有error, 16=error code)
               // 12345678901234567890
               else if(ReplyStrLoadPort.Pos("ABS") > 0) {
                  pos = ReplyStrLoadPort.Pos("ABS");
                  pnlLoadPortOperation->Caption = "Error";
                  pnlLoadPortErrorCode->Caption = ReplyStrLoadPort.SubString(pos+9,2);
                  pnlLoadPortErrorCode1->Caption = ReplyStrLoadPort.SubString(pos+9,2);

                  // 2020 9 3 - chc Error Code
                  pnlLoadPortS5->Caption = ReplyStrLoadPort.SubString(pos+9,1);
                  pnlLoadPortS6->Caption = ReplyStrLoadPort.SubString(pos+10,1);

                  pnlLoadPort->Enabled = true;
                  // 2020 4 20 - chc ABS則Alarm為On
                  pnlLoadPortAlarm->Color = clLime;

                  // 2020 5 14 - chc Error Code
                  PutLoadPortErrorCodeMsg();

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // 0000GET:MAPR/0000000000000000000000000;1A*( bottem to top)
               // 12345678901234567890
               // CassetteBuffer[25]
               else if(ReplyStrLoadPort.Pos("MAPR") > 0) {

                  // 2020 4 29 - chc 做一次就可以!
                  //for(int i=0 ; i<25 ; i++) {

                     pos = ReplyStrLoadPort.Pos("MAPR");
                     sprintf(CassetteBuffer,"%s",ReplyStrLoadPort.SubString(pos+5,25).c_str());
                     pnlLoadPortOperation->Caption = "Ready";
                     pnlLoadPort->Enabled = true;

                     // 2023 8 2 - chc LP1/LP2
                     //UpdateCassetteState(1);
                     UpdateCassetteState(LOADPORT_1,1);

                     boolstas = true;
                     // 2020 4 20 - chc Succ則Alarm為Off
                     pnlLoadPortAlarm->Color = clSilver;
                     boolMapping = true;

                  //}

               }

               // 2020 4 29 - chc Mapping
               else if(ReplyStrLoadPort.Pos("MOV:MAPP/") > 0) {
                  pos = ReplyStrLoadPort.Pos("MAPP/");
                  pnlLoadPortInterLockCode->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  pnlLoadPortInterLockCode1->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  PutLoadPortInterLockMsg();
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  pnlLoadPortAlarm->Color = clLime;
                  boolMapping = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }

               // 2020 5 20 - chc Clear Error Code & Msg
               if(boolclearerrorcode == true) {
                  // Error code
                  pnlLoadPortErrorCode->Caption = "";
                  pnlLoadPortErrorCode1->Caption = "";
                  pnlLoadPortErrorMsg->Caption = "";
                  // Interlock code
                  pnlLoadPortInterLockCode->Caption = "";
                  pnlLoadPortInterLockCode1->Caption = "";
                  pnlLoadPortInterLockMsg->Caption = "";
               }

               // Clear
               ReplyStrLoadPort = "";
            }
            else {
               if(Buf[i] == 0x01)
                  ReplyStrLoadPort += "<";
               else
                  ReplyStrLoadPort += Buf[i];
            }
         }
      }

   // 先不管
   //}

   if(pnlLoadPort->Enabled == true) {
      btnLoadPortEnable->Visible = false;
      if(boolmap == true)
         btnLoadPortMapClick(this);
   }
   if(pnlLoadPort->Enabled == true) {
      if(boolstas == true) {
         btnLoadPortStasClick(this);
      }
   }
   // Load/Unload LoadUnloadState = 1/2;
   if(boollpld == true) {
      tmLoadUnload->Enabled = true;
   }
}
//---------------------------------------------------------------------------
// CassetteBuffer[]
// pnlTray25
// 0：no wafer exists
// 1：wafer exists
// 2：Cross
// 3：Thickness error（Thick）
// 4：Thickness error（Thin）
// 5：position error
// mode: 0-Clear, 1-Set

// 2023 8 2 - chc LP1/LP2
//void __fastcall TMainForm::UpdateCassetteState(int mode)
void __fastcall TMainForm::UpdateCassetteState(int portno, int mode)
{
TPanel *panel,*panel1;
bool first = true;

   // 2020 7 17 - chc Set Mapping Status
   boolMappingStatus = true;

   for(int i=0 ; i<25 ; i++) {

      // 2023 8 2 - chc LP1/LP2
      if(portno == LOADPORT_2) {
         panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1)));
         panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1) + "Select"));
      }
      else {

         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1)));
         panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      }
      // Set
      if(mode == 1) {

         // 2023 8 2 - chc LP1/LP2
         //if(CassetteBuffer[i] == '0') {
         if(CassetteBuffer[portno][i] == '0') {

            panel->Color = clSilver;
            panel1->Enabled = false;
            panel1->Color = clGray;
         }

         // 2023 8 2 - chc LP1/LP2
         //else if(CassetteBuffer[i] == '1') {
         else if(CassetteBuffer[portno][i] == '1') {

            panel->Color = clLime;
            panel1->Enabled = true;
            panel1->Color = clLime;

            // 第一片位置
            // 小到大
            if(rgLoadOrder->ItemIndex == 0) {
               if(first == true) {
                  first = false;
                  rgWaferNo->ItemIndex = 24 - i;
               }
            }
            // 大到小
            else {
               rgWaferNo->ItemIndex = 24 - i;
            }

         }
         else {
            panel->Color = clRed;
            panel1->Enabled = false;
            panel1->Color = clGray;

            // 2020 7 17 - chc Set Mapping Status
            boolMappingStatus = false;

         }
      }
      // Clear: ORGN(UnLoad)
      else {

         // 2023 8 2 - chc LP1/LP2
         //CassetteBuffer[i] = '0';
         CassetteBuffer[portno][i] = '0';

         panel->Color = clSilver;
         panel1->Enabled = false;
         panel1->Color = clGray;
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlignerORGNClick(TObject *Sender)
{

   pnlAlignerORGN->Color = clSilver;
   pnlAlignerORGN1->Color = clSilver;
   edAlignerCmd->Text = "MOV:ORGN;";
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlignerAlignmentClick(TObject *Sender)
{

   // 2020 5 12 - chc 選擇角度: AlignmentDegreeMode
   int degree;
   if(AlignmentDegreeMode == ALIGNMENT_DEGREE_UNLOAD) {
      // 2020 5 12 - chc 備份角度值
      degree = edAlignerDegree->Text.ToInt();
      edAlignerDegree->Text = edAlignerDegreeOut->Text;
   }

   // 2020 5 4 - chc 先做角度設定
   rgAlignerSet->ItemIndex = 1;
   AlignerOFSEState = 0;
   btnAlignerSetClick(this);

   // 2020 5 12 - chc 還原角度值
   if(AlignmentDegreeMode == ALIGNMENT_DEGREE_UNLOAD) {
      edAlignerDegree->Text = IntToStr(degree);
   }

   int cnt = 0;
   int max = 20;
   while(1) {
      if(AlignerOFSEState == 1) {
         break;
      }
      else if(AlignerOFSEState == 2) {
         pnlAlignerAlignment->Color = clRed;
         pnlAlignerMessage->Caption = "角度設定失敗!";
         return;
      }
      cnt++;
      if(cnt > max) {
         pnlAlignerMessage->Caption = "角度設定Timeout!";
         return;
      }
      WaitTime(100);
   }

   pnlAlignerAlignment->Color = clSilver;
   edAlignerCmd->Text = "MOV:ARLD;";
   btnAlignerCMDClick(this);

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlignerVacuumOffClick(TObject *Sender)
{

   pnlAlignerVacuumOff->Color = clSilver;
   edAlignerCmd->Text = "MOV:ACOP;";
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortStasClick(TObject *Sender)
{

   edLoadPortCmd->Text = "GET:STAS;";
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
//unsigned char LoadPortStatus[20];
void __fastcall TMainForm::UpdateLoadPortStatus_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<20 ; i++) {
      // pnlLoadPortS1
      panel = (TPanel*)(FindComponent("pnlLoadPortS" + IntToStr(i+1)));
      msg.sprintf("%c",LoadPortStatus[i]);
      panel->Caption = msg;
   }
}
//---------------------------------------------------------------------------
//unsigned char AlignerStatus[15];
// A B C D EE FFF G H I JJJ
// 0 1 2 3 45 678 9 0 1 234
// 0 1 2 3 4  5   6 7 8 9
void __fastcall TMainForm::UpdateAlignerStatus_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<10 ; i++) {
      // pnlAlignerS1
      panel = (TPanel*)(FindComponent("pnlAlignerS" + IntToStr(i+1)));
      switch(i) {
         case 0:
         case 1:
         case 2:
         case 3:
            msg.sprintf("%c",AlignerStatus[i]);
            panel->Caption = msg;
            break;
         case 4:
            msg.sprintf("%c%c",AlignerStatus[4],AlignerStatus[5]);
            panel->Caption = msg;

            // 2020 5 20 - chc Error code
            pnlAlignerErrorCode->Caption = msg;
            pnlAlignerErrorCode1->Caption = msg;

            break;
         case 5:
            msg.sprintf("%c%c%c",AlignerStatus[6],AlignerStatus[7],AlignerStatus[8]);
            panel->Caption = msg;
            // 011 - 無片, 111- 有片
            if(msg == "011")
               pnlAlignerWithWafer->Color = clSilver;
            else
               pnlAlignerWithWafer->Color = clLime;
            break;
         case 6:
            msg.sprintf("%c",AlignerStatus[9]);
            panel->Caption = msg;
            break;
         case 7:
            msg.sprintf("%c",AlignerStatus[10]);
            panel->Caption = msg;
            break;
         case 8:
            msg.sprintf("%c",AlignerStatus[11]);
            panel->Caption = msg;
            break;
         case 9:
            msg.sprintf("%c%c%c",AlignerStatus[12],AlignerStatus[13],AlignerStatus[14]);
            panel->Caption = msg;
            break;
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlignerStasClick(TObject *Sender)
{

   edAlignerCmd->Text = "GET:STAS;";

   // 2020 7 17 - chc 是ORGN, 加做STAT
   WriteSystemLog("Aligner: 是ORGN, 送出GET:STAS...");

   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRobotStasClick(TObject *Sender)
{

   edRobotCmd->Text = "LS";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlignerEnableClick(TObject *Sender)
{

   pnlAligner->Enabled = true;
   btnAlignerEnable->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPortEnableClick(TObject *Sender)
{

   pnlLoadPort->Enabled = true;
   btnLoadPortEnable->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRobotEnableClick(TObject *Sender)
{

   pnlRobot->Enabled = true;
}
//---------------------------------------------------------------------------
                  // Error(10碼): Robotstatus(4 character; S4S3S2S1) + Errorcode(2 characters; E2E1) + ErrorAxisInformation(4 characters - XYZW)
                  // S1: 0- 1：ON-LINE MODE
                  //     1- 1：MANUAL MODE
                  //     2- 1：AUTO MODE
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // MANUAL MODE is the switch to enable the automatic operation of the controller.
                  // When MANUAL is selected, the teach pendant is in one of KEY-IN,
                  // TEACH, and CHECK mode.i
                  // S1=“0”=0x30 ........................ After ON-LINE mode, and switches the key switch to the MANUAL
                  // S1=“1”=0x31 ............................. ON-LINE mode
                  // S1=“2”=0x32 ............................. MANUAL mode
                  // S1=“4”=0x34 ............................. AUTO mode
                  // S2: 0- 0：Fixed
                  //     1- 1：STOP signal ON / 0: STOP signal OF
                  //     2- 1：in ES (emergency stop) / 0: not in ES
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // STOP signal is turned ON in operation prohibited status due to GD(operation prohibiting) command.
                  // S2=“1”＝0x31............................ Not in ES and STOP signal is not ON.
                  // S2=“2”＝0x32............................ STOP signal is ON.
                  // S2=“4”＝0x34............................ in ES
                  // S2=“6”＝0x36............................ In ES and STOP signal is ON.
                  // S3: 0- 0：Z-axis zone output (SAFTY ZONE)
                  //     1- 1：Positioning completed / 0: not completed
                  //     2- 1：A-CAL completed / 0: not completed
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // Z-axis zone outputi is set to "1" when the following condition is satisfied.
                  // The Z-axis coordinate is located at a higher position (smaller value)
                  //      than the value set in System Parameter → [RESPONSE] →[RESPONCE] → [SAFE. ZONE].
                  // S3=“0”＝0x30: Neither A-CAL nor positioning has been completed.
                  // S3=“2”＝0x32: Positioning has been completed.
                  // S3=“4”＝0x34: A-CAL has been completed but positioning has not.
                  // S3=“6”＝0x36: Both A-CAL and positioning have been completed.
                  // S4: 0- 0：Fixed
                  //     1- 0：Fixed
                  //     2- 1：Executing action command 0: End
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // When the robot is being operated by GP and GZ commands, S4 character is "1".
                  // Therefore, “S4+S3+S2+S1”＝[0x30][0x36][0x30][0x31]=“0601” shows that the
                  // robot is in the following status.
                  //      ◆ In ON-LINE MODE
                  //      ◆ A-CAL completed
                  //      ◆ Positioning completed
                  // E2 E1 Error Description
                  //      00 Normal status (no error)
                  //      09 Positioning error (Refer to error axis information.)
                  //      10 Emergency stop state
                  //      20 A-CAL does not end normally. (Refer to error axis information.)
                  //      30 The address is out of the limit.
                  //      31 The robot was tried to be moved to the END(??) point.
                  //      32 FAN alarm status (When FAN alarm function is active.)
                  //      40 The position data is out of the limited area. (Refer to error axis information.)
                  //      51 The robot is in overrun status. (Refer to error axis information.)
                  //      61 Communication command error
                  //      62 A command which could not be executed in the current mode was received.
                  //      63 System data (SG, SP) is corrupted.
                  //      64 The position data cannot be read from the memory card.
                  //      67 Servo parameter is corrupted.
                  //      70 Low encoder battery
                  //      80 The robot received another command during command processing.
                  //      82 Sensor input does not turn ON. (When sensor stop function is active.)
                  //      84 The measurement result is out of the range. (When glass alignment function is active.)
                  //      90 The robot was tried to be operated before A-CAL had been completed.
                  //      95 Coordinate transformation error: The specified position data is invalid.
                  //      A0 Driver error (Refer to error axis information.)
                  //      B0 Servo lock does not work.
                  //      C0 Program error (When HARL-U2 is in use.)
                  //      D0 Aligner error: The line sensor cannot be initialized.
                  //      D1 Aligner error: The wafer edge cannot be detected.
                  //      D3 Aligner error: Too much scans
                  //      D5 Aligner error: The pivot axis rotation frequency is not sufficient.
                  //      D7 Aligner error: The correction amount exceeds the set value.
                  //      D8 Aligner error: Wrong transfer robot is specified.
                  //      D9 Aligner error: Wrong axis is specified for correction output.
                  //      DA Aligner error: Wrong address is specified for correction output.
                  //      DB Aligner error: Wrong direction is specified for motor rotation.
                  //      DC Aligner error: Wrong parameter is specified.
                  //      E0 Axis interlock (When axis interlock function is active.)
                  //      E1, E2=“0”∼“9”(0x30∼0x39): “A”∼“F”(0x41∼0x46)
                  // Axis-Error
                  //      When a positioning error (09)
                  //        0: Normal
                  //        1: Abnormal
                  //      When an A-CAL error (20)
                  //        0: Normal
                  //        1: Abnormal
                  //      When an overrun error (51) has occurred
                  //        0: Normal
                  //        1: Origin side
                  //        2: Overrun side
                  //        3: Both sides
                  //      When a position data outside limited area error (40) has occurred
                  //        0: Normal
                  //        1: Lower limit side
                  //        2: Upper limit side
                  //      When a driver error (A0) has occurred
                  //        0: Normal
                  //        1: Abnormal
                  // 10碼: ErrorCode
// 12Bytes: 001 E [S4 S3 S2 S1 E2 E1 AX AY AZ AW AR AC]
// Therefore, “S4+S3+S2+S1”＝[0x30][0x36][0x30][0x31]=“0601” shows that the
// robot is in the following status.
// ◆ In ON-LINE MODE
// ◆ A-CAL completed
// ◆ Positioning completed
// When a positioning error (09) has occurred, the information shows if each
// axis is normal or abnormal by using the following values
// 0 - Normal, 1 - Abnormal
// RobotStatus[12]
// 060262000000
// mode 0-S4S3S2S1, 1-All(12 Digits)
void __fastcall TMainForm::UpdateRobotStatus_1(int mode)
{
TPanel *panel;
AnsiString msg;
int code,bit;
int cnt;

   // 2020 5 21 - chc 區分是否全部?
   //for(int i=0 ; i<12 ; i++) {
   if(mode == 0)
      cnt = 4;
   else
      cnt = 12;
   for(int i=0 ; i<cnt ; i++) {

      // pnlAlignerS1
      switch(i) {
         // S4 S3 S2 S1
         //pnlRobotS40
         case 0:
         case 1:
         case 2:
         case 3:
            code = RobotStatus[i] - '0';
            bit = 0x01;
            for(int j=0 ; j<8 ; j++) {
               if(i == 0)
                  panel = (TPanel*)(FindComponent("pnlRobotS4" + IntToStr(j)));
               else if(i == 1)
                  panel = (TPanel*)(FindComponent("pnlRobotS3" + IntToStr(j)));
               else if(i == 2)
                  panel = (TPanel*)(FindComponent("pnlRobotS2" + IntToStr(j)));
               else if(i == 3)
                  panel = (TPanel*)(FindComponent("pnlRobotS1" + IntToStr(j)));
               if((code & bit) != 0)
                  panel->Color = clLime;
               else
                  panel->Color = clSilver;
               bit = bit << 1;
            }
            break;
         case 4:
            msg.sprintf("%c",RobotStatus[4]);
            pnlRobotE2->Caption = msg;
            break;
         case 5:
            msg.sprintf("%c",RobotStatus[5]);
            pnlRobotE1->Caption = msg;

            // 2020 5 20 - chc Error code
            pnlRobotErrorCode->Caption = pnlRobotE2->Caption + pnlRobotE1->Caption;
            pnlRobotErrorCode1->Caption = pnlRobotErrorCode->Caption;

            break;
         case 6:
            msg.sprintf("%c",RobotStatus[6]);
            pnlRobotAX->Caption = msg;
            break;
         case 7:
            msg.sprintf("%c",RobotStatus[7]);
            pnlRobotAY->Caption = msg;
            break;
         case 8:
            msg.sprintf("%c",RobotStatus[8]);
            pnlRobotAZ->Caption = msg;
            break;
         case 9:
            msg.sprintf("%c",RobotStatus[9]);
            pnlRobotAW->Caption = msg;
            break;
         case 10:
            msg.sprintf("%c",RobotStatus[10]);
            pnlRobotAR->Caption = msg;
            break;
         case 11:
            msg.sprintf("%c",RobotStatus[11]);
            pnlRobotAC->Caption = msg;
            break;
      }
   }
}
//---------------------------------------------------------------------------
// SOD0 1 - Vacuum On
void __fastcall TMainForm::btnRobotVacuumOnClick(TObject *Sender)
{

   edRobotCmd->Text = "SOD0 1";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------
// SOD0 2 - Vacuum Off
void __fastcall TMainForm::btnRobotVacuumOffClick(TObject *Sender)
{

   edRobotCmd->Text = "SOD0 2";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------
bool __fastcall TMainForm::WaitLoadPortDone(timems)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;

   GetTimeTic(&starttime,&starttick);
   while(1) {
      Sleep(10);
      Application->ProcessMessages();
      GetTimeTic(&stoptime,&stoptick);
      elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
      if(elapsedms > timems)
         return false;
      if(pnlLoadPortOperation->Caption != "Busy")
         return true;
   }
}
//---------------------------------------------------------------------------
// 是否有片? LID0: 0-有片, 1-無片
// Ret: 001 0/1
void __fastcall TMainForm::btnRobotWithWaferClick(TObject *Sender)
{

   RobotWithWafer = ROBOT_WAFER_UNKOWN;
   pnlRobotWithWafer->Color = clSilver;
   edRobotCmd->Text = "LID0";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAlignerWithWaferClick(TObject *Sender)
{
        
   edAlignerCmd->Text = "GET:STAS;";
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------
// Load/UnLoad LoadPort
// 2020 4 19 - chc Get LED
// GET:LEST/abcdefgh(0-Off, 1-On, 2-blink)
// Presence, Placement, Load, UnLoad, Operator Access1, Status1, Status2, Operator Access2     <KWF-12F, Alarm, Power>
void __fastcall TMainForm::btnLoadPortLEDClick(TObject *Sender)
{

   edLoadPortCmd->Text = "GET:LEST;";
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
//unsigned char LoadPortLED[8];
void __fastcall TMainForm::UpdateLoadPortLED_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<8 ; i++) {
      switch(i) {
         case 0:
            panel = pnlLoadPortPresence;
            break;
         case 1:
            panel = pnlLoadPortPlacement;
            break;
         case 2:
            panel = pnlLoadPortLoad;
            break;
         case 3:
            panel = pnlLoadPortUnLoad;
            break;
         case 4:
            return;
            break;
         case 5:
            panel = pnlLoadPortStatus1;
            break;
         case 6:
            panel = pnlLoadPortStatus2;
            break;
         case 7:
            return;
            break;
      }
      if(LoadPortLED[i] == '0')
         panel->Color = clSilver;
      else if(LoadPortLED[i] == '1')
         panel->Color = clLime;
      else if(LoadPortLED[i] == '2')
         panel->Color = clYellow;

      // Load
      if(i == 2) {

         // 2021 9 30 - chc 直接設為clLime
         //pnlEFEMCassette->Color = panel->Color;
         pnlEFEMCassette->Color = clLime;

         if(panel->Color == clLime) {
            btnCassetteLoad->Caption = "UnLoad";

            // 2020 5 21 - chc 可以取片
            btnLoadWafer->Enabled = true;

         }
      }
      // UnLoad
      if(i == 3) {

         // 2021 9 30 - chc 直接設為clSilver
         //pnlEFEMCassette->Color = panel->Color;
         pnlEFEMCassette->Color = clSilver;

         if(panel->Color == clLime) {
            btnCassetteLoad->Caption = "Load";

            // 2020 5 21 - chc 不可以取片
            btnLoadWafer->Enabled = false;
            pnlLoadWafer->Color = clSilver;

         }
      }

   }
}
//---------------------------------------------------------------------------
// Load/Unload LoadUnloadState = 1/2;
// 1: LPLD / LOUD
// 2: LOLD / LPUD
void __fastcall TMainForm::tmLoadUnloadTimer(TObject *Sender)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int step = 0;
AnsiString msg;

   tmLoadUnload->Enabled = false;

   if(pnlLoadPort->Enabled == false) {
      return;
   }

   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      Sleep(1);
      Application->ProcessMessages();
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > 5000) {
         WriteSystemLog("tmLoadUnloadTimer TimeOut! " + IntToStr(step));
         return;
      }
      if(pnlLoadPort->Enabled == true) {
         if(step == 0) {
            step = 1;
            if(LoadUnloadState == 1) {
               edLoadPortCmd->Text = "SET:LPLD;";
            }
            else {
               edLoadPortCmd->Text = "SET:LOLD;";
            }
            btnLoadPortCMDClick(this);
         }
         else if(step == 1) {
            step = 2;
            if(LoadUnloadState == 1) {
               edLoadPortCmd->Text = "SET:LOUD;";
            }
            else {
               edLoadPortCmd->Text = "SET:LPUD;";
            }
            btnLoadPortCMDClick(this);
            return;
         }
      }
   }
}
//---------------------------------------------------------------------------
// LP1: Load / Unload
void __fastcall TMainForm::btnCassetteLoadClick(TObject *Sender)
{

   // 2022 2 13 - chc RCMD: 1-Cancel, 2-Abort SECSRemoteCommand
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
      SECSRemoteCommand = SECS_REMOTE_NONE;

   // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
      if(boolInLoadWafer == true) {
         if(btnCassetteLoad->Caption == "UnLoad")
            pnlAlarmMessage->Caption = "Cannot do UnLoad during fetching!";
         else
            pnlAlarmMessage->Caption = "Cannot do Load during fetching!";
         WriteSystemLog(pnlAlarmMessage->Caption);
         Beep(500);
         return;
      }
      if(boolInUnloadWafer == true) {
         if(btnCassetteLoad->Caption == "UnLoad")
            pnlAlarmMessage->Caption = "Cannot do UnLoad during storing!";
         else
            pnlAlarmMessage->Caption = "Cannot do Load during storing!";
         WriteSystemLog(pnlAlarmMessage->Caption);
         Beep(500);
         return;
      }
      if(boolInMeasureRun == true) {
         if(btnCassetteLoad->Caption == "UnLoad")
            pnlAlarmMessage->Caption = "Cannot do UnLoad during measuring!";
         else
            pnlAlarmMessage->Caption = "Cannot do Load during measuring!";
         WriteSystemLog(pnlAlarmMessage->Caption);
         Beep(500);
         return;
      }
   }

   // 2021 10 27 - chc 將取片Status清成灰色
   // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {

      pnlLoadWafer->Color = clSilver;
      pnlUnloadWafer->Color = clSilver;
      pnlMeasure->Color = clSilver;
      pnlOriginal->Color = clSilver;
      pnlZeroPosition->Color = clSilver;
      pnlTargetPosition->Color = clSilver;
      pnlSetLimit->Color = clSilver;
   }
   
   // 2021 9 8b - chc 有CST
   rgCSTExist->ItemIndex = WAFER_EXIST_YES;

   // 2021 6 11 - chc alarm, 先決定Recipe
   // 2021 9 15 - chc 離線才要問
   if(cbOffLine->Checked == true) {

      if(btnCassetteLoad->Caption == "Load") {
         if(Application->MessageBox("是否已切換到正確Recipe?      ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            return;
         }
      }
   }

   // 2021 5 4 - chc SetupEFEMSocket
   if(EFEMMode == EFEM_RORZE) {

      // 2021 10 15 - chc Message
      pnlOperationMessage->Caption = "LP1 Loading...";

      // 2021 11 11 - chc 禁用pcSystem
      pcSystem->Enabled = false;

      // 2021 11 12 - chc Log
      WriteSystemLog(pnlOperationMessage->Caption);

      pnlCassetteLoad->Color = clSilver;
      if(pnlLoadPort1ORGN->Color == clLime) {
         WriteSystemLog("檢查LoadPort...");

         // 2023 7 31 - chc @@@@ 要確認是否要做? 可能另一個LP在運作中
         if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {

            rgRobotStage->ItemIndex = ROBOT_STAGE_LP1;
            // 12": Low Arm
            if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_12)
               rgRobotArm->ItemIndex = ROBOT_ARM_LOW;
            // 8": Up Arm
            else if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_8)
               rgRobotArm->ItemIndex = ROBOT_ARM_UP;
            // None
            else
               rgRobotArm->ItemIndex = WAFER_SIZE_NONE;
            // Slot1
            combRobotSlot->ItemIndex = 0;
            combRobotSlot->Text = "1";
            rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
         }
         // Load...
         if(btnCassetteLoad->Caption == "Load") {
            pnlStartMessage->Caption = "Check before Cassette Loading...";
            pnlStartMessage->Visible = true;
         }
         else {
            pnlStartMessage->Caption = "Check before Cassette UnLoading...";
            pnlStartMessage->Visible = true;
         }
         // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
         if(BeforeLoadPortLoadUnloadFun(LOADPORT_1) == false) {
            pnlCassetteLoad->Color = clRed;
            if(btnCassetteLoad->Caption == "Load")
               pnlOperationMessage->Caption = "Load Fail!";
            else
               pnlOperationMessage->Caption = "Unload Fail!";

            // 2021 11 11 - chc 禁用pcSystem
            pcSystem->Enabled = true;

            WriteSystemLog(pnlOperationMessage->Caption);
            return;
         }
         // UnLoad
         if(btnCassetteLoad->Caption == "UnLoad") {
            WriteSystemLog("執行BeforeUnload()...");
            if(BeforeUnload() == false) {
               pnlCassetteLoad->Color = clRed;
               pnlAlarmMessage->Caption = "Unload Fail!";

               // 2021 11 11 - chc 禁用pcSystem
               pcSystem->Enabled = true;

               WriteSystemLog("執行BeforeUnload(): Fail");
               return;
            }
            WriteSystemLog("執行BeforeUnload(): Ok");
         }
      }

      // 2021 11 12 - chc Loadport異常
      else {
         pnlCassetteLoad->Color = clRed;
         pnlAlarmMessage->Caption = "LP1 Error(ORGN not completed)!";
         pcSystem->Enabled = true;
         WriteSystemLog("pnlAlarmMessage->Caption");
         return;
      }

      boolLoadUnloadStatus = false;
      // Load
      if(btnCassetteLoad->Caption == "Load") {
         // CST
         pnlEFEMCassette->Color = clSilver;
         // Load...
         pnlStartMessage->Caption = "Cassette Loading...";
         pnlStartMessage->Visible = true;
         // LP1
         // 2021 5 5 - chc 送CSTREAD後, SECS會送MAP要求做LOAD動作
         // => 於人員LOAD時才做
         pnlLoadPort1CLMP->Color = clSilver;
         // 變更Port編號
         rgRFIDLoadPort->ItemIndex = LOADPORT_1;
         // 12"
         if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_12)
            rgRFIDWaferSize->ItemIndex = 1;
         else
            rgRFIDWaferSize->ItemIndex = 0;
         rgRFIDTagType->ItemIndex = 2;
         btnRFIDReadClick(this);
         WriteSystemLog("RFID完成1.");

         // SECS: 變更Port編號
         rgSECSPortNo->ItemIndex = LOADPORT_1;
         // 有連線時由SECS MAP 觸發LOAD
         int timeout,cnt;
         // 是否連線?
         if(pnlSECSConnect->Color == clLime && cbOffLine->Checked == false) {
            // 連線且Recmote才要做
            rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
            WriteSystemLog("boolSendSCESCommand: 19");
            rgSecsCommandSet->ItemIndex = -1;
            boolSendSCESCommand = true;
            rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
            timeout = 45;
         }
         else {
            timeout = 2;
            if(pnlSECSConnect->Color != clLime)
               WriteSystemLog("SECS未連線: 直接做Load");
            if(cbOffLine->Checked == true)
               WriteSystemLog("在Local狀態下: 直接做Load");

            btnLoadPort1CLMPClick(this);
         }
         cnt = 0;
         while(1) {
            WaitTime(1000);
            cnt++;
            if(cnt > timeout) {
               pnlOperationMessage->Caption = "LP1 Load Fail!";
               pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
               break;
            }
            if(pnlLoadPort1CLMP->Color == clLime) {
               pnlOperationMessage->Caption = "LP1 Loaded.";
               pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
               WriteSystemLog("boolSendSCESCommand: 5");

               // 2021 5 4 - chc 進入Run
               // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause
               //rgEQStatus->ItemIndex = EQ_STATUS_RUN;
               //rgSecsCommandSet->ItemIndex = -1;
               //boolSendSCESCommand = true;
               //rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;
               // 2021 10 27 - chc Load後為為EXECUTING
               //SendSECSStatus(EQ_STATUS_IDLE);
               SendSECSStatus(EQ_STATUS_EXECUTING);

               // 2021 6 3 - chc 禁止變更LoadPort
               rgLoadPortSelect->Enabled = false;

               // 2021 9 30 - chc CST
               pnlEFEMCassette->Color = clLime;

               break;
            }
            else if(pnlLoadPort1CLMP->Color == clRed) {
               pnlOperationMessage->Caption = "LP1 Load Timeout失敗!";
               pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
               break;
            }
         }
      }
      // UnLoad
      else {
         // Unload...
         pnlStartMessage->Caption = "Cassette Unloading...";
         pnlStartMessage->Visible = true;

         // 2012 UnLoad再檢查一次
         WriteSystemLog("再執行BeforeUnload()...");
         if(BeforeUnload() == false) {
            pnlAlarmMessage->Caption = "LP1 Unload Fail!";
            WriteSystemLog("再執行BeforeUnload(): Fail");
err:
            pnlCassetteLoad->Color = clRed;
            // 禁用pcSystem
            pcSystem->Enabled = true;
            return;
         }

         // 2023 8 1 - chc 是LP2才做
         if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {

            WriteSystemLog("再執行BeforeUnload(): Ok");
            // 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
            if(boolInLoadWafer == true) {
               pnlAlarmMessage->Caption = "Cannot do UnLoad during fetching!";
               WriteSystemLog(pnlAlarmMessage->Caption);
               goto err;
            }
            if(boolInUnloadWafer == true) {
               pnlAlarmMessage->Caption = "Cannot do UnLoad during storing!";
               WriteSystemLog(pnlAlarmMessage->Caption);
               goto err;
            }
         }
         // LP1
         btnLoadPort1UCLMClick(this);
         if(pnlLoadPort1UCLM->Color == clLime) {
            pnlOperationMessage->Caption = "LP1 UnLoad finished.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
            // LOTEND
            rgPortStatus->ItemIndex = PORT_STATUS_LOTEND;

            WriteSystemLog("boolSendSCESCommand: 7");

            // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
            //rgEQStatus->ItemIndex = EQ_STATUS_IDLE;
            //rgSecsCommandSet->ItemIndex = -1;
            //boolSendSCESCommand = true;
            //rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
            // 2021 10 27 - chc Unload後改成Ready
            //SendSECSStatus(EQ_STATUS_IDLE);
            // 2021 10 27 - chc Unload完成為Idle
            //SendSECSStatus(EQ_STATUS_READY);
            SendSECSStatus(EQ_STATUS_IDLE);

            // 2021 6 3 - chc 可變更LoadPort
            rgLoadPortSelect->Enabled = true;

            // 2021 9 30 - chc CST
            pnlEFEMCassette->Color = clSilver;

         }
      }
      if(boolLoadUnloadStatus == true)
         pnlCassetteLoad->Color = clLime;
      else
         pnlCassetteLoad->Color = clRed;

      // 2021 11 11 - chc 禁用pcSystem
      pcSystem->Enabled = true;

      pnlStartMessage->Visible = false;
      return;
   }

   // Hirata
   pnlCassetteLoad->Color = clSilver;
   if(pnlLoadPort->Enabled == true) {

      // 2020 5 2 - chc Load...
      if(btnCassetteLoad->Caption == "Load") {
         pnlStartMessage->Caption = "Check before CST Loading...";
         pnlStartMessage->Visible = true;
      }
      else {
         pnlStartMessage->Caption = "Check before CST UnLoading...";
         pnlStartMessage->Visible = true;
      }

      // 2020 5 4 - chc 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
      if(BeforeLoadPortLoadUnload() == false) {
         pnlCassetteLoad->Color = clRed;
         return;
      }

      // 2020 7 17 - chc UnLoad
      if(btnCassetteLoad->Caption == "UnLoad") {
         if(BeforeUnload() == false) {
            pnlCassetteLoad->Color = clRed;
            return;
         }
      }

      boolLoadUnloadStatus = false;

      if(btnCassetteLoad->Caption == "Load") {

         // 2020 5 2 - chc Load...
         pnlStartMessage->Caption = "Cassette Loading...";
         pnlStartMessage->Visible = true;

         edLoadPortCmd->Text = "MOV:FPML;";
         btnLoadPortCMDClick(this);
         if(pnlCassetteLoad->Color == clLime) {
            pnlOperationMessage->Caption = "Load完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }
      else {

         // 2020 5 2 - chc Unload...
         pnlStartMessage->Caption = "Cassette Unloading...";
         pnlStartMessage->Visible = true;

         edLoadPortCmd->Text = "MOV:ORGN;";
         btnLoadPortCMDClick(this);
         if(pnlCassetteLoad->Color == clLime) {
            pnlOperationMessage->Caption = "UnLoad完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }

      // 2020 5 4 - chc 等20秒
      int cnt = 0;
      int max = 40;
      while(1) {
         if(boolLoadUnloadStatus == true) {
            pnlCassetteLoad->Color = clLime;
            break;
         }
         cnt++;
         if(cnt > max) {
            pnlCassetteLoad->Color = clRed;
            break;
         }
         WaitTime(500);
      }

      // 2020 5 2 - chc Load...
      pnlStartMessage->Visible = false;

   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnChuckVacuumOnClick(TObject *Sender)
{

   // 8"
   if(pnlStageVacuum->Color != clLime)
      pnlStageVacuumClick(this);

   // 2021 6 3 - chc 12"
   if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
      if(pnlStageVacuum1->Color != clLime)
         pnlStageVacuum1Click(this);
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnChuckVacuumOffClick(TObject *Sender)
{

   // 2021 7 17 - chc 8"/12" Vacuum重寫
   /*
   if(pnlStageVacuum->Color == clLime)
      pnlStageVacuumClick(this);

   // 2021 6 3 - chc 12"
   if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
      if(pnlStageVacuum1->Color == clLime)
         pnlStageVacuum1Click(this);
   }
   */
   // 8"
   if(pnlStageVacuum1->Color == clLime)
      pnlStageVacuum1Click(this);
   // 12"
   if(pnlStageVacuum->Color == clLime)
      pnlStageVacuumClick(this);

}
//---------------------------------------------------------------------------
bool __fastcall TMainForm::ChckChuckVacuumOn()
{

   if(pnlStageVacuum->Color == clLime)
      return true;
   return false;
}
//---------------------------------------------------------------------------
bool __fastcall TMainForm::ChckChuckVacuumOff()
{

   if(pnlStageVacuum->Color != clLime)
      return true;
   return false;
}
//---------------------------------------------------------------------------
// 2020 4 23 - chc 到LF真空關高度
void __fastcall TMainForm::btnDemoLFVacuumOffClick(TObject *Sender)
{
int lvalue;
double dy;

   lvalue = edLVacuumOff->Text.ToInt();

   // 2021 4 29 - chc 將高度轉成pulse
   dy = (double)lvalue / L_RESOLUTION;
   lvalue = dy;

   // 2020 5 20 - chc L水平高度
   int level;
   level = edLLevel->Text.ToInt();
   lvalue += level;

   // 2021 9 11 - chc 是否加速
   //MoveToL(lvalue);
   MoveToL(lvalue,false);
}
//---------------------------------------------------------------------------
// 2020 4 24 - chc Init ComPort
void __fastcall TMainForm::InitRobotCom()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動Robot Com Port...";
   try {
      pnlRobotStatus->Color = clSilver;
      ybRobot->Active = false;
      Sleep(200);
      if(combRobotBaudrate->Text == "115200")
         ybRobot->Baud = ybRobot->br115200;
      else if(combRobotBaudrate->Text == "57600")
         ybRobot->Baud = ybRobot->br57600;
      else if(combRobotBaudrate->Text == "38400")
         ybRobot->Baud = ybRobot->br38400;
      else if(combRobotBaudrate->Text == "19200") {
         ybRobot->Baud = ybRobot->br19200;
         WriteSystemLog("Robot: 19200");
      }
      else if(combRobotBaudrate->Text == "9600")
         ybRobot->Baud = ybRobot->br9600;
      // 由參數決定COM Port
      ybRobot->PortNo = combRobotComport->ItemIndex+1;
      WriteSystemLog("Robot: COM" + IntToStr(ybRobot->PortNo));

      // Parity, DataBit, StopBit
      //ybRobot->Parity = ybRobot->ptEvenParity;
      //ybRobot->ByteSize = 7;
      //ybRobot->StopBits = ybRobot->sbOneStopBit;
      //ybRobot->FlowControl = ybRobot->fcNone;
      //WriteSystemLog("Robot: 7E1None");

      ybRobot->Active = true;
      pnlRobotStatus->Color = clLime;
      boolRobotStatus = true;
      RobotButton();
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybRobot: " + e.Message;
      sbSystemMessage->Panels->Items[1]->Text = "ybRobot: " + e.Message;
      pnlRobotStatus->Color = clRed;
      boolRobotStatus = false;
      RobotButton();
   }
   UpdateRobotStatus();
   pnlSystemMessage->Caption = "啟動Robot Com Port.";

}
//---------------------------------------------------------------------------
// 2020 4 25 - chc Init ComPort
void __fastcall TMainForm::InitLoadPortCom()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動LoadPort Com Port...";
   try {
      pnlLoadPortStatus->Color = clSilver;
      ybLoadPort->Active = false;
      Sleep(200);
      if(combLoadPortBaudrate->Text == "115200")
         ybLoadPort->Baud = ybLoadPort->br115200;
      else if(combLoadPortBaudrate->Text == "57600")
         ybLoadPort->Baud = ybLoadPort->br57600;
      else if(combLoadPortBaudrate->Text == "38400")
         ybLoadPort->Baud = ybLoadPort->br38400;
      else if(combLoadPortBaudrate->Text == "19200")
         ybLoadPort->Baud = ybLoadPort->br19200;
      else if(combLoadPortBaudrate->Text == "9600")
         ybLoadPort->Baud = ybLoadPort->br9600;
      // 由參數決定COM Port
      ybLoadPort->PortNo = combLoadPortComport->ItemIndex+1;

      // Parity, DataBit, StopBit
      //ybLoadPort->Parity = ybLoadPort->ptNoParity;
      //ybLoadPort->ByteSize = 8;
      //ybLoadPort->StopBits = ybLoadPort->sbOneStopBit;

      ybLoadPort->Active = true;
      pnlLoadPortStatus->Color = clLime;
      boolLoadPortStatus = true;
      LoadPortButton(0);
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybLoadPort: " + e.Message;
      sbSystemMessage->Panels->Items[1]->Text = "ybLoadPort: " + e.Message;
      pnlLoadPortStatus->Color = clRed;
      boolLoadPortStatus = false;
      LoadPortButton(0);
   }
   UpdateLoadPortStatus();
   pnlSystemMessage->Caption = "啟動LoadPort Com Port.";

}
//---------------------------------------------------------------------------
// 2020 4 25 - chc Init ComPort
void __fastcall TMainForm::InitAlignerCom()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動Aligner Com Port...";
   try {
      pnlAlignerStatus->Color = clSilver;
      ybAligner->Active = false;
      Sleep(200);
      if(combAlignerBaudrate->Text == "115200")
         ybAligner->Baud = ybAligner->br115200;
      else if(combAlignerBaudrate->Text == "57600")
         ybAligner->Baud = ybAligner->br57600;
      else if(combAlignerBaudrate->Text == "38400")
         ybAligner->Baud = ybAligner->br38400;
      else if(combAlignerBaudrate->Text == "19200")
         ybAligner->Baud = ybAligner->br19200;
      else if(combAlignerBaudrate->Text == "9600")
         ybAligner->Baud = ybAligner->br9600;
      // 由參數決定COM Port
      ybAligner->PortNo = combAlignerComport->ItemIndex+1;

      // Parity, DataBit, StopBit
      //ybAligner->Parity = ybAligner->ptNoParity;
      //ybAligner->ByteSize = 8;
      //ybAligner->StopBits = ybAligner->sbOneStopBit;

      ybAligner->Active = true;
      pnlAlignerStatus->Color = clLime;
      boolAlignerStatus = true;
      AlignerButton();
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybAligner: " + e.Message;
      sbSystemMessage->Panels->Items[1]->Text = "ybAligner: " + e.Message;
      pnlAlignerStatus->Color = clRed;
      boolAlignerStatus = false;
      AlignerButton();
   }
   UpdateAlignerStatus();
   pnlSystemMessage->Caption = "啟動Aligner Com Port.";

}
//---------------------------------------------------------------------------
bool boolLoopStop = false;
void __fastcall TMainForm::btnLoopTestClick(TObject *Sender)
{
int loopcnt,loopno,startno,endno,workno,indexno,nextno;

// 2022 1 27 - chc LoopTest記錄SECS離或連線時的取退片狀態
bool boolonline,booloffline;
   boolonline = cbSECSAtuo->Checked;
   booloffline = cbOffLineAtuo->Checked;
   cbSECSAtuo->Checked = false;
   cbOffLineAtuo->Checked = false;

   // 2021 6 4 - chc 測試片數
   int wafercnt = 0;
   pnlTestWaferCount->Caption = IntToStr(wafercnt);

   pnlLoopTest->Color = clSilver;
   loopcnt = edLoopTestCount->Text.ToInt();
   loopno = 0;
   pnlLoopTestCount->Caption = IntToStr(loopno);
   btnLoopTestStop->Visible = true;
   boolLoopStop = false;
   btnLoopTest->Enabled = false;
   if(rgLoopTest->ItemIndex == 0) {
      startno = 25 - rgWaferNo->ItemIndex;
      endno = 25 - rgWaferNo->ItemIndex;
   }
   else {
      startno = GetFirstNo();
      endno = GetLastNo();
      if(startno == -1 || endno == -1) {
         pnlOperationMessage->Caption = "Cassete無Wafer!";
         pnlLoopTest->Color = clRed;
         goto end;
      }
   }
   if(CheckWithWafer(startno) == false) {
      pnlOperationMessage->Caption = "Cassete指定位置無Wafer! " + IntToStr(startno);
      pnlLoopTest->Color = clRed;
      goto end;
   }

   // startno: 1 - 25
   // workno: 1 - 25
   // indexno: 24 - 0
   workno = startno;
   while(1) {
nextwafer:
      if(CheckWithWafer(workno) == false) {
         pnlOperationMessage->Caption = "Cassete指定位置無Wafer(作業前檢查)! " + IntToStr(workno);
         pnlLoopTest->Color = clRed;
         goto end;
      }
      if(boolLoopStop == true) {
         pnlOperationMessage->Caption = "Loop測試中斷!";
         pnlLoopTest->Color = clMaroon;
         goto end;
      }
      indexno = 25 - workno;
      rgWaferNo->ItemIndex = indexno;
      btnLoadWaferClick(this);
      if(pnlLoadWafer->Color != clLime) {
         pnlSystemMessage->Caption = "取片異常!";
         pnlLoopTest->Color = clRed;
         goto end;
      }
      WaitTime(2000);
      btnUnloadWaferClick(this);
      if(pnlUnloadWafer->Color != clLime) {
         pnlSystemMessage->Caption = "退片異常!";
         pnlLoopTest->Color = clRed;
         goto end;
      }

      // 2021 6 4 - chc 測試片數
      wafercnt++;
      pnlTestWaferCount->Caption = IntToStr(wafercnt);
      pnlTestWaferCount->Refresh();

      if(workno == endno) {
         workno = startno;
      }
      else {
         nextno = GetNextNo(workno);
         if(nextno == -1) {
            pnlOperationMessage->Caption = "Cassete指定下一位置無Wafer! " + IntToStr(workno);
            pnlLoopTest->Color = clRed;
            goto end;
         }
         workno = nextno;

         // 2020 7 16 - chc 所有片
         if(rgLoopTest->ItemIndex == 1) {
            goto nextwafer;
         }

      }
      loopno++;
      pnlLoopTestCount->Caption = IntToStr(loopno);
      if(loopno >= loopcnt) {
         pnlOperationMessage->Caption = "Loop測試完成.";
         break;
      }
      if(cbLoopPause->Checked == true) {
         if(Application->MessageBox(("準備做Loop" + IntToStr(loopno+1) + ", 第" + IntToStr(workno) + "片?    ").c_str(), "Loop作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlLoopTest->Color = clGreen;
            goto end;
         }
      }
   }
   pnlLoopTest->Color = clLime;

end:
   btnLoopTest->Enabled = true;
   btnLoopTestStop->Visible = false;

   // 2022 1 27 - chc 記錄SECS離或連線時的取退片狀態
   cbSECSAtuo->Checked = boolonline;
   cbOffLineAtuo->Checked = booloffline;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoopTestStopClick(TObject *Sender)
{

   boolLoopStop = true;
   btnLoopTestStop->Visible = false;
}
//---------------------------------------------------------------------------
// 0 - 24 (25 - 1)
int __fastcall TMainForm::GetFirstNo()
{
TPanel *panel;
int no=-1;

// 2021 10 4 - chc 判定是否片?
bool boolgot = false;

   // pnlTray1
   for(no=1 ; no<=25 ; no++) {

      // 2020 7 16 - chc 指定
      //panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));

      if(panel->Color == clLime) {

         // 2021 10 4 - chc 判定是否片?
         boolgot = true;

         break;
      }
   }

   // 2021 10 4 - chc 判定是否片?
   if(boolgot == false)
      return -1;

   return no;
}
//---------------------------------------------------------------------------
// 0 - 24 (25 - 1)
int __fastcall TMainForm::GetLastNo()
{
TPanel *panel;
int no=-1;

// 2021 10 4 - chc 判定是否片?
bool boolgot = false;

   // pnlTray1
   for(no=25 ; no>=1 ; no--) {

      // 2020 7 16 - chc 指定
      //panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));

      if(panel->Color == clLime) {

         // 2021 10 4 - chc 判定是否片?
         boolgot = true;

         break;
      }
   }

   // 2021 10 4 - chc 判定是否片?
   if(boolgot == false)
      return -1;

   return no;
}
//---------------------------------------------------------------------------
// 0 - 24 (25 - 1)
int __fastcall TMainForm::GetNextNo(int cno)
{
TPanel *panel;
int no=-1;

// 2021 10 4 - chc 判定是否片?
bool boolgot = false;

   // pnlTray1
   for(no=cno+1 ; no<=25 ; no++) {

      // 2020 7 16 - chc 指定
      //panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));

      if(panel->Color == clLime) {

         // 2021 10 4 - chc 判定是否片?
         boolgot = true;

         break;
      }
   }

   // 2021 10 4 - chc 判定是否片?
   if(boolgot == false)
      return -1;

   return no;
}
//---------------------------------------------------------------------------
// 0 - 24 (25 - 1)
bool __fastcall TMainForm::CheckWithWafer(int cno)
{
TPanel *panel;
int no=-1;

   // pnlTray1
   panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(cno)));
   if(panel->Color == clLime)
      return true;
   return false;
}
//---------------------------------------------------------------------------
// SET:RSET;
void __fastcall TMainForm::btnAlignerResetClick(TObject *Sender)
{

   pnlAlignerReset->Color = clSilver;
   edAlignerCmd->Text = "SET:RSET;";
   btnAlignerCMDClick(this);

   // 2020 5 12 - chc 紅燈
   // 2020 8 12 - chc TSMC修改
   //RedLamp(false);
   boolEFEMError = false;

}
//---------------------------------------------------------------------------
// 2020 4 27 - chc 以Timer處理SetupEFEM
void __fastcall TMainForm::tmSetupEFEMTimer(TObject *Sender)
{

   // 2023 8 2 - chc Init Start
   pnlEFEMUnit->Caption = "Initialize...";

   pnlHome2->Visible = false;
   tmSetupEFEM->Enabled = false;
   if(SetupEFEM() == false) {
      pnlEFEMReady->Color = clRed;
      pnlLeftWindow->Color = clGray;
      pcEFEMH->Enabled = false;
      pcEFEMR->Enabled = false;
      pnlSystemMessage->Caption = "EFEM Error! Unable to work.";

      // 2023 8 2 - chc Init Start
      pnlEFEMUnit->Caption = "Fail!";
      pnlEFEMUnit->Font->Color = clRed;

   }
   else {

      // 2023 8 2 - chc Init Start
      pnlEFEMUnit->Caption = "Completed.";

      pnlEFEMReady->Color = clLime;
      pnlLeftWindow->Color = clSilver;
      pcEFEMH->Enabled = true;
      pcEFEMR->Enabled = true;
      pnlSystemMessage->Caption = "EFEM正常! 系統Ready.";
      boolEFEMStatus = true;

      // 2021 4 25 - chc TSMC修改: 亮黃燈
      if(EFEMMode == EFEM_RORZE) {
         int lpno = rgLoadPortSelect->ItemIndex;
      }
      else {
         // OneLine, Door Open
         if(MainForm->pnlLoadPortS2->Caption == "0" && MainForm->pnlLoadPortS11->Caption == "0") {
            MainForm->btnCassetteLoad->Caption = "UnLoad";
            MainForm->GreenLamp(true);
            MainForm->YellowLamp(false);
            btnLoadWafer->Enabled = true;
         }
         else {
            MainForm->btnCassetteLoad->Caption = "Load";
            MainForm->GreenLamp(false);
            MainForm->YellowLamp(true);
            btnLoadWafer->Enabled = false;
            pnlLoadWafer->Color = clSilver;
         }
      }
      MainForm->StageFFU(true);
      MainForm->EFEMFFU(true);

   }

   // 2021 5 4 - chc 先做Update
   Sleep(500);
   UpdateMotionStatus();
   Sleep(500);

   // 2020 5 20a - chc 若HomeDone檢查Vacuum, CDA
   WriteSystemLog("SetupEFEM完成(tmSetupEFEM): 檢查Vacuum, CDA");

   // 2021 6 11 - chc 要到SVON後才能做
   //if(CheckCDAVacuum() == true)
   //   pnlHome2->Visible = true;

}
//---------------------------------------------------------------------------
// 2020 4 29 - chc Load Port Mapping
void __fastcall TMainForm::btnLoadPortMappingClick(TObject *Sender)
{

   // 2020 5 4 - chc 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPortCmd->Text = "MOV:MAPP;";                                           // Mapping
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
// 2020 5 4 - chc 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
bool __fastcall TMainForm::BeforeLoadPortLoadUnload()
{

   // 2021 5 4 - chc SetupEFEMSocket
   if(EFEMMode == EFEM_RORZE) {
      // ORGN
      if(pnlRobotORGNStatus->Color != clLime) {
         pnlAlarmMessage->Caption = "Robot異常, 無法作動!";
         return false;
      }
      // Robot Home
      btnRobotStageHomeClick(this);
      if(pnlRobotStageHome->Color != clLime) {
         pnlAlarmMessage->Caption = "Robot無法回原點!";
         return false;
      }
      // Placement
      if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
         btnLoadPort1GPIOClick(this);
         if(pnlLoadPort1Presence->Color == clSilver) {
            pnlAlarmMessage->Caption = "LoadPort1無FOUP!";
            return false;
         }
      }
      else {
         btnLoadPort2GPIOClick(this);
         if(pnlLoadPort2Presence->Color == clSilver) {
            pnlAlarmMessage->Caption = "LoadPort2無FOUP!";
            return false;
         }
      }

      return true;
   }

   if(pnlRobot->Enabled == false) {
      pnlLoadPortMessage->Caption = "Robot無法作動!";
      pnlAlarmMessage->Caption = pnlLoadPortMessage->Caption;
      return false;
   }
   // Robot原點
   btnRobotOriginalClick(this);
   if(pnlRobotOriginal->Color != clLime) {
      pnlLoadPortMessage->Caption = "Robot無法回原點!";
      pnlAlarmMessage->Caption = pnlLoadPortMessage->Caption;
      return false;
   }

   // LR: 取得位置 GP 880 ( 0 0 20 0) => 001 210 0 82 270.26L 0
   // LR: 取得位置 GP 881 ( 0 0 20 0) => 001 677.9 0 82 270.26L 0
   //                                    12345678901234567890
   // L
   //   For SCALAR type robot, "R" is right arm (RIGHT) and "L" is left arm (LEFT).
   //   For orthogonal type robot, the arm attitude is fixed to "L".
   // 最後碼固定為0
   // X < 300為安全
   btnRobotGetPositionClick(this);
   WaitTime(1000);
   if(boolRobotLRCommand == true) {
      pnlLoadPortMessage->Caption = "Robot讀X異常!";
      pnlAlarmMessage->Caption = pnlLoadPortMessage->Caption;
      return false;
   }
   if(RobotXPosition > 300) {
      pnlLoadPortMessage->Caption = "Robot X過大! " + IntToStr(RobotXPosition);
      pnlAlarmMessage->Caption = pnlLoadPortMessage->Caption;
      return false;
   }

   // 取得LoadPort Status
   // 2020 5 6 - chc 不能看S12
   /*
   btnLoadPortStasClick(this);
   WaitTime(1000);
   if(pnlLoadPort->Enabled == false) {
      pnlLoadPortMessage->Caption = "LoadPort作動異常!";
      return false;
   }
   // 看Protrution? 1-Ok, 0-NG(有東西)
   if(pnlLoadPortS12->Caption != "1") {
      pnlLoadPortMessage->Caption = "LoadPort柵有障礙物!";
      return false;
   }
   */

   return true;
}
//---------------------------------------------------------------------------
// 2020 5 4 - chc Save Aligner Parameters
void __fastcall TMainForm::btnAlignerSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pnlSystemMessage->Caption = "Aligner參數更新中...";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   // Aligner
   AlignerDegree = edAlignerDegree->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter" ,"Degree"                      ,AlignerDegree);
   AlignerSpeed = edAlignerSpeed->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter" ,"Speed"                       ,AlignerSpeed);
   AlignerType = edAlignerType->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter" ,"Type"                        ,AlignerType);

   // AlignerOut
   AlignerDegreeOut = edAlignerDegreeOut->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter" ,"Degree Out"                  ,AlignerDegreeOut);

   delete pSystemFile;
   pnlSystemMessage->Caption = "Aligner: Parameter update complete.";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;

}
//---------------------------------------------------------------------------
// 2020 5 4 - chc Read Aligner Parameters
void __fastcall TMainForm::LoadAlignerParameter()
{
TIniFile *pSystemFile;
AnsiString str;

   pnlSystemMessage->Caption = "Aligner參數讀取中...";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   if(EFEMMode == EFEM_RORZE) {
      AlignerSize = pSystemFile->ReadInteger("Aligner Parameter" ,"Size"      ,0);
      AlignerDegree = pSystemFile->ReadInteger("Aligner Parameter" ,"Degree"     ,0);
      rgWaferSize->ItemIndex = AlignerSize;
      rgWaferDegree->ItemIndex = AlignerDegree;

      // 2021 7 22 - chc update
      rgWaferOrientation->ItemIndex = AlignerDegree;

   }
   else {
      // Aligner
      AlignerDegree = pSystemFile->ReadInteger("Aligner Parameter" ,"Degree"       ,900);
      AlignerSpeed = pSystemFile->ReadInteger("Aligner Parameter" ,"Speed"         ,100);
      AlignerType = pSystemFile->ReadInteger("Aligner Parameter" ,"Type"           ,5);
      edAlignerDegree->Text = IntToStr(AlignerDegree);
      edAlignerSpeed->Text = IntToStr(AlignerSpeed);
      edAlignerType->Text = IntToStr(AlignerType);

      // Aligner Out
      AlignerDegreeOut = pSystemFile->ReadInteger("Aligner Parameter" ,"Degree Out"       ,900);
      edAlignerDegreeOut->Text = IntToStr(AlignerDegreeOut);
   }
   delete pSystemFile;
   pnlSystemMessage->Caption = "Aligner參數讀取完成.";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;

}
//---------------------------------------------------------------------------
// LR
void __fastcall TMainForm::btnRobotGetPositionClick(TObject *Sender)
{

   pnlRobotXPosition->Caption = "";
   boolRobotLRCommand = true;
   edRobotCmd->Text = "LR";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------
// 2020 5 4 - chc Reset Error
void __fastcall TMainForm::btnLoadPortResetClick(TObject *Sender)
{

   pnlLoadPortReset->Color = clSilver;
   edLoadPortCmd->Text = "SET:RSET;";
   btnLoadPortCMDClick(this);

   // 2020 5 12 - chc 紅燈
   // 2020 8 12 - chc TSMC修改
   //RedLamp(false);
   boolEFEMError = false;

}
//---------------------------------------------------------------------------
// boolset
// 2020 5 4 - chc 共用Routine
void __fastcall TMainForm::SetLevel(bool boolset)
{

   // 2021 4 24 - chc 要為可使用
   //pcOP->Visible = boolset;
   //tsOperation->TabVisible = boolset;

   // OP只可動X/Y/Z
   btnUpdateSystemParameter->Visible = boolset;
   btnEFEMMaintenanceMode->Visible = boolset;
   pnlEFEMMaintenanceMode->Visible = boolset;
   /*
   btnBackwardZ1->Visible = boolset;
   btnUp100x->Visible = boolset;
   btnUp10x->Visible = boolset;
   btnUp5x->Visible = boolset;
   btnUp1x->Visible = boolset;
   btnDown1x->Visible = boolset;
   btnDown5x->Visible = boolset;
   btnDown10x->Visible = boolset;
   btnDown100x->Visible = boolset;
   btnMoveZ1->Visible = boolset;

   btnBackwardX1->Visible = boolset;
   btnLeft10x->Visible = boolset;
   btnLeft5x->Visible = boolset;
   btnLeft1x->Visible = boolset;
   btnRight1x->Visible = boolset;
   btnRight5x->Visible = boolset;
   btnRight10x->Visible = boolset;
   btnMoveX1->Visible = boolset;

   btnBackwardY1->Visible = boolset;
   btnFront10x->Visible = boolset;
   btnFront5x->Visible = boolset;
   btnFront1x->Visible = boolset;
   btnRear1x->Visible = boolset;
   btnRear5x->Visible = boolset;
   btnRear10x->Visible = boolset;
   btnMoveY1->Visible = boolset;
   */
   btnMoveT1->Visible = boolset;
   btnCCW10x->Visible = boolset;
   btnCCW5x->Visible = boolset;
   btnCCW1x->Visible = boolset;
   btnCW1x->Visible = boolset;
   btnCW5x->Visible = boolset;
   btnCW10x->Visible = boolset;
   btnBackwardT1->Visible = boolset;

   pnlZUnit->Visible = boolset;
   // loop Test
   gbLoopTest->Visible = boolset;
   // Command
   tsCommand->TabVisible = boolset;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::Panel94Click(TObject *Sender)
{
AnsiString ReplyStrRobot;
int pos,len;

   return;
   ReplyStrRobot = "001 210 0 112.8 269.61L 0";
   pos = ReplyStrRobot.Pos("001 ");
   len = ReplyStrRobot.Length();

   WriteSystemLog("len > 12, 進行X 解碼...");
   AnsiString temp;
   temp = ReplyStrRobot.SubString(pos+4,len-4);
   WriteSystemLog("len > 12, 進行X 解碼: " + temp);
   int pos1 = temp.Pos(" ");
   boolRobotLRCommand = false;
   RobotXPosition = (int)(temp.SubString(1,pos1-1).ToDouble());
   pnlRobotXPosition->Caption = IntToStr(RobotXPosition);
   pnlRobot->Enabled = true;
   WriteSystemLog("len > 12, 進行X 解碼完成: " + IntToStr(RobotXPosition));

}
//---------------------------------------------------------------------------
// 2020 5 6  - chc Robot Clear Alarm
// 回0601
void __fastcall TMainForm::btnRobotClearAlarmClick(TObject *Sender)
{

   edRobotCmd->Text = "CL";
   btnRobotCMDClick(this);

   // 2020 5 12 - chc 紅燈
   // 2020 8 12 - chc TSMC修改: 清MotionError狀態
   //RedLamp(false);

   // 2020 8 12 - chc TSMC修改: 清Robot狀態
   RobotCmd = ROBOT_CMD_NONE;
   boolEFEMError = false;

}
//---------------------------------------------------------------------------
// 2020 5 6  - chc Robot Enable
// GD後GE會看先到0621, 要再下LS才會看到0601
void __fastcall TMainForm::btnRobotEanbleClick(TObject *Sender)
{

   edRobotCmd->Text = "GE";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------
// 2020 5 6  - chc Robot Disable
// 回0601
void __fastcall TMainForm::btnRobotDisableClick(TObject *Sender)
{

   edRobotCmd->Text = "GD";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------
// 2020 5 12 - chc Tray Select
void __fastcall TMainForm::pnlTraySelectClick(TObject *Sender)
{

   TPanel* pnlSender = (TPanel*)Sender;
   if(pnlSender->Color == clSilver)
      pnlSender->Color = clLime;
   else if(pnlSender->Color == clLime)
      pnlSender->Color = clSilver;
}
//---------------------------------------------------------------------------
// 2020 5 12 - chc 改變次序
void __fastcall TMainForm::rgLoadOrderChange(TObject *Sender,
      int ButtonIndex)
{
TPanel *panel;
bool first = true;

   for(int i=0 ; i<25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      if(panel->Color == clLime) {
         // 第一片位置
         // 小到大
         if(rgLoadOrder->ItemIndex == 0) {
            if(first == true) {
               first = false;
               rgWaferNo->ItemIndex = 24 - i;
               break;
            }
         }
         // 大到小
         else {
            rgWaferNo->ItemIndex = 24 - i;
         }
      }
   }

}
//---------------------------------------------------------------------------
// 2020 5 12 - chc AutoLoad時指到下一片
// In(no): 1-25
// Out: 1-25(-1: None)
int __fastcall TMainForm::ToNextWafer(int no)
{
TPanel *panel;
int outno = -1;

   // 小到大
   if(rgLoadOrder->ItemIndex == 0) {
      for(int i=no+1 ; i<=25 ; i++) {
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
         if(panel->Color == clLime) {
            outno = i;
            break;
         }
      }

      // 2021 7 17 - chc 重頭開始
      if(outno == -1) {
         pnlOperationMessage->Caption = "已完成最後一片的取退片作業.";

         // 2021 10 20 - chc ToNextWafer(): 若為SECS連線且Auto則不用重指定
         // 2021 11 11 - chc 離線也可以
         //if(cbOffLine->Checked == false && cbSECSAtuo->Checked == true)
         if((cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true))

            return outno;

         for(int i=1 ; i<=25 ; i++) {
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
            if(panel->Color == clLime) {
               outno = i;
               break;
            }
         }
      }

   }
   // 大到小
   else {
      for(int i=no-1 ; i>=1 ; i--) {
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
         if(panel->Color == clLime) {
            outno = i;
            break;
         }
      }

      // 2021 7 17 - chc 重頭開始
      if(outno == -1) {

         // 2021 10 20 - chc ToNextWafer(): 若為SECS連線且Auto則不用重指定
         // 2021 11 11 - chc 離線也可以
         //if(cbOffLine->Checked == false && cbSECSAtuo->Checked == true)
         if((cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true))

            return outno;

         pnlOperationMessage->Caption = "已完成最後一片的取退片作業.";
         for(int i=25 ; i>=1 ; i--) {
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
            if(panel->Color == clLime) {
               outno = i;
               break;
            }
         }
      }

   }
   return outno;
}
//---------------------------------------------------------------------------
// 2020 5 12 - chc 全選
void __fastcall TMainForm::btnAllSelectClick(TObject *Sender)
{
TPanel *panel,*panel1;

   for(int i=1 ; i<=25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i)));
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
      if(panel->Color == clLime)
         panel1->Color = panel->Color;
      else
         panel1->Color = clGray;
   }

   // 2021 7 17 -  chc 記錄為Load後的第一片
   boolFirstAfterLoad = true;

}
//---------------------------------------------------------------------------
void __fastcall TMainForm::GreenLamp(bool mode)
{

   if(mode == true) {
      if(pnlDOGreenLamp->Color != clLime)
         pnlDOGreenLampClick(this);
   }
   else {
      if(pnlDOGreenLamp->Color == clLime)
         pnlDOGreenLampClick(this);
   }
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::BlueLamp(bool mode)
{

   if(mode == true) {
      if(pnlDOBlueLamp->Color != clLime)
         pnlDOBlueLampClick(this);
   }
   else {
      if(pnlDOBlueLamp->Color == clLime)
         pnlDOBlueLampClick(this);
   }
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::YellowLamp(bool mode)
{

   if(mode == true) {
      if(pnlDOYellowLamp->Color != clLime)
         pnlDOYellowLampClick(this);
   }
   else {
      if(pnlDOYellowLamp->Color == clLime)
         pnlDOYellowLampClick(this);
   }
}
//---------------------------------------------------------------------------
// pnlDOTReset
void __fastcall TMainForm::RedLamp(bool mode)
{

   if(mode == true) {
      if(pnlDORedLamp->Color != clLime) {
         pnlDORedLampClick(this);

         // 2020 8 12 - chc TSMC修改: 紅燈與Buzzer分離控制
         //if(tmBuzzer->Enabled == false) {
         //   Buzzer(true);
         //   tmBuzzer->Enabled = true;
         //}

      }

      // 2020 7 16 - chc 紅燈亮時, 要關黃綠燈
      if(pnlDOGreenLamp->Color == clLime)
         pnlDOGreenLampClick(this);
      if(pnlDOYellowLamp->Color == clLime)
         pnlDOYellowLampClick(this);

      // 2020 8 12 - chc TSMC修改
      boolRedLamp = true;

   }
   else {
      if(pnlDORedLamp->Color == clLime)
         pnlDORedLampClick(this);

      // 2020 8 12 - chc TSMC修改
      boolRedLamp = false;
      // 紅燈關時要恢復黃/綠燈
      if(btnCassetteLoad->Caption == "Load")
         YellowLamp(true);
      else
         GreenLamp(true);

   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmBuzzerTimer(TObject *Sender)
{

   tmBuzzer->Enabled = false;
   Buzzer(false);
}
//---------------------------------------------------------------------------
// Buzzer
void __fastcall TMainForm::Buzzer(bool mode)
{

   if(mode == true) {
      if(pnlDOBuzzer->Color != clLime) {
         pnlDOBuzzerClick(this);
      }

      // 2020 8 12 - chc TSMC修改
      boolBuzzer = true;

   }
   else {
      if(pnlDOBuzzer->Color == clLime)
         pnlDOBuzzerClick(this);

      // 2020 8 12 - chc TSMC修改
      boolBuzzer = false;

   }
}
//---------------------------------------------------------------------------
//Inter Lock Code
//-------------------------------------------------
//01: Host AVAILABLE not input
//10: No FOUP mounting
//14: Clamping not completed
//15: Docking not completed
//16: Door vacuum not completed
//17: Unlatching not completed
//18: Door opening not completed
//19: Mapping not started
//1A: Mapping forward not completed
//1C: Z axis is not door position
//1D: Not in the mapping range
//1E: Undocking not completed
//-------------------------------------------------
// pnlLoadPortInterLockCode->Caption
void __fastcall TMainForm::PutLoadPortInterLockMsg()
{
AnsiString msg = "";
int code = 0;

   if(pnlLoadPortInterLockCode->Caption == "")
      code = 0;
   else if(pnlLoadPortInterLockCode->Caption == "01")
      code = 1;
   else if(pnlLoadPortInterLockCode->Caption == "10")
      code = 2;
   else if(pnlLoadPortInterLockCode->Caption == "14")
      code = 3;
   else if(pnlLoadPortInterLockCode->Caption == "15")
      code = 4;
   else if(pnlLoadPortInterLockCode->Caption == "16")
      code = 5;
   else if(pnlLoadPortInterLockCode->Caption == "17")
      code = 6;
   else if(pnlLoadPortInterLockCode->Caption == "18")
      code = 7;
   else if(pnlLoadPortInterLockCode->Caption == "19")
      code = 8;
   else if(pnlLoadPortInterLockCode->Caption == "1A")
      code = 9;
   else if(pnlLoadPortInterLockCode->Caption == "1C")
      code = 10;
   else if(pnlLoadPortInterLockCode->Caption == "1D")
      code = 11;
   else if(pnlLoadPortInterLockCode->Caption == "1E")
      code = 12;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Host AVAILABLE not input";
         break;
      case 2:
         msg = "No FOUP mounting";
         break;
      case 3:
         msg = "Clamping not completed";
         break;
      case 4:
         msg = "Docking not completed";
         break;
      case 5:
         msg = "Door vacuum not completed";
         break;
      case 6:
         msg = "Unlatching not completed";
         break;
      case 7:
         msg = "Door opening not completed";
         break;
      case 8:
         msg = "Mapping not started";
         break;
      case 9:
         msg = "Mapping forward not completed";
         break;
      case 10:
         msg = "Z axis is not door position";
         break;
      case 11:
         msg = "Not in the mapping range";
         break;
      case 12:
         msg = "Undocking not completed";
         break;
   }
   pnlLoadPortInterLockMsg->Caption = msg;
   pnlLoadPortInterLockMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[LoadPort Interlock] " + pnlLoadPortInterLockCode->Caption + ": " + msg);
   }
}
//---------------------------------------------------------------------------
// 2020 5 14 - chc LoadPort Error Code
// -------------------------------------------------------------------------------------------------------------------
//                                                      Error Code
// -------------------------------------------------------------------------------------------------------------------
// 0 0 Normal
// 1 0 Clamp time over
// 1 1 Unclamp time over
// 1 2 Dock time over
// 1 3 Undock time over
// 1 4 Latch time over
// 1 5 Unlatch time over
// 1 6 Vacuum time over
// 1 7 Vacuum release time over
// 1 8 Door open time over
// 1 9 Door close time over
// 1 A Mapping forward time over
// 1 B Mapping return time over
// 1 F communication error(3 times of resending  (T-Type)
// 2 0 Home return time over
// 2 1 Loading time over
// 2 2 Unloading time over
// 2 3 Positioning time over
// 2 8 Door open/close position movement time over (mapping elevating operation)
// 2 9 Mapping start position movement time over (elevating operation)
// 2 A Mapping end position movement time over (elevating operation)
// 2 B Load position movement time over (elevating operation)
// 4 0 Mapping data error
// 4 1 Mode select error
// 7 0 Clamp sensor error
// 7 1 Dock sensor
// 7 2 Latch sensor error
// 7 3 Door sensor error
// 7 4 Mapping sensor error
// 7 7 Elevator axis sensor error
// A 0 Wafer dropWafer drop
// A 1 Wafer protrusion
// A 2 FOUP mount error (Mount sensor)
// A 3 FOUP mount error (Load sensor)
// A 5 Air pressure drop
// B 0 Host error
// C 0 Parameter error
// E 0 FAN stop alarm
// E 3 Voltage drop
// F E Dock hand pinch error
void __fastcall TMainForm::PutLoadPortErrorCodeMsg()
{
AnsiString msg = "";
AnsiString errorcode;
int code = 0;

   errorcode = pnlLoadPortS5->Caption + pnlLoadPortS6->Caption;
   if(errorcode == "")
      code = 0;
   else if(errorcode == "10")
      code = 1;
   else if(errorcode == "11")
      code = 2;
   else if(errorcode == "12")
      code = 3;
   else if(errorcode == "13")
      code = 4;
   else if(errorcode == "14")
      code = 5;
   else if(errorcode == "15")
      code = 6;
   else if(errorcode == "16")
      code = 7;
   else if(errorcode == "17")
      code = 8;
   else if(errorcode == "18")
      code = 9;
   else if(errorcode == "19")
      code = 10;
   else if(errorcode == "1A")
      code = 11;
   else if(errorcode == "1B")
      code = 12;
   else if(errorcode == "1F")
      code = 13;
   else if(errorcode == "20")
      code = 14;
   else if(errorcode == "21")
      code = 15;
   else if(errorcode == "22")
      code = 16;
   else if(errorcode == "23")
      code = 17;
   else if(errorcode == "28")
      code = 18;
   else if(errorcode == "29")
      code = 19;
   else if(errorcode == "2A")
      code = 20;
   else if(errorcode == "2B")
      code = 21;
   else if(errorcode == "40")
      code = 22;
   else if(errorcode == "41")
      code = 23;
   else if(errorcode == "70")
      code = 24;
   else if(errorcode == "71")
      code = 25;
   else if(errorcode == "72")
      code = 26;
   else if(errorcode == "73")
      code = 27;
   else if(errorcode == "74")
      code = 28;
   else if(errorcode == "77")
      code = 29;
   else if(errorcode == "A0")
      code = 30;
   else if(errorcode == "A1")
      code = 31;
   else if(errorcode == "A2")
      code = 32;
   else if(errorcode == "A3")
      code = 33;
   else if(errorcode == "A5")
      code = 34;
   else if(errorcode == "B0")
      code = 35;
   else if(errorcode == "C0")
      code = 36;
   else if(errorcode == "E0")
      code = 37;
   else if(errorcode == "E3")
      code = 38;
   else if(errorcode == "FE")
      code = 39;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Clamp time over";
         break;
      case 2:
         msg = "Unclamp time over";
         break;
      case 3:
         msg = "Dock time over";
         break;
      case 4:
         msg = "Undock time over";
         break;
      case 5:
         msg = "Latch time over";
         break;
      case 6:
         msg = "Unlatch time over";
         break;
      case 7:
         msg = "Vacuum time over";
         break;
      case 8:
         msg = "Vacuum release time over";
         break;
      case 9:
         msg = "Door open time over";
         break;
      case 10:
         msg = "Door close time over";
         break;
      case 11:
         msg = "Mapping forward time over";
         break;
      case 12:
         msg = "Mapping return time over";
         break;
      case 13:
         msg = "communication error(3 times of resending (T-Type)";
         break;
      case 14:
         msg = "Home return time over";
         break;
      case 15:
         msg = "Loading time over";
         break;
      case 16:
         msg = "Unloading time over";
         break;
      case 17:
         msg = "Positioning time over";
         break;
      case 18:
         msg = "Door open/close position movement time over (mapping elevating operation)";
         break;
      case 19:
         msg = "Mapping start position movement time over (elevating operation)";
         break;
      case 20:
         msg = "Mapping end position movement time over (elevating operation)";
         break;
      case 21:
         msg = "Load position movement time over (elevating operation)";
         break;
      case 22:
         msg = "Mapping data error";
         break;
      case 23:
         msg = "Mode select error";
         break;
      case 24:
         msg = "Clamp sensor error";
         break;
      case 25:
         msg = "Dock sensor";
         break;
      case 26:
         msg = "Latch sensor error";
         break;
      case 27:
         msg = "Door sensor error";
         break;
      case 28:
         msg = "Mapping sensor error";
         break;
      case 29:
         msg = "Elevator axis sensor error";
         break;
      case 30:
         msg = "Wafer dropWafer drop";
         break;
      case 31:
         msg = "Wafer protrusion";
         break;
      case 32:
         msg = "FOUP mount error (Mount sensor)";
         break;
      case 33:
         msg = "FOUP mount error (Load sensor)";
         break;
      case 34:
         msg = "Air pressure drop";
         break;
      case 35:
         msg = "Host error";
         break;
      case 36:
         msg = "Parameter error";
         break;
      case 37:
         msg = "FAN stop alarm";
         break;
      case 38:
         msg = "Voltage drop";
         break;
      case 39:
         msg = "Dock hand pinch error";
         break;

   }
   pnlLoadPortErrorMsg->Caption = msg;
   pnlLoadPortErrorMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[LoadPort] " + errorcode + ": " + msg);
   }

}
//---------------------------------------------------------------------------
// 2020 5 14 - chc Error Code
//00  Normal
//10  Suction ON time over
//11  Suction OFF time over
//12  Lift UP time over
//13  Lift DOWN time over
//14  Workpiece lost error
//40  AREA ERROR
//50  OVER RUN ERROR
//99  SYSTEM ERROR
//A0  DRIVER ERROR
//D0  LINE SENSOR NOT READY
//D1  SEARCHED FEW EDGES
//D3  SCAN DATA OVER FLOW
//D5  ROTATION.LESS
//D7  OFFSET LIMIT OVER
//D8  OFFSET ROBOT OVER
//D9  OFFSET AXIS OVER
//DA  OFFSET ADDR ERROR
//DB  MOTOR DIRECTION ERROR
//DC  PARAMETER ERROR
void __fastcall TMainForm::PutAlignerCodeMsg()
{
AnsiString msg = "";
AnsiString errorcode;
int code = 0;

   errorcode = pnlAlignerErrorCode->Caption;
   if(errorcode == "")
      code = 0;
   else if(errorcode == "10")
      code = 1;
   else if(errorcode == "11")
      code = 2;
   else if(errorcode == "12")
      code = 3;
   else if(errorcode == "13")
      code = 4;
   else if(errorcode == "14")
      code = 5;
   else if(errorcode == "40")
      code = 6;
   else if(errorcode == "50")
      code = 7;
   else if(errorcode == "99")
      code = 8;
   else if(errorcode == "A0")
      code = 9;
   else if(errorcode == "D0")
      code = 10;
   else if(errorcode == "D1")
      code = 11;
   else if(errorcode == "D3")
      code = 12;
   else if(errorcode == "D5")
      code = 13;
   else if(errorcode == "D7")
      code = 14;
   else if(errorcode == "D8")
      code = 15;
   else if(errorcode == "D9")
      code = 16;
   else if(errorcode == "DA")
      code = 17;
   else if(errorcode == "DB")
      code = 18;
   else if(errorcode == "DC")
      code = 19;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Suction ON time over";
         break;
      case 2:
         msg = "Suction OFF time over";
         break;
      case 3:
         msg = "Lift UP time over";
         break;
      case 4:
         msg = "Lift DOWN time over";
         break;
      case 5:
         msg = "Workpiece lost error";
         break;
      case 6:
         msg = "AREA ERROR";
         break;
      case 7:
         msg = "OVER RUN ERROR";
         break;
      case 8:
         msg = "SYSTEM ERROR";
         break;
      case 9:
         msg = "DRIVER ERROR";
         break;
      case 10:
         msg = "LINE SENSOR NOT READY";
         break;
      case 11:
         msg = "SEARCHED FEW EDGES";
         break;
      case 12:
         msg = "SCAN DATA OVER FLOW";
         break;
      case 13:
         msg = "ROTATION.LESS";
         break;
      case 14:
         msg = "OFFSET LIMIT OVER";
         break;
      case 15:
         msg = "OFFSET ROBOT OVER";
         break;
      case 16:
         msg = "OFFSET AXIS OVER";
         break;
      case 17:
         msg = "OFFSET ADDR ERROR";
         break;
      case 18:
         msg = "MOTOR DIRECTION ERROR";
         break;
      case 19:
         msg = "PARAMETER ERROR";
         break;

   }
   pnlAlignerErrorMsg->Caption = msg;
   pnlAlignerErrorMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[Aligner] " + errorcode + ": " + msg);
   }

}
//---------------------------------------------------------------------------
// 2020 5 14 - chc Error Code
// 1 00 Normal status (no error)
// 2 09 Positioning error (Refer to error axis information.)
// 3 10 Emergency stop state
// 4 20 A-CAL does not end normally. (Refer to error axis information.)
// 5 30 The address is out of the limit.
// 6 31 The robot was tried to be moved to the END(??) point.
// 7 32 FAN alarm status (When FAN alarm function is active.)
// 8 40 The position data is out of the limited area. (Refer to error axis information.)
// 9 51 The robot is in overrun status. (Refer to error axis information.)
//10 61 Communication command error
//11 62 A command which could not be executed in the current mode was received.
//12 63 System data (SG, SP) is corrupted.
//13 64 The position data cannot be read from the memory card.
//14 67 Servo parameter is corrupted.
//15 70 Low encoder battery
//16 80 The robot received another command during command processing.
//17 82 Sensor input does not turn ON. (When sensor stop function is active.)
//18 84 The measurement result is out of the range. (When glass alignment function is active.)
//19 90 The robot was tried to be operated before A-CAL had been completed.
//20 95 Coordinate transformation error: The specified position data is invalid.
//21 A0 Driver error (Refer to error axis information.)
//22 B0 Servo lock does not work.
//23 C0 Program error (When HARL-U2 is in use.)
//24 D0 Aligner error: The line sensor cannot be initialized.
//25 D1 Aligner error: The wafer edge cannot be detected.
//26 D3 Aligner error: Too much scans
//27 D5 Aligner error: The pivot axis rotation frequency is not sufficient.
//28 D7 Aligner error: The correction amount exceeds the set value.
//29 D8 Aligner error: Wrong transfer robot is specified.
//30 D9 Aligner error: Wrong axis is specified for correction output.
//31 DA Aligner error: Wrong address is specified for correction output.
//32 DB Aligner error: Wrong direction is specified for motor rotation.
//33 DC Aligner error: Wrong parameter is specified.
//34 E0 Axis interlock (When axis interlock function is active.)
//E1, E2="0"~"9"(0x30∼0x39): "A"~"F"(0x41∼0x46)

void __fastcall TMainForm::PutRobotErrorCodeMsg()
{
AnsiString msg = "";
AnsiString errorcode;
int code = 0;

   errorcode = pnlRobotErrorCode->Caption;
   if(errorcode == "")
      code = 0;
   else if(errorcode == "00")
      code = 1;
   else if(errorcode == "09")
      code = 2;
   else if(errorcode == "10")
      code = 3;
   else if(errorcode == "20")
      code = 4;
   else if(errorcode == "30")
      code = 5;
   else if(errorcode == "31")
      code = 6;
   else if(errorcode == "32")
      code = 7;
   else if(errorcode == "40")
      code = 8;
   else if(errorcode == "51")
      code = 9;
   else if(errorcode == "61")
      code = 10;
   else if(errorcode == "62")
      code = 11;
   else if(errorcode == "63")
      code = 12;
   else if(errorcode == "64")
      code = 13;
   else if(errorcode == "67")
      code = 14;
   else if(errorcode == "70")
      code = 15;
   else if(errorcode == "80")
      code = 16;
   else if(errorcode == "82")
      code = 17;
   else if(errorcode == "84")
      code = 18;
   else if(errorcode == "90")
      code = 19;
   else if(errorcode == "95")
      code = 20;
   else if(errorcode == "A0")
      code = 21;
   else if(errorcode == "B0")
      code = 22;
   else if(errorcode == "C0")
      code = 23;
   else if(errorcode == "D0")
      code = 24;
   else if(errorcode == "D1")
      code = 25;
   else if(errorcode == "D3")
      code = 26;
   else if(errorcode == "D5")
      code = 27;
   else if(errorcode == "D7")
      code = 28;
   else if(errorcode == "D8")
      code = 29;
   else if(errorcode == "D9")
      code = 30;
   else if(errorcode == "DA")
      code = 31;
   else if(errorcode == "DB")
      code = 32;
   else if(errorcode == "DC")
      code = 33;
   else if(errorcode == "E0")
      code = 34;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Normal status (no error)";
         break;
      case 2:
         msg = "Positioning error (Refer to error axis information.)";
         break;
      case 3:
         msg = "Emergency stop state";
         break;
      case 4:
         msg = "A-CAL does not end normally. (Refer to error axis information.)";
         break;
      case 5:
         msg = "The address is out of the limit";
         break;
      case 6:
         msg = "The robot was tried to be moved to the END(??) point";
         break;
      case 7:
         msg = "FAN alarm status (When FAN alarm function is active.)";
         break;
      case 8:
         msg = "The position data is out of the limited area. (Refer to error axis information.)";
         break;
      case 9:
         msg = "The robot is in overrun status. (Refer to error axis information.)";
         break;
      case 10:
         msg = "Communication command error";
         break;
      case 11:
         msg = "A command which could not be executed in the current mode was received.";
         break;
      case 12:
         msg = "System data (SG, SP) is corrupted.";
         break;
      case 13:
         msg = "The position data cannot be read from the memory card.";
         break;
      case 14:
         msg = "Servo parameter is corrupted.";
         break;
      case 15:
         msg = "Low encoder battery";
         break;
      case 16:
         msg = "The robot received another command during command processing.";
         break;
      case 17:
         msg = "Sensor input does not turn ON. (When sensor stop function is active.)";
         break;
      case 18:
         msg = "The measurement result is out of the range. (When glass alignment function is active.)";
         break;
      case 19:
         msg = "The robot was tried to be operated before A-CAL had been completed.";
         break;
      case 20:
         msg = "Coordinate transformation error: The specified position data is invalid.";
         break;
      case 21:
         msg = "Driver error (Refer to error axis information.)";
         break;
      case 22:
         msg = "Servo lock does not work.";
         break;
      case 23:
         msg = "Program error (When HARL-U2 is in use.)";
         break;
      case 24:
         msg = "Aligner error: The line sensor cannot be initialized.";
         break;
      case 25:
         msg = "Aligner error: The wafer edge cannot be detected.";
         break;
      case 26:
         msg = "Aligner error: Too much scans";
         break;
      case 27:
         msg = "Aligner error: The pivot axis rotation frequency is not sufficient.";
         break;
      case 28:
         msg = "Aligner error: The correction amount exceeds the set value.";
         break;
      case 29:
         msg = "Aligner error: Wrong transfer robot is specified.";
         break;
      case 30:
         msg = "Aligner error: Wrong axis is specified for correction output.";
         break;
      case 31:
         msg = "Aligner error: Wrong address is specified for correction output.";
         break;
      case 32:
         msg = "Aligner error: Wrong direction is specified for motor rotation.";
         break;
      case 33:
         msg = "Aligner error: Wrong parameter is specified.";
         break;
      case 34:
         msg = "Axis interlock (When axis interlock function is active.)";
         break;

   }
   pnlRobotErrorMsg->Caption = msg;
   pnlRobotErrorMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 1) {
      AddErrorLog("[Robot] " + errorcode + ": " + msg);
   }

}
//---------------------------------------------------------------------------
// 2020 5 14 - chc 設定第一片
int TotalWafer = 0;
void __fastcall TMainForm::SetFristWafer()
{
TPanel *panel;
bool first = true;

   WriteSystemLog("SetFristWafer: Enter...");
   for(int i=0 ; i<25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      if(panel->Color == clLime) {
         // 第一片位置
         // 小到大
         if(rgLoadOrder->ItemIndex == 0) {
            if(first == true) {
               first = false;
               rgWaferNo->ItemIndex = 24 - i;
               break;
            }
         }
         // 大到小
         else {
            rgWaferNo->ItemIndex = 24 - i;
         }
      }
   }

   // 2020 5 22 - chc 計算總數量
   int tno = 0;
   for(int i=0 ; i<25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      if(panel->Color == clLime) {
         tno++;
      }
   }
   WriteSystemLog("SetFristWafer: 總片數= " + IntToStr(tno));
   TotalWafer = tno;
   //pbWafer->MaxValue = tno;
   pbWafer->Position = 0;

}
//---------------------------------------------------------------------------
// 2020 5 20 - chc for Robot test
void __fastcall TMainForm::Panel98Click(TObject *Sender)
{

   return;

   // 060262000000
   sprintf(RobotStatus,"060262000000");
   UpdateRobotStatus_1(1);
   PutRobotErrorCodeMsg();
}
//---------------------------------------------------------------------------
// 2020 5 20 - chc for LoadPort test
void __fastcall TMainForm::Panel93Click(TObject *Sender)
{

   return;

   // 0000GET:STAS/02100010101000000000;45*
   //              12345678901234567890
   // 28: Error code
   sprintf(LoadPortStatus,"02102810101000000000");
   UpdateLoadPortStatus_1();
   // STAS or ABS
   // Error Code
   pnlLoadPortErrorCode->Caption = "28";
   pnlLoadPortErrorCode1->Caption = "28";
   PutLoadPortErrorCodeMsg();
   // InterLock code
   pnlLoadPortInterLockCode->Caption = "1A";
   pnlLoadPortInterLockCode1->Caption = "1A";
   PutLoadPortInterLockMsg();

}
//---------------------------------------------------------------------------
// 2020 5 20 - chc for Aligner test
void __fastcall TMainForm::Panel105Click(TObject *Sender)
{

   return;

   sprintf(AlignerStatus,"001011011100000");
   UpdateAlignerStatus_1();
   // ABS
   // 0000ABS:FPML/16;D0* (ABS=有error, 16=error code)
   // 12345678901234567890
   pnlAlignerErrorCode->Caption = "11";
   pnlAlignerErrorCode1->Caption = "11";
   PutAlignerCodeMsg();

}
//---------------------------------------------------------------------------
// boolRobotStatus = false;
void __fastcall TMainForm::RobotButton()
{

   btnRobotCMD->Enabled = boolRobotStatus;
   btnRobotOriginal->Enabled = boolRobotStatus;
   btnRobotPos->Enabled = boolRobotStatus;
   cbRobot->Enabled = boolRobotStatus;
   rgWaferLocation->Enabled = boolRobotStatus;
   btnRobotGet->Enabled = boolRobotStatus;
   btnRobotPut->Enabled = boolRobotStatus;
   btnRobotVacuumOn->Enabled = boolRobotStatus;
   btnRobotVacuumOff->Enabled = boolRobotStatus;
   btnRobotStas->Enabled = boolRobotStatus;
   btnRobotWithWafer->Enabled = boolRobotStatus;
   btnRobotGetPosition->Enabled = boolRobotStatus;
   btnRobotClearAlarm->Enabled = boolRobotStatus;
   btnRobotEanble->Enabled = boolRobotStatus;
   btnRobotDisable->Enabled = boolRobotStatus;
}
//---------------------------------------------------------------------------
// boolLoadPortStatus = false;
void __fastcall TMainForm::LoadPortButton(int mode)
{

   btnLoadPortCMD->Enabled = boolLoadPortStatus;
   btnLoadPortLoad->Enabled = boolLoadPortStatus;
   btnLoadPortUnLoad->Enabled = boolLoadPortStatus;
   btnLoadPortLED->Enabled = boolLoadPortStatus;
   btnLoadPortMap->Enabled = boolLoadPortStatus;
   btnLoadPortStas->Enabled = boolLoadPortStatus;
   btnLoadPortMapping->Enabled = boolLoadPortStatus;
   btnLoadPortReset->Enabled = boolLoadPortStatus;

   if(mode == 1 || boolLoadPortStatus == false)
      btnCassetteLoad->Enabled = boolLoadPortStatus;
}
//---------------------------------------------------------------------------
// boolAlignerStatus = false;
void __fastcall TMainForm::AlignerButton()
{

   btnAlignerCMD->Enabled = boolAlignerStatus;
   btnAlignerORGN->Enabled = boolAlignerStatus;
   btnAlignerVacuumOff->Enabled = boolAlignerStatus;
   btnAlignerAlignment->Enabled = boolAlignerStatus;
   btnAlignerStas->Enabled = boolAlignerStatus;
   btnAlignerWithWafer->Enabled = boolAlignerStatus;
   rgAlignerSet->Enabled = boolAlignerStatus;
   btnAlignerSet->Enabled = boolAlignerStatus;
   btnAlignerGet->Enabled = boolAlignerStatus;
   btnAlignerReset->Enabled = boolAlignerStatus;
   btnAlignerSave->Enabled = boolAlignerStatus;
   edAlignerDegree->Enabled = boolAlignerStatus;
   edAlignerDegreeOut->Enabled = boolAlignerStatus;
   edAlignerSpeed->Enabled = boolAlignerStatus;
   edAlignerType->Enabled = boolAlignerStatus;
}
//---------------------------------------------------------------------------
// 2020 5 20a - chc 若HomeDone檢查Vacuum, CDA
// 設定boolCDAVacuum: false-Error, true-Success
bool __fastcall TMainForm::CheckCDAVacuum()
{

   // 2020 5 21 - chc 記錄是否開始做DIO
   if(MainForm->boolDIO == false) {
      WriteSystemLog("CheckCDAVacuum: 尚未做過DIO更新, 不執行.");
      boolCDAVacuum = false;
      return false;
   }
   WriteSystemLog("CheckCDAVacuum: Enter...");

   // 2021 5 4 - chc 改成看Status: HSL_IO_InStatus
   if(HSL_IO_InStatus[2] == false || HSL_IO_InStatus[3] == false) {
      // 2021 5 4 - chc Log
      if(HSL_IO_InStatus[2] == false)
         WriteSystemLog("SystemCDA Error!");
      if(HSL_IO_InStatus[3] == false)
         WriteSystemLog("SystemVacuum Error!");

      pnlAlarmMessage->Caption = "System CDA or Vacuum is abnormal! stop operation.";
      //AddAlarmLog(pnlAlarmMessage->Caption);
      pcEFEMH->Enabled = false;
      pcEFEMR->Enabled = false;

      // 2020 5 20a - chc Error Log
      // 2021 5 4 - chc 改成看Status
      //if(pnlBit2->Color != clLime || pnlBit11->Color != clLime)
      if(boolSystemCDA == false || boolEFEMCDA == false)

         AddErrorLog("[System] CDA異常!");
      else
         AddErrorLog("[System] Vacuum異常!");
      boolCDAVacuum = false;

      // 2023 8 2 - chc Init Start
      if(pnlHomeStep->Visible == true) {
         pnlCDAVacuumUnit->Caption = "Fail!";
         pnlCDAVacuumUnit->Font->Color = clRed;
      }

      return false;
   }
   else {
      if(pnlAlarmMessage->Caption == "System CDA or Vacuum is abnormal! stop operation.")
         pnlAlarmMessage->Caption = "";
   }
   boolCDAVacuum = true;

   // 2023 8 2 - chc Init Start
   if(pnlHomeStep->Visible == true) {
      pnlCDAVacuumUnit->Caption = "Completed.";
   }

   return true;
}
//---------------------------------------------------------------------------
// 2020 5 20a - chc Error Log
// SystemError.log
void __fastcall TMainForm::LoadErrorLog()
{
AnsiString fname;

   fname = ErrorLogFileName;
   if(FileExists(fname)) {
      mmLog->Lines->LoadFromFile(fname);
   }

   // 2020 5 22 - chc SystemHelp
   fname = SystemHelpFileName;
   mmSystemHelp->Lines->LoadFromFile(fname);

}
//---------------------------------------------------------------------------
// 2020 5 20a - chc Error Log
// SystemError.log
void __fastcall TMainForm::AddErrorLog(AnsiString msg)
{
AnsiString temp;

   DateTimeToString(temp,"yyyy'/'mm'/'dd hh':'nn':'ss",Now());
   msg = temp + "> " + msg + "\n";
   mmLog->Lines->Append(msg);

   FILE *logFile;
   logFile = fopen(ErrorLogFileName.c_str(),"a+t");
   fprintf(logFile,msg.c_str());
   fclose(logFile);

}
//---------------------------------------------------------------------------
// 2020 5 20a - chc Error Log
// ErrorLog.txt
void __fastcall TMainForm::ClearErrorLog()
{

   mmLog->Lines->Clear();
   if(FileExists(ErrorLogFileName)) {
      DeleteFile(ErrorLogFileName.c_str());
   }
}
//---------------------------------------------------------------------------
// 2020 5 20a - chc for test
void __fastcall TMainForm::pnlXClick(TObject *Sender)
{

   return;

   AddErrorLog("Robot: Test");
}
//---------------------------------------------------------------------------
// 2020 5 21 - chc 強制為Ready
void __fastcall TMainForm::pnlEFEMReadyClick(TObject *Sender)
{

   pnlEFEMReady->Color = clLime;
}
//---------------------------------------------------------------------------
// 2020 5 21 - chc for test
void __fastcall TMainForm::Label182Click(TObject *Sender)
{

   return;

   boolRobotStatus = true;
   RobotButton();
}
//---------------------------------------------------------------------------
// 2020 5 21 - chc 記錄為Load後的第一片
void __fastcall TMainForm::btnReStartClick(TObject *Sender)
{

   boolFirstAfterLoad = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::cbAutoLoadClick(TObject *Sender)
{

   pbWafer->Visible = cbAutoLoad->Checked;
   pbWafer->Position = 0;
}
//---------------------------------------------------------------------------
// 2020 5 22 - chc 更新pbWafer
void __fastcall TMainForm::UpdateProgress(int no)
{
TPanel *panel;
bool first = true;
int cno = 0;
int progress = 0;

   if(pbWafer->Visible == false)
      return;

   // 小到大
   if(rgLoadOrder->ItemIndex == 0) {
      for(int i=0 ; i<25 ; i++) {
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
         if(panel->Color == clLime) {
            cno++;
            if((i+1) == no) {
               WriteSystemLog("UpdateProgress小到大: 片數= " + IntToStr(cno) + "," + IntToStr(pbWafer->MaxValue));
               //pbWafer->Position = cno;
               break;;
            }
         }
      }
   }
   else {
      for(int i=24 ; i>=0 ; i--) {
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
         if(panel->Color == clLime) {
            cno++;
            if((i+1) == no) {
               WriteSystemLog("UpdateProgress大到小: 片數= " + IntToStr(cno) + "," + IntToStr(pbWafer->MaxValue));
               //pbWafer->Position = cno;
               break;
            }
         }
      }
   }
   if(cno > 0 && TotalWafer > 0) {
      if(cno >= TotalWafer)
         progress = 100;
      else
         progress = (cno * 100) / TotalWafer;
   }
   pbWafer->Position = progress;
}
//---------------------------------------------------------------------------
// 2020 6 22 - chc 維護模式
void __fastcall TMainForm::rgMaintenanceModeClick(TObject *Sender)
{
TIniFile *pSystemFile;
int mode;

   pnlSystemMessage->Caption = "維護模式參數更新中...";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   // 維護模式
   mode = rgMaintenanceMode->ItemIndex;
   pSystemFile->WriteInteger("Maintenance" ,"Mode"                              ,mode);

   delete pSystemFile;
   pnlSystemMessage->Caption = "Maintenance: Parameter update complete.";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------
// 2020 6 22 - chc 維護模式
void __fastcall TMainForm::ReadMaintenanceMode()
{
TIniFile *pSystemFile;
int mode;

   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   // 維護模式
   mode = pSystemFile->ReadInteger("Maintenance" ,"Mode"                        ,0);
   rgMaintenanceMode->ItemIndex = mode;

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2020 6 22 - chc 維修燈
void __fastcall TMainForm::btnMaintenanceLightClick(TObject *Sender)
{

   pnlDOMaintenanceLightClick(this);
}
//---------------------------------------------------------------------------
// 2020 6 22 - chc 開/關維修燈
void __fastcall TMainForm::MaintenanceLight(bool mode)
{

   if(mode == false) {
      if(pnlDOMaintenanceLight->Color == clLime)
         pnlDOMaintenanceLightClick(this);
   }
   else {
      if(pnlDOMaintenanceLight->Color != clLime)
         pnlDOMaintenanceLightClick(this);
   }
}
//---------------------------------------------------------------------------
// 2020 6 22 - chc 要開靜電Bar及FFU
void __fastcall TMainForm::StageBarFFU(bool mode)
{

   if(mode == true) {
      if(pnlStageBar->Color != clLime)
         pnlStageBarClick(this);
      if(pnlDOStageFFU->Color != clLime)
         pnlDOStageFFUClick(this);
   }
   else {
      if(pnlStageBar->Color == clLime)
         pnlStageBarClick(this);
      if(pnlDOStageFFU->Color == clLime)
         pnlDOStageFFUClick(this);
   }
}
//---------------------------------------------------------------------------
// 2020 8 12 - chc TSMC修改: Bar
void __fastcall TMainForm::StageBar(bool mode)
{

   if(mode == true) {
      if(pnlStageBar->Color != clLime)
         pnlStageBarClick(this);
   }
   else {
      if(pnlStageBar->Color == clLime)
         pnlStageBarClick(this);
   }
}
//---------------------------------------------------------------------------
// 2020 8 12 - chc TSMC修改: FFU
void __fastcall TMainForm::StageFFU(bool mode)
{

   if(mode == true) {
      if(pnlDOStageFFU->Color != clLime)
         pnlDOStageFFUClick(this);
   }
   else {
      if(pnlDOStageFFU->Color == clLime)
         pnlDOStageFFUClick(this);
   }
}
//---------------------------------------------------------------------------
// 2020 8 12 - chc TSMC修改: FFU
void __fastcall TMainForm::EFEMFFU(bool mode)
{

   if(mode == true) {
      if(pnlDOEFEMFFU->Color != clLime)
         pnlDOEFEMFFUClick(this);
   }
   else {
      if(pnlDOEFEMFFU->Color == clLime)
         pnlDOEFEMFFUClick(this);
   }
}
//---------------------------------------------------------------------------
// 2020 6 22 - chc 維護模式
// 1. 暫停: Robot / Z 安全位置
// 2. 允許開啟外罩
// 3.
void __fastcall TMainForm::cbMaintenanceModeClick(TObject *Sender)
{
static bool boolload = false;
static bool boolunload = false;

   cbMaintenanceMode->Enabled = false;
   // 開門: DO0 Off, DI13 Off
   if(cbMaintenanceMode->Checked == true) {
      pnlOperationMessage->Caption = "進入開啟觀測模式...";
      // Robot安全位置
      if(boolInUnLoad == true && boolInLoad == true) {
         pnlOperationMessage->Caption = "等待Robot作業完成...";
         pnlSystemMessage->Caption = pnlOperationMessage->Caption;
         while(1) {
            if(boolInUnLoad == false && boolInLoad == false) {
               pnlOperationMessage->Caption = "Robot作業完成, 可開啟Stage門檢.";
               pnlSystemMessage->Caption = pnlOperationMessage->Caption;
               break;
            }
            WaitTime(100);
            //Sleep(100);
            //Application->ProcessMessages();
         }
      }

      // Z安全位置
      if(rgMaintenanceMode->ItemIndex == 1) {
         pnlOperationMessage->Caption = "等待Z回到原點...";
         pnlSystemMessage->Caption = pnlOperationMessage->Caption;
         btnToOriginalClick(this);                                              // 入料點
      }

      pnlOperationMessage->Caption = "準備開啟Stage門檢...";
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;

      // 門鎖Off
      if(pnlStageLock->Color == clLime) {
         pnlStageLockClick(this);

         // 檢查DI13是否為Off? 若不是則不作業: 要DO0 Off - 關門 - 再DO0 On
         WaitTime(1000);
         //Sleep(500);

         //if(pnlBit13->Color == clLime) {
         if(HSL_IO_InStatus[13] == true) {
            pnlSystemMessage->Caption = "Stage門鎖異常! 維持關閉狀態.";
            pnlOperationMessage->Caption = pnlSystemMessage->Caption;
            pnlStageLockClick(this);
            cbMaintenanceMode->Checked = false;
         }
         else {
            boolload = btnLoadWafer->Enabled;
            boolunload = btnUnloadWafer->Enabled;
            rgWaferNo->Enabled = false;
            btnLoadWafer->Enabled = false;
            pnlLoadWafer->Color = clSilver;
            btnUnloadWafer->Enabled = false;
            pnlOperationMessage->Caption = "進入開啟觀測模式.";
            pnlSystemMessage->Caption = pnlOperationMessage->Caption;
         }

      }
      else {
         pnlOperationMessage->Caption = "開啟Stage門檢失敗!";
         pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      }

   }
   // 關門: DO0 on, DI13 On
   else {
stage_again:
      pnlOperationMessage->Caption = "進入關閉觀測模式...";
      if(pnlStageLock->Color == clSilver) {
         pnlStageLockClick(this);
         WaitTime(1000);
         //Sleep(500);
      }
      // 檢查DI13是否為On? 若不是則不作業: 要DO0 Off - 關門 - 再DO0 On

      //if(pnlBit13->Color != clLime) {
      if(HSL_IO_InStatus[13] != true) {
         pnlOperationMessage->Caption = "Stage門尚未關閉, 請關閉.";
         Application->MessageBox("請確認Stage門已關閉   ", " Olympus Operation", MB_OK);
         // DO0 Off
         if(pnlStageLock->Color == clLime) {
            pnlStageLockClick(this);
            WaitTime(1000);
            //Sleep(500);
         }
         goto stage_again;
      }
      else {
         pnlSystemMessage->Caption = "檢查Stage門鎖: 已關閉.";
         rgWaferNo->Enabled = true;
         btnLoadWafer->Enabled = true;
         btnUnloadWafer->Enabled = true;
         btnLoadWafer->Enabled = boolload;
         btnUnloadWafer->Enabled = boolunload;
         pnlOperationMessage->Caption = "關閉觀測模式.";
      }

   }

   cbMaintenanceMode->Enabled = true;
}
//---------------------------------------------------------------------------
// 2020 7 14 - chc Stage門檢
// DO0-On, 若DI13未On則不能作業
void __fastcall TMainForm::CheckStageDoor()
{

   WriteSystemLog(">檢查Stage門鎖...");
   while(1) {
      pnlSystemMessage->Caption = "檢查Stage門鎖...";

      // 2021 5 5 - chc - 改用HSL_IO_OuStatus |= STAGE_LOCK
      //if(pnlStageLock->Color == clSilver) {
      if((HSL_IO_OuStatus & STAGE_LOCK) == 0) {
         WriteSystemLog(">檢查Stage門鎖, HSL_IO_OuStatus bit0為0, 再送一次");

         pnlStageLockClick(this);
         WaitTime(1000);
         //Sleep(1000);
      }
      else
         WriteSystemLog(">檢查Stage門鎖, HSL_IO_OuStatus bit0為1");

      // 2020 7 15 - chc 呼叫
      if(boolInMotionUpdate == false) {
         UpdateMotionStatus();
      }

      WaitTime(1000);

      // 檢查DI13是否為On? 若不是則不作業: 要DO0 Off - 關門 - 再DO0 On
      //if(pnlBit13->Color != clLime) {
      if(HSL_IO_InStatus[13] != true) {
         pnlSystemMessage->Caption = "Stage門尚未關閉, 請關閉.";
         Application->MessageBox("請確認Stage門已關閉, 關閉後繼續...   ", " Olympus Operation", MB_OK);
         // DO0 Off
         if(pnlStageLock->Color == clLime) {
            pnlStageLockClick(this);
            WaitTime(1000);
            //Sleep(1000);
         }
      }
      else {
         pnlSystemMessage->Caption = "檢查Stage門鎖: 已關閉.";
         break;
      }

   }
   WriteSystemLog(">檢查Stage門鎖ok.");
}
//---------------------------------------------------------------------------
// 2020 7 16 - chc 設定極限值
void __fastcall TMainForm::btnSetLimitClick(TObject *Sender)
{
AnsiString msg;

   double fcmd;

   // 2021 6 24 - chc X => Z
   //GetPosition(X_AXIS, &fcmd);
   GetPosition(Z_AXIS, &fcmd);

   cmd = fcmd;
   msg.sprintf("%.1f",fcmd/10.0);
   pnlSetLimit->Caption = msg;
   pnlSetLimit->Color = clLime;
   if(btnTargetPosition->Visible == false) {
      btnTargetPosition->Visible = true;
      pnlTargetPosition->Visible = true;
   }

   // 2020 7 20 - chc 寫到水平傾斜位置
   // 2021 6 24 - chc X => Z
   //edAOIX->Text = IntToStr(cmd);
   //edLoadX->Text = IntToStr(cmd);
   edAOIZ->Text = IntToStr(cmd);
   edLoadZ->Text = IntToStr(cmd);

}
//---------------------------------------------------------------------------
// 2020 7 16 - chc 取得Z限制下限
int __fastcall TMainForm::GetZLimit()
{
int zlimit,zoffset,limit;

   zlimit = edZLimit->Text.ToInt();
   zoffset = -1;
   if(MainForm->pnlSetLimit->Color == clLime && btnSetLimit->Visible == true)
      zoffset = (MainForm->pnlSetLimit->Caption.ToDouble() * 10) + edZOffset->Text.ToInt() / Z_RESOLUTION;

   if(zoffset == -1)
      return zlimit;
   if(zlimit < zoffset)
      limit = zlimit;
   else
      limit = zoffset;

   return limit;
}
//---------------------------------------------------------------------------
// 2020 7 17 - chc 是ORGN, 改由Timer加做STAT
void __fastcall TMainForm::tmAlignerStasTimer(TObject *Sender)
{

   tmAlignerStas->Enabled = false;
   WriteSystemLog("Aligner: 是ORGN, Timer中執行GetStas...");
   btnAlignerStasClick(this);
}
//---------------------------------------------------------------------------
// 2020 7 17 - chc Robot/Chuck/Aligner has wafer?
bool __fastcall TMainForm::BeforeUnload()
{

   // 2021 5 4 - chc SetupEFEMSocket
   if(EFEMMode == EFEM_RORZE) {
      pnlOperationMessage->Caption = "UnLoad前檢查Aligner...";

      // 2021 11 12 - chc Log
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);

      // 2021 11 9 - chc 不只看Sensor也要檢查Wafer狀態
      //if(IsAlignerWithWafer() == true) {
      if(IsAlignerWithWafer() == true || pnlWaferAlignerInformation->Color == clLime) {

         WriteSystemLog("BeforeUnload() Aligner with wafer!");
         pnlAlarmMessage->Caption = "Aligner上有Wafer!";
         return false;
      }
      // Chuck上是否有Wafer
      pnlOperationMessage->Caption = "檢查Stage...";

      // 2021 11 12 - chc Log
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);

      // 2021 11 9 - chc 不只看Sensor也要檢查Wafer狀態
      //if(IsChuckWithWafer() == true) {
      if(IsChuckWithWafer() == true || pnlWaferChuckInformation->Color == clLime) {

         WriteSystemLog("BeforeUnload() Chuck with wafer!");
         pnlAlarmMessage->Caption = "Stage上有Wafer!";
         return false;
      }
      // Robot上是否有Wafer
      pnlOperationMessage->Caption = "檢查Robot...";

      // 2021 11 12 - chc Log
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);

      // 2021 11 9 - chc 不只看Sensor也要檢查Wafer狀態
      //if(IsRobotWithWafer() == true) {
      if(IsRobotWithWafer() == true || pnlWaferRobotInformation->Color == clLime || pnlWaferRobotInformationLow->Color == clLime) {

         WriteSystemLog("BeforeUnload() Robot with wafer!");
         pnlAlarmMessage->Caption = "Robot上有Wafer!";
         return false;
      }
      pnlOperationMessage->Caption = "UnLoad前檢查Ok.";

      // 2021 11 12 - chc Log
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);

      return true;
   }

   // 1. 確認Chuck是否無片?
   pnlOperationMessage->Caption = "檢查Chuck...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(pnlBit7->Color == clLime) {
      pnlOperationMessage->Caption = "Chuck有Wafer!";
      pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      return false;
   }

   // 2. 確認Aligner是否無片?
   pnlOperationMessage->Caption = "檢查Aligner...";
   btnAlignerStasClick(this);
   int cnt,timeout;
   cnt = 0;
   timeout = 20;
   // 等
   while(1) {
      if(pnlAligner->Enabled == true)
         break;
      Sleep(100);
      Application->ProcessMessages();
      cnt++;
      if(cnt > timeout) {
         pnlOperationMessage->Caption = "Aligner Timeout Error!";
         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         return false;
      }
   }
   if(pnlAlignerS6->Caption != "011") {
      pnlOperationMessage->Caption = "Aligner有Wafer!";
      pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      return false;
   }
   // 3. 確認Robot是否無片?
   pnlOperationMessage->Caption = "檢查Robot...";
   btnRobotWithWaferClick(this);
   // 等
   cnt = 0;
   timeout = 20;
   while(1) {
      if(pnlRobot->Enabled == true)
         break;
      Sleep(100);
      Application->ProcessMessages();
      cnt++;
      if(cnt > timeout) {
         pnlOperationMessage->Caption = "Robot通訊異常!";
         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         return false;
      }
   }
   if(pnlRobotWithWafer->Color == clLime) {
      pnlOperationMessage->Caption = "Robot上有Wafer!";
      pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      return false;
   }
   pnlOperationMessage->Caption = "UnLoad前檢查Ok.";

   return true;
}
//---------------------------------------------------------------------------
// 2020 7 17 - chc LF上升
void __fastcall TMainForm::tmLFupTimer(TObject *Sender)
{

   tmLFup->Enabled = false;
   //pnlOperationMessage->Caption = "Chuck LF上升...";
   //WriteSystemLog(pnlOperationMessage->Caption);
   boolLFUpState = false;
   WriteSystemLog("(Timer)Chuck LF上升...");
   btnDemoLFUpClick(this);
   WriteSystemLog("(Timer)Chuck LF上升.");
}
//---------------------------------------------------------------------------
// 2020 7 17 - chc LF Down
void __fastcall TMainForm::tmLFDownTimer(TObject *Sender)
{

   tmLFDown->Enabled = false;
   boolLFDownState = false;
   pnlOperationMessage->Caption = "Chuck LF到低點...";
   WriteSystemLog(pnlOperationMessage->Caption);
   btnDemoLFDownClick(this);
}
//---------------------------------------------------------------------------
// 2020 7 21 - chc Reset
void __fastcall TMainForm::pnlSetLimitClick(TObject *Sender)
{

   if(pnlSetLimit->Color == clLime)
      pnlSetLimit->Color = (TColor)0x00FFAAAA;
}
//---------------------------------------------------------------------------
// 2020 8 12 - chc TSMC修改: 改用timer
void __fastcall TMainForm::tmAlignerORGTimer(TObject *Sender)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int timeout = 10000;

   tmAlignerORG->Enabled = false;
   boolAlignerORGN = false;
   btnAlignerORGNClick(this);
   WriteSystemLog("Wait... Aligner ORGN");
   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime)
         break;
      Sleep(1);
      Application->ProcessMessages();
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > timeout) {
         pnlRobotGet->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Aligner取片後歸Home異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         return;
      }
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::comboOlympusVisionNameClick(TObject *Sender)
{
AnsiString svisionrecipe;

   svisionrecipe = comboOlympusVisionName->Text;
}
//---------------------------------------------------------------------------
// 2016 4 16 - chc CCD Select
void __fastcall TMainForm::rgCCDSelectChange(TObject *Sender,
      int ButtonIndex)
{
int no,gain,shutter;

   WriteSystemLog("進入rgCCDSeletctChange: " + IntToStr(rgCCDSelect->ItemIndex));

   // 目前CCD(0/1/2)若在取像中要關閉
   if(CCDSelectNo != -1 && bool_scA1300_StatusAry[CCDSelectNo] == true) {
      if(btnReviewLive->Caption == "Grab") {
         if(scA1300ThreadAry[CCDSelectNo]->boolBaslerLive == true) {
            scA1300ThreadAry[CCDSelectNo]->boolBaslerLive = false;
            btnReviewLive->Caption = "Live";
         }
      }
   }

   no = rgCCDSelect->ItemIndex;
   if(bool_scA1300_StatusAry[no] == false) {
      return;
   }
   CCDSelectNo = no;
   //if(rgCCDSelect->Items->Strings[no] == "Color(R)"){
   //   pnlUpColorCCD->Color = clLime;
   //   pnlUpBWCCD->Color = clSilver;
   //   pnlDownBWCCD->Color = clSilver;
   //}
   //else if(rgCCDSelect->Items->Strings[no] == "Gray(U)"){
   //   pnlUpColorCCD->Color = clSilver;
   //   pnlUpBWCCD->Color = clLime;
   //   pnlDownBWCCD->Color = clSilver;
   //}
   //else {
   //   pnlUpColorCCD->Color = clSilver;
   //   pnlUpBWCCD->Color = clSilver;
   //   pnlDownBWCCD->Color = clLime;
   //}

   // 重新顯示
   no = rgCCDSelect->ItemIndex;
   GigaWidth = CCDInfoAry[no].Width;
   GigaHeight = CCDInfoAry[no].Height;
   shutter = scA1300ShutterAry[no];
   gain = scA1300GainAry[no];

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner: Send Command
void __fastcall TMainForm::btnAlignerSendClick(TObject *Sender)
{
char buf[50];
AnsiString cmd,msg;
int len;

   pnlAlignerSend->Color = clSilver;
   if(csAlignerSocket->Active == true) {
      cmd = edAlignerCommand->Text;
      len = cmd.Length();
      sprintf(buf,"oALN1.%s\r",cmd.c_str());
      len += 6;
      csAlignerSocket->Socket->SendBuf(buf,len+1);
      pnlAlignerSocketConnect->Color = clLime;

      // 2021 9 25 - chc Log
      WriteSystemLog("Aligner送出: " + cmd);

      // 2023 8 2 - chc 加入">"送出
      msg.sprintf(">oALN1.%s",cmd.c_str());
      AddAlignerMessage(msg);

   }
   else
      pnlAlignerSocketConnect->Color = clRed;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
// oALN1,ORGN(0)
void __fastcall TMainForm::btnRorzeAlignerORGNClick(TObject *Sender)
{
static bool first = true;

   btnRorzeAlignerORGN->Enabled = false;
   pnlAlignerADSensor->Caption = "";
   pnlAlignerORGN->Color = clSilver;
   pnlAlignerORGN1->Color = clSilver;
   pnlAlignerORGN1->Refresh();
   if(first == true) {
      first = false;
      // Set IP/Port...
      // DEQU.STDT[1]=172.20.9.100
      // DEQU.STDT[2]=12100
      // DEQU.STDT[3]=172.20.9.161
      // DEQU.STDT[5]=001               - Aligner TCP Server
      // DEQU.STDT[6]=1                 - Aligner Body No
      edAlignerCommand->Text = "DEQU.STDT[1]=172.20.9.100";
      AlignerCmd = "DEQU.STDT[1]";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);
      edAlignerCommand->Text = "DEQU.STDT[2]=12100";
      AlignerCmd = "DEQU.STDT[2]";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);
      edAlignerCommand->Text = "DEQU.STDT[3]=172.20.9.161";
      AlignerCmd = "DEQU.STDT[3]";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);
      edAlignerCommand->Text = "DEQU.STDT[5]=001";
      AlignerCmd = "DEQU.STDT[5]";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);
      edAlignerCommand->Text = "DEQU.STDT[6]=1";
      AlignerCmd = "DEQU.STDT[6]";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);
      // Event
      edAlignerCommand->Text = "EVNT(0,0)";
      AlignerCmd = "EVNT";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);
      // Mode
      edAlignerCommand->Text = "Mode(1)";
      AlignerCmd = "Mode";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);
      // Event: STAT
      edAlignerCommand->Text = "EVNT(1,1)";
      AlignerCmd = "EVNT";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);

      // 2021 6 30 - chc Event: GPRS
      // 2021 6 30a - chc
      /*
      // 2021 6 30 - chc DPRS.STDT[1]=500
      // Aligner Vacuum 變化量超過500mpa
      edAlignerCommand->Text = "DPRS.STDT[1]=500";
      AlignerCmd = "DPRS.STDT[5]";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);

      edAlignerCommand->Text = "EVNT(5,1)";
      AlignerCmd = "EVNT";
      btnAlignerSendClick(this);
      WaitDelayTime(1000);
      */

   }
   // GTAD
   btnAlignerGTADClick(this);
   WaitDelayTime(1000);
   // ORGN
   edAlignerCommand->Text = "ORGN(0)";
   AlignerCmd = "ORGN";
   btnAlignerSendClick(this);
   boolAlignerComplete = false;
   int ret;

   // 2021 4 25 - chc 由20s上調至30s
   //ret = WaitAlignerComplete(3,20000);
   ret = WaitAlignerComplete(3,30000);

   if(ret != 0) {
      pnlAlignerORGN->Color = clRed;
      pnlAlignerORGN1->Color = clRed;
   }
   else {
      pnlAlignerORGN->Color = clLime;
      pnlAlignerORGN1->Color = clLime;
   }
   btnRorzeAlignerORGN->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
void __fastcall TMainForm::btnAlignerALGNClick(TObject *Sender)
{
AnsiString str;
double waferdegree;
int wafersize;

   // P1: 1-Sbstate Alignment
   // P2: D000.00 - D359.99
   // P3: 0 - Ends without shifting the substrate after alignment
   //     1 - Shifts the substrate after alignment
   //     2 - Shifts the substrate after alignment And then picks it up with the Z-Axis
   // P4: 0 - Current Substrate size
   //     1~8: Designated substrate type
   //edAlignerCommand->Text = "ALGN(1,0,0,0)";
   waferdegree = rgWaferDegree->ItemIndex * 90.0;
   wafersize = rgWaferSize->ItemIndex + 1;
   // 使用current size(P4=0)
   //str.sprintf("ALGN(1,D%06.2f,1,%d)",waferdegree,wafersize);

   // 2021 4 29 - chc 使用(1,0,1,0)會有異常, 要為(1,0,0,0)
   //str.sprintf("ALGN(1,D%06.2f,1,0)",waferdegree);
   str.sprintf("ALGN(1,D%06.2f,0,0)",waferdegree);
   WriteSystemLog("Aligner送出: " + str);

   edAlignerCommand->Text = str;
   AlignerCmd = "ALGN";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
void __fastcall TMainForm::btnAlignerSTATClick(TObject *Sender)
{

   edAlignerCommand->Text = "STAT";
   AlignerCmd = "STAT";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
void __fastcall TMainForm::btnAlignerCLMPClick(TObject *Sender)
{

   edAlignerCommand->Text = "CLMP(0)";
   AlignerCmd = "CLMP";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
void __fastcall TMainForm::btnAlignerUCLMClick(TObject *Sender)
{

   edAlignerCommand->Text = "UCLM(0)";
   AlignerCmd = "UCLM";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Init Aligner
void __fastcall TMainForm::btnAlignerINITClick(TObject *Sender)
{

   edAlignerCommand->Text = "INIT";
   AlignerCmd = "INIT";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
void __fastcall TMainForm::btnAlignerRSTAClick(TObject *Sender)
{

   edAlignerCommand->Text = "RSTA(0)";
   AlignerCmd = "RSTA";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
void __fastcall TMainForm::btnAlignerSTOPClick(TObject *Sender)
{

   edAlignerCommand->Text = "STOP";
   AlignerCmd = "STOP";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
// To z Very Bottom Position
void __fastcall TMainForm::btnAlignerzHomeClick(TObject *Sender)
{

   edAlignerCommand->Text = "HOME(1)";
   AlignerCmd = "HOME";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
// Set the target substrate type of the aligner
// SSIZ(1..8) to DALN[0..7]
// oALN1.DALN.STDT[0..7][0..31]
// [14] - Notch 0-degree position offset
void __fastcall TMainForm::btnAlignerSSIZClick(TObject *Sender)
{

   edAlignerCommand->Text = "SSIZ(" + IntToStr(rgWaferSize->ItemIndex+1) + ")";
   AlignerCmd = "SSIZ";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
void __fastcall TMainForm::btnAlignerGTADClick(TObject *Sender)
{

   edAlignerCommand->Text = "GTAD";
   AlignerCmd = "GTAD";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
// SSIZ - HOME - clamp - Alginment - Unclamp
// 入料點: SSIZ(1) - HOME(1)
// 12": 入料點 - 放片 - ALGN - 取片
//  8": 入料點 - 放片 - SSIZ(2) - ALGN  - SSIZ(1) - HOME(1) - 取片
void __fastcall TMainForm::btnAlignerDoClick(TObject *Sender)
{
int ret;

   pnlAlignerDo->Color = clSilver;

   // Clamp
   // 2021 11 12 - chc 要先吸住才做SSIZ,zHome
   btnAlignerCLMPClick(this);
   AddAlignerMessage("CLMP完成.");

   // 2021 6 30 - chc 讀Vacuum
   // 2021 6 30a - chc
   //WriteSystemLog("GPRS...");
   //btnAlignerGPRSClick(this);
   //WaitDelayTime(500);
   //WriteSystemLog("GPRS.");

   // SSIZ
   // SSIZ不會有回應, 等1000ms就可以
   btnAlignerSSIZClick(this);

   // 2021 9 30 - chc 用Wait
   //WaitDelayTime(200);
   ret = WaitAlignerComplete(4,1000);
   // 2021 9 30 - chc 不視為Error
   //if(ret != 0)
   //   goto error;

   AddAlignerMessage("SetSize完成.");

   // ORGN / HOME ?
   //btnAlignerORGNClick(this);
   btnAlignerzHomeClick(this);
   //WaitDelayTime(1000);
   boolAlignerComplete = false;
   ret = WaitAlignerComplete(1,10000);
   if(ret != 0)
      goto error;

   // 2021 11 12 - chc Log
   AddAlignerMessage("zHome完成.");

   // Clamp
   // 2021 11 12 - chc 要先吸住才做SSIZ,zHome
   //btnAlignerCLMPClick(this);

   // 2021 9 20a - chc 將時間縮為800ms
   //WaitDelayTime(1000);
   WaitDelayTime(800);

   // Alignment
   btnAlignerALGNClick(this);
   //WaitDelayTime(1000);
   boolAlignerComplete = false;
   ret = WaitAlignerComplete(2,20000);
   if(ret != 0)
      goto error;

   // 2021 11 12 - chc Log
   AddAlignerMessage("ALGN完成.");

   // nClamp
   btnAlignerUCLMClick(this);

   // 2021 9 20a - chc 將時間縮為800ms
   //WaitDelayTime(1000);
   // 2021 9 30 - chc 會有Timeout問題, 先改回用WaitDelayTime(), 但將時間縮為800ms
   //WaitDelayTime(800);
   ret = WaitAlignerComplete(5,5000);
   if(ret != 0) {
      pnlOperationMessage->Caption = "Aligner: UnClamp Timeout!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 2021 11 12 - chc Log
   AddAlignerMessage("UCLM完成.");

error:
   if(ret == 0)
      pnlAlignerDo->Color = clLime;
   else
      pnlAlignerDo->Color = clRed;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner
void __fastcall TMainForm::btnInputClick(TObject *Sender)
{
int ret,sizeno;

   pnlInput->Color = clSilver;

   // 2021 9 11a - chc 改等指令完成
   boolAlignerComplete = false;
   WriteSystemLog("Aligner到入料點: SSIZ");

   // SSIZ
   sizeno = rgWaferSize->ItemIndex;
   // 入料點為固定12寸位置, SSIZ(8")則會到8"的轉正位置, 12吋的轉正與入料點是相同的
   rgWaferSize->ItemIndex = 0;
   btnAlignerSSIZClick(this);

   // 2021 9 11a - chc 改等指令完成: boolAlignerComplete = false
   // 2021 9 30 - chc SSIZ不會有回應, 等1000ms就可以
   //WaitDelayTime(200);
   //WriteSystemLog("Aligner到入料點: SSIZ等待200ms完成.");
   // 2021 9 23a - chc 改到2000
   //ret = WaitAlignerComplete(4,1000);
   ret = WaitAlignerComplete(4,1000);

   // 2021 9 3 - chc 不視為Error
   //if(ret != 0)
   //   goto error;

   // 2021 9 11a - chc Log
   WriteSystemLog("Aligner到入料點: zHome...");

   // HOME
   btnAlignerzHomeClick(this);
   boolAlignerComplete = false;
   ret = WaitAlignerComplete(1,10000);
   rgWaferSize->ItemIndex = sizeno;

   // 2021 9 11a - chc 檢查是否異常?
   if(ret != 0)
      goto error;

   // 2021 9 11a - chc Log
   WriteSystemLog("Aligner到入料點: zHome.");

   // SSIZ & Home才會變動位置: SSIZ不會動, zHome才會移動

   // 2021 9 11a - chc 改等指令完成
   boolAlignerComplete = false;
   WriteSystemLog("Aligner到入料點: UCLM");

   // 2021 7 22 - chc UnClamp
   btnAlignerUCLMClick(this);

   // 2021 9 11a - chc 改等指令完成
   //WaitDelayTime(1000);
   // 2021 9 20a - chc 會有Timeout問題, 先改回用WaitDelayTime(), 但將時間縮為800ms
   // 2021 9 23 - chc c
   // 2021 9 23a - chc final版寫法
   ret = WaitAlignerComplete(5,5000);
   if(ret != 0)
      goto error;
   //WaitDelayTime(800);
   //WaitDelayTime(1000);

   pnlInput->Color = clLime;

   // 2021 9 11a - chc Log
   WriteSystemLog("Aligner到入料點: Succ.");

   return;
error:
   pnlInput->Color = clRed;

   // 2021 9 11a - chc Log
   WriteSystemLog("Aligner到入料點: Fail!");

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner Message
void TMainForm::AddAlignerMessage(AnsiString msg)
{
AnsiString putmsg;
static AnsiString oldmsg = "";

   //if(oldmsg == msg)                            // 重複不收錄
   //   return;
   oldmsg = msg;
   putmsg = Now().FormatString("nn':'ss':'zzz'-> '") + msg;
   // 以Memo取代, 最多共470 Rows
   mmAligner->Lines->Insert(0,putmsg);
   mmAligner->Refresh();

   if(mmAligner->Lines->Count > 500) {
      for(int i=470 ; i<mmAligner->Lines->Count ; i++)
         mmAligner->Lines->Delete(i);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner Message
void __fastcall TMainForm::mnSaveAlignerToFileClick(TObject *Sender)
{

   if(mmAligner->Lines->Count == 0) {
      Application->MessageBox("目前尚無記錄事項!","量測系統: Aligner記錄檔寫入作業    ",MB_ICONINFORMATION|MB_OK);
      return;
   }
   if(sdAIMessages->Execute()) {
      mmAligner->Lines->SaveToFile(sdAIMessages->FileName.c_str());
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner Message
void __fastcall TMainForm::mnClearAlignerMessageClick(TObject *Sender)
{

   mmAligner->Clear();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner Socket
void __fastcall TMainForm::csAlignerSocketConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlRorzeAligner->Enabled = true;
   pnlAlignerSocketConnect->Color = clLime;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner Socket
void __fastcall TMainForm::csAlignerSocketDisconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlRorzeAligner->Enabled = false;
   pnlAlignerSocketConnect->Color = clSilver;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner Socket
void __fastcall TMainForm::csAlignerSocketError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   ErrorCode = 0;
   pnlAlignerSocketConnect->Color = clRed;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Aligner Socket
void __fastcall TMainForm::csAlignerSocketRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
static char receivestr[256];
static int receivecnt = 0;
static bool inactive = false;
AnsiString text,cmdstr,slen,scmd,spar[30],retcmd;
bool flag,done;
int pos,parcnt,len;
char buf[256];

// 2021 9 16 - chc Alarm
static bool boolorgnerror = false;
static bool boolmotorstall = false;
static bool boolseneorerror = false;
static bool boolcommunicationerror = false;
static bool booldrivererror = false;
static bool boolcontrolpowererror = false;
static bool booloverheaterror = false;
static bool boolnotchdetecterror = false;
static bool boolchuckerror = false;
int errorstate = -1;
int pos1;
AnsiString errorcode,errorname;
// 要Defeuat為"00"
static AnsiString errorcodeold = "00";

   if(inactive == true) {
      AddAlignerMessage("Re-Entrant!");
      return;
   }
   inactive = true;

   parcnt = 0;
   text = Socket->ReceiveText();
   sprintf(buf,"%s",text.c_str());
   len = text.Length();
   for(int i=0 ; i<len ; i++) {
      if(buf[i] == 0x0d)
         buf[i] = '@';
      else if(buf[i] < 0x20)
         continue;
      receivestr[receivecnt++] = buf[i];
   }
   receivestr[receivecnt] = 0x0;
   text.sprintf("%s",receivestr);
   while(1) {
      // aALN1.INIT@
      // 12345678901234567890
      pos = text.Pos("@");
      if(pos != 0) {
         cmdstr = text.SubString(1,pos-1);

         // 2023 8 2 - chc 加入"<"
         //AddAlignerMessage(cmdstr);
         AddAlignerMessage("<" + cmdstr);

         WriteSystemLog("Aligner Command: " + cmdstr);
         text.Delete(1,pos);
         receivecnt -= pos;

         // aALN1.INIT@
         // 12345678901234567890
         retcmd = cmdstr.SubString(7,4);
         if((AlignerCmd == retcmd && cmdstr.SubString(1,1) != "c") || retcmd == "CNCT") {
            pnlAlignerCancelCode->Caption = "";
            pnlAlignerCancelCode->Color = clSilver;
            pnlAlignerSend->Color = clLime;
            if(retcmd == "CNCT") {
               boolAlignerInit = true;
               pnlAlignerReady->Color = clLime;
               pnlAlignerReady1->Color = clLime;
            }

            // 2021 6 30 - chc GPRS: pnlAlignerVacuum, -55kpa
            // eALN1.GPRS:-0053000
            // 12345678901234567890
            // 2021 6 30b - chc
            //
            if(retcmd == "GPRS") {
               int pos,len,value;
               try {
                  len = cmdstr.Length();
                  WriteSystemLog("csAlignerSocketRead: GPRS Read..." + cmdstr);
                  pnlAlignerVacuumValue->Caption = cmdstr.SubString(12,len-11);
                  value = pnlAlignerVacuumValue->Caption.ToInt();
                  value /= 1000;
                  pnlAlignerVacuum->Caption = IntToStr(value) + "kpa";
                  if(abs(value) < 50 && abs(value) > 0) {
                     pnlAlignerVacuumValue->Color = clRed;
                     pnlAlignerVacuum->Color = clRed;
                  }
                  else {
                     pnlAlignerVacuumValue->Color = clBlack;
                     pnlAlignerVacuum->Color = clBlack;
                  }
                  WriteSystemLog("csAlignerSocketRead: GPRS Read.");
               }
               catch(Exception &e) {
                  WriteSystemLog("GPRS(csAlignerSocketRead) - Exception Error");
               }

            }
            //

            // aALN1.GTAD:4095
            // 1234567890123456
            if(retcmd == "GTAD") {
               int pos,len;
               len = cmdstr.Length();
               pnlAlignerADSensor->Caption = cmdstr.SubString(12,len-11);
               if(pnlAlignerADSensor->Caption.ToInt() < 4000)
                  pnlAlignerADSensor->Color = clRed;
               else
                  pnlAlignerADSensor->Color = clLime;
            }

            // 2021 4 25 - chc GPIO: 取得是否有Wafer
            // CLMP之後: aALN1.GPIO:000100205FFEDA30/000000001F000081
            //           11         16              1              16   => 44
            // aALN1.GPIO:00000010/00000041(In/Out: Bit6=1 With Wafer, 0-Without wafer)
            // 11         8       1       8                             => 28
            // => pnlAlignerWithWafer1
            // DI: Bit8,9
            // DO: Bit6
            else if(retcmd == "GPIO") {
               char dibuf[20],dobuf[20];
               int pos,len,hexdigitalno;
               len = cmdstr.Length();
               bool boolwithwafer;

               // 2021 11 15 - chc 是28才對, 或直接比對"aTRB1.GPIO:"
               //if(len == 28) {
               if(len == 28 || cmdstr.Pos(".GPIO:") > 0) {

                  sprintf(dibuf,"%s",cmdstr.SubString(12,8).c_str());
                  sprintf(dobuf,"%s",cmdstr.SubString(21,8).c_str());
                  for(int i=0 ; i<8 ; i++) {
                     if(dibuf[i] >= '0' && dibuf[i] <= '9')
                        dibuf[i] -= '0';
                     else {
                        dibuf[i] -= 'A';
                        dibuf[i] += 10;
                     }
                     if(dobuf[i] >= '0' && dobuf[i] <= '9')
                        dobuf[i] -= '0';
                     else {
                        dobuf[i] -= 'A';
                        dobuf[i] += 10;
                     }
                  }
                  // 8個4Bit(32bits), Bit6
                  // 2021 11 12 - chc Aligner GPIO寫錯, 是[7-6/4]
                  //boolwithwafer = dobuf[8-6/4] & 0x04;
                  boolwithwafer = dobuf[7-6/4] & 0x04;

                  if(boolwithwafer == true)
                     pnlAlignerWithWafer1->Color = clLime;
                  else
                     pnlAlignerWithWafer1->Color = clSilver;
               }

               // 2021 11 12 - chc 這是LP的格式! 當時是範例參考但卻未刪除!
               /*
               bool boolpresenceled,boolplacementled,boolloadled,boolunloadled;
               bool boolmanualled,boolalarmled,boolclampled,booldockled;
               TPanel *panel;
               len = cmdstr.Length();
               if(len == 44) {
                  sprintf(dibuf,"%s",cmdstr.SubString(12,16).c_str());
                  sprintf(dobuf,"%s",cmdstr.SubString(29,16).c_str());
                  for(int i=0 ; i<16 ; i++) {
                     if(dibuf[i] >= '0' && dibuf[i] <= '9')
                        dibuf[i] -= '0';
                     else {
                        dibuf[i] -= 'A';
                        dibuf[i] += 10;
                     }
                     if(dobuf[i] >= '0' && dobuf[i] <= '9')
                        dobuf[i] -= '0';
                     else {
                        dobuf[i] -= 'A';
                        dobuf[i] += 10;
                     }
                  }
                  // 0(63-60)0(59-56)0(55-52)1(51-48)0(47-44)0(43-40)0(39-36)0(35-32)0(31-28)8(27-24)0(23-20)0(19-16)0(15-12)0(11-8)8(7-4)1(3-0)
                  boolclampled = dobuf[15-LOADPORT_CLAMP_BIT/4] & 0x01;
                  booldockled = dobuf[15-LOADPORT_DOCK_BIT/4] & 0x02;
                  boolpresenceled = dobuf[15-LOADPORT_PRESENCE_BIT/4] & 0x01;
                  boolplacementled = dobuf[15-LOADPORT_PLACEMENT_BIT/4] & 0x02;
                  boolloadled = dobuf[15-LOADPORT_LOAD_BIT/4] & 0x04;
                  boolunloadled = dobuf[15-LOADPORT_UNLOAD_BIT/4] & 0x08;
                  boolmanualled = dobuf[15-LOADPORT_MANUAL_BIT/4] & 0x04;
                  boolalarmled = dobuf[15-LOADPORT_ALARM_BIT/4] & 0x08;
                  // Clamp
                  if(boolclampled == true)
                     pnlLoadPort1Clamp->Color = clWhite;
                  else
                     pnlLoadPort1Clamp->Color = clSilver;
                  // Dock
                  if(booldockled == true)
                     pnlLoadPort1Dock->Color = clWhite;
                  else
                     pnlLoadPort1Dock->Color = clSilver;
                  // Presence
                  if(boolpresenceled == true)
                     pnlLoadPort1Presence->Color = clWhite;
                  else
                     pnlLoadPort1Presence->Color = clSilver;
                  // Placement
                  if(boolplacementled == true)
                     pnlLoadPort1Placement->Color = clWhite;
                  else
                     pnlLoadPort1Placement->Color = clSilver;
                  // Load
                  if(boolloadled == true)
                     pnlLoadPort1Load->Color = clLime;
                  else
                     pnlLoadPort1Load->Color = clSilver;
                  // UnLoad
                  if(boolunloadled == true)
                     pnlLoadPort1Unload->Color = clBlue;
                  else
                     pnlLoadPort1Unload->Color = clSilver;
                  // Manual
                  if(boolmanualled == true)
                     pnlLoadPort1Manual->Color = clWhite;
                  else
                     pnlLoadPort1Manual->Color = clSilver;
                  // Alarm
                  if(boolalarmled == true)
                     pnlLoadPort1Alarm->Color = clRed;
                  else
                     pnlLoadPort1Alarm->Color = clSilver;
               }
               */

            }
         }
         else {

            // 2021 10 12 - chc 位置錯誤
            //pnlAlignerSend->Color = clRed;

            if(cmdstr.SubString(1,1) == "c") {

               // 2021 10 12 - chc 位置錯誤
               pnlAlignerSend->Color = clRed;

               pnlAlignerCancelCode->Color = clRed;
               pnlAlignerCancelCode->Font->Color = clWhite;
               // cALN1.ORGB:000F
               // 1234567890123456
               AnsiString cancelcode = cmdstr.SubString(12,4);
               if(cancelcode == "0001")
                  pnlAlignerCancelCode->Caption = "0001-Command not designated";
               else if(cancelcode == "0002")
                  pnlAlignerCancelCode->Caption = "0002-The designated target motion not equipped";
               else if(cancelcode == "0003")
                  pnlAlignerCancelCode->Caption = "0003-Too many/too few parameters(number of elements)";
               else if(cancelcode == "0004")
                  pnlAlignerCancelCode->Caption = "0004-Command not equipped";
               else if(cancelcode == "0005")
                  pnlAlignerCancelCode->Caption = "0005-Too many/too few parameters";
               else if(cancelcode == "0006")
                  pnlAlignerCancelCode->Caption = "0006-Abnormal range of the parameter";
               else if(cancelcode == "0007")
                  pnlAlignerCancelCode->Caption = "0007-Abnormal mode";
               else if(cancelcode == "0008")
                  pnlAlignerCancelCode->Caption = "0008-Abnormal data";
               else if(cancelcode == "0009")
                  pnlAlignerCancelCode->Caption = "0009-System in operation";
               else if(cancelcode == "000A")
                  pnlAlignerCancelCode->Caption = "000A-Origin search not completed";
               else if(cancelcode == "000B")
                  pnlAlignerCancelCode->Caption = "000B-Moving/Processing";
               else if(cancelcode == "000C")
                  pnlAlignerCancelCode->Caption = "000C-No Motion";
               else if(cancelcode == "000D")
                  pnlAlignerCancelCode->Caption = "000D-Abnormal flash memory";
               else if(cancelcode == "000E")
                  pnlAlignerCancelCode->Caption = "000E-Insufficient memory";
               else if(cancelcode == "000F")
                  pnlAlignerCancelCode->Caption = "000F-Error-occurred state";
               else if(cancelcode == "0010")
                  pnlAlignerCancelCode->Caption = "0010-Origin search is completed but the motion cannot be started due to interlock";
               else if(cancelcode == "0011")
                  pnlAlignerCancelCode->Caption = "0011-The emergency stop signal is turned on";
               else if(cancelcode == "0012")
                  pnlAlignerCancelCode->Caption = "0012-The temporarily stop signal is turned on";
               else if(cancelcode == "0013")
                  pnlAlignerCancelCode->Caption = "0013-Abnormal intelock signal";
               else if(cancelcode == "0014")
                  pnlAlignerCancelCode->Caption = "0014-Drive power is turned off";
               else if(cancelcode == "0015")
                  pnlAlignerCancelCode->Caption = "0015-Not excited";
               else if(cancelcode == "0016")
                  pnlAlignerCancelCode->Caption = "0016-Abnormal current position";
               else if(cancelcode == "0017")
                  pnlAlignerCancelCode->Caption = "0017-Abnormal target position";
               else if(cancelcode == "0018")
                  pnlAlignerCancelCode->Caption = "0018-Command porcessing";
               else if(cancelcode == "0019")
                  pnlAlignerCancelCode->Caption = "0019-Invalid substrate state";
               else if(cancelcode == "0020")
                  pnlAlignerCancelCode->Caption = "0020-Substrate yet to be aligned";
            }
         }

         if(boolWaitAlignerComplete == true) {
            AddAlignerMessage("檢查STAT:11000...");
            // 12345/6789
            // D1: Operation mode 0-Initializing, 1-Remote, 2-Maintenance
            // D2: Origin Search Complete 0-Not Completed, 1-Completed
            // D3: Command Processing 0-Stop, 1-Processing
            // D4: Operation Status 0-Stop, 1-Moving, 2-Temporary Stop
            // D5: Motion Speed 0-Maximum Speed, 1-Override speed
            // D6,D7: Controller Identiofication code 00-Whole of the Aligner, 01-X, 02-Y, 03-Z, 04-Spindle
            // D8,D9: Error Code
            // 2021 9 25 - chc 檢查4碼就可以
            //if(cmdstr.Pos("STAT:11000") != 0 || cmdstr.Pos("STAT:10000") != 0) {
            if(cmdstr.Pos("STAT:1100") != 0 || cmdstr.Pos("STAT:1000") != 0) {

               AddAlignerMessage("檢查STAT:11000 ok.");
               boolAlignerComplete = true;
               boolWaitAlignerComplete = false;

               // 2021 9 20 - chc 是指令已完成
               // 2021 9 25 - chc 是AlignerCmd才對
               //AddAlignerMessage("檢查指令: " + retcmd + "已完成.");
               //WriteSystemLog("檢查指令: " + retcmd + "已完成.");
               AddAlignerMessage("檢查指令: " + AlignerCmd + "已完成.");
               WriteSystemLog("檢查指令: " + AlignerCmd + "已完成.");

            }

            // 2021 9 11a - chc 檢查Ack Code
            // 221 9 20a - chc 是指令已被執行, 不應設為完成!
            //else if(AlignerCmd == retcmd && cmdstr.SubString(1,1) == "a") {
            //   AddAlignerMessage("檢查指令: " + retcmd + "已執行.");
            //   boolAlignerComplete = true;
            //   boolWaitAlignerComplete = false;
            //   WriteSystemLog("檢查指令: " + retcmd + "已執行.");
            //}

            else
               AddAlignerMessage("檢查STAT:11000 fail!");

            // 221 9 20a - chc 是指令已被執行, 不應設為完成!
            if(AlignerCmd == retcmd && cmdstr.SubString(1,1) == "a") {
               AddAlignerMessage("檢查指令: " + retcmd + "已執行.");
               WriteSystemLog("檢查指令: " + retcmd + "已執行.");

               // 2021 9 23 - chc 還原原寫法
               // 2021 9 23a - chc final版寫法
               //boolAlignerComplete = true;
               //boolWaitAlignerComplete = false;
               //WriteSystemLog("檢查指令: " + retcmd + "強制為已完成.");

               // 2021 9 30 - chc SSIZ視為完成
               if(AlignerCmd == "SSIZ") {
                  boolAlignerComplete = true;
                  boolWaitAlignerComplete = false;
                  WriteSystemLog("檢查指令: " + retcmd + "強制為已完成.");
               }

            }

         }

         // 2021 9 19 - chc Aligner Alarm code
         // aALN1.STAT:11000/0000
         // 123456789012345678901234567890
         pos1 = 0;
         pos1 = cmdstr.Pos("STAT:");
         if(pos1 > 0) {
            errorcode = cmdstr.SubString(pos1+13,2);
            if(errorcode == "00") {
               if(errorcodeold != errorcode)
                  AddAlignerMessage(">Aligner 恢復正常.");
               errorname = "正常";
               pnlAlignerErrorCode1->Hint = errorname;
               pnlAlignerErrorCode1->Caption = "";
               // Alarm Reset
               if(boolorgnerror == true) {
                  SetSECSAlarm(32001,0,1,"Aligner ORGN Abnormal");
               }
               if(boolmotorstall == true) {
                  SetSECSAlarm(32002,0,1,"Aligner Motor Stall");
               }
               if(boolseneorerror == true) {
                  SetSECSAlarm(32003,0,1,"Aligner Sensor Abnormal");
               }
               if(boolcommunicationerror == true) {
                  SetSECSAlarm(32004,0,1,"Aligner Controller Communication Abnormal");
               }
               if(booldrivererror == true) {
                  SetSECSAlarm(32005,0,1,"Aligner Driver Abnormal");
               }
               if(boolcontrolpowererror == true) {
                  SetSECSAlarm(32006,0,1,"Aligner Control Power Abnormal");
               }
               if(booloverheaterror == true) {
                  SetSECSAlarm(32007,0,1,"Aligner Overheat Abnormal");
               }
               if(boolnotchdetecterror == true) {
                  SetSECSAlarm(32008,0,1,"Aligner Notch Detection Error");
               }
               if(boolchuckerror == true) {
                  SetSECSAlarm(32009,0,1,"Aligner Chucking Error");
               }
               boolorgnerror = false;
               boolmotorstall = false;
               boolseneorerror = false;
               boolcommunicationerror = false;
               booldrivererror = false;
               boolcontrolpowererror = false;
               booloverheaterror = false;
               boolnotchdetecterror = false;
               boolchuckerror = false;
            }
            // Aligner
            //#define ALIGNER_ALARM_ORGN             0
            //#define ALIGNER_ALARM_MOTOR_STALL      1
            //#define ALIGNER_ALARM_SENSOR           2
            //#define ALIGNER_ALARM_COMMUNICATION    3
            //#define ALIGNER_ALARM_DRIVER           4
            //#define ALIGNER_ALARM_POWER            5
            //#define ALIGNER_ALARM_OVER_HEAT        6
            //#define ALIGNER_ALARM_NOTCH_DETECT     7
            //#define ALIGNER_ALARM_CHUCK            8
            else {
               errorname = "異常";
               if(errorcode == "01") {
                  errorname = "失步";
                  errorstate = ALIGNER_ALARM_MOTOR_STALL;
               }
               else if(errorcode == "02") {
                  errorname = "極限";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "03") {
                  errorname = "位置錯誤";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "04") {
                  errorname = "指令錯誤";
                  errorstate = ALIGNER_ALARM_COMMUNICATION;
               }
               else if(errorcode == "05") {
                  errorname = "通訊錯誤";
                  errorstate = ALIGNER_ALARM_COMMUNICATION;
               }
               else if(errorcode == "06") {
                  errorname = "吸附Sensor異常";
                  errorstate = ALIGNER_ALARM_SENSOR;
               }
               else if(errorcode == "07") {
                  errorname = "驅動器EMS異常";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "08") {
                  errorname = "Wafer(真空)掉落";
                  errorstate = ALIGNER_ALARM_CHUCK;
               }
               else if(errorcode == "0E") {
                  errorname = "驅動器異常";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "0F") {
                  errorname = "驅動器電源異常";
                  errorstate = ALIGNER_ALARM_POWER;
               }
               else if(errorcode == "10") {
                  errorname = "控制電源異常";
                  errorstate = ALIGNER_ALARM_POWER;
               }
               else if(errorcode == "13") {
                  errorname = "驅動器溫度異常";
                  errorstate = ALIGNER_ALARM_OVER_HEAT;
               }
               else if(errorcode == "14") {
                  errorname = "驅動器FPGA異常";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "15") {
                  errorname = "馬達斷線";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "16") {
                  errorname = "馬達過載";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "17") {
                  errorname = "馬達起動異常";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "18") {
                  errorname = "Alignment Sensor異常";
                  errorstate = ALIGNER_ALARM_SENSOR;
               }
               else if(errorcode == "19") {
                  errorname = "排熱風扇異常";
                  errorstate = ALIGNER_ALARM_OVER_HEAT;
               }
               else if(errorcode == "1A") {
                  errorname = "偵測Sensor異常";
                  errorstate = ALIGNER_ALARM_SENSOR;
               }
               else if(errorcode == "40") {
                  errorname = "設備驅動異常";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "41") {
                  errorname = "驅動器控制異常";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "42") {
                  errorname = "工作啟始異常";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "45") {
                  errorname = "設定資料讀取異常";
                  errorstate = ALIGNER_ALARM_DRIVER;
               }
               else if(errorcode == "83") {
                  errorname = "原點搜尋異常";
                  errorstate = ALIGNER_ALARM_ORGN;
               }
               else if(errorcode == "84") {
                  errorname = "Chucking異常";
                  errorstate = ALIGNER_ALARM_CHUCK;
               }
               else if(errorcode == "90") {
                  errorname = "Notch偵測異常";
                  errorstate = ALIGNER_ALARM_NOTCH_DETECT;
               }
               else if(errorcode == "91") {
                  errorname = "偵測Sensor異常";
                  errorstate = ALIGNER_ALARM_SENSOR;
               }
               else if(errorcode == "92") {
                  errorname = "尋邊異常";
                  errorstate = ALIGNER_ALARM_NOTCH_DETECT;
               }
               pnlAlignerErrorCode1->Hint = "Aligner: " + errorname;
               pnlOpeationMessage->Caption = "Aligner: " + errorname;
               //RedLamp(true);
               //???
               AddAlignerMessage(">Aligner 異常原因: " + errorname);
               //Beep(100);
               //???
               //#define ALIGNER_ALARM_ORGN             0
               //#define ALIGNER_ALARM_MOTOR_STALL      1
               //#define ALIGNER_ALARM_SENSOR           2
               //#define ALIGNER_ALARM_COMMUNICATION    3
               //#define ALIGNER_ALARM_DRIVER           4
               //#define ALIGNER_ALARM_POWER            5
               //#define ALIGNER_ALARM_OVER_HEAT        6
               //#define ALIGNER_ALARM_NOTCH_DETECT     7
               //#define ALIGNER_ALARM_CHUCK            8
               //static bool boolorgnerror = false;
               //static bool boolmotorstall = false;
               //static bool boolseneorerror = false;
               //static bool boolcommunicationerror = false;
               //static bool booldrivererror = false;
               //static bool boolcontrolpowererror = false;
               //static bool booloverheaterror = false;
               //static bool boolnotchdetecterror = false;
               //static bool boolchuckerror = false;
               if(errorstate == ALIGNER_ALARM_ORGN) {
                  if(boolorgnerror == false) {
                     boolorgnerror = true;
                     SetSECSAlarm(32001,1,1,"Aligner ORGN Abnormal");
                  }
               }
               else if(errorstate == ROBOT_ALARM_MOTOR_STALL) {
                  if(boolmotorstall == false) {
                     boolmotorstall = true;
                     SetSECSAlarm(32002,1,1,"Aligner Motor Stall");
                  }
               }
               else if(errorstate == ALIGNER_ALARM_SENSOR) {
                  if(boolseneorerror == false) {
                     boolseneorerror = true;
                     SetSECSAlarm(32003,1,1,"Alinger Sensor Abnormal");
                  }
               }
               else if(errorstate == ALIGNER_ALARM_COMMUNICATION) {
                  if(boolcommunicationerror == false) {
                     boolcommunicationerror = true;
                     SetSECSAlarm(32004,1,1,"Aligner Controller Communication Abnormal");
                  }
               }
               else if(errorstate == ALIGNER_ALARM_DRIVER) {
                  if(booldrivererror == false) {
                     booldrivererror = true;
                     SetSECSAlarm(32005,1,1,"Aligner Driver Abnormal");
                  }
               }
               else if(errorstate == ALIGNER_ALARM_POWER) {
                  if(boolcontrolpowererror == false) {
                     boolcontrolpowererror = true;
                     SetSECSAlarm(32006,1,1,"Aliner Power fall");
                  }
               }
               else if(errorstate == ALIGNER_ALARM_OVER_HEAT) {
                  if(booloverheaterror == false) {
                     booloverheaterror = true;
                     SetSECSAlarm(32007,1,1,"Aligner Temperature Abnormal");
                  }
               }
               else if(errorstate == ALIGNER_ALARM_NOTCH_DETECT) {
                  if(boolnotchdetecterror == false) {
                     boolnotchdetecterror = true;
                     SetSECSAlarm(32008,1,1,"Aligner Notch Detection Error");
                  }
               }
               else if(errorstate == ALIGNER_ALARM_CHUCK) {
                  if(boolchuckerror == false) {
                     boolchuckerror = true;
                     SetSECSAlarm(32009,1,1,"Aligner Chucking Error");
                  }
               }
            }
            // 記錄Robot Error Code
            errorcodeold = errorcode;
         }

      }
      else
         break;
   }
   sprintf(receivestr,"%s",text.c_str());

   inactive = false;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::btnRobotSendClick(TObject *Sender)
{
char buf[50];
AnsiString cmd,msg;
int len;

   pnlRobotSend->Color = clSilver;
   if(csRobotSocket->Active == true) {

      // 2021 5 3 - chc Robot動作中
      // 初始為Idle, 看到1100/0000就是結束, 待確認STAT/GPIO/HOME....
      RobotMoveState = ROBOT_IDLE;

      cmd = edRobotCommand->Text;
      len = cmd.Length();
      sprintf(buf,"oTRB1.%s\r",cmd.c_str());
      len += 6;
      csRobotSocket->Socket->SendBuf(buf,len+1);
      pnlRobotSocketConnect->Color = clLime;

      // 2021 10 12 - chc 設為clLime
      pnlRobotSend->Color = clLime;

      // 2023 8 2 - chc 加入送出
      msg.sprintf(buf,">oTRB1.%s",cmd.c_str());
      AddRobotMessage(msg);

   }
   else {
      pnlRobotSocketConnect->Color = clRed;

      // 2021 10 12 - chc 設為clRed
      pnlRobotSend->Color = clRed;

   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::btnRobotToHomeClick(TObject *Sender)
{

   // 要取消Robot Home
   btnRobotToHome->Enabled = false;

   pnlOpeationMessage->Caption = "Robot Homing...";
   btnRobotORGNClick(this);
   pnlRobotToHomeStatus->Color = pnlRobotORGNStatus->Color;
   if(pnlRobotToHomeStatus->Color == clLime)
      pnlOpeationMessage->Caption = "Robot Homing Completed.";
   else
      pnlOpeationMessage->Caption = "Robot Homing Fail!";

   btnRobotToHome->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::cbRobotActiveClick(TObject *Sender)
{

   // 2021 8 9 - chc 改用Close
   //csRobotSocket->Active = cbRobotActive->Checked;

   // 要Disable Robot Status
   if(cbRobotActive->Checked == false) {
      pnlRobotSocketConnect->Color = clSilver;
      // 若為True則要等eTRB1.CNCT(一開機時也要等 - Robot Connect)
      // 清除Init flag
      boolRobotInit = false;
      btnRobotORGN->Enabled = false;

      // Disable Robot Socket
      // 2021 8 9 - chc 改用Close
      //csRobotSocket->Active = false;
      csRobotSocket->Close();

   }
   // Enable Robot Socket
   else {
      csRobotSocket->Active = true;

      // 2021 8 4 - chc 恢復
      btnRobotORGN->Enabled = true;
      boolRobotInit = true;

   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot : ORGN
void __fastcall TMainForm::btnRobotORGNClick(TObject *Sender)
{
AnsiString str;
int cnt;
bool boolfirst = true;

   btnRobotORGN->Enabled = false;
   pnlRobotORGNStatus->Color = clSilver;
   pnlRobotORGNStatus->Refresh();
   // ORGN前要取下Wafer
   if(Application->MessageBox("執行ORGN之前須確認Fork上已無Wafer, Fork上無Wafer嗎? ", "Robot ORGN作業", MB_OKCANCEL) == IDCANCEL) {
      pnlOpeationMessage->Caption = "ORGN前要排除Fork上的Wafer";
      btnRobotORGN->Enabled = true;
      return;
   }
   btnRobotORGN->Enabled = false;

   // 確認Robot是否Ready? 要在btnRobotORGN->Enabled=false後做, 否則不會作動!
   if(pnlRobotReady->Color != clLime) {
      pnlOpeationMessage->Caption = "Robot not ready! sent STAT";
      int trycnt = 0;
      while(1) {
         edRobotCommand->Text = "STAT";
         sRobotCmd = "STAT";
         btnRobotSendClick(this);
         DelayTimeRobot(500);
         if(pnlRobotReady->Color == clLime) {
            pnlOpeationMessage->Caption = "Robot ready.";
            break;
         }
         trycnt++;
         // 60秒
         if(trycnt > 60) {
            AddRobotMessage("Robot not ready! Timeout: 30sec");
            pnlOpeationMessage->Caption = "Robot not ready! Timeout: 30sec";
            break;
         }
      }
   }

   // Event
   if(boolfirst == true) {
      boolfirst = false;

      edRobotCommand->Text = "EVNT(0,0)";
      sRobotCmd = "EVNT";
      btnRobotSendClick(this);
      DelayTimeRobot(1000);

      // 0-Initializing, 1-Remote, 2-Maintenance, 3-Recovery
      edRobotCommand->Text = "MODE(1)";
      sRobotCmd = "MODE";
      btnRobotSendClick(this);
      DelayTimeRobot(1000);

      edRobotCommand->Text = "EVNT(1,1)";
      sRobotCmd = "EVNT";
      btnRobotSendClick(this);
      DelayTimeRobot(1000);

      // 不送Speed
      sRobotCmd = "SSPD";
      rgRobotSpeedClick(this);
      DelayTimeRobot(500);
   }

   pnlOpeationMessage->Caption = "Robot Homing...";
   WriteSystemLog("送出OGN(3)");
   // ORGN: 等11000/0000
   edRobotCommand->Text = "ORGN(3)";

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // Robot動作中
   // 2021 5 3 - chc 在btnRobotSendClick()中指定
   //RobotMoveState = ROBOT_IDLE;

   pnlOpeationMessage->Caption = "Robot ORGN Sent...";
   sRobotCmd = "ORGN";
   btnRobotSendClick(this);
   DelayTimeRobot(200);
   cnt = 0;
   WriteSystemLog("送出OGN(3), 等...");
   // Timeout: 120Sec
   while(1) {
      if(RobotMoveState == ROBOT_DONE) {
         WriteSystemLog("送出ORGN(3), ok.");
         DelayTimeRobot(10);
         break;
      }
      DelayTimeRobot(10);
      cnt++;
      if(cnt > 12000) {
         WriteSystemLog("送出ORGN(3), timeout!");
         pnlOpeationMessage->Caption = "Robot Command Timeout!";
         pnlOperationResult->Color = clRed;
         btnRobotORGN->Enabled = true;
         pnlOpeationMessage->Caption = "Robot Home失敗(Timeout 120sec)!";

         // 2021 9 15 - chc Alarm
         if(pnlRobotORGNStatus->Color == clSilver)
            SetSECSAlarm(31001,1,1,"Robot ORGN Error");

         pnlRobotORGNStatus->Color = clRed;
         return;;
      }

      // 有設Event不需要再送STAT
      //edRobotCommand->Text = "STAT";
      //btnRobotSendClick(this);

   }


   // 2021 9 15 - chc Alarm
   if(pnlRobotORGNStatus->Color == clRed)
      SetSECSAlarm(31001,0,1,"Robot ORGN Error");

   // 是否執行過Home?
   boolRobotDone = true;
   pnlRobotORGNStatus->Color = clLime;
   pnlOpeationMessage->Caption = "Robot Home完成.";
   btnRobotORGN->Enabled = true;
   pnlOperationResult->Color = clLime;
   btnRobotORGN->Enabled = true;
   // 2021 6 30 - chc 重設速度60%
   rgRobotSpeed->ItemIndex = 2;
   rgRobotSpeedClick(this);

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::btnRobotSTATClick(TObject *Sender)
{

   edRobotCommand->Text = "STAT";
   sRobotCmd = "STAT";
   btnRobotSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Reset
void __fastcall TMainForm::btnRobotRSTAClick(TObject *Sender)
{
AnsiString str;
int cnt;

   // Reset前要取下Wafer
   if(Application->MessageBox("執行Reset之前須確認Fork上已無Wafer, Fork上無Wafer嗎? ", "Robot Reset作業", MB_OKCANCEL) == IDCANCEL) {
      pnlSystemMessage->Caption = "Reset前要排除Fork上的Wafer";
      return;
   }
   // 清除內部Status
   //if(Station[ROBOT_STATION].boolWithWafer == true)
   //   Station[ROBOT_STATION].boolWithWafer = false;

   // 2018 12 6 - chc 清顏色
   pnlOperationResult->Color = clSilver;
   pnlOpeationMessage->Caption = "Robot Reset...";

   // Reset: 等10000/0000
   edRobotCommand->Text = "RSTA(1)";
   sRobotCmd = "RSTA";

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // Robot動作中
   // 2021 5 3 - chc 在btnRobotSendClick()中指定
   //RobotMoveState = ROBOT_RESET;

   btnRobotSendClick(this);
   cnt = 0;
   // Timeout: 5Sec
   while(1) {
      if(RobotMoveState == ROBOT_DONE) {
         // 改成SleepEx
         //Sleep(10);
         SleepEx(10,true);
         Application->ProcessMessages();
         break;
      }
      // 改成SleepEx
      //Sleep(10);
      SleepEx(10,true);
      Application->ProcessMessages();

      cnt++;
      if(cnt > 500) {
         pnlOpeationMessage->Caption = "Robot Command Timeout!";
         pnlOperationResult->Color = clRed;
         return;;
      }

      // 使用Event, 不需要STAT
      //edRobotCommand->Text = "STAT";
      //btnSendRobotCommandClick(this);
   }

   // 確認Z/T是否到-EL @@暫
   if(Application->MessageBox("Robot RSTA(Robot ORGN), 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      goto end;
   }

   // ORGN: 等11000/0000
   edRobotCommand->Text = "ORGN(3)";

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // Robot動作中
   // 2021 5 3 - chc 在btnRobotSendClick()中指定
   //RobotMoveState = ROBOT_IDLE;

   sRobotCmd = "ORGN";
   btnRobotSendClick(this);
   cnt = 0;
   // Timeout: 120Sec
   while(1) {
      if(RobotMoveState == ROBOT_DONE) {
         // 改成SleepEx
         //Sleep(10);
         SleepEx(10,true);
         Application->ProcessMessages();
         break;
      }
      // 改成SleepEx
      //Sleep(10);
      SleepEx(10,true);
      Application->ProcessMessages();

      cnt++;
      if(cnt > 12000) {
         pnlOpeationMessage->Caption = "Robot Command Timeout!";
         pnlOperationResult->Color = clRed;
         return;;
      }

      // 使用Event, 不需要STAT
      //edRobotCommand->Text = "STAT";
      //btnSendRobotCommandClick(this);
   }

end:
   pnlOperationResult->Color = clLime;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::rgRobotSpeedClick(TObject *Sender)
{
int speed;
AnsiString cmd;

   // 1-20: 1-100
   speed = rgRobotSpeed->ItemIndex;
   switch(speed) {
      case 0:
         speed = 2;
         break;
      case 1:
         speed = 6;
         break;
      case 2:
         speed = 12;
         break;
      case 3:

         // 2021 6 4 - chc 由100%降成80%
         //speed = 20;
         speed = 16;

         break;
   }
   cmd.sprintf("SSPD(%d)",speed);
   edRobotCommand->Text = cmd;

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // Robot動作
   btnRobotSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::btnRobotHOMEClick(TObject *Sender)
{

   // Reset前要取下Wafer
   if(Application->MessageBox("執行Home之前須確認Fork上已無Wafer, Fork上無Wafer嗎? ", "Robot Home作業", MB_OKCANCEL) == IDCANCEL) {
      pnlSystemMessage->Caption = "Home前要排除Fork上的Wafer";
      return;
   }
   // 清除內部Status
   //if(Station[ROBOT_STATION].boolWithWafer == true)
   //   Station[ROBOT_STATION].boolWithWafer = false;

   edRobotCommand->Text = "HOME";

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // Robot動作
   btnRobotSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::btnRobotStageHomeClick(TObject *Sender)
{
int stageno,armno,opno,slotno,startno;
AnsiString cmd,msg;

   pnlRobotStageHome->Color = clSilver;
   // 點位: 1(LoadPort1-11)/2(LoadPort2-21/3(Aligner-1)/4(Chuck-6)
   // 2021 6 30 - chc 分取放片
   //stageno = GetStageNo();
   stageno = GetStageNo(ROBOT_HOME_GET);

   // 1-Upper, 2-Lower
   armno = rgRobotArm->ItemIndex + 1;
   // 1-取(Low), 2-放(High)
   opno = rgRobotOperation->ItemIndex + 1;
   slotno = combRobotSlot->ItemIndex + 1;
   // Aligner/Chuck => 1
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER || rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE)
      slotno = 1;
   cmd.sprintf("HOME(%d,%d,%d,%d)",opno,armno,stageno,slotno);
   edRobotCommand->Text = cmd;
   sRobotCmd = "HOME";

   // 確認 @@暫
   if(cbRobotStep->Checked == true) {
      msg.sprintf("Robot Standby: %s?",cmd);
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotStageHome->Color = clRed;
         return;
      }
   }

   // 2021 5 3 - chc Robot動作中
   // 2021 5 3 - chc 在btnRobotSendClick()中指定
   //RobotMoveState = ROBOT_IDLE;

   // 2021 5 4 - chc Robot動作
   boolRobotComplete = false;

   btnRobotSendClick(this);

   // 2021 5 4 - chc
   // 2021 6 30 - chc 成20Sec
   //ret = WaitRobotComplete(1,6000);
   ret = WaitRobotComplete(1,20000);

   if(ret != 0) {
      // Re-Check
      if(RobotCode1 == "1100" && RobotCode2 == "0000") {
         WriteSystemLog("Robot Error Re-Check STAT ok");
         goto ok;
      }
      goto error;
   }
ok:
   pnlRobotStageHome->Color = clLime;
   return;
error:
   pnlRobotStageHome->Color = clRed;

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot: 取片
void __fastcall TMainForm::btnRorzeRobotGetClick(TObject *Sender)
{
AnsiString cmd,msg;
int ret,stageno,armno,slotno;
TPanel *panel;

   pnlRorzeRobotGet->Color = clSilver;

   // 2021 11 11 - chc 檢查是否為Load: 已關門
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1 || rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {
      if(btnCassetteLoad->Caption == "Load") {
         pnlAlarmMessage->Caption = "LP門已關, 不可以取片!";
         WriteSystemLog(pnlAlarmMessage->Caption);
         pnlRorzeRobotGet->Color = clRed;
         Beep(500);
         return;
      }

      // 2021 11 22 - chc 尚未檢查LP1/LP2: 是否CST上有Wafer?
      panel = (TPanel*)(FindComponent("pnlTray" + combRobotSlot->Text));
      if(panel->Color != clLime) {
         pnlSystemMessage->Caption = "CST " + combRobotSlot->Text + " 上無Wafer!";
         pnlAlarmMessage->Caption = pnlSystemMessage->Caption;
         pnlRorzeRobotGet->Color = clRed;
         Beep(500);
         return;
      }
   }

   // 2021 6 30 - chc 分取放片
   //stageno = GetStageNo();
   stageno = GetStageNo(ROBOT_HOME_GET);

   // 1-Upper, 2-Lower
   armno = rgRobotArm->ItemIndex + 1;
   slotno = combRobotSlot->ItemIndex + 1;

   // 2021 5 5 - chc 檢查W
   if(GoRobotWAxis(0) == false) {
      pnlRorzeRobotGet->Color = clRed;
      pnlAlarmMessage->Caption = "W軸移動失敗!";
      return;
   }

   // 2021 6 30 - chc 監看Aligner
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER) {
      boolAlignerMonitor = false;

      // 2021 9 20a - chc 確認Aligner是否有片? - 取片中不用做
      if(boolInLoad == false) {
         if(IsAlignerWithWafer() == false) {
            pnlOperationMessage->Caption = "Get失敗: Aligner上無Wafer!";
            WriteSystemLog(pnlOperationMessage->Caption);
            if(boolAlignerWithoutWafer == false) {
               boolAlignerWithoutWafer = true;
               SetSECSAlarm(41003,1,0,"Aligner without Wafer");
            }

            // 2021 11 12 - chc 顯示狀態
            pnlRorzeRobotGet->Color = clRed;
            pnlAlarmMessage->Caption = "Get失敗: Aligner上無Wafer!";
            WriteSystemLog(pnlAlarmMessage->Caption);

            return;
         }
      }
      if(boolAlignerWithoutWafer == true) {
         boolAlignerWithoutWafer = false;
         SetSECSAlarm(41003,0,0,"Aligner without Wafer");
      }

   }

   // 2021 5 6 - chc 檢查Stage上是否有片?
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {

      // 是否在入料點?
      btnToOriginalPositionClick(this);
      if(pnlToOriginalPosition->Color != clLime) {
         WriteSystemLog("Get: 到入料點失敗!");
         pnlAlarmMessage->Caption = "Get: 到入料點失敗!";
         pnlAlarmMessage->Caption = pnlSystemMessage->Caption;
         return;
      }
      // 檢查Z高度: 要在CCDZ以上
      double fcmd;
      int inz,cz;
      GetPosition(Z_AXIS, &fcmd);
      cz = fcmd;
      inz = edOriginalZ->Text.ToInt();
      if(cz > (inz + 100)) {

         // 2021 9 11 - chc 加速: MOVE_WAIT
         //if(MoveToZ(inz) == false) {
         if(MoveToZ(inz,MOVE_WAIT) == false) {

            pnlSystemMessage->Caption = "Z上升到CCD對焦高度Fail!";
            pnlAlarmMessage->Caption = pnlSystemMessage->Caption;
            return;
         }
      }

      if(IsChuckWithWafer() == false) {
         pnlRorzeRobotGet->Color = clRed;
         WriteSystemLog("Robot取片: Stage上無片!");
         pnlAlarmMessage->Caption = "Robot取片: Stage上無片!";

         // 2021 9 20a - chc Alarm
         if(boolChuckWithoutWafer == false) {
            boolChuckWithoutWafer = true;
            SetSECSAlarm(41002,1,0,"Chuck Without Wafer");
         }

         return;
      }

      // 2021 9 20a - chc Alarm
      if(boolChuckWithoutWafer == true) {
         boolChuckWithoutWafer = false;
         SetSECSAlarm(41002,0,0,"Chuck Without Wafer");
      }

      // 頂Pin上來
      // L-Vacuum of Position
      WriteSystemLog("Robot取片: Stage Pin到真空點...");
      btnDemoLFVacuumOffClick(this);
      if(boolLFUpState == false) {
         pnlRorzeRobotGet->Color = clRed;
         pnlSystemMessage->Caption = "Lift 到解真空位置失敗!";
         WriteSystemLog("Robot取片: Stage Pin到真空點 Error!");
         return;
      }
      WriteSystemLog("Robot取片: Stage Pin到真空點.");
      WriteSystemLog("Robot取片: Stage關真空...");

      // Vacuum Off
      // 2021 7 17 - chc 8"/12" Vacuum重寫
      /*
      if(pnlStageVacuum->Color == clLime) {
         pnlStageVacuumClick(this);
      }

      // 2021 6 3 - chc 12"
      if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
         if(pnlStageVacuum1->Color == clLime)
            pnlStageVacuum1Click(this);
      }
      */
      if(pnlStageVacuum->Color == clLime)
         pnlStageVacuumClick(this);
      if(pnlStageVacuum1->Color == clLime)
         pnlStageVacuum1Click(this);

      // 2021 9 11 - chc 稍Delay
      Sleep(100);

      // L-Up
      WriteSystemLog("Robot取片: Stage Pin上升...");
      btnDemoLFUpClick(this);
      if(boolLFUpState == false) {
         pnlRorzeRobotGet->Color = clRed;
         pnlSystemMessage->Caption = "Lift pin上升失敗!";
         WriteSystemLog("Robot取片: Stage Pin上升 Error!");
         return;
      }
      WriteSystemLog("Robot取片: Stage Pin上升.");
   }
/*
   // 檢查Aligner上是否有片?
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER) {
      if(IsAlignerWithWafer() == false) {
         pnlRorzeRobotGet->Color = clRed;
         WriteSystemLog("Robot取片: Aligner上無片!");
         pnlAlarmMessage->Caption = "Robot取片: Aligner上無片!";
         return;
      }
   }
   // 檢查LP1上是否有片?
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1) {
      if(pnlLoadPort1Load->Color == clSilver) {
         pnlRorzeRobotGet->Color = clRed;
         WriteSystemLog("Robot取片: LP1尚未Load!");
         pnlAlarmMessage->Caption = "Robot取片: LP1尚未Load!";
         return;
      }
      // pnlTray25
      TPanel *panel;
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(slotno)));
      if(panel->Color == clSilver) {
         pnlRorzeRobotGet->Color = clRed;
         WriteSystemLog("Robot取片: LP1 Carrier上無第" + IntToStr(slotno) + "片!");
         pnlAlarmMessage->Caption = "Robot取片: LP2 Carrier上無第" + IntToStr(slotno) + "片!";
         return;
      }
   }
   // 檢查LP2上是否有片?
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {
      if(pnlLoadPort2Load->Color == clSilver) {
         pnlRorzeRobotGet->Color = clRed;
         WriteSystemLog("Robot取片: LP2尚未Load!");
         pnlAlarmMessage->Caption = "Robot取片: LP2尚未Load!";
         return;
      }
      // pnlTray25
      TPanel *panel;
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(slotno)));
      if(panel->Color == clSilver) {
         pnlRorzeRobotGet->Color = clRed;
         WriteSystemLog("Robot取片: LP2 Carrier上無第" + IntToStr(slotno) + "片!");
         pnlAlarmMessage->Caption = "Robot取片: LP2 Carrier上無第" + IntToStr(slotno) + "片!";
         return;
      }
   }
*/

   // 確認 @@暫
   if(cbRobotStep->Checked == true) {
      msg.sprintf("Robot取片: 點位,Arm(1-Up,2-Low),片數= %d,%d,%d 正確?",stageno,armno,slotno);
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRorzeRobotGet->Color = clRed;
         return;
      }
   }

   // 2021 12 15 - chc 到Stage取片要Reset中心點位置
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
      pnlCenterXFind->Caption = "";
      pnlCenterYFind->Caption = "";
   }

   // 2021 5 6 - chc 取片前PTST-PROC
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1) {

      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_1;
      //rgSECSPortNo->ItemIndex = LOADPORT_2;

      // Buffer狀態改變: PTST slotno
      WaferBuffer[slotno-1].Status = 0;
      WorkingBuffer[slotno-1] = '0';
      rgPortStatus->ItemIndex = PORT_STATUS_PROC;
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      WriteSystemLog("LP1 取片前送出PTST-PROC");
   }
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {

      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_2;
      //rgSECSPortNo->ItemIndex = LOADPORT_1;

      // Buffer狀態改變: PTST slotno
      WaferBuffer[slotno-1].Status = 0;
      WorkingBuffer[slotno-1] = '0';

      // 2023 8 1 - chc LP1/LP2
      //rgPortStatus->ItemIndex = PORT_STATUS_PROC;
      rgPortStatus2->ItemIndex = PORT_STATUS_PROC;

      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      WriteSystemLog("LP2 取片前送出PTST-PROC");
   }

   // Aligner/Chuck => 1
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER || rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE)
      slotno = 1;
   cmd.sprintf("LOAD(%d,%d,%d)",armno,stageno,slotno);
   edRobotCommand->Text = cmd;

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // 確認 @@暫
   if(cbRobotStep->Checked == true) {
      msg.sprintf("Robot取片Command: %s 正確?",cmd);
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRorzeRobotGet->Color = clRed;
         return;
      }
   }

   // 2021 11 12 - chc Log
   pnlAlarmMessage->Caption = "Get: " + cmd;
   WriteSystemLog(pnlAlarmMessage->Caption);

   // Robot動作
   boolRobotComplete = false;
   btnRobotSendClick(this);

   // 2021 4 29 - chc 成6Sec
   //ret = WaitRobotComplete(3,10000);
   // 2021 6 30 - chc 成20Sec
   //ret = WaitRobotComplete(3,6000);
   ret = WaitRobotComplete(3,20000);

   if(ret != 0) {

      // 2021 4 29 - chc Re-Check
      if(RobotCode1 == "1100" && RobotCode2 == "0000") {
         WriteSystemLog("Robot Error Re-Check STAT ok");
         goto ok;
      }

      goto error;
   }
ok:
   pnlRorzeRobotGet->Color = clLime;

   // 2021 11 12 - chc Log
   pnlAlarmMessage->Caption = "Get完成.";
   WriteSystemLog(pnlAlarmMessage->Caption);

   // 2021 5 7 - chc 更新Wafer位置
   MainForm->pnlWaferRobotInformation->Color = clLime;
   MainForm->pnlWaferRobotInformation1->Color = clLime;
   MainForm->pnlWaferRobotInformation2->Color = clLime;
   MainForm->pnlWaferRobotInformation->Refresh();
   MainForm->pnlWaferRobotInformation1->Refresh();
   MainForm->pnlWaferRobotInformation2->Refresh();
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER) {
      MainForm->pnlWaferAlignerInformation->Color = (TColor)0x0068C6AA;
      MainForm->pnlWaferAlignerInformation1->Color = clSilver;
      MainForm->pnlWaferAlignerInformation2->Color = clSilver;
      MainForm->pnlWaferAlignerInformation->Refresh();
      MainForm->pnlWaferAlignerInformation1->Refresh();
      MainForm->pnlWaferAlignerInformation2->Refresh();
   }
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1 || rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {
      panel = (TPanel*)(FindComponent("pnlTray" + combRobotSlot->Text));
      panel->Color = (TColor)0x0068C6AA;
   }

   // 2021 5 6 - chc 設定作業中的WaferID
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1 || rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {
      WorkingWaferID = WaferBuffer[slotno-1].ID;
      edSECSWaferID->Text = WorkingWaferID;
      // 更新Buffer
      WorkingBuffer[slotno-1] = '0';

      // 2023 7 31 - chc LP1/LP2
      if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP2)
         edMapData2->Text = WorkingBuffer;
      else

         edMapData->Text = WorkingBuffer;
      // Up
      if(armno == 1) {
         edUpArmID->Text = WorkingWaferID;
         edLowArmID->Text = "";
      }
      // Low
      else {
         edUpArmID->Text = "";
         edLowArmID->Text = WorkingWaferID;
      }
   }

   // 2021 5 4 - chc SECS: 取片
   if(rgRobotArm->ItemIndex == ROBOT_ARM_UP)
      rgUpArmExist->ItemIndex = WAFER_EXIST_YES;
   else
      rgLowArmExist->ItemIndex = WAFER_EXIST_YES;
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE)
      rgEQExist->ItemIndex = WAFER_EXIST_NO;
   // SlotNo
   edSECSSlotNo->Text = combRobotSlot->Text;
   // Cassette to Robot
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1) {

      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_1;
      //rgSECSPortNo->ItemIndex = LOADPORT_2;

      rgSECSStatus->ItemIndex = STATUS_FETCH;
      WriteSystemLog("boolSendSCESCommand: 9");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PREV - SECS_CMD_STAT_1;
      WriteSystemLog("LP1 取片後送出PTST-FETCH");
      WaitTime(100);
      // Buffer狀態改變: PTST slotno
      WaferBuffer[slotno-1].Status = 0;
      WorkingBuffer[slotno-1] = '0';
      rgPortStatus->ItemIndex = PORT_STATUS_PROC;
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      WriteSystemLog("LP1 取片後送出PTST-PROC");
   }
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {

      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_2;
      //rgSECSPortNo->ItemIndex = LOADPORT_1;

      rgSECSStatus->ItemIndex = STATUS_FETCH;
      WriteSystemLog("boolSendSCESCommand: 10");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PREV - SECS_CMD_STAT_1;
      WriteSystemLog("LP2 取片後送出PTST-FETCH");
      WaitTime(100);
      // Buffer狀態改變: PTST slotno
      WaferBuffer[slotno-1].Status = 0;
      WorkingBuffer[slotno-1] = '0';

      // 2023 8 1 - chc LP1/LP2
      //rgPortStatus->ItemIndex = PORT_STATUS_PROC;
      rgPortStatus2->ItemIndex = PORT_STATUS_PROC;

      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      WriteSystemLog("LP2 取片後送出PTST-PROC");
   }
   // Stage to Robot
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
      rgSECSStatus->ItemIndex = STATUS_SEND;
      WriteSystemLog("boolSendSCESCommand: 11");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PREV - SECS_CMD_STAT_1;
   }

   // 2021 5 5 - chc STAT => SECS, robot狀態改變
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;

   // 2021 5 6 - chc Pin下降
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {

      // 2021 6 16 - chc 由Timer做
      /*
      // L下降
      WriteSystemLog("流程測試: Stage Pin到下位點...");
      // L-Down
      btnDemoLFDownClick(this);
      if(boolLFUpState == false) {
         pnlRorzeRobotGet->Color = clRed;
         pnlSystemMessage->Caption = "Lift pin下降失敗!";
         WriteSystemLog("Robot取片: Stage Pin到下位點 Error");
         return;
      }
      WriteSystemLog("Robot取片: Stage Pin到下位點.");
      */
      tmPinLiftDown->Enabled = true;

   }

   // 2021 11 12 - chc Log
   WriteSystemLog("Get: Leave.");

   return;
error:
   pnlRorzeRobotGet->Color = clRed;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot: 放片
void __fastcall TMainForm::btnRorzeRobotPutClick(TObject *Sender)
{
AnsiString cmd,msg;
int ret,stageno,armno,slotno;
TPanel *panel;

   pnlRorzeRobotPut->Color = clSilver;

   // 2021 11 11 - chc 檢查是否為Load: 已關門
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1 || rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {
      if(btnCassetteLoad->Caption == "Load") {
         pnlAlarmMessage->Caption = "LP門已關, 不可以放片!";
         WriteSystemLog(pnlAlarmMessage->Caption);
         pnlRorzeRobotPut->Color = clRed;
         Beep(500);
         return;
      }

      // 2021 11 22 - chc 尚未檢查LP1/LP2: 是否CST上有Wafer?
      panel = (TPanel*)(FindComponent("pnlTray" + combRobotSlot->Text));
      if(panel->Color == clLime) {
         pnlSystemMessage->Caption = "CST " + combRobotSlot->Text + " 上有Wafer!";
         pnlAlarmMessage->Caption = pnlSystemMessage->Caption;
         pnlRorzeRobotPut->Color = clRed;
         Beep(500);
         return;
      }
   }

   // 2021 6 30 - chc 分取放片
   //stageno = GetStageNo();
   stageno = GetStageNo(ROBOT_HOME_PUT);

   // 1-Upper, 2-Lower
   armno = rgRobotArm->ItemIndex + 1;
   slotno = combRobotSlot->ItemIndex + 1;

   // 2021 6 30 - chc 監看Aligner
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER)
      boolAlignerMonitor = true;

   // 2021 5 5 - chc 檢查W
   if(GoRobotWAxis(1) == false) {
      pnlRorzeRobotGet->Color = clRed;
      pnlAlarmMessage->Caption = "W軸移動失敗!";
      return;
   }

   // 是否在入料點?
   // 2021 5 6 - chc 檢查Stage上是否有片?
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
      btnToOriginalPositionClick(this);
      if(pnlToOriginalPosition->Color != clLime) {
         WriteSystemLog("Get: 到入料點失敗!");
         pnlAlarmMessage->Caption = "Get: 到入料點失敗!";
         pnlAlarmMessage->Caption = pnlSystemMessage->Caption;
         return;
      }
      // 檢查Z高度: 要在CCDZ以上
      double fcmd;
      int inz,cz;
      GetPosition(Z_AXIS, &fcmd);
      cz = fcmd;
      inz = edOriginalZ->Text.ToInt();
      if(cz > (inz + 100)) {

         // 2021 9 11 - chc 加速: MOVE_WAIT
         //if(MoveToZ(inz) == false) {
         if(MoveToZ(inz,MOVE_WAIT) == false) {

            pnlSystemMessage->Caption = "Z上升到CCD對焦高度Fail!";
            pnlAlarmMessage->Caption = pnlSystemMessage->Caption;
            return;
         }
      }
   }

   // 確認 @@暫
   if(cbRobotStep->Checked == true) {
      msg.sprintf("Robot放片: 點位,Arm(1-Up,2-Low),片數= %d,%d,%d 正確?",stageno,armno,slotno);
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRorzeRobotPut->Color = clRed;
         return;
      }
   }

   // 2021 5 6 - chc 在Put中會做
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
      if(IsChuckWithWafer() == true) {
         pnlRorzeRobotPut->Color = clRed;
         WriteSystemLog("Robot放片: Stage上有片!");
         pnlAlarmMessage->Caption = "Robot放片: Stage上有片!";
         return;
      }
      WriteSystemLog("Robot放片: Stage Pin上升...");
      // L-Up
      btnDemoLFUpClick(this);
      if(boolLFUpState == false) {
         pnlRorzeRobotPut->Color = clRed;
         pnlSystemMessage->Caption = "Lift pin上升失敗!";
         WriteSystemLog("Robot放片: Stage Pin上升 Error!");
         return;
      }
      WriteSystemLog("Put: Stage Pin上升.");

   }
/*
   // 檢查Aligner上是否有片?
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER) {
      if(IsAlignerWithWafer() == true) {
         pnlRorzeRobotGet->Color = clRed;
         WriteSystemLog("Robot取片: Aligner上有片!");
         pnlAlarmMessage->Caption = "Robot取片: Aligner上有片!";
         return;
      }
   }
*/

   // 2021 12 15 - chc 到Stage放片要Reset
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
      pnlCenterXFind->Caption = "";
      pnlCenterYFind->Caption = "";
   }

   // Aligner/Chuck => 1
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER || rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE)
      slotno = 1;
   cmd.sprintf("UNLD(%d,%d,%d)",armno,stageno,slotno);
   edRobotCommand->Text = cmd;

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // 確認 @@暫
   if(cbRobotStep->Checked == true) {
      msg.sprintf("Robot放片Command: %s 正確?",cmd);
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRorzeRobotPut->Color = clRed;
         return;
      }
   }

   // Robot動作
   boolRobotComplete = false;
   btnRobotSendClick(this);

   // 2021 4 29 - chc 成6Sec
   //ret = WaitRobotComplete(4,10000);
   // 2021 6 30 - chc 成20Sec
   //ret = WaitRobotComplete(4,6000);
   ret = WaitRobotComplete(4,20000);

   if(ret != 0) {

      // 2021 4 29 - chc Re-Check
      if(RobotCode1 == "1100" && RobotCode2 == "0000") {
         WriteSystemLog("Robot Error Re-Check STAT ok");
         goto ok;
      }

      goto error;
   }
ok:

   // 2021 6 4 - chc 更新Wafer位置
   MainForm->pnlWaferRobotInformation->Color = (TColor)0x0068C6AA;
   MainForm->pnlWaferRobotInformation1->Color = clSilver;
   MainForm->pnlWaferRobotInformation2->Color = clSilver;
   pnlWaferRobotInformation->Refresh();
   pnlWaferRobotInformation1->Refresh();
   pnlWaferRobotInformation2->Refresh();

   // 2021 5 9 - chc 在Put中會做
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
      // 開真空
      WriteSystemLog("Put: Stage Vacuum On...");
      // Vacuum-On
      if(pnlStageVacuum->Color != clLime) {
         pnlStageVacuumClick(this);
      }

      // 2021 6 3 - chc 12"
      if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
         if(pnlStageVacuum1->Color != clLime)
            pnlStageVacuum1Click(this);
      }

      WriteSystemLog("Put: Stage Pin到下位點...");
      // L-Down
      btnDemoLFDownClick(this);
      if(boolLFUpState == false) {
         pnlRunTest->Color = clRed;
         pnlSystemMessage->Caption = "Lift pin下降失敗!";
         WriteSystemLog("Put: Stage Pin到下位點 Error");
         goto error;
      }
      WriteSystemLog("Put: Stage Pin到下位點.");
   }
   pnlRorzeRobotPut->Color = clLime;

   // 確認 @@暫
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
      if(cbRobotStep->Checked == true) {
         if(Application->MessageBox("Wafer已在Stage上, 準備做中心尋找, 繼續?", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRorzeRobotPut->Color = clRed;
            return;
         }
      }
      // 2021 5 5 - chc 到Stage要做中心點尋找
      WaitTime(1000);
      if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
         pnlCenterXFind->Caption = "0";
         pnlCenterYFind->Caption = "0";
         btnFindCenterClick(this);
      }
   }

   // 2021 5 7 - chc 更新Wafer位置
   MainForm->pnlWaferRobotInformation->Color = (TColor)0x0068C6AA;
   MainForm->pnlWaferRobotInformation1->Color = clSilver;
   MainForm->pnlWaferRobotInformation2->Color = clSilver;
   MainForm->pnlWaferRobotInformation->Refresh();
   MainForm->pnlWaferRobotInformation1->Refresh();
   MainForm->pnlWaferRobotInformation2->Refresh();
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_ALIGNER) {
      MainForm->pnlWaferAlignerInformation->Color = clLime;
      MainForm->pnlWaferAlignerInformation1->Color = clLime;
      MainForm->pnlWaferAlignerInformation2->Color = clLime;
      MainForm->pnlWaferAlignerInformation->Refresh();
      MainForm->pnlWaferAlignerInformation1->Refresh();
      MainForm->pnlWaferAlignerInformation2->Refresh();
   }
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1 || rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {
      panel = (TPanel*)(FindComponent("pnlTray" + combRobotSlot->Text));
      panel->Color = clLime;
   }

   // 2021 5 6 - chc 設定作業中的WaferID
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1 || rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {
      WorkingWaferID = "";
      edSECSWaferID->Text = WorkingWaferID;
      // 更新Buffer
      WorkingBuffer[slotno-1] = '1';

      // 2023 7 31 - chc LP1/LP2
      if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP2)
         edMapData2->Text = WorkingBuffer;
      else

         edMapData->Text = WorkingBuffer;
      // Up
      if(armno == 1) {
         edUpArmID->Text = WorkingWaferID;
         edLowArmID->Text = "";
      }
      // Low
      else {
         edUpArmID->Text = "";
         edLowArmID->Text = WorkingWaferID;
      }
   }

   // 2021 5 4 - chc SECS: 放片
   if(rgRobotArm->ItemIndex == ROBOT_ARM_UP)
      rgUpArmExist->ItemIndex = WAFER_EXIST_NO;
   else
      rgLowArmExist->ItemIndex = WAFER_EXIST_NO;
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE)
      rgEQExist->ItemIndex = WAFER_EXIST_YES;
   // Robot to Cassette
   if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP1) {

      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_1;
      //rgSECSPortNo->ItemIndex = LOADPORT_2;

      rgSECSStatus->ItemIndex = STATUS_STORE;
      WriteSystemLog("boolSendSCESCommand: 12");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PREV - SECS_CMD_STAT_1;
      Sleep(100);
      // Buffer狀態改變: PTST slotno
      WaferBuffer[slotno-1].Status = 1;
      WorkingBuffer[slotno-1] = '1';
      rgPortStatus->ItemIndex = PORT_STATUS_PROC;
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
   }
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_LP2) {

      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_2;
      //rgSECSPortNo->ItemIndex = LOADPORT_1;

      rgSECSStatus->ItemIndex = STATUS_STORE;
      WriteSystemLog("boolSendSCESCommand: 13");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PREV - SECS_CMD_STAT_1;
      Sleep(100);
      // Buffer狀態改變: PTST slotno
      WaferBuffer[slotno-1].Status = 1;
      WorkingBuffer[slotno-1] = '1';

      // 2023 8 1 - chc LP1/LP2
      //rgPortStatus->ItemIndex = PORT_STATUS_PROC;
      rgPortStatus2->ItemIndex = PORT_STATUS_PROC;

      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
   }
   // Arm to Stage
   else if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
      rgSECSStatus->ItemIndex = STATUS_RECEIVE;
      WriteSystemLog("boolSendSCESCommand: 14");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PREV - SECS_CMD_STAT_1;
   }

   // 2021 5 5 - chc STAT => SECS, robot狀態改變
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;

   // 2021 11 12 - chc Log
   WriteSystemLog("Put: Leave.");

   return;
error:
   pnlRorzeRobotPut->Color = clRed;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::mnSaveRobotToFileClick(TObject *Sender)
{

   if(mmRobot->Lines->Count == 0) {
      Application->MessageBox("目前尚無記錄事項!","量測系統: Robot記錄檔寫入作業    ",MB_ICONINFORMATION|MB_OK);
      return;
   }
   if(sdAIMessages->Execute()) {
      mmRobot->Lines->SaveToFile(sdAIMessages->FileName.c_str());
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void __fastcall TMainForm::mnClearRobotMessageClick(TObject *Sender)
{

   mmRobot->Clear();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot
void TMainForm::AddRobotMessage(AnsiString msg)
{
AnsiString putmsg;
static AnsiString oldmsg = "";

   //if(oldmsg == msg)                            // 重複不收錄
   //   return;
   oldmsg = msg;
   putmsg = Now().FormatString("nn':'ss':'zzz'-> '") + msg;
   // 以Memo取代, 最多共470 Rows
   mmRobot->Lines->Insert(0,putmsg);
   mmRobot->Refresh();

   if(mmRobot->Lines->Count > 500) {
      for(int i=470 ; i<mmRobot->Lines->Count ; i++)
         mmRobot->Lines->Delete(i);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot Socket
void __fastcall TMainForm::csRobotSocketConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlRobotSocketConnect->Color = clLime;
   AddRobotMessage("Robot 連線.");
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot Socket
void __fastcall TMainForm::csRobotSocketDisconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlRobotSocketConnect->Color = clRed;
   AddRobotMessage("Robot 斷線.");
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Robot Socket
void __fastcall TMainForm::csRobotSocketError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   ErrorCode = 0;
}
//---------------------------------------------------------------------------
// 2021 9 11 - chc 加速: GPIO是否已取得
bool boolRobotGPIO = false;

// 2021 4 11 - chc Rorze
// Robot Socket
AnsiString ssBuffer = "";
void __fastcall TMainForm::csRobotSocketRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
// Re-Entrant
static bool inactive = false;

   if(inactive == true) {
      pnlSystemMessage->Caption = "csRobot - Re-Entrant!";
      return;
   }
   inactive = true;

char tempbuf[500];
int readno;
AnsiString temp;
int length;
AnsiString command,para,ackstr;
int cmdpos;
int cmdpar[10];
int cmdparno,len;
int ret;
unsigned char cbuf[10],c;
// 解析Robot動作:11000/0000, :11010/0000
int pos1,pos2,pos3;
AnsiString code1,code2,errorname,errorcode;
// 要Defeuat為"00"
static AnsiString errorcodeold = "00";

// 2021 9 16 - chc Alarm
static bool boolorgnerror = false;
static bool boolmotorstall = false;
static bool boolseneorerror = false;
static bool booldrivererror = false;
static bool boolwaferfall = false;
static bool boolexhaustfanerror = false;
static bool boolencodererror = false;
static bool boolcontrolpowererror = false;
static bool booloverheaterror = false;
static bool boolmotorcableerror = false;
static bool boolcommunicationerror = false;
static bool boolwaferretainingerror = false;
int errorstate = -1;

   // Try-Catch
   try {
      readno = Socket->ReceiveBuf(tempbuf,256);
      tempbuf[readno] = 0;
      ssBuffer += tempbuf;

      for(int i=1 ;  ; i++) {
         if(ssBuffer.Length() == 0 || i > ssBuffer.Length())
            break;

         // 以CR/LF/0為結束碼
         sprintf(cbuf,"%s",ssBuffer.SubString(i,1).c_str());
         c = cbuf[0];
         if(c == 0x0d || c == 0x0a || c == 0x0) {
            temp = ssBuffer.SubString(1,i);

            // 2023 8 2 - chc 改成"<"
            //AddRobotMessage(temp + " >" + IntToStr(ssBuffer.Length()));
            AddRobotMessage("<" + temp + "." + IntToStr(ssBuffer.Length()));

            length = ssBuffer.Length();
            // 取得Command
            pos3 = 0;
            pos3 = temp.Pos(".");

            // 確認是否收到.CNCT?
            if(btnRobotORGN->Enabled == false) {
               // 已Init
               if(boolRobotInit == true) {
                  // 要Vacuum On才可運作
                  //if(pnlBit2->Color == clLime && pnlBit3->Color == clLime)
                  //???
                     btnRobotORGN->Enabled = true;
               }
               else if(temp.SubString(pos3+1,4) == "CNCT") {
                  AddRobotMessage(">Robot收到CNCT.");
                  // Robot Status
                  if(pnlRobotReady->Color != clLime) {
                     AddRobotMessage(">設定Robot Ready.");
                     pnlRobotReady->Color = clLime;
                     Application->ProcessMessages();
                  }
                  pnlRorzeRobot->Enabled = true;
                  boolRobotInit = true;
                  // 要Vacuum On才可運作
                  //if(pnlBit2->Color == clLime && pnlBit3->Color == clLime)
                  //???
                     btnRobotORGN->Enabled = true;
               }
               else if(temp.SubString(pos3+1,4) == "ORGN") {
                  AddRobotMessage(">Robot收到ORGN.");
               }
            }

            // 解析Robot動作:11000/0000, :11010/0000
            // aTRB1.STAT:12345/1234
            // 123456789012345678901234567890
            // pos3 = 6
            // pos1 = 11
            //#define ROBOT_IDLE           0
            //#define ROBOT_MOVING         1
            //#define ROBOT_DONE           2
            //int RobotMoveState;
            pos1 = 0;
            pos1 = temp.Pos(":");
            if(pos1 != 0) {

               // 2021 4 29 - chc S1取前4位
               //code1 = temp.SubString(pos1+1,5);
               code1 = temp.SubString(pos1+1,4);

               code2 = temp.SubString(pos1+7,4);
               errorcode = temp.SubString(pos1+9,2);
               pnlRobotErrorCode1->Caption = code2;

               // 記錄Robot Status
               RobotCode1 = code1;
               RobotCode2 = code2;
               RobotErrorCode = errorcode;

               // 取得Command: STAT, HOME, LOAD....
               command = temp.SubString(pos3+1,4);

               // 記錄RobotState & RobotCommand
               RobotCommand = command;
               RobotMoveStateSave = RobotMoveState;

               if(command == "STAT") {

                  // 2021 4 5 - Log
                  WriteSystemLog("Robot: STAT Command... " + code1 + "," + code2);

                  if(RobotMoveState == ROBOT_IDLE) {

                     // 2021 4 25 - chc 加入10010
                     //if(code1 == "11010" && code2 == "0000")
                     // 2021 4 29 - chc S1取前4位
                     //if((code1 == "11010" || code1 == "10010") && code2 == "0000")
                     if((code1 == "1101" || code1 == "1001") && code2 == "0000") {

                        // 2021 4 5 - Log
                        WriteSystemLog("Robot: STAT Command Idle(0) to Moving(1).");

                        RobotMoveState = ROBOT_MOVING;
                     }
                  }
                  else if(RobotMoveState == ROBOT_MOVING) {

                     // 2021 4 29 - chc S1取前4位
                     //if(code1 == "11000" && (code2 == "0000" || code2 == "0083" ||code2 == "0084")) {
                     if(code1 == "1100" && (code2 == "0000" || code2 == "0083" ||code2 == "0084")) {

                        RobotMoveState = ROBOT_DONE;
                        // 第2片問題
                        if(boolWaitSecondDone == true) {
                           AddRobotMessage("第2片已RobotDone: ROBOT_MOVING");
                           boolWaitSecondDone = false;
                        }

                        // 2021 4 5 - Log
                        WriteSystemLog("Robot: STAT Command Moving(1) to Done(2).");

                     }
                  }
                  else if(RobotMoveState == ROBOT_RESET) {

                     // 2021 4 29 - chc S1取前4位
                     //if(code1 == "11000" && (code2 == "0000" || code2 == "0083" ||code2 == "0084")) {
                     if(code1 == "1100" && (code2 == "0000" || code2 == "0083" ||code2 == "0084")) {

                        RobotMoveState = ROBOT_DONE;
                        // 第2片問題
                        if(boolWaitSecondDone == true) {
                           AddRobotMessage("第2片已RobotDone: ROBOT_RESET");
                           boolWaitSecondDone = false;
                        }

                        // 2021 4 5 - Log
                        WriteSystemLog("Robot: STAT Command Reset(3) to Done(2).");

                     }
                  }
                  // 等Robot Home
                  else if(RobotMoveState == ROBOT_HOME_MOVE) {

                     // 2021 4 29 - chc S1取前4位
                     //if(code1 == "11000" && (code2 == "0000" || code2 == "0083" ||code2 == "0084")) {
                     if(code1 == "1100" && (code2 == "0000" || code2 == "0083" ||code2 == "0084")) {

                        RobotMoveState = ROBOT_DONE;
                        // 訊息
                        AddRobotMessage("Home OK");
                        // 第2片問題
                        if(boolWaitSecondDone == true) {
                           AddRobotMessage("第2片已RobotDone: ROBOT_MOVE");
                           boolWaitSecondDone = false;
                        }

                        // 2021 4 5 - Log
                        WriteSystemLog("Robot: STAT Command HomeMove(5) to Done(2).");

                     }
                  }

                  // 2021 4 30 - chc 1100/0000強制為ok
                  if((code1 == "1100" && code2 == "0000") && RobotMoveState != ROBOT_DONE) {

                     // 2021 4 5 - Log
                     WriteSystemLog("Robot: STAT(1100,0000) 強制為ROBOT_DONE(0,1,2) = " + IntToStr(RobotMoveState));

                     RobotMoveState = ROBOT_DONE;
                     AddRobotMessage("1100,0000: 強制為ROBOT_DONE");
                  }
                  if(RobotMoveState == ROBOT_DONE) {
                     boolRobotComplete = true;

                     // 2021 4 5 - Log
                     WriteSystemLog("Robot: STAT已ROBOT_DONE, 指定Complete.");

                  }

                  // 解析Robot動作:11000/0000, :11010/00cd
                  // Robot Error   cd- Error Code
                  //   01-失步,02-極限,03-急停,04-指令錯誤
                  //   05-通訊錯誤, 06-吸附Sensor異常
                  //   07-預留, 08-Wafer掉落
                  //   83-不可原點Search, 84-吸附Error
                  if(errorcode == "00") {
                     pnlRobotErrorMessage->Caption = "";
                     AlarmStatus.boolRobot = false;
                     if(errorcodeold != errorcode)
                        AddRobotMessage(">Robot 恢復正常.");
                     errorname = "";
                     pnlRobotErrorCode1->Hint = errorname;
                     pnlRobotErrorCode1->Caption = "";

                     // 2021 9 15a - chc
                     if(boolorgnerror == true) {
                        SetSECSAlarm(31001,0,1,"Robot ORGN Abnormal");
                     }
                     if(boolmotorstall == true) {
                        SetSECSAlarm(31002,0,1,"Robot Motor Stall");
                     }
                     if(boolseneorerror == true) {
                        SetSECSAlarm(31003,0,1,"Robot Sensor Abnormal");
                     }
                     if(boolcommunicationerror == true) {
                        SetSECSAlarm(31004,0,1,"Robot Controller Communication Abnormal");
                     }
                     if(booldrivererror == true) {
                        SetSECSAlarm(31005,0,1,"Robot Driver Abnormal");
                     }
                     if(boolwaferfall == true) {
                        SetSECSAlarm(31006,0,1,"Robot Wafer fall");
                     }
                     if(boolexhaustfanerror == true) {
                        SetSECSAlarm(31007,0,1,"Robot Exhaust Fan Abnormal");
                     }
                     if(boolencodererror == true) {
                        SetSECSAlarm(31008,0,1,"Robot Encoder Error");
                     }
                     if(boolcontrolpowererror == true) {
                        SetSECSAlarm(31009,0,1,"Robot Control Power Abnormal");
                     }
                     if(booloverheaterror == true) {
                        SetSECSAlarm(31010,0,1,"Robot Overheat Abnormal");
                     }
                     if(boolmotorcableerror == true) {
                        SetSECSAlarm(31011,0,1,"Robot Motor Cable Abnormal");
                     }
                     if(boolwaferretainingerror == true) {
                        SetSECSAlarm(31012,0,1,"Robot Wafer Retaining Error");
                     }
                     boolorgnerror = false;
                     boolmotorstall = false;
                     boolseneorerror = false;
                     booldrivererror = false;
                     boolwaferfall = false;
                     boolexhaustfanerror = false;
                     boolencodererror = false;
                     boolcontrolpowererror = false;
                     booloverheaterror = false;
                     boolmotorcableerror = false;
                     boolcommunicationerror = false;
                     boolwaferretainingerror = false;

                  }
                  // Error
                  // 2021 9 16 - chc Alarm
                  //#define ROBOT_ALARM_ORGN             0
                  //#define ROBOT_ALARM_MOTOR_STALL      1
                  //#define ROBOT_ALARM_SENSOR           2
                  //#define ROBOT_ALARM_DRIVER           3
                  //#define ROBOT_ALARM_WAFER_FALL       4
                  //#define ROBOT_ALARM_FAN              5
                  //#define ROBOT_ALARM_ENCODER          6
                  //#define ROBOT_ALARM_POWER            7
                  //#define ROBOT_ALARM_OVER_HEAT        8
                  //#define ROBOT_ALARM_CABLE            9
                  //#define ROBOT_ALARM_COMMUNICATION    10
                  //#define ROBOT_ALARM_RETAINING        11
                  else {
                     AlarmStatus.boolRobot = true;
                     errorname = "異常";
                     if(errorcode == "01") {
                        errorname = "失步";
                        errorstate = ROBOT_ALARM_MOTOR_STALL;
                     }
                     else if(errorcode == "02") {
                        errorname = "極限";
                        errorstate = ROBOT_ALARM_DRIVER;
                     }
                     else if(errorcode == "03") {
                        errorname = "急停";
                        errorstate = ROBOT_ALARM_DRIVER;
                     }
                     else if(errorcode == "04") {
                        errorname = "指令錯誤";
                        errorstate = ROBOT_ALARM_COMMUNICATION;
                     }
                     else if(errorcode == "05") {
                        errorname = "通訊錯誤";
                        errorstate = ROBOT_ALARM_COMMUNICATION;
                     }
                     else if(errorcode == "06") {
                        errorname = "吸附Sensor異常";
                        errorstate = ROBOT_ALARM_SENSOR;
                     }
                     else if(errorcode == "07")
                        errorname = "預留";
                     else if(errorcode == "08") {
                        errorname = "Wafer掉落";
                        errorstate = ROBOT_ALARM_WAFER_FALL;
                     }
                     else if(errorcode == "0C") {
                        errorname = "原點復歸未完成";
                        errorstate = ROBOT_ALARM_ORGN;
                     }
                     else if(errorcode == "0E") {
                        errorname = "驅動器異常";
                        errorstate = ROBOT_ALARM_DRIVER;
                     }
                     else if(errorcode == "12") {
                        errorname = "再生單元過熱";
                        errorstate = ROBOT_ALARM_OVER_HEAT;
                     }
                     else if(errorcode == "14") {
                        errorname = "排熱風扇異常";
                        errorstate = ROBOT_ALARM_FAN;
                     }
                     else if(errorcode == "15") {
                        errorname = "運作位置異常";
                        errorstate = ROBOT_ALARM_DRIVER;
                     }
                     else if(errorcode == "16") {
                        errorname = "Encoder資料移失";
                        errorstate = ROBOT_ALARM_ENCODER;
                     }
                     else if(errorcode == "17") {
                        errorname = "Encoder通訊異常";
                        errorstate = ROBOT_ALARM_ENCODER;
                     }
                     else if(errorcode == "18") {
                        errorname = "Encoder超速";
                        errorstate = ROBOT_ALARM_ENCODER;
                     }
                     else if(errorcode == "19") {
                        errorname = "Encoder EPROM異常";
                        errorstate = ROBOT_ALARM_ENCODER;
                     }
                     else if(errorcode == "1A") {
                        errorname = "Encoder ABS-INC異常";
                        errorstate = ROBOT_ALARM_ENCODER;
                     }
                     else if(errorcode == "1B") {
                        errorname = "Encoder係數塊異常";
                        errorstate = ROBOT_ALARM_ENCODER;
                     }
                     else if(errorcode == "1C") {
                        errorname = "Encoder 溫度異常";
                        errorstate = ROBOT_ALARM_ENCODER;
                     }
                     else if(errorcode == "1D") {
                        errorname = "Encoder Reset異常";
                        errorstate = ROBOT_ALARM_ENCODER;
                     }
                     else if(errorcode == "20") {
                        errorname = "控制電源異常";
                        errorstate = ROBOT_ALARM_POWER;
                     }
                     else if(errorcode == "21") {
                        errorname = "驅動器電源異常";
                        errorstate = ROBOT_ALARM_DRIVER;
                     }
                     else if(errorcode == "22") {
                        errorname = "EEPROM異常";
                        errorstate = ROBOT_ALARM_DRIVER;
                     }
                     else if(errorcode == "24") {
                        errorname = "過熱";
                        errorstate = ROBOT_ALARM_OVER_HEAT;
                     }
                     else if(errorcode == "25") {
                        errorname = "過電流";
                        errorstate = ROBOT_ALARM_DRIVER;
                     }
                     else if(errorcode == "26") {
                        errorname = "馬達線路異常";
                        errorstate = ROBOT_ALARM_CABLE;
                     }
                     else if(errorcode == "83") {
                        errorname = "不可原點Search";
                        pnlRobotErrorMessage->Caption = "";
                        AlarmStatus.boolRobot = false;
                        errorstate = ROBOT_ALARM_ORGN;
                     }
                     else if(errorcode == "84") {
                        errorname = "Wafer retaining error";
                        pnlRobotErrorMessage->Caption = "";
                        AlarmStatus.boolRobot = false;
                        errorstate = ROBOT_ALARM_RETAINING;
                     }
                     pnlRobotErrorCode1->Hint = "Robot: " + errorname;

                     pnlRobotErrorMessage->Caption = errorname;
                     pnlOpeationMessage->Caption = "Robot: " + errorname;
                     //RedLamp(true);
                     //???
                     AddRobotMessage(">Robot 異常原因: " + errorname);
                     //Beep(100);
                     //???

                     // 2021 9 16 - chc Alarm
                     //#define ROBOT_ALARM_ORGN             0
                     //#define ROBOT_ALARM_MOTOR_STALL      1
                     //#define ROBOT_ALARM_SENSOR           2
                     //#define ROBOT_ALARM_DRIVER           3
                     //#define ROBOT_ALARM_WAFER_FALL       4
                     //#define ROBOT_ALARM_FAN              5
                     //#define ROBOT_ALARM_ENCODER          6
                     //#define ROBOT_ALARM_POWER            7
                     //#define ROBOT_ALARM_OVER_HEAT        8
                     //#define ROBOT_ALARM_CABLE            9
                     //#define ROBOT_ALARM_COMMUNICATION    10
                     //#define ROBOT_ALARM_RETAINING        11
                     if(errorstate == ROBOT_ALARM_ORGN) {
                        if(boolorgnerror == false) {
                           boolorgnerror = true;
                           SetSECSAlarm(31001,1,1,"Robot ORGN Abnormal");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_MOTOR_STALL) {
                        if(boolmotorstall == false) {
                           boolmotorstall = true;
                           SetSECSAlarm(31002,1,1,"Robot Motor Stall");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_SENSOR) {
                        if(boolseneorerror == false) {
                           boolseneorerror = true;
                           SetSECSAlarm(31003,1,1,"Robot Sensor Abnormal");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_COMMUNICATION) {
                        if(boolcommunicationerror == false) {
                           boolcommunicationerror = true;
                           SetSECSAlarm(31004,1,1,"Robot Controller Communication Abnormal");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_DRIVER) {
                        if(booldrivererror == false) {
                           booldrivererror = true;
                           SetSECSAlarm(31005,1,1,"Robot Driver Abnormal");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_WAFER_FALL) {
                        if(boolwaferfall == false) {
                           boolwaferfall = true;
                           SetSECSAlarm(31006,1,1,"Robot Wafer fall");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_FAN) {
                        if(boolexhaustfanerror == false) {
                           boolexhaustfanerror = true;
                           SetSECSAlarm(31007,1,1,"Robot Exhaust Fan Abnormal");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_ENCODER) {
                        if(boolencodererror == false) {
                           boolencodererror = true;
                           SetSECSAlarm(31008,1,1,"Robot Encoder Error");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_POWER) {
                        if(boolcontrolpowererror == false) {
                           boolcontrolpowererror = true;
                           SetSECSAlarm(31009,1,1,"Robot Control Power Abnormal");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_OVER_HEAT) {
                        if(booloverheaterror == false) {
                           booloverheaterror = true;
                           SetSECSAlarm(31010,1,1,"Robot Overheat Abnormal");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_CABLE) {
                        if(boolmotorcableerror == false) {
                           boolmotorcableerror = true;
                           SetSECSAlarm(31011,1,1,"Robot Motor Cable Abnormal");
                        }
                     }
                     else if(errorstate == ROBOT_ALARM_RETAINING) {
                        if(boolwaferretainingerror == false) {
                           boolwaferretainingerror = true;
                           SetSECSAlarm(31012,1,1,"Robot Wafer Retaining Error");
                        }
                     }

                  }
                  // 記錄Robot Error Code
                  errorcodeold = errorcode;
               }
               // Home Command
               if(command == "HOME") {
                  if(RobotMoveState == ROBOT_HOME) {
                     RobotMoveState = ROBOT_HOME_MOVE;
                  }
               }
               //SetGreenLamp();
               //???

               // 2021 4 25 - chc GPIO
               // 上Arm無Wafer(inbit 8,9有, outbit 8-電磁鐵): 00A000E0/1E000041
               // 上Arm吸真空有Wafer(inbit 8,9有, outbit 8-電磁鐵): 00A003E0/1E000141
               // 下Arm無Wafer吸真空(inbit 18,19有, outbit 18-電磁鐵): 00A803E0/1E040149
               //                                                         bit19        bit8 - light error
               //                                                                  bit8 - 電磁鐵on
               // 下Arm有Wafer吸真空(inbit 18有,19有, outbit 18-電磁鐵): 00AC00E0/1E040241
               // aTRB1.GPIO:00AC00E0/1E040241
               // aTRB1.GPIO:00AC00E0/EE040241(Yes-Lower Arm)
               // aTRB1.GPIO:00A000E0/EE080241(No-Lower Arm)
               if(command == "GPIO") {
                  char dibuf[20],dobuf[20];
                  int pos,len,hexdigitalno,up,down;
                  len = temp.Length();

                  // 2021 11 15 - chc 是28才對, 或直接比對"aTRB1.GPIO:"
                  //if(len == 22) {
                  if(len == 28 || temp.Pos(".GPIO:") > 0) {

                     bool boolwithwaferup,boolwithwaferdown;
                     sprintf(dibuf,"%s",temp.SubString(12,8).c_str());
                     sprintf(dobuf,"%s",temp.SubString(21,8).c_str());
                     for(int i=0 ; i<8 ; i++) {
                        if(dibuf[i] >= '0' && dibuf[i] <= '9')
                           dibuf[i] -= '0';
                        else {
                           dibuf[i] -= 'A';
                           dibuf[i] += 10;
                        }
                        if(dobuf[i] >= '0' && dobuf[i] <= '9')
                           dobuf[i] -= '0';
                        else {
                           dobuf[i] -= 'A';
                           dobuf[i] += 10;
                        }
                     }
                     // 8個4Bit(32bits), inBit8,9(Up Arm), inBit18,19(Down Arm)
                     // 2021 11 12 - chc 寫錯
                     //up = dibuf[8-8/4] & 0x03;
                     up = dibuf[7-8/4] & 0x03;

                     if(up == 0x3)
                        boolwithwaferup = true;
                     else
                        boolwithwaferup = false;

                     // 2021 11 12 - chc 寫錯
                     //down = dibuf[8-18/4] & 0x0c;
                     down = dibuf[7-18/4] & 0x0c;

                     if(down == 0x0c)
                        boolwithwaferdown = true;
                     else
                        boolwithwaferdown = false;
                     if(boolwithwaferup == true)
                        pnlRobotWithWaferUp->Color = clLime;
                     else
                        pnlRobotWithWaferUp->Color = clSilver;
                     if(boolwithwaferdown == true)
                        pnlRobotWithWaferDown->Color = clLime;
                     else
                        pnlRobotWithWaferDown->Color = clSilver;
                  }

                  // 2021 9 11 - chc 加速: GPIO是否已取得
                  WriteSystemLog("Robot GPIO收到.");
                  boolRobotGPIO = true;

               }

            }

            pnlRobotReceive->Caption = temp;
            if(length > i) {
               temp = ssBuffer.SubString(i+1,length-i);
               ssBuffer = temp;
            }
            else {
               ssBuffer = "";
            }
            i = 0;
         }
      }
   }
   catch(Exception &e) {
      pnlOpeationMessage->Caption = "csRobot - SocketRead ERROR: " + e.Message;
      AddRobotMessage(pnlSystemMessage->Caption);
   }
   inactive = false;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1
void __fastcall TMainForm::btnLoadPort1SendClick(TObject *Sender)
{
char buf[50];
AnsiString cmd,msg;
int len;
static bool boolactive = false;

   if(boolactive == true) {
      pnlLoadPort1SocketConnect->Color = clRed;
      return;
   }
   boolactive = true;
   pnlLoadPort1Send->Color = clSilver;
   if(csLoadPort1Socket->Active == true) {
      cmd = edLoadPort1Command->Text;
      len = cmd.Length();
      sprintf(buf,"oSTG1.%s\r",cmd.c_str());
      len += 6;
      csLoadPort1Socket->Socket->SendBuf(buf,len+1);
      pnlLoadPort1SocketConnect->Color = clLime;

      // 2023 8 2 - chc 加入Message
      msg.sprintf(">oSTG1.%s",cmd.c_str());
      AddLoadPort1Message(msg);

   }
   else
      pnlLoadPort1SocketConnect->Color = clRed;
   boolactive = false;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: ORGN
void __fastcall TMainForm::btnLoadPort1ORGNClick(TObject *Sender)
{
static bool first = true;

   btnLoadPort1ORGN->Enabled = false;
   pnlLoadPort1ORGN->Color = clSilver;
   pnlLoadPort1ORGN->Refresh();
   if(first == true) {
      first = false;
      // Set IP/Port...
      // DEQU.STDT[1]=172.20.9.100
      // DEQU.STDT[68]=12100
      edLoadPort1Command->Text = "DEQU.STDT[1]=172.20.9.100";
      LoadPort1Cmd = "DEQU.STDT[1]";
      btnLoadPort1SendClick(this);
      WaitDelayTime(1000);
      edLoadPort1Command->Text = "DEQU.STDT[68]=12100";
      LoadPort1Cmd = "DEQU.STDT[68]";
      btnLoadPort1SendClick(this);
      WaitDelayTime(1000);
      // Event
      edLoadPort1Command->Text = "EVNT(0,0)";
      LoadPort1Cmd = "EVNT";
      btnLoadPort1SendClick(this);
      WaitDelayTime(1000);
      // Mode
      edLoadPort1Command->Text = "MODE(1)";
      LoadPort1Cmd = "MODE";
      btnLoadPort1SendClick(this);
      WaitDelayTime(1000);
      // Event
      edLoadPort1Command->Text = "EVNT(1,1)";
      LoadPort1Cmd = "EVNT";
      btnLoadPort1SendClick(this);
      WaitDelayTime(1000);
   }
   // ORGN
   edLoadPort1Command->Text = "ORGN(0)";
   LoadPort1Cmd = "ORGN";
   btnLoadPort1SendClick(this);
   boolLoadPort1Complete = false;
   int ret;

   // 2021 4 25 - chc 由20s調至45s
   //ret = WaitLoadPort1Complete(2,20000);
   // 2021 5 10 - chc 由45s調至60s
   //ret = WaitLoadPort1Complete(2,45000);
   ret = WaitLoadPort1Complete(2,60000);

   if(ret != 0)
      pnlLoadPort1ORGN->Color = clRed;
   else
      pnlLoadPort1ORGN->Color = clLime;
   btnLoadPort1ORGN->Enabled = true;

   // 2021 5 4 - chc Clear Status
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {

      // 2023 8 2 - chc LP1/LP2
      //UpdateCassetteState(0);
      UpdateCassetteState(LOADPORT_1,0);
   }

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: CLMP
void __fastcall TMainForm::btnLoadPort1CLMPClick(TObject *Sender)
{

   // 2021 11 22 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(boolInLoadWafer == true || boolInUnloadWafer == true || boolInMeasureRun == true || WaferInSystem() == true) {
      pnlAlarmMessage->Caption = "In Operation, LP1 cannot Load!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      pnlLoadPort1CLMP->Color = clRed;
      Beep(500);
      return;
   }

   // 2021 11 21 - chc Load Image
   imLoad->Visible = true;

   // 2021 9 15 - chc Log
   WriteSystemLog("LP1 Load...");

   // 2021 6 30 - chc 8"才要做
   if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_8) {

      // 2021 6 24 - chc 先做Lock
      pnlSystemMessage->Caption = "Locking";
      btnLoadPort1LockClick(this);
      Sleep(1000);

      // 2021 6 30 - chc 先做Dock
      pnlSystemMessage->Caption = "Docking";
      btnLoadPort1CarrierDockClick(this);
      Sleep(2000);

   }
   pnlSystemMessage->Caption = "CLMP...";

   // 2023 8 1 - chc 加入Portno
   //ClearWaferBuffer();
   ClearWaferBuffer(LOADPORT_1);

   // CLMP
   pnlLoadPort1CLMP->Color = clSilver;
   edLoadPort1Command->Text = "CLMP";
   LoadPort1Cmd = "CLMP";
   btnLoadPort1SendClick(this);
   boolLoadPort1Complete = false;
   int ret;
   ret = WaitLoadPort1Complete(3,20000);
   if(ret != 0) {
      pnlLoadPort1CLMP->Color = clRed;

      // 2021 7 17 - chc 做UnLock
      btnLoadPort1UnlockClick(this);
      Sleep(1000);

      // 2021 7 22 - chc Error
      pnlSystemMessage->Caption = "CLMP Error";

   }
   else {
      pnlLoadPort1CLMP->Color = clLime;

      // 2021 5 4 - chc 設為完成
      boolLoadUnloadStatus = true;
      // 可以取片
      btnLoadWafer->Enabled = true;

      boolLP1CassetteMapping = false;

      // 2021 9 15 - chc SECS強制為clLime
      if(cbOffLine->Checked == false)
         pnlCassetteLoad->Color = clLime;

      // 2021 5 4 - chc 加做GetMap
      // 2021 5 5 - chc btnLoadPort2GMAPClick無反應!
      //btnLoadPort1GMAPClick(this);
      WaitTime(500);
      edLoadPort1Command->Text = "GMAP";
      LoadPort1Cmd = "GMAP";
      btnLoadPort1SendClick(this);

      // 2021 5 9 - chc 記錄為Load後的第一片
      boolFirstAfterLoad = true;
      pnlLoadPort1UCLM->Color = clSilver;

      // 2021 10 27 - chc 強制為EXECUTING
      if(rgEQStatus->ItemIndex != EQ_STATUS_EXECUTING)
         SendSECSStatus(EQ_STATUS_EXECUTING);

   }

   // 2021 5 4 - chc 加做GPIO
   WaitTime(500);
   btnLoadPort1GPIOClick(this);

   // 2021 6 24 - chc 可變更LoadPort
   rgLoadPortSelect->Enabled = false;

   // 2021 9 15 - chc Log
   WriteSystemLog("LP1 Loaded.");

   // 2021 11 21 - chc Load Image
   imLoad->Visible = false;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: UCLM
void __fastcall TMainForm::btnLoadPort1UCLMClick(TObject *Sender)
{

   // 2021 11 22 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(boolInLoadWafer == true || boolInUnloadWafer == true || boolInMeasureRun == true || WaferInSystem() == true) {
      pnlAlarmMessage->Caption = "In Operation, LP1 cannot UnLoad!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      pnlLoadPort2UCLM->Color = clRed;
      Beep(500);
      return;
   }

   // 2021 11 21 - chc Load Image
   imUnload->Visible = true;

   // 2021 9 15 - chc Log
   WriteSystemLog("LP1 UnLoad...");

   // 2023 8 1 - chc 加入Portno
   //ClearWaferBuffer();
   ClearWaferBuffer(LOADPORT_1);

   // CLMP
   pnlLoadPort1UCLM->Color = clSilver;
   edLoadPort1Command->Text = "UCLM";
   LoadPort1Cmd = "UCLM";
   btnLoadPort1SendClick(this);
   boolLoadPort1Complete = false;
   int ret;
   ret = WaitLoadPort1Complete(4,20000);
   if(ret != 0)
      pnlLoadPort1UCLM->Color = clRed;
   else {
      pnlLoadPort1UCLM->Color = clLime;

      // 2021 5 4 - chc 設為完成
      boolLoadUnloadStatus = true;
      // 不可以取片
      btnLoadWafer->Enabled = false;
      pnlLoadWafer->Color = clSilver;

      // 2021 9 15 - chc SECS強制為clLime
      if(cbOffLine->Checked == false)
         pnlCassetteLoad->Color = clLime;

      // 2021 5 6 - chc 送LOTEND, UR, UC
      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_1;
      //rgSECSPortNo->ItemIndex = LOADPORT_2;

      rgPortStatus->ItemIndex = PORT_STATUS_LOTEND;
      WriteSystemLog("boolSendSCESCommand: UCLM, LP1, LOTEND");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

      // UR
      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_1;
      //rgSECSPortNo->ItemIndex = LOADPORT_2;

      rgPortStatus->ItemIndex = PORT_STATUS_UR;
      WriteSystemLog("boolSendSCESCommand: UCLM, LP1, UR");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

      // 2021 5 9 - chc 記錄為Load後的第一片
      boolFirstAfterLoad = false;
      pnlLoadPort1CLMP->Color = clSilver;
      boolLP1CassetteMapping = false;
   }

   // 2021 5 4 - chc 加做GPIO
   btnLoadPort1GPIOClick(this);

   // 2021 6 30 - chc 8"才要做
   if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_8) {

      // 2021 6 24 - chc UnLock
      btnLoadPort1UnlockClick(this);
      Sleep(1000);

      // 2021 6 30 - chc UnDock
      //btnLoadPort1CarrierUnDockClick(this);
      //Sleep(2000);
   }

   // 2021 6 24 - chc 可變更LoadPort
   rgLoadPortSelect->Enabled = true;

   // 2021 9 15 - chc Log
   WriteSystemLog("LP1 UnLoaded.");

   // 2021 11 21 - chc Load Image
   imUnload->Visible = false;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: WMAP
void __fastcall TMainForm::btnLoadPort1WMAPClick(TObject *Sender)
{

   // 2021 11 22 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(boolInLoadWafer == true || boolInUnloadWafer == true || boolInMeasureRun == true || WaferInSystem() == true) {
      pnlAlarmMessage->Caption = "作業中, 8吋Port無法Mapping!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      pnlLoadPort1WMAP->Color = clRed;
      Beep(500);
      return;
   }

   // WMAP
   pnlLoadPort1WMAP->Color = clSilver;
   edLoadPort1Command->Text = "WMAP";
   LoadPort1Cmd = "WMAP";
   btnLoadPort1SendClick(this);
   boolLoadPort1Complete = false;
   int ret;
   ret = WaitLoadPort1Complete(5,20000);
   if(ret != 0)
      pnlLoadPort1WMAP->Color = clRed;
   else
      pnlLoadPort1WMAP->Color = clLime;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: INIT
void __fastcall TMainForm::btnLoadPort1INITClick(TObject *Sender)
{

   edLoadPort1Command->Text = "INIT";
   LoadPort1Cmd = "INIT";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: STAT
void __fastcall TMainForm::btnLoadPort1STATClick(TObject *Sender)
{

   edLoadPort1Command->Text = "STAT";
   LoadPort1Cmd = "STAT";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: GMAP
void __fastcall TMainForm::btnLoadPort1GMAPClick(TObject *Sender)
{

   edLoadPort1Command->Text = "GMAP";
   LoadPort1Cmd = "GMAP";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: RSTA
void __fastcall TMainForm::btnLoadPort1RSTAClick(TObject *Sender)
{

   edLoadPort1Command->Text = "RSTA(1)";
   LoadPort1Cmd = "RSTA";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: MODE
void __fastcall TMainForm::btnLoadPort1MODEClick(TObject *Sender)
{

   // Remote
   if(rgLoadPort1Mode->ItemIndex == 0)
      edLoadPort1Command->Text = "MODE(1)";
   // Maintenance
   else
      edLoadPort1Command->Text = "MODE(2)";
   LoadPort1Cmd = "MODE";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: LOAD
// Carrying in the carrier using the E84 function
// Carries in the carrier using the function of SEMI standard E84
void __fastcall TMainForm::btnLoadPort1LOADClick(TObject *Sender)
{

   edLoadPort1Command->Text = "LOAD";
   LoadPort1Cmd = "LOAD";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: UNLD
// Carrying out the carrier using the E84 function
// Carries out the carrier using the function of SEMI standard E84
void __fastcall TMainForm::btnLoadPort1UNLDClick(TObject *Sender)
{

   edLoadPort1Command->Text = "UNLD";
   LoadPort1Cmd = "UNLD";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: E84
void __fastcall TMainForm::cbLoadPort1E84Click(TObject *Sender)
{

   btnLoadPort1LOAD->Enabled = cbLoadPort1E84->Checked;
   btnLoadPort1UNLD->Enabled = cbLoadPort1E84->Checked;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: GPIO
void __fastcall TMainForm::btnLoadPort1GPIOClick(TObject *Sender)
{

   edLoadPort1Command->Text = "GPIO";
   LoadPort1Cmd = "GPIO";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: Presence
void __fastcall TMainForm::pnlLoadPort1PresenceClick(TObject *Sender)
{

   if(pnlLoadPort1Presence->Color != clSilver) {
      SetLoadPortPresence(1,false);
   }
   else {
      SetLoadPortPresence(1,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: Placement
void __fastcall TMainForm::pnlLoadPort1PlacementClick(TObject *Sender)
{

   if(pnlLoadPort1Placement->Color != clSilver) {
      SetLoadPortPlacement(1,false);
   }
   else {
      SetLoadPortPlacement(1,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: Load
void __fastcall TMainForm::pnlLoadPort1LoadClick(TObject *Sender)
{

   if(pnlLoadPort1Load->Color != clSilver) {
      SetLoadPortLoad(1,false);
   }
   else {
      SetLoadPortLoad(1,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: UnLoad
void __fastcall TMainForm::pnlLoadPort1UnloadClick(TObject *Sender)
{

   if(pnlLoadPort1Unload->Color != clSilver) {
      SetLoadPortUnload(1,false);
   }
   else {
      SetLoadPortUnload(1,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: Manual
void __fastcall TMainForm::pnlLoadPort1ManualClick(TObject *Sender)
{

   if(pnlLoadPort1Manual->Color != clSilver) {
      SetLoadPortManual(1,false);
   }
   else {
      SetLoadPortManual(1,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: Alarm
void __fastcall TMainForm::pnlLoadPort1AlarmClick(TObject *Sender)
{

   if(pnlLoadPort1Alarm->Color != clSilver) {
      SetLoadPortAlarm(1,false);
   }
   else {
      SetLoadPortAlarm(1,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: Clamp
void __fastcall TMainForm::pnlLoadPort1ClampClick(TObject *Sender)
{

   if(pnlLoadPort1Clamp->Color != clSilver) {
      SetLoadPortClamp(1,false);
   }
   else {
      SetLoadPortClamp(1,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1: Dock
void __fastcall TMainForm::pnlLoadPort1DockClick(TObject *Sender)
{

   if(pnlLoadPort1Dock->Color != clSilver) {
      SetLoadPortDock(1,false);
   }
   else {
      SetLoadPortDock(1,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1
void __fastcall TMainForm::mnSaveLoadProt1ToFileClick(TObject *Sender)
{

   if(mmLoadPort1->Lines->Count == 0) {
      Application->MessageBox("目前尚無記錄事項!","量測系統: LoadPort1記錄檔寫入作業    ",MB_ICONINFORMATION|MB_OK);
      return;
   }
   if(sdAIMessages->Execute()) {
      mmLoadPort1->Lines->SaveToFile(sdAIMessages->FileName.c_str());
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1
void __fastcall TMainForm::mnClearLoadPort1MessageClick(TObject *Sender)
{

   mmLoadPort1->Clear();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1 Socket
void __fastcall TMainForm::csLoadPort1SocketConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlLoadPort1->Enabled = true;
   pnlLoadPort1SocketConnect->Color = clLime;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1 Socket
void __fastcall TMainForm::csLoadPort1SocketDisconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlLoadPort1->Enabled = false;
   pnlLoadPort1SocketConnect->Color = clSilver;

   // 2021 8 4 - chc 加入Error Code
   pnlLoadPort1SocketConnect->Caption = "";

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1 Socket
void __fastcall TMainForm::csLoadPort1SocketError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   pnlLoadPort1SocketConnect->Color = clRed;

   // 2021 8 4 - chc 加入Error Code
   pnlLoadPort1SocketConnect->Caption = IntToStr(ErrorCode);

   ErrorCode = 0;

}
//---------------------------------------------------------------------------
// 2021 8 3 - chc LP2 - Parameter: Min/Max Thickness
int LP1DPRMStep = 0;

// 2021 4 11 - chc Rorze
// LoadPort1 Socket
// STAT: 21000/0000
// GPIO:
void __fastcall TMainForm::csLoadPort1SocketRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
static char receivestr[256];
static int receivecnt = 0;
static bool inactive = false;
AnsiString text,cmdstr,slen,scmd,spar[30],retcmd,stype,smapdata;
bool flag,done;
int pos,parcnt,len;
char buf[256];
char waferstatus[50];
int waferno;

// 2021 9 16 - chc Alarm
static bool boolorgnerror = false;
static bool boolmotorstall = false;
static bool boolseneorerror = false;
static bool boolcommunicationerror = false;
static bool booldrivererror = false;
static bool boolmappingsensorerror = false;
static bool boolexhaustfanerror = false;
static bool boolcontrolpowererror = false;
static bool booloverheaterror = false;
static bool boolmotorcableerror = false;
static bool boolcarriercarryinerror = false;
static bool boolcarriercarryouterror = false;
static bool boolbusytimeouterror = false;
int errorstate = -1;
int pos1;
AnsiString errorcode,errorname;
// 要Defeuat為"00"
static AnsiString errorcodeold = "00";

   if(inactive == true) {
      AddLoadPort1Message("Re-Entrant!");
      return;
   }
   inactive = true;

   parcnt = 0;
   text = Socket->ReceiveText();
   sprintf(buf,"%s",text.c_str());
   len = text.Length();
   for(int i=0 ; i<len ; i++) {
      if(buf[i] == 0x0d)
         buf[i] = '@';
      else if(buf[i] < 0x20)
         continue;
      receivestr[receivecnt++] = buf[i];
   }
   receivestr[receivecnt] = 0x0;
   text.sprintf("%s",receivestr);
   while(1) {
      // aSTG1.INIT@
      // 12345678901234567890
      pos = text.Pos("@");
      if(pos != 0) {
         cmdstr = text.SubString(1,pos-1);

         // 2023 8 2 - chc 加入"<"
         //AddLoadPort1Message(cmdstr);
         AddLoadPort1Message("<" + cmdstr);

         text.Delete(1,pos);
         receivecnt -= pos;

         // aSTG1.INIT@
         // 12345678901234567890
         retcmd = cmdstr.SubString(7,4);
         if((LoadPort1Cmd == retcmd && cmdstr.SubString(1,1) != "c") || retcmd == "CNCT") {
            pnlLoadPort1CancelCode->Caption = "";
            pnlLoadPort1CancelCode->Color = clSilver;
            pnlLoadPort1Send->Color = clLime;
            pnlLoadPortReady->Color = clLime;
            if(retcmd == "CNCT") {
               boolLoadPort1Init = true;
               pnlLoadPort1Ready->Color = clLime;
            }
            // aALN1.GMAP:nnnn...
            // 1234567890123456
            // pnlTray25
            else if(retcmd == "GMAP") {
               boolLP1CassetteMapping = true;
               int pos,len;
               TPanel *panel,*panel1,*panel2,*panel3;
               len = cmdstr.Length();
               waferno = len - 11;
               // 清顏色
               for(int i=0 ; i<25 ; i++) {
                  panel = (TPanel*)(FindComponent("pnlLoadPort1Tray" + IntToStr(i+1)));
                  panel->Color = clSilver;
                  panel2 = (TPanel*)(FindComponent("pnlLoadPort1Tray" + IntToStr(i+1) + "Select"));
                  panel2->Color = clSilver;

                  panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1)));
                  panel1->Color = clSilver;
                  panel3 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
                  panel3->Color = clSilver;
               }
               sprintf(waferstatus,"%s",cmdstr.SubString(12,len-11).c_str());
               smapdata.sprintf("%s",waferstatus);
               WriteSystemLog("LP1(Mapdata): " + smapdata);
               for(int i=0 ; i<waferno ; i++) {

                  // 2023 8 2 - chc LP1/LP2
                  //CassetteBuffer[i] = waferstatus[i];
                  CassetteBuffer[LOADPORT_1][i] = waferstatus[i];

                  WaferBuffer[i].Status = waferstatus[i] - '0';
                  panel = (TPanel*)(FindComponent("pnlLoadPort1Tray" + IntToStr(i+1)));
                  panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1)));
                  panel2 = (TPanel*)(FindComponent("pnlLoadPort1Tray" + IntToStr(i+1) + "Select"));
                  panel3 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
                  // 0 - Wafer not exist                                        clSilver
                  // 1 - Wafer exists                                           clLime
                  // 2 - Thickness abnormal(thick wafer)                        clBlue
                  // 3 - Cross                                                  clMaroon
                  // 4 - Front bow                                              clRed
                  // 5 - two or more wafers exist in the same slot              clPurple
                  // 6 - Thickness abnormal(thin wafer)                         clOlive
                  switch(waferstatus[i]) {
                     case '0':
                        panel->Color = clSilver;
                        stype = "無Wafer";
                        break;
                     case '1':
                        panel->Color = clLime;
                        stype = "有Wafer";
                        break;
                     case '2':
                        panel->Color = clBlue;
                        stype = "Wafer過厚";
                        break;
                     case '3':
                        panel->Color = clMaroon;
                        stype = "Wafer交叉";
                        break;
                     case '4':
                        panel->Color = clRed;
                        stype = "Wafer突出";
                        break;
                     case '5':
                        panel->Color = clPurple;
                        stype = "Wafer疊片";
                        break;
                     case '6':
                        panel->Color = clOlive;
                        stype = "Wafer過薄";
                        break;
                  }
                  panel1->Color = panel->Color;
                  panel2->Color = panel->Color;
                  panel3->Color = panel->Color;

                  // 2021 7 26 - chc Hint of Wafer
                  panel1->Hint = stype + "(狀態: 無-灰色, 有-綠色, 過厚-藍色, 交叉-暗紅色, 突出-紅色, 疊片-紫色, 過薄-橄欖色)";
                  panel3->Hint = stype + "(狀態: 無-灰色, 有-綠色, 過厚-藍色, 交叉-暗紅色, 突出-紅色, 疊片-紫色, 過薄-橄欖色)";
               }

               // 2021 5 4 - chc 更新Mapping & LoadPort
               waferstatus[26] = 0x0;

               // 2023 8 2 - chc LP1/LP2
               //CassetteBuffer[26] = 0x0;
               //sprintf(WorkingBuffer,"%s",CassetteBuffer);
               CassetteBuffer[LOADPORT_1][26] = 0x0;
               sprintf(WorkingBuffer,"%s",CassetteBuffer[LOADPORT_1]);

               // 2021 9 8 - chc 變更Port編號
               rgSECSPortNo->ItemIndex = LOADPORT_1;
               //rgSECSPortNo->ItemIndex = LOADPORT_2;

               edMapData->Text = waferstatus;
               rgPortStatus->ItemIndex = PORT_STATUS_MAP;
               WriteSystemLog("boolSendSCESCommand: 15, " + edMapData->Text);
               rgSecsCommandSet->ItemIndex = -1;
               boolSendSCESCommand = true;
               rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

               // 2023 8 2 - chc LP1/LP2
               //UpdateCassetteState(1);
               UpdateCassetteState(LOADPORT_1,1);

            }
            // aSTG1.GPIO:000100204C011570/0000000008000081 => 44
            // 12345678901234567890123456789012345678901234567890
            //            1234567890123456 1234567890123456
            // Bit63 - Bit0, 每個digit 4個bits
            // ClampLED(48): 0001000008000081
            //               0(63-60)0(59-56)0(55-52)1(51-48)0(47-44)0(43-40)0(39-36)0(35-32)0(31-28)8(27-24)0(23-20)0(19-16)0(15-12)0(11-8)8(7-4)1(3-0)
            // DockLED(49):  0003000008000081
            // Presence: 44
            // Placement: 45
            // Load: 42
            // UnLoad: 43
            // Manual: 46
            // Alarm: 47
            // Clamp: 48
            // Dock: 49
            // CLMP之後: GPIO:000100205FFEDA30/000000001F000081
            //         00       0 0 0 0 0 0 0 0         63 - 56
            //         01       0 0 0 0 0 0 0 1         55 - 48                 48: 300mm DSC
            //         00       0 0 0 0 0 0 0 0         47 - 40
            //         20       0 0 1 0 0 0 0 0         39 - 32                 37: Cover UnLock
            //         5F       0 1 0 1 1 1 1 1         31 - 24                 30: Open carrier detecting sensor
            //                                                                 *28: door detection
            //                                                                  27: Obstacle defecting sensor
            //                                                                  26: FOSB identification senosr
            //                                                                  25: Presence
            //                                                                  24: Info Pad D
            //         FE       1 1 1 1 1 1 1 0         23 - 16                 23: Info Pad C
            //                                                                  22: Info Pad B
            //                                                                  21: Info Pad A
            //                                                                  20: Presence Middle
            //                                                                  19: Presence right
            //                                                                  18: Presence Left
            //                                                                 *17: Carier clamp close
            //                                                                 *16: Carier clamp open
            //         DA       1 1 0 1 1 0 1 0         15 - 8                 *15: Lower pressure limit
            //                                                                 *14: Upper pressure limit
            //                                                                  13: Mapping sensor preparation
            //                                                                  12: Mapping sensor containing
            //                                                                 *11: FOUP door right open
            //                                                                 *10: FOUP door right close
            //                                                                 *09: FOUP door left open
            //                                                                 *08: FOUP door left close
            //         30       0 0 1 1 0 0 0 0         7  - 0                  07: Protrusion 2
            //                                                                 *06: Protrusion
            //                                                                  05: Exhaust FAN2
            //                                                                  04: Exhaust FAN1
            //                                                                  03: Not connect
            //                                                                  02: Not connect
            //                                                                  01: Temporarity stop
            //                                                                  00: Emergency stop
            // CLMP之後: GPIO:000100205FFEDA30/000000001F000081
            //            door detection On
            //            Carier clamp close
            //            Pressure Limit on
            //            FOUP door open
            //            protrusion Off
            // UCLM之後: GPIO:000100204FFD1570/000000001C000081
            //            door detection Off
            //            Carier clamp open
            //            Pressure Limit off
            //            FOUP door close
            //            protrusion On
            //
            else if(retcmd == "GPIO") {
               //WriteSystemLog("LP1 - GPIO = " + cmdstr);
               char dibuf[20],dobuf[20];
               int pos,len,hexdigitalno;
               bool boolpresenceled,boolplacementled,boolloadled,boolunloadled;
               bool boolmanualled,boolalarmled,boolclampled,booldockled;
               TPanel *panel;
               len = cmdstr.Length();
               if(len == 44) {
                  sprintf(dibuf,"%s",cmdstr.SubString(12,16).c_str());
                  sprintf(dobuf,"%s",cmdstr.SubString(29,16).c_str());
                  for(int i=0 ; i<16 ; i++) {
                     if(dibuf[i] >= '0' && dibuf[i] <= '9')
                        dibuf[i] -= '0';
                     else {
                        dibuf[i] -= 'A';
                        dibuf[i] += 10;
                     }
                     if(dobuf[i] >= '0' && dobuf[i] <= '9')
                        dobuf[i] -= '0';
                     else {
                        dobuf[i] -= 'A';
                        dobuf[i] += 10;
                     }
                  }
                  // 1       2       3       4       5       6       7       8       9       10      11      12      13      14     15    16
                  // 0(63-60)0(59-56)0(55-52)1(51-48)0(47-44)0(43-40)0(39-36)0(35-32)0(31-28)8(27-24)0(23-20)0(19-16)0(15-12)0(11-8)8(7-4)1(3-0)
                  // aSTG1.GPIO:007F00204E161570/000000001E0000E1
                  // LP2
                  // 無12"Carrier
                  //   [18].Presence left: Off
                  //   [19].Presence right: Off
                  //   [20].Presence Middle: Off
                  // 有12"Carrier
                  //   [18].Presence left: On
                  //   [19].Presence right: On
                  //   [20].Presence Middle: On
                  // 由in決定狀態
                  LogInStatus(1,dibuf);
                  // 42 ~ 49
                  // 不是DO
                  //boolclampled = dobuf[15-LOADPORT_CLAMP_BIT/4] & 0x01;                         // 48
                  //booldockled = dobuf[15-LOADPORT_DOCK_BIT/4] & 0x02;                           // 49
                  //boolpresenceled = dobuf[15-LOADPORT_PRESENCE_BIT/4] & 0x01;                   // 44
                  //boolplacementled = dobuf[15-LOADPORT_PLACEMENT_BIT/4] & 0x02;                 // 45
                  //boolloadled = dobuf[15-LOADPORT_LOAD_BIT/4] & 0x04;                           // 42
                  //boolunloadled = dobuf[15-LOADPORT_UNLOAD_BIT/4] & 0x08;                       // 43
                  //boolmanualled = dobuf[15-LOADPORT_MANUAL_BIT/4] & 0x04;                       // 46
                  //boolalarmled = dobuf[15-LOADPORT_ALARM_BIT/4] & 0x08;                         // 47
                  // Presence
                  bool boolpresenceleft,boolpresenceright,boolpresencemiddle,boolpresence;
                  //boolpresenceleft = dibuf[15-LOADPORT_PRESENCE_LEFT_BIT/4] & 0x04;             // 18
                  //boolpresenceright = dibuf[15-LOADPORT_PRESENCE_RIGHT_BIT/4] & 0x08;           // 19
                  //boolpresencemiddle = dibuf[15-LOADPORT_PRESENCE_MIDDLE_BIT/4] & 0x01;         // 20
                  boolpresenceleft = GetBitValue(dibuf, 18);
                  boolpresenceright = GetBitValue(dibuf, 19);
                  boolpresencemiddle = GetBitValue(dibuf, 20);
                  boolpresence = GetBitValue(dibuf, 25);

                  // 300mmDSC, 200mmDSC, 150mmDSC
                  bool bool300mmDSC,bool200mmDSC,bool150mmDSC;
                  bool300mmDSC = GetBitValue(dibuf, 48);
                  bool200mmDSC = GetBitValue(dibuf, 49);
                  bool150mmDSC = GetBitValue(dibuf, 50);
                  // 200mm,150mm,adapter,cover
                  bool boolcst,bool200mm,bool150mm,booladapter,boolcover;
                  boolcst = GetBitValue(dibuf, 51);
                  bool200mm = GetBitValue(dibuf, 52);
                  bool150mm = GetBitValue(dibuf, 53);
                  booladapter = GetBitValue(dibuf, 54);
                  boolcover = GetBitValue(dibuf, 55);
                  // Display
                  // Left
                  if(boolpresenceleft == true)
                     pnlLP1Left->Color = clLime;
                  else
                     pnlLP1Left->Color = clSilver;
                  // Right
                  if(boolpresenceright == true)
                     pnlLP1Right->Color = clLime;
                  else
                     pnlLP1Right->Color = clSilver;
                  // Middle
                  if(boolpresencemiddle == true)
                     pnlLP1Middle->Color = clLime;
                  else
                     pnlLP1Middle->Color = clSilver;
                  // Presence
                  if(boolpresence == true)
                     pnlLP1Presence->Color = clLime;
                  else
                     pnlLP1Presence->Color = clSilver;
                  // 300mmDSC
                  if(bool300mmDSC == true)
                     pnlLP1300DSC->Color = clLime;
                  else
                     pnlLP1300DSC->Color = clSilver;
                  // 200mmDSC
                  if(bool200mmDSC == true)
                     pnlLP1200DSC->Color = clLime;
                  else
                     pnlLP1200DSC->Color = clSilver;
                  // 150mmDSC
                  if(bool150mmDSC == true)
                     pnlLP1150DSC->Color = clLime;
                  else
                     pnlLP1150DSC->Color = clSilver;
                  // CST
                  if(boolcst == true)
                     pnlLP1CST->Color = clLime;
                  else
                     pnlLP1CST->Color = clSilver;
                  // 200mm
                  if(bool200mm == true)
                     pnlLP1200mm->Color = clLime;
                  else
                     pnlLP1200mm->Color = clSilver;
                  // 150mm
                  if(bool150mm == true)
                     pnlLP1150mm->Color = clLime;
                  else
                     pnlLP1150mm->Color = clSilver;
                  // Adapter
                  if(booladapter == true)
                     pnlLP1Adapter->Color = clLime;
                  else
                     pnlLP1Adapter->Color = clSilver;
                  // Cover
                  if(boolcover == true)
                     pnlLP1Cover->Color = clLime;
                  else
                     pnlLP1Cover->Color = clSilver;

                  // 2023 7 27 - chc 加入Presence: 25
                  // 由25決定Presence
                  if(boolpresence == true)
                     boolpresenceled = true;
                  else
                     boolpresenceled = false;

                  // 2023 7 27 - chc 決定Wafer Size & placement
                  // 12"
                  if(boolpresenceleft == true && boolpresenceright == true && boolpresencemiddle == true) {
                     rgLoadPort1WaferSize->ItemIndex = WAFER_SIZE_12;
                     boolplacementled = true;
                     pnlLP1Size->Caption = "12\"";
                     cbLP1E84->Enabled = true;
                  }
                  // 8"
                  else if(boolpresenceleft == true && boolpresenceright == false && boolpresencemiddle == true &&
                          bool300mmDSC == true && bool200mmDSC == true && bool150mmDSC == true && boolcst == true &&
                          bool200mm == true && bool150mm == true && booladapter == true && boolcover == true) {
                     rgLoadPort1WaferSize->ItemIndex = WAFER_SIZE_8;
                     boolplacementled = true;
                     pnlLP1Size->Caption = "8\"";
                     cbLP1E84->Checked = false;
                     cbLP1E84->Enabled = false;
                  }
                  else {
                     rgLoadPort1WaferSize->ItemIndex = WAFER_SIZE_NONE;
                     boolplacementled = false;
                     pnlLP1Size->Caption = "--";
                     cbLP1E84->Checked = false;
                     cbLP1E84->Enabled = false;
                  }

                  // Load
                  bool boolFOUPLeftDoor,boolFOUPRightDoor,boolCarrierClamp;
                  // FOUP Left Door: 9
                  // FOUP Right Door: 11
                  // Carrier Clamp: 17
                  //boolFOUPLeftDoor = dibuf[15-9/4] & 0x02;                      // 9
                  //boolFOUPRightDoor = dibuf[15-11/4] & 0x08;                    // 11
                  //boolCarrierClamp = dibuf[15-17/4] & 0x02;                     // 17
                  boolFOUPLeftDoor = GetBitValue(dibuf, 9);
                  boolFOUPRightDoor = GetBitValue(dibuf, 11);
                  boolCarrierClamp = GetBitValue(dibuf, 17);

                  // 2021 6 30 - chc 8"/12"不同
                  //=> 8"看Bit6: off=>Loaded, On=>UnLoaded
                  bool boolprotrusion;
                  if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_8) {
                     boolprotrusion = GetBitValue(dibuf, 6);
                     // Loaded
                     if(boolprotrusion == false) {
                        boolloadled = true;
                        boolunloadled = false;
                     }
                     else {
                        boolloadled = false;
                        boolunloadled = true;
                     }
                  }
                  // 12"
                  else {
                     // LOAD
                     if(boolFOUPLeftDoor == true && boolFOUPRightDoor == true && boolCarrierClamp == true) {
                        boolloadled = true;
                        boolunloadled = false;
                     }
                     else {
                        boolloadled = false;
                        boolunloadled = true;
                     }
                  }
                  // Clamp
                  if(boolCarrierClamp == true)
                     boolclampled = true;
                  else
                     boolclampled = false;

                  // 再確認Placement/Presence
                  if(boolpresenceled == false || boolplacementled == false) {
                     rgLoadPort1WaferSize->ItemIndex = WAFER_SIZE_NONE;
                     pnlLP1Size->Caption = "--";
                     cbLP1E84->Checked = false;
                     cbLP1E84->Enabled = false;
                  }

                  // 2023 7 25 - chc 區分12"/8"
                  // 12"
                  if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_12) {
                     if(pnlLoadPort1Title->Caption != "LP1(12\")") {
                        pnlLoadPort1Title->Caption = "LP1(12\")";
                        rgLoadPortSelect->Items->Strings[0] = "LP1(12\")";
                     }
                  }
                  // 8"
                  else if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_8) {
                     if(pnlLoadPort1Title->Caption != "LP1(8\")") {
                        pnlLoadPort1Title->Caption = "LP1(8\")";
                        rgLoadPortSelect->Items->Strings[0] = "LP1(8\")";
                     }
                  }
                  // None
                  else {
                     if(pnlLoadPort1Title->Caption != "LP1(--)") {
                        pnlLoadPort1Title->Caption = "LP1(--)";
                        rgLoadPortSelect->Items->Strings[0] = "LP1(--)";
                     }
                  }

                  bool boolcassette = false;

                  // 2023 7 27 - chc 不看boolcassette
                  //// Cassette(8")
                  //if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_8) {
                  //   if(bool200mm == true && bool150mm == true && booladapter == true)
                  //      boolcassette = true;
                  //}
                  boolcassette = true;

                  // 2021 5 6 - chc 設定Load button staus
                  //if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {

                     // 2021 7 17 - chc 要有CST才可Enable
                     //if(boolpresenceled == true && boolplacementled == true)
                     if(boolpresenceled == true && boolplacementled == true && boolcassette == true) {

                        // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
                        // 2023 2 21 - chc 不檢查WaferInSystem()
                        //if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false && WaferInSystem() == false) {
                        if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false) {

                           btnCassetteLoad->Enabled = true;

                           // 2021 11 12 - ch cog
                           WriteSystemLog("LP1 Socket GPIO - 啟動Load Button");
                        }

                     }
                     else {
                        btnCassetteLoad->Enabled = false;
                     }

                     if(boolpresenceled == true && boolplacementled == true && boolcassette == true) {
                        if(boolloadled == false && boolunloadled == true) {
                           btnCassetteLoad->Caption = "Load";
                           btnLoadWafer->Enabled = false;
                           pnlLoadWafer->Color = clSilver;
                           MainForm->GreenLamp(false);
                           MainForm->YellowLamp(true);
                        }
                        else if(boolloadled == true && boolunloadled == false) {
                           btnCassetteLoad->Caption = "UnLoad";
                           btnLoadWafer->Enabled = true;
                           MainForm->GreenLamp(true);
                           MainForm->YellowLamp(false);
                        }
                        else
                           btnCassetteLoad->Enabled = false;
                     }
                  //}

                  // Clamp
                  if(boolclampled == true) {
                     SetLoadPortClamp(1,true);
                     //WriteSystemLog("LP1 - GPIO = CLMP");
                  }
                  else {
                     SetLoadPortClamp(1,false);
                  }
                  // Dock
                  //if(booldockled == true) {
                  //   SetLoadPortDock(1,true)
                  //   WriteSystemLog("LP1 - GPIO = DOCK");
                  //}
                  //else {
                  //   SetLoadPortDock(1,false)
                  //}
                  // Presence
                  if(boolpresenceled == true) {

                     // 2021 5 4 - chc Cassette是否為置入

                     SetLoadPortPresence(1,true);
                     WriteSystemLog("LP1 - GPIO = Presence");
                  }
                  else {
                     SetLoadPortPresence(1,false);
                  }
                  // Placement
                  if(boolplacementled == true) {
                     SetLoadPortPlacement(1,true);
                     WriteSystemLog("LP1 - GPIO = Placement");
                  }
                  else {
                     SetLoadPortPlacement(1,false);
                  }
                  // Load
                  if(boolloadled == true) {
                     SetLoadPortLoad(1,true);
                     //WriteSystemLog("LP1 - GPIO = Load");
                  }
                  else {
                     SetLoadPortLoad(1,false);
                  }
                  // UnLoad
                  if(boolunloadled == true) {
                     SetLoadPortUnload(1,true);
                     //WriteSystemLog("LP1 - GPIO = UnLoad");
                  }
                  else {
                     SetLoadPortUnload(1,false);
                  }
                  // Manual
                  //if(boolmanualled == true) {
                  //   SetLoadPortManual(1,true);
                  //   WriteSystemLog("LP1 - GPIO = Manual");
                  //}
                  //else {
                  //   SetLoadPortManual(1,false);
                  //}
                  // Alarm
                  //if(boolalarmled == true) {
                  //   SetLoadPortAlarm(1,true);
                  //   WriteSystemLog("LP1 - GPIO = Alarm");
                  //}
                  //else {
                  //   SetLoadPortAlarm(1,false);
                  //}
               }
            }

            // 2021 4 26 - chc STAT
            // aSTG1.STAT:10000/0000
            // 123456789012345678901234567890
            //retcmd = cmdstr.SubString(7,4);
            else if(retcmd == "STAT") {
               AnsiString errcode,errcode1;
               errcode = cmdstr.SubString(18,4);
               errcode1 = cmdstr.SubString(20,2);
               if(errcode1 != "00") {
                  // LoadPort
                  //#define LOADPORT_ALARM_ORGN             0
                  //#define LOADPORT_ALARM_MOTOR_STALL      1
                  //#define LOADPORT_ALARM_SENSOR           2
                  //#define LOADPORT_ALARM_COMMUNICATION    3
                  //#define LOADPORT_ALARM_DRIVER           4
                  //#define LOADPORT_ALARM_MAPPING_SENSOR   5
                  //#define LOADPORT_ALARM_FAN              6
                  //#define LOADPORT_ALARM_POWER            7
                  //#define LOADPORT_ALARM_OVER_HEAT        8
                  //#define LOADPORT_ALARM_CABLE            9
                  //#define LOADPORT_ALARM_CARRY_IN         10
                  //#define LOADPORT_ALARM_CARRY_OUT        11
                  //#define LOADPORT_ALARM_BUSY_TIMEOUT     12
                  errorname = "異常";
                  if(errcode1 == "01") {
                     pnlLoadPortErrorCode1->Hint = "Motor stall";
                     errorname = "失步";
                     errorstate = LOADPORT_ALARM_MOTOR_STALL;
                  }
                  else if(errcode1 == "02") {
                     pnlLoadPortErrorCode1->Hint = "Sensor abnormal";
                     errorname = "Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "03") {
                     pnlLoadPortErrorCode1->Hint = "Emergency stop";
                     errorname = "急停";
                     errorstate = LOADPORT_ALARM_POWER;
                  }
                  else if(errcode1 == "04") {
                     pnlLoadPortErrorCode1->Hint = "Command error";
                     errorname = "指令異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "05") {
                     pnlLoadPortErrorCode1->Hint = "Communication error";
                     errorname = "通訊異常";
                     errorstate = LOADPORT_ALARM_COMMUNICATION;
                  }
                  else if(errcode1 == "06") {
                     pnlLoadPortErrorCode1->Hint = "Chucking sensor abnormal";
                     errorname = "Chucking Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "07") {
                     pnlLoadPortErrorCode1->Hint = "(Reserved)";
                     errorname = "預留";
                  }
                  else if(errcode1 == "08") {
                     pnlLoadPortErrorCode1->Hint = "Obstacle detection sensor error";
                     errorname = "障礙偵測Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "09") {
                     pnlLoadPortErrorCode1->Hint = "Second origin sensor abnormal";
                     errorname = "原點Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "0A") {
                     pnlLoadPortErrorCode1->Hint = "Mapping sensor abnormal";
                     errorname = "Mapping Sensor異常";
                     errorstate = LOADPORT_ALARM_MAPPING_SENSOR;
                  }
                  else if(errcode1 == "0B") {
                     pnlLoadPortErrorCode1->Hint = "Wafer protrusion detecting sensor abnormal";
                     errorname = "凸片偵測Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "0E") {
                     pnlLoadPortErrorCode1->Hint = "Driver abnormal";
                     errorname = "驅動器異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "20") {
                     pnlLoadPortErrorCode1->Hint = "Control power abnormal";
                     errorname = "控制電源異常";
                     errorstate = LOADPORT_ALARM_POWER;
                  }
                  else if(errcode1 == "21") {
                     pnlLoadPortErrorCode1->Hint = "Driver power abnormal";
                     errorname = "驅動器電源異常";
                     errorstate = LOADPORT_ALARM_POWER;
                  }
                  else if(errcode1 == "22") {
                     pnlLoadPortErrorCode1->Hint = "EEPROM abnormal";
                     errorname = "驅動器異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "23") {
                     pnlLoadPortErrorCode1->Hint = "Z search error";
                     errorname = "驅動器異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "24") {
                     pnlLoadPortErrorCode1->Hint = "Overheat";
                     errorname = "過熱異常";
                     errorstate = LOADPORT_ALARM_OVER_HEAT;
                  }
                  else if(errcode1 == "25") {
                     pnlLoadPortErrorCode1->Hint = "Overcurrent";
                     errorname = "過電流異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "26") {
                     pnlLoadPortErrorCode1->Hint = "Motor cable abnormal";
                     errorname = "馬達線路異常";
                     errorstate = LOADPORT_ALARM_CABLE;
                  }
                  else if(errcode1 == "27") {
                     pnlLoadPortErrorCode1->Hint = "Motor stall(position deviation)";
                     errorname = "失步(位置)";
                     errorstate = ROBOT_ALARM_MOTOR_STALL;
                  }
                  else if(errcode1 == "28") {
                     pnlLoadPortErrorCode1->Hint = "Motor stall(time over)";
                     errorname = "失步(過時)";
                     errorstate = ROBOT_ALARM_MOTOR_STALL;
                  }
                  else if(errcode1 == "89") {
                     pnlLoadPortErrorCode1->Hint = "Exhaust fan abnormal";
                     errorname = "排風扇異常";
                     errorstate = LOADPORT_ALARM_FAN;
                  }
                  else if(errcode1 == "92") {
                     pnlLoadPortErrorCode1->Hint = "Foup clamp/rotation disabled";
                     errorname = "Foup Clamp異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "93") {
                     pnlLoadPortErrorCode1->Hint = "Foup unclam;/rotation disabled";
                     errorname = "Foup UnClamp異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "94") {
                     pnlLoadPortErrorCode1->Hint = "Latch key lock disabled";
                     errorname = "Latch Key Lock異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "96") {
                     pnlLoadPortErrorCode1->Hint = "Latch key release disabled";
                     errorname = "Latch Key Release異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "97") {
                     pnlLoadPortErrorCode1->Hint = "Mapping sensor preparation disabled";
                     errorname = "Mapping Sensor異常";
                     errorstate = LOADPORT_ALARM_MAPPING_SENSOR;
                  }
                  else if(errcode1 == "98") {
                     pnlLoadPortErrorCode1->Hint = "Mapping sensor containing disabled";
                     errorname = "Mapping Sensor異常";
                     errorstate = LOADPORT_ALARM_MAPPING_SENSOR;
                  }
                  else if(errcode1 == "99") {
                     pnlLoadPortErrorCode1->Hint = "Chucking on disabled";
                     errorname = "Chucking On異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "9A") {
                     pnlLoadPortErrorCode1->Hint = "Wafer protrusion";
                     errorname = "Wafer凸出異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9B") {
                     pnlLoadPortErrorCode1->Hint = "No door on FOUP/With door on FOSB";
                     errorname = "FOUP異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9C") {
                     pnlLoadPortErrorCode1->Hint = "Carrier improperly taken";
                     errorname = "Carrier異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9D") {
                     pnlLoadPortErrorCode1->Hint = "FOSB door detection";
                     errorname = "FOSB異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9E") {
                     pnlLoadPortErrorCode1->Hint = "Carrier improperly placed";
                     errorname = "Carrier位置異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9F") {
                     pnlLoadPortErrorCode1->Hint = "Carrier detection error";
                     errorname = "Carrier偵測異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "A0") {
                     pnlLoadPortErrorCode1->Hint = "Cover lock disabled";
                     errorname = "Cover Lock異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "A1") {
                     pnlLoadPortErrorCode1->Hint = "Cover unlock disabled";
                     errorname = "Cover UnLock異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "B0") {
                     pnlLoadPortErrorCode1->Hint = "TR_REQ timeout";
                     errorname = "TR_REQ異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "B1") {
                     pnlLoadPortErrorCode1->Hint = "BUSY ON timeout";
                     errorname = "Busy or Timeout";
                     errorstate = LOADPORT_ALARM_BUSY_TIMEOUT;
                  }
                  else if(errcode1 == "B2") {
                     pnlLoadPortErrorCode1->Hint = "Carrier carry-in timeout";
                     errorname = "Carrier Carry-In異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "B3") {
                     pnlLoadPortErrorCode1->Hint = "Carrier carry-out timeout";
                     errorname = "Carrier Carry-Out異常";
                     errorstate = LOADPORT_ALARM_CARRY_OUT;
                  }
                  else if(errcode1 == "B4") {
                     pnlLoadPortErrorCode1->Hint = "BUSY OFF timeout";
                     errorname = "BUSY off timeout異常";
                     errorstate = LOADPORT_ALARM_BUSY_TIMEOUT;
                  }
                  else if(errcode1 == "B5") {
                     pnlLoadPortErrorCode1->Hint = "(Reserved)";
                     errorname = "預留";
                  }
                  else if(errcode1 == "B6") {
                     pnlLoadPortErrorCode1->Hint = "VALID OFF timeout";
                     errorname = "VALID off timeout異常";
                     errorstate = LOADPORT_ALARM_BUSY_TIMEOUT;
                  }
                  else if(errcode1 == "B7") {
                     pnlLoadPortErrorCode1->Hint = "CONTINUE timeout";
                     errorname = "CONTINUE timeout異常";
                     errorstate = LOADPORT_ALARM_BUSY_TIMEOUT;
                  }
                  else if(errcode1 == "B8") {
                     pnlLoadPortErrorCode1->Hint = "Signal abnormal detected from VALID,CS_0=ON to TR_REQ=ON";
                     errorname = "Signal-1異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "B9") {
                     pnlLoadPortErrorCode1->Hint = "Signal abnormal detected from TR_REQ=ON to BUSY=ON";
                     errorname = "Signal-2異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "BA") {
                     pnlLoadPortErrorCode1->Hint = "Signal abnormal detected from BUSY=ON to Placement=ON";
                     errorname = "Signal-3異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "BB") {
                     pnlLoadPortErrorCode1->Hint = "Signal abnormal detected from Placement=ON to COMPLETE=ON";
                     errorname = "Signal-4異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "BC") {
                     pnlLoadPortErrorCode1->Hint = "Signal abnormal detected from COMPLETE=ON to VALID=OFF";
                     errorname = "Signal-5異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "BF") {
                     pnlLoadPortErrorCode1->Hint = "VALID,CS_0 signal abnormal";
                     errorname = "Signal-6異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  pnlLoadPortErrorCode1->Caption = errcode;

                  // 2021 9 18 - chc Alarm
                  pnlLoadPortErrorCode1->Hint = "LP2: " + errorname;
                  pnlOpeationMessage->Caption = "LP2: " + errorname;
                  //RedLamp(true);
                  //???
                  AddLoadPort1Message(">Robot 異常原因: " + errorname);
                  //Beep(100);
                  //???

                  // 2021 9 16 - chc Alarm
                  //#define LOADPORT_ALARM_ORGN             0
                  //#define LOADPORT_ALARM_MOTOR_STALL      1
                  //#define LOADPORT_ALARM_SENSOR           2
                  //#define LOADPORT_ALARM_COMMUNICATION    3
                  //#define LOADPORT_ALARM_DRIVER           4
                  //#define LOADPORT_ALARM_MAPPING_SENSOR   5
                  //#define LOADPORT_ALARM_FAN              6
                  //#define LOADPORT_ALARM_POWER            7
                  //#define LOADPORT_ALARM_OVER_HEAT        8
                  //#define LOADPORT_ALARM_CABLE            9
                  //#define LOADPORT_ALARM_CARRY_IN         10
                  //#define LOADPORT_ALARM_CARRY_OUT        11
                  //#define LOADPORT_ALARM_BUSY_TIMEOUT     12
                  //static bool boolorgnerror = false;
                  //static bool boolmotorstall = false;
                  //static bool boolseneorerror = false;
                  //static bool boolcommunicationerror = false;
                  //static bool booldrivererror = false;
                  //static bool boolmappingsensorerror = false;
                  //static bool boolexhaustfanerror = false;
                  //static bool boolcontrolpowererror = false;
                  //static bool booloverheaterror = false;
                  //static bool boolmotorcableerror = false;
                  //static bool boolcarriercarryinerror = false;
                  //static bool boolcarriercarryouterror = false;
                  //static bool boolbusytimeouterror = false;
                  if(errorstate == LOADPORT_ALARM_ORGN) {
                     if(boolorgnerror == false) {
                        boolorgnerror = true;
                        SetSECSAlarm(34001,1,1,"LP2 ORGN Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_MOTOR_STALL) {
                     if(boolmotorstall == false) {
                        boolmotorstall = true;
                        SetSECSAlarm(34002,1,1,"LP2 Motor Stall");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_SENSOR) {
                     if(boolseneorerror == false) {
                        boolseneorerror = true;
                        SetSECSAlarm(34003,1,1,"LP2 Sensor Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_COMMUNICATION) {
                     if(boolcommunicationerror == false) {
                        boolcommunicationerror = true;
                        SetSECSAlarm(34004,1,1,"LP2 Controller Communication Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_DRIVER) {
                     if(booldrivererror == false) {
                        booldrivererror = true;
                        SetSECSAlarm(34005,1,1,"LP2 Driver Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_MAPPING_SENSOR) {
                     if(boolmappingsensorerror == false) {
                        boolmappingsensorerror = true;
                        SetSECSAlarm(34006,1,1,"LP2 Mapping Sensor Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_FAN) {
                     if(boolexhaustfanerror == false) {
                        boolexhaustfanerror = true;
                        SetSECSAlarm(34007,1,1,"LP2 Exhaust Fan Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_POWER) {
                     if(boolcontrolpowererror == false) {
                        boolcontrolpowererror = true;
                        SetSECSAlarm(34008,1,1,"LP2 Control Power Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_OVER_HEAT) {
                     if(booloverheaterror == false) {
                        booloverheaterror = true;
                        SetSECSAlarm(34009,1,1,"LP2 Overheat Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_CABLE) {
                     if(boolmotorcableerror == false) {
                        boolmotorcableerror = true;
                        SetSECSAlarm(34010,1,1,"LP2 Motor Cable Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_CARRY_IN) {
                     if(boolcarriercarryinerror == false) {
                        boolcarriercarryinerror = true;
                        SetSECSAlarm(34011,1,0,"LP2 Carrier Carry-In Error");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_CARRY_OUT) {
                     if(boolcarriercarryouterror == false) {
                        boolcarriercarryouterror = true;
                        SetSECSAlarm(34012,1,0,"LP2 Carrier Carry-Out Error");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_BUSY_TIMEOUT) {
                     if(boolbusytimeouterror == false) {
                        boolbusytimeouterror = true;
                        SetSECSAlarm(34013,1,0,"LP2 Busy or Timeout");
                     }
                  }
                  // 記錄Robot Error Code
                  errorcodeold = errorcode;

               }
               else {
                  pnlLoadPortErrorCode1->Caption = "";
                  // LoadPort
                  //static bool boolorgnerror = false;
                  //static bool boolmotorstall = false;
                  //static bool boolseneorerror = false;
                  //static bool boolcommunicationerror = false;
                  //static bool booldrivererror = false;
                  //static bool boolmappingsensorerror = false;
                  //static bool boolexhaustfanerror = false;
                  //static bool boolcontrolpowererror = false;
                  //static bool booloverheaterror = false;
                  //static bool boolmotorcableerror = false;
                  //static bool boolcarriercarryinerror = false;
                  //static bool boolcarriercarryouterror = false;
                  //static bool boolbusytimeouterror = false;
                  if(errorcodeold != errorcode)
                     AddLoadPort1Message(">8吋Port 恢復正常.");
                  errorname = "正常";
                  pnlLoadPortErrorCode1->Hint = errorname;
                  pnlLoadPortErrorCode1->Caption = "";
                  // Alarm Reset
                  if(boolorgnerror == true) {
                     SetSECSAlarm(34001,0,1,"LP2 ORGN Abnormal");
                  }
                  if(boolmotorstall == true) {
                     SetSECSAlarm(34002,0,1,"LP2 Motor Stall");
                  }
                  if(boolseneorerror == true) {
                     SetSECSAlarm(34003,0,1,"LP2 Sensor Abnormal");
                  }
                  if(boolcommunicationerror == true) {
                     SetSECSAlarm(34004,0,1,"LP2 Controller Communication Abnormal");
                  }
                  if(booldrivererror == true) {
                     SetSECSAlarm(34005,0,1,"LP2 Driver Abnormal");
                  }
                  if(boolmappingsensorerror == true) {
                     SetSECSAlarm(34006,0,1,"LP2 Mapping Sensor Abnormal");
                  }
                  if(boolexhaustfanerror == true) {
                     SetSECSAlarm(34007,0,1,"LP2 Exhaust Fan Abnormal");
                  }
                  if(boolcontrolpowererror == true) {
                     SetSECSAlarm(34008,0,1,"LP2 Control Power Abnormal");
                  }
                  if(booloverheaterror == true) {
                     SetSECSAlarm(34009,0,1,"LP2 Overheat Abnormal");
                  }
                  if(boolmotorcableerror == true) {
                     SetSECSAlarm(34010,0,1,"LP2 Motor Cable Error");
                  }
                  if(boolcarriercarryinerror == true) {
                     SetSECSAlarm(34011,0,0,"LP2 Carry-In Error");
                  }
                  if(boolcarriercarryouterror == true) {
                     SetSECSAlarm(34012,0,0,"LP2 Carry-Out Error");
                  }
                  if(boolbusytimeouterror == true) {
                     SetSECSAlarm(34013,0,0,"LP2 Busy or Timeout");
                  }
                  boolorgnerror = false;
                  boolmotorstall = false;
                  boolseneorerror = false;
                  boolcommunicationerror = false;
                  booldrivererror = false;
                  boolmappingsensorerror = false;
                  boolexhaustfanerror = false;
                  boolcontrolpowererror = false;
                  booloverheaterror = false;
                  boolmotorcableerror = false;
                  boolcarriercarryinerror = false;
                  boolcarriercarryouterror = false;
                  boolbusytimeouterror = false;

               }
            }

            // 2021 8 3 - chc LP2 - Parameter: Min/Max Thickness: LP1DPRMStep
            // aSTG1.DPRM.GTDT=0000
            // 123456789012345678901234567890
            else if(retcmd == "DPRM") {
               int no,len;
               len = cmdstr.Length();
               no = len - 16;
               AnsiString svalue;
               svalue = cmdstr.SubString(19,no);
               if(LP1DPRMStep == 2) {
                  pnlLoadPort1MinThickness->Caption = svalue;
                  LP1DPRMStep++;
               }
               else if(LP1DPRMStep == 4) {
                  pnlLoadPort1MaxThickness->Caption = svalue;
                  LP1DPRMStep++;
               }
            }

         }
         else {

            // 2021 10 12 - chc 位置不對
            //pnlLoadPort1Send->Color = clRed;

            if(cmdstr.SubString(1,1) == "c") {

               // 2021 10 12 - chc 位置不對
               pnlLoadPort1Send->Color = clRed;

               pnlLoadPort1CancelCode->Color = clRed;
               pnlLoadPort1CancelCode->Font->Color = clWhite;
               // cSTG1.ORGB:000F
               // 1234567890123456
               AnsiString cancelcode = cmdstr.SubString(12,4);
               if(cancelcode == "0200")
                  pnlLoadPort1CancelCode->Caption = "The Operation objective is not supported";
               else if(cancelcode == "0300")
                  pnlLoadPort1CancelCode->Caption = "The composition elements of command are too few";
               else if(cancelcode == "0310")
                  pnlLoadPort1CancelCode->Caption = "The composition elements of command are too many";
               else if(cancelcode == "0400")
                  pnlLoadPort1CancelCode->Caption = "Command not supported";
               else if(cancelcode == "0500")
                  pnlLoadPort1CancelCode->Caption = "Too few parameters";
               else if(cancelcode == "0510")
                  pnlLoadPort1CancelCode->Caption = "Too many parameters";
               else if(cancelcode == "0520")
                  pnlLoadPort1CancelCode->Caption = "Inproper number of parameters";
               else if(cancelcode == "060X")
                  pnlLoadPort1CancelCode->Caption = "The value of the No.(X+1)parameter is too small";
               else if(cancelcode == "061X")
                  pnlLoadPort1CancelCode->Caption = "The value of the No.(X+1)parameter is too large";
               else if(cancelcode == "062X")
                  pnlLoadPort1CancelCode->Caption = "The No.(X+1)parameter is not numerical number";
               else if(cancelcode == "063X")
                  pnlLoadPort1CancelCode->Caption = "The digit number of the No.(X+1)parameter is not proper";
               else if(cancelcode == "064X")
                  pnlLoadPort1CancelCode->Caption = "The No.(X+1)parameter is not a hexadecimal number";
               else if(cancelcode == "065X")
                  pnlLoadPort1CancelCode->Caption = "The No.(X+1)parameter is not proper";
               else if(cancelcode == "066X")
                  pnlLoadPort1CancelCode->Caption = "The No.(X+1)parameter is not pulse";
               else if(cancelcode == "0700")
                  pnlLoadPort1CancelCode->Caption = "Abnormal Mode: Not ready";
               else if(cancelcode == "0702")
                  pnlLoadPort1CancelCode->Caption = "Abnormal Mode: Not in the maintenance mode";
               else if(cancelcode == "08XX")
                  pnlLoadPort1CancelCode->Caption = "The setting data of the No(XX+1)is not proper";
               else if(cancelcode == "0920")
                  pnlLoadPort1CancelCode->Caption = "Inproper setting";
               else if(cancelcode == "0A00")
                  pnlLoadPort1CancelCode->Caption = "Origin search not completed";
               else if(cancelcode == "0A01")
                  pnlLoadPort1CancelCode->Caption = "Origin reset not completed";
               else if(cancelcode == "0B00")
                  pnlLoadPort1CancelCode->Caption = "Processing";
               else if(cancelcode == "0B01")
                  pnlLoadPort1CancelCode->Caption = "Moving";
               else if(cancelcode == "0D00")
                  pnlLoadPort1CancelCode->Caption = "Abnormal flash memory";
               else if(cancelcode == "0F00")
                  pnlLoadPort1CancelCode->Caption = "Error-occurred state";
               else if(cancelcode == "1000")
                  pnlLoadPort1CancelCode->Caption = "Movment is unable due to carrier presence";
               else if(cancelcode == "1001")
                  pnlLoadPort1CancelCode->Caption = "Movment is unable due to no carrier presence";
               else if(cancelcode == "1002")
                  pnlLoadPort1CancelCode->Caption = "Improper Setting";
               else if(cancelcode == "1003")
                  pnlLoadPort1CancelCode->Caption = "Improper current position";
               else if(cancelcode == "1004")
                  pnlLoadPort1CancelCode->Caption = "Movment is unable due to small designated posistion";
               else if(cancelcode == "1005")
                  pnlLoadPort1CancelCode->Caption = "Movment is unable due to large designated posistion";
               else if(cancelcode == "1006")
                  pnlLoadPort1CancelCode->Caption = "Presence of the adapter cannot be identified";
               else if(cancelcode == "1007")
                  pnlLoadPort1CancelCode->Caption = "Origin search cannot be perfomed due to abnormal presence state of the adspter";
               else if(cancelcode == "1008")
                  pnlLoadPort1CancelCode->Caption = "Adapter not prepared";
               else if(cancelcode == "1009")
                  pnlLoadPort1CancelCode->Caption = "Cover not closed";
               else if(cancelcode == "103X")
                  pnlLoadPort1CancelCode->Caption = "Interfering with the No.(X+1)axis";
               else if(cancelcode == "1100")
                  pnlLoadPort1CancelCode->Caption = "Emergency stop signal is ON";
               else if(cancelcode == "1200")
                  pnlLoadPort1CancelCode->Caption = "Pause signal is ON/Area sensor beam is blocked";
               else if(cancelcode == "1300")
                  pnlLoadPort1CancelCode->Caption = "Interlock signal is ON";
               else if(cancelcode == "1400")
                  pnlLoadPort1CancelCode->Caption = "Drive power is OFF";
               else if(cancelcode == "2000")
                  pnlLoadPort1CancelCode->Caption = "No response from the ID reader/writer";
               else if(cancelcode == "2100")
                  pnlLoadPort1CancelCode->Caption = "Command for the ID reader/writer is cancelled";
               pnlLoadPort1CancelCode->Hint = pnlLoadPort1CancelCode->Caption;
            }
         }

         if(boolWaitLoadPort1Complete == true) {
            AddLoadPort1Message("檢查STAT:11000...");
            // 12345/6789
            // D1: Operation mode 0-Initializing, 1-Remote, 2-Maintenance, 3-Recovery
            // D2: Origin Search Complete 0-Not Completed, 1-Completed
            // D3: Command Processing 0-Stop, 1-Processing
            // D4: Operation Status 0-Stop, 1-Moving, 2-Temporary Stop
            // D5: Motion Speed 0-Normal, 1-Maintenance
            // D6,D7: Identiofication code for the error-occurred controller(s)
            // D8,D9: Error Code
            if(cmdstr.Pos("STAT:11000") != 0 || cmdstr.Pos("STAT:10000") != 0) {
               AddLoadPort1Message("檢查STAT:11000 ok.");
               boolLoadPort1Complete = true;
               boolWaitLoadPort1Complete = false;

               // 221 9 20 - chc Log
               AddLoadPort1Message("檢查指令: " + retcmd + "已完成.");
               WriteSystemLog("檢查指令: " + retcmd + "已完成.");

            }
            else {
               AddLoadPort1Message("檢查STAT:11000 fail!");
            }

            // 221 9 20a - chc 是指令已被執行, 不應設為完成!
            if(AlignerCmd == retcmd && cmdstr.SubString(1,1) == "a") {
               AddLoadPort1Message("檢查指令: " + retcmd + "已執行.");
               WriteSystemLog("檢查指令: " + retcmd + "已執行.");
            }

         }
      }
      else
         break;
   }
   sprintf(receivestr,"%s",text.c_str());

   inactive = false;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort1 Message
void TMainForm::AddLoadPort1Message(AnsiString msg)
{
AnsiString putmsg;
static AnsiString oldmsg = "";

   //if(oldmsg == msg)                            // 重複不收錄
   //   return;
   oldmsg = msg;
   putmsg = Now().FormatString("nn':'ss':'zzz'-> '") + msg;
   // 以Memo取代, 最多共470 Rows
   mmLoadPort1->Lines->Insert(0,putmsg);
   mmLoadPort1->Refresh();

   if(mmLoadPort1->Lines->Count > 500) {
      for(int i=470 ; i<mmLoadPort1->Lines->Count ; i++)
         mmLoadPort1->Lines->Delete(i);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2
void __fastcall TMainForm::btnLoadPort2SendClick(TObject *Sender)
{
char buf[50];
AnsiString cmd,msg;
int len;
static bool boolactive = false;

   if(boolactive == true) {
      pnlLoadPort1SocketConnect->Color = clRed;
      return;
   }
   boolactive = true;

   pnlLoadPort2Send->Color = clSilver;
   if(csLoadPort2Socket->Active == true) {
      cmd = edLoadPort2Command->Text;
      len = cmd.Length();
      sprintf(buf,"oSTG2.%s\r",cmd.c_str());
      len += 6;
      csLoadPort2Socket->Socket->SendBuf(buf,len+1);
      pnlLoadPort2SocketConnect->Color = clLime;

      // 2023 8 2 - chc 加入Message
      msg.sprintf(">oSTG2.%s",cmd.c_str());
      AddLoadPort2Message(msg);

   }
   else
      pnlLoadPort2SocketConnect->Color = clRed;
   boolactive = false;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: ORGN
void __fastcall TMainForm::btnLoadPort2ORGNClick(TObject *Sender)
{
static bool first = true;

   btnLoadPort2ORGN->Enabled = false;
   pnlLoadPort2ORGN->Color = clSilver;
   pnlLoadPort2ORGN->Refresh();
   if(first == true) {
      first = false;
      // Set IP/Port...
      // DEQU.STDT[1]=172.20.9.100
      // DEQU.STDT[68]=12100
      edLoadPort2Command->Text = "DEQU.STDT[1]=172.20.9.100";
      LoadPort2Cmd = "DEQU.STDT[1]";
      btnLoadPort2SendClick(this);
      WaitDelayTime(1000);
      edLoadPort2Command->Text = "DEQU.STDT[68]=12100";
      LoadPort2Cmd = "DEQU.STDT[68]";
      btnLoadPort2SendClick(this);
      WaitDelayTime(1000);
      // Event
      edLoadPort2Command->Text = "EVNT(0,0)";
      LoadPort2Cmd = "EVNT";
      btnLoadPort2SendClick(this);
      WaitDelayTime(1000);
      // Mode
      edLoadPort2Command->Text = "Mode(1)";
      LoadPort2Cmd = "Mode";
      btnLoadPort2SendClick(this);
      WaitDelayTime(1000);
      // Event
      edLoadPort2Command->Text = "EVNT(1,1)";
      LoadPort2Cmd = "EVNT";
      btnLoadPort2SendClick(this);
      WaitDelayTime(1000);
   }
   // ORGN
   edLoadPort2Command->Text = "ORGN(0)";
   LoadPort2Cmd = "ORGN";
   btnLoadPort2SendClick(this);
   boolLoadPort2Complete = false;
   int ret;

   // 2021 4 25 - chc 由20s調至45s
   //ret = WaitLoadPort2Complete(2,20000);
   // 2021 5 10 - chc 由45s調至60s
   //ret = WaitLoadPort2Complete(2,45000);
   ret = WaitLoadPort2Complete(2,60000);

   if(ret != 0)
      pnlLoadPort2ORGN->Color = clRed;
   else
      pnlLoadPort2ORGN->Color = clLime;
   btnLoadPort2ORGN->Enabled = true;

   // 2021 5 4 - chc Clear Status
   if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {

      // 2023 8 2 - chc LP1/LP2
      //UpdateCassetteState(0);
      UpdateCassetteState(LOADPORT_2,0);
   }

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: CLMP
void __fastcall TMainForm::btnLoadPort2CLMPClick(TObject *Sender)
{

   // 2021 11 22 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(boolInLoadWafer == true || boolInUnloadWafer == true || boolInMeasureRun == true || WaferInSystem() == true) {
      pnlAlarmMessage->Caption = "In Operation, LP2 cannot Load!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      pnlLoadPort2CLMP->Color = clRed;
      Beep(500);
      return;
   }

   // 2021 11 21 - chc Load Image
   imLoad->Visible = true;

   // 2023 8 1 - chc 加入Portno
   //ClearWaferBuffer();
   ClearWaferBuffer(LOADPORT_2);

   boolLP2CassetteMapping = false;

   // 2021 9 15 - chc Log
   WriteSystemLog("LP2 Load...");

   // 2021 6 30 - chc 8"才要做
   if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_8) {

      // 2021 6 30 - chc 先做Lock & Dock
      pnlSystemMessage->Caption = "Locking";
      btnLoadPort2LockClick(this);
      Sleep(1000);
      pnlSystemMessage->Caption = "Docking";
      btnLoadPort2CarrierDockClick(this);
      Sleep(2000);
   }

   // 2023 8 1 - chc 加入Portno
   //ClearWaferBuffer();
   ClearWaferBuffer(LOADPORT_2);

   pnlSystemMessage->Caption = "CLMP...";
   // CLMP
   pnlLoadPort2CLMP->Color = clSilver;
   edLoadPort2Command->Text = "CLMP";
   LoadPort2Cmd = "CLMP";
   btnLoadPort2SendClick(this);
   boolLoadPort2Complete = false;
   int ret;
   ret = WaitLoadPort2Complete(3,20000);
   if(ret != 0) {
      pnlLoadPort2CLMP->Color = clRed;

      // 2021 7 17 - chc 做UnLock
      btnLoadPort2UnlockClick(this);
      Sleep(1000);

      // 2021 7 22 - chc Error
      pnlSystemMessage->Caption = "CLMP Error";

   }
   else {
      pnlLoadPort2CLMP->Color = clLime;

      // 2021 5 4 - chc 設為完成
      boolLoadUnloadStatus = true;

      boolLP2CassetteMapping = false;

      // 2021 9 15 - chc SECS強制為clLime
      if(cbOffLine->Checked == false)
         pnlCassetteLoad->Color = clLime;

      // 2021 5 4 - chc 加做GetMap
      // 2021 5 5 - chc btnLoadPort2GMAPClick無反應!
      //btnLoadPort2GMAPClick(this);
      WaitTime(500);
      edLoadPort2Command->Text = "GMAP";
      LoadPort2Cmd = "GMAP";
      btnLoadPort2SendClick(this);

      // 2021 5 9 - chc 記錄為Load後的第一片
      boolFirstAfterLoad = true;
      pnlLoadPort2UCLM->Color = clSilver;

      // 2021 10 27 - chc 強制為EXECUTING
      if(rgEQStatus->ItemIndex != EQ_STATUS_EXECUTING)
         SendSECSStatus(EQ_STATUS_EXECUTING);

   }

   // 2021 5 4 - chc 加做GPIO
   WaitTime(500);
   btnLoadPort2GPIOClick(this);

   // 2021 6 24 - chc 可變更LoadPort
   rgLoadPortSelect->Enabled = false;

   // 2021 9 15 - chc Log
   WriteSystemLog("LP2 Loaded.");

   // 2021 11 21 - chc Load Image
   imLoad->Visible = false;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: UCLM
void __fastcall TMainForm::btnLoadPort2UCLMClick(TObject *Sender)
{

   // 2021 11 22 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(boolInLoadWafer == true || boolInUnloadWafer == true || boolInMeasureRun == true || WaferInSystem() == true) {
      pnlAlarmMessage->Caption = "In Operation, LP2 cannot UnLoad!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      pnlLoadPort2UCLM->Color = clRed;
      Beep(500);
      return;
   }

   // 2021 11 21 - chc Load Image
   imUnload->Visible = true;

   // 2021 9 15 - chc Log
   WriteSystemLog("LP2 UnLoad...");

   // 2023 8 1 - chc 加入Portno
   //ClearWaferBuffer();
   ClearWaferBuffer(LOADPORT_2);

   // UCLM
   pnlLoadPort2UCLM->Color = clSilver;
   edLoadPort2Command->Text = "UCLM";
   LoadPort2Cmd = "UCLM";
   btnLoadPort2SendClick(this);
   boolLoadPort2Complete = false;
   int ret;
   ret = WaitLoadPort2Complete(4,20000);
   if(ret != 0)
      pnlLoadPort2UCLM->Color = clRed;
   else {
      pnlLoadPort2UCLM->Color = clLime;

      // 2021 5 4 - chc 設為完成
      boolLoadUnloadStatus = true;

      // 2021 5 6 - chc 送LOTEND, UR, UC
      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_2;
      //rgSECSPortNo->ItemIndex = LOADPORT_1;

      // 2021 9 15 - chc SECS強制為clLime
      if(cbOffLine->Checked == false)
         pnlCassetteLoad->Color = clLime;

      // 2023 8 1 - chc LP1/LP2
      //rgPortStatus->ItemIndex = PORT_STATUS_LOTEND;
      rgPortStatus2->ItemIndex = PORT_STATUS_LOTEND;

      WriteSystemLog("boolSendSCESCommand: LP2, LOTEND");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      WaitTime(100);

      // UR
      // 2021 9 8 - chc 變更Port編號
      rgSECSPortNo->ItemIndex = LOADPORT_2;
      //rgSECSPortNo->ItemIndex = LOADPORT_1;

      // 2023 8 1 - chc LP1/LP2
      //rgPortStatus->ItemIndex = PORT_STATUS_UR;
      rgPortStatus2->ItemIndex = PORT_STATUS_UR;

      WriteSystemLog("boolSendSCESCommand: LP2, UR");
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

      // 2021 5 9 - chc 記錄為Load後的第一片
      boolFirstAfterLoad = false;
      pnlLoadPort2CLMP->Color = clSilver;
      boolLP2CassetteMapping = false;

   }

   // 2021 5 4 - chc 加做GPIO
   btnLoadPort2GPIOClick(this);

   // 2021 6 30 - chc 8"才要做
   if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_8) {

      // 2021 6 30 - chc UnLock & UnDock
      btnLoadPort2UnlockClick(this);
      Sleep(1000);

      //btnLoadPort2CarrierUnDockClick(this);
      //Sleep(2000);
   }

   // 2021 6 24 - chc 可變更LoadPort
   rgLoadPortSelect->Enabled = true;

   // 2021 9 15 - chc Log
   WriteSystemLog("LP2 UnLoaded.");

   // 2021 11 21 - chc Load Image
   imUnload->Visible = false;

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: WMAP
void __fastcall TMainForm::btnLoadPort2WMAPClick(TObject *Sender)
{

   // 2021 11 22 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(boolInLoadWafer == true || boolInUnloadWafer == true || boolInMeasureRun == true || WaferInSystem() == true) {
      pnlAlarmMessage->Caption = "作業中, 12吋Port無法Mapping!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      pnlLoadPort2WMAP->Color = clRed;
      Beep(500);
      return;
   }

   // WMAP
   pnlLoadPort2WMAP->Color = clSilver;
   edLoadPort2Command->Text = "WMAP";
   LoadPort2Cmd = "WMAP";
   btnLoadPort2SendClick(this);
   boolLoadPort2Complete = false;
   int ret;
   ret = WaitLoadPort2Complete(5,20000);
   if(ret != 0)
      pnlLoadPort2WMAP->Color = clRed;
   else
      pnlLoadPort2WMAP->Color = clLime;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: INIT
void __fastcall TMainForm::btnLoadPort2INITClick(TObject *Sender)
{

   edLoadPort2Command->Text = "INIT";
   LoadPort2Cmd = "INIT";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: STAT
void __fastcall TMainForm::btnLoadPort2STATClick(TObject *Sender)
{

   edLoadPort2Command->Text = "STAT";
   LoadPort2Cmd = "STAT";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: GMAP
void __fastcall TMainForm::btnLoadPort2GMAPClick(TObject *Sender)
{

   edLoadPort2Command->Text = "GMAP";
   LoadPort2Cmd = "GMAP";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: RSTA
void __fastcall TMainForm::btnLoadPort2RSTAClick(TObject *Sender)
{

   edLoadPort2Command->Text = "RSTA(1)";
   LoadPort2Cmd = "RSTA";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Mode
void __fastcall TMainForm::btnLoadPort2MODEClick(TObject *Sender)
{

   // Remote
   if(rgLoadPort2Mode->ItemIndex == 0)
      edLoadPort2Command->Text = "MODE(1)";
   // Maintenance
   else
      edLoadPort2Command->Text = "MODE(2)";
   LoadPort2Cmd = "MODE";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: LOAD
void __fastcall TMainForm::btnLoadPort2LOADClick(TObject *Sender)
{

   edLoadPort2Command->Text = "LOAD";
   LoadPort2Cmd = "LOAD";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: UNLD
void __fastcall TMainForm::btnLoadPort2UNLDClick(TObject *Sender)
{

   edLoadPort2Command->Text = "UNLD";
   LoadPort2Cmd = "UNLD";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: E84
void __fastcall TMainForm::cbLoadPort2E84Click(TObject *Sender)
{

   btnLoadPort2LOAD->Enabled = cbLoadPort2E84->Checked;
   btnLoadPort2UNLD->Enabled = cbLoadPort2E84->Checked;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: GPIO
void __fastcall TMainForm::btnLoadPort2GPIOClick(TObject *Sender)
{

   edLoadPort2Command->Text = "GPIO";
   LoadPort2Cmd = "GPIO";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Presence
void __fastcall TMainForm::pnlLoadPort2PresenceClick(TObject *Sender)
{

   if(pnlLoadPort2Presence->Color != clSilver) {
      SetLoadPortPresence(2,false);
   }
   else {
      SetLoadPortPresence(2,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Placement
void __fastcall TMainForm::pnlLoadPort2PlacementClick(TObject *Sender)
{

   if(pnlLoadPort2Placement->Color != clSilver) {
      SetLoadPortPlacement(2,false);
   }
   else {
      SetLoadPortPlacement(2,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Load
void __fastcall TMainForm::pnlLoadPort2LoadClick(TObject *Sender)
{

   if(pnlLoadPort2Load->Color != clSilver) {
      SetLoadPortLoad(2,false);
   }
   else {
      SetLoadPortLoad(2,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: UnLoad
void __fastcall TMainForm::pnlLoadPort2UnloadClick(TObject *Sender)
{

   if(pnlLoadPort2Unload->Color != clSilver) {
      SetLoadPortUnload(2,false);
   }
   else {
      SetLoadPortUnload(2,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Manual
void __fastcall TMainForm::pnlLoadPort2ManualClick(TObject *Sender)
{

   if(pnlLoadPort2Manual->Color != clSilver) {
      SetLoadPortManual(2,false);
   }
   else {
      SetLoadPortManual(2,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Alarm
void __fastcall TMainForm::pnlLoadPort2AlarmClick(TObject *Sender)
{

   if(pnlLoadPort2Alarm->Color != clSilver) {
      SetLoadPortAlarm(2,false);
   }
   else {
      SetLoadPortAlarm(2,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Clamp
void __fastcall TMainForm::pnlLoadPort2ClampClick(TObject *Sender)
{

   if(pnlLoadPort2Clamp->Color != clSilver) {
      SetLoadPortClamp(2,false);
   }
   else {
      SetLoadPortClamp(2,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Dock
void __fastcall TMainForm::pnlLoadPort2DockClick(TObject *Sender)
{

   if(pnlLoadPort2Dock->Color != clSilver) {
      SetLoadPortDock(2,false);
   }
   else {
      SetLoadPortDock(2,true);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Message
void __fastcall TMainForm::mnSaveLoadProt2ToFileClick(TObject *Sender)
{

   if(mmLoadPort2->Lines->Count == 0) {
      Application->MessageBox("目前尚無記錄事項!","量測系統: LoadPort2記錄檔寫入作業    ",MB_ICONINFORMATION|MB_OK);
      return;
   }
   if(sdAIMessages->Execute()) {
      mmLoadPort2->Lines->SaveToFile(sdAIMessages->FileName.c_str());
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2: Message
void __fastcall TMainForm::mnClearLoadPort2MessageClick(TObject *Sender)
{

   mmLoadPort2->Clear();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2 Message
void TMainForm::AddLoadPort2Message(AnsiString msg)
{
AnsiString putmsg;
static AnsiString oldmsg = "";

   //if(oldmsg == msg)                            // 重複不收錄
   //   return;
   oldmsg = msg;
   putmsg = Now().FormatString("nn':'ss':'zzz'-> '") + msg;
   // 以Memo取代, 最多共470 Rows
   mmLoadPort2->Lines->Insert(0,putmsg);
   mmLoadPort2->Refresh();

   if(mmLoadPort2->Lines->Count > 500) {
      for(int i=470 ; i<mmLoadPort2->Lines->Count ; i++)
         mmLoadPort2->Lines->Delete(i);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2 Socek
void __fastcall TMainForm::csLoadPort2SocketConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlLoadPort2->Enabled = true;
   pnlLoadPort2SocketConnect->Color = clLime;

   // 2021 8 4 - chc 加入Error Code
   pnlLoadPort2SocketConnect->Caption = "";

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2 Socek
void __fastcall TMainForm::csLoadPort2SocketDisconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlLoadPort2->Enabled = false;
   pnlLoadPort2SocketConnect->Color = clSilver;

   // 2021 8 4 - chc 加入Error Code
   pnlLoadPort2SocketConnect->Caption = "";

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// LoadPort2 Socek
void __fastcall TMainForm::csLoadPort2SocketError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   pnlLoadPort2SocketConnect->Color = clRed;

   // 2021 8 4 - chc 加入Error Code
   pnlLoadPort2SocketConnect->Caption = IntToStr(ErrorCode);

   ErrorCode = 0;
}
//---------------------------------------------------------------------------
// 2021 8 3 - chc LP2 - Parameter: Min/Max Thickness
int LP2DPRMStep = 0;

// 2021 4 11 - chc Rorze
// LoadPort2 Socek
void __fastcall TMainForm::csLoadPort2SocketRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
static char receivestr[256];
static int receivecnt = 0;
static bool inactive = false;
AnsiString text,cmdstr,slen,scmd,spar[30],retcmd,stype,smapdata;
bool flag,done;
int pos,parcnt,len;
char buf[256];
char waferstatus[50];
int waferno;

// 2021 9 16 - chc Alarm
static bool boolorgnerror = false;
static bool boolmotorstall = false;
static bool boolseneorerror = false;
static bool boolcommunicationerror = false;
static bool booldrivererror = false;
static bool boolmappingsensorerror = false;
static bool boolexhaustfanerror = false;
static bool boolcontrolpowererror = false;
static bool booloverheaterror = false;
static bool boolmotorcableerror = false;
static bool boolcarriercarryinerror = false;
static bool boolcarriercarryouterror = false;
static bool boolbusytimeouterror = false;
int errorstate = -1;
int pos1;
AnsiString errorcode,errorname;
// 要Defeuat為"00"
static AnsiString errorcodeold = "00";

   if(inactive == true) {
      AddLoadPort2Message("Re-Entrant!");
      return;
   }
   inactive = true;

   parcnt = 0;
   text = Socket->ReceiveText();
   sprintf(buf,"%s",text.c_str());
   len = text.Length();
   for(int i=0 ; i<len ; i++) {
      if(buf[i] == 0x0d)
         buf[i] = '@';
      else if(buf[i] < 0x20)
         continue;
      receivestr[receivecnt++] = buf[i];
   }
   receivestr[receivecnt] = 0x0;
   text.sprintf("%s",receivestr);
   while(1) {
      // aSTG1.INIT@
      // 12345678901234567890
      pos = text.Pos("@");
      if(pos != 0) {
         cmdstr = text.SubString(1,pos-1);

         // 2023 8 2 - chc 加入"<"
         //AddLoadPort2Message(cmdstr);
         AddLoadPort2Message("<" + cmdstr);

         text.Delete(1,pos);
         receivecnt -= pos;

         // aSTG1.INIT@
         // 12345678901234567890
         retcmd = cmdstr.SubString(7,4);
         if((LoadPort2Cmd == retcmd && cmdstr.SubString(1,1) != "c") || retcmd == "CNCT") {
            pnlLoadPort2CancelCode->Caption = "";
            pnlLoadPort2CancelCode->Color = clSilver;
            pnlLoadPort2Send->Color = clLime;
            if(retcmd == "CNCT") {
               boolLoadPort2Init = true;
               pnlLoadPort2Ready->Color = clLime;
               pnlLoadPort2Ready1->Color = clLime;
            }
            // aALN1.GMAP:nnnn...
            // 1234567890123456
            // pnlTray25
            else if(retcmd == "GMAP") {
               boolLP2CassetteMapping = true;
               int pos,len;
               TPanel *panel,*panel1,*panel2,*panel3;
               len = cmdstr.Length();
               waferno = len - 11;
               // 清顏色
               for(int i=0 ; i<25 ; i++) {
                  panel = (TPanel*)(FindComponent("pnlLoadPort2Tray" + IntToStr(i+1)));
                  panel->Color = clSilver;
                  panel2 = (TPanel*)(FindComponent("pnlLoadPort2Tray" + IntToStr(i+1) + "Select"));
                  panel2->Color = clSilver;
                  panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1)));
                  panel1->Color = clSilver;
                  panel3 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1) + "Select"));
                  panel3->Color = clSilver;
               }
               sprintf(waferstatus,"%s",cmdstr.SubString(12,len-11).c_str());
               smapdata.sprintf("%s",waferstatus);
               WriteSystemLog("LP2(Mapdata): " + smapdata);
               for(int i=0 ; i<waferno ; i++) {

                  // 2023 8 2 - chc LP1/LP2
                  //CassetteBuffer[i] = waferstatus[i];
                  CassetteBuffer[LOADPORT_2][i] = waferstatus[i];

                  WaferBuffer[i].Status = waferstatus[i] - '0';
                  panel = (TPanel*)(FindComponent("pnlLoadPort2Tray" + IntToStr(i+1)));
                  panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1)));
                  panel2 = (TPanel*)(FindComponent("pnlLoadPort2Tray" + IntToStr(i+1) + "Select"));
                  panel3 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1) + "Select"));
                  // 0 - Wafer not exist                                        clSilver
                  // 1 - Wafer exists                                           clLime
                  // 2 - Thickness abnormal(thick wafer)                        clBlue
                  // 3 - Cross                                                  clMaroon
                  // 4 - Front bow                                              clRed
                  // 5 - two or more wafers exist in the same slot              clPurple
                  // 6 - Thickness abnormal(thin wafer)                         clOlive
                  switch(waferstatus[i]) {
                     case '0':
                        panel->Color = clSilver;
                        stype = "無Wafer";
                        break;
                     case '1':
                        panel->Color = clLime;
                        stype = "有Wafer";
                        break;
                     case '2':
                        panel->Color = clBlue;
                        stype = "Wafer過厚";
                        break;
                     case '3':
                        panel->Color = clMaroon;
                        stype = "Wafer交叉";
                        break;
                     case '4':
                        panel->Color = clRed;
                        stype = "Wafer突出";
                        break;
                     case '5':
                        panel->Color = clPurple;
                        stype = "Wafer疊片";
                        break;
                     case '6':
                        panel->Color = clOlive;
                        stype = "Wafer過薄";
                        break;
                  }
                  panel1->Color = panel->Color;
                  panel2->Color = panel->Color;
                  panel3->Color = panel->Color;

                  // 2021 7 26 - chc Hint of Wafer
                  panel1->Hint = stype + "(狀態: 無-灰色, 有-綠色, 過厚-藍色, 交叉-暗紅色, 突出-紅色, 疊片-紫色, 過薄-橄欖色)";
                  panel3->Hint = stype + "(狀態: 無-灰色, 有-綠色, 過厚-藍色, 交叉-暗紅色, 突出-紅色, 疊片-紫色, 過薄-橄欖色)";

               }

               // 2021 5 4 - chc 更新Mapping & LoadPort
               waferstatus[26] = 0x0;

               // 2023 8 2 - chc LP1/LP2
               //CassetteBuffer[26] = 0x0;
               //sprintf(WorkingBuffer,"%s",CassetteBuffer);
               CassetteBuffer[LOADPORT_2][26] = 0x0;
               sprintf(WorkingBuffer,"%s",CassetteBuffer[LOADPORT_2]);

               // 2021 9 8 - chc 變更Port編號
               rgSECSPortNo->ItemIndex = LOADPORT_2;
               //rgSECSPortNo->ItemIndex = LOADPORT_1;

               // 2023 7 31 - chc LP1/LP2
               //edMapData->Text = waferstatus;
               edMapData2->Text = waferstatus;

               // 2023 8 1 - chc LP1/LP2
               //rgPortStatus->ItemIndex = PORT_STATUS_MAP;
               rgPortStatus2->ItemIndex = PORT_STATUS_MAP;

               WriteSystemLog("boolSendSCESCommand: 16, " + edMapData2->Text);
               rgSecsCommandSet->ItemIndex = -1;
               boolSendSCESCommand = true;
               rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

               // 2023 8 2 - chc LP1/LP2
               UpdateCassetteState(LOADPORT_2,1);

            }
            // aSTG1.GPIO:000100204C011570/0000000008000081 => 44
            // 12345678901234567890123456789012345678901234567890
            //            1234567890123456 1234567890123456
            // Bit63 - Bit0, 每個digit 4個bits
            // ClampLED(48): 0001000008000081
            //               0(63-60)0(59-56)0(55-52)1(51-48)0(47-44)0(43-40)0(39-36)0(35-32)0(31-28)8(27-24)0(23-20)0(19-16)0(15-12)0(11-8)8(7-4)1(3-0)
            // DockLED(49):  0003000008000081
            // Presence: 44
            // Placement: 45
            // Load: 42
            // UnLoad: 43
            // Manual: 46
            // Alarm: 47
            // Clamp: 48
            // Dock: 49
            // CLMP之後: GPIO:000100205FFEDA30/000000001F000081
            //         00       0 0 0 0 0 0 0 0         63 - 56
            //         01       0 0 0 0 0 0 0 1         55 - 48                 48: 300mm DSC
            //         00       0 0 0 0 0 0 0 0         47 - 40
            //         20       0 0 1 0 0 0 0 0         39 - 32                 37: Cover UnLock
            //         5F       0 1 0 1 1 1 1 1         31 - 24                 30: Open carrier detecting sensor
            //                                                                 *28: door detection
            //                                                                  27: Obstacle defecting sensor
            //                                                                  26: FOSB identification senosr
            //                                                                  25: Presence
            //                                                                  24: Info Pad D
            //         FE       1 1 1 1 1 1 1 0         23 - 16                 23: Info Pad C
            //                                                                  22: Info Pad B
            //                                                                  21: Info Pad A
            //                                                                  20: Presence Middle
            //                                                                  19: Presence right
            //                                                                  18: Presence Left
            //                                                                 *17: Carier clamp close
            //                                                                 *16: Carier clamp open
            //         DA       1 1 0 1 1 0 1 0         15 - 8                 *15: Lower pressure limit
            //                                                                 *14: Upper pressure limit
            //                                                                  13: Mapping sensor preparation
            //                                                                  12: Mapping sensor containing
            //                                                                 *11: FOUP door right open
            //                                                                 *10: FOUP door right close
            //                                                                 *09: FOUP door left open
            //                                                                 *08: FOUP door left close
            //         30       0 0 1 1 0 0 0 0         7  - 0                  07: Protrusion 2
            //                                                                 *06: Protrusion
            //                                                                  05: Exhaust FAN2
            //                                                                  04: Exhaust FAN1
            //                                                                  03: Not connect
            //                                                                  02: Not connect
            //                                                                  01: Temporarity stop
            //                                                                  00: Emergency stop
            // CLMP之後: GPIO:000100205FFEDA30/000000001F000081
            //            door detection On
            //            Carier clamp close
            //            Pressure Limit on
            //            FOUP door open
            //            protrusion Off
            // UCLM之後: GPIO:000100204FFD1570/000000001C000081
            //            door detection Off
            //            Carier clamp open
            //            Pressure Limit off
            //            FOUP door close
            //            protrusion On
            //
            else if(retcmd == "GPIO") {
               //WriteSystemLog("LP2 - GPIO = " + cmdstr);
               char dibuf[20],dobuf[20];
               int pos,len,hexdigitalno;
               bool boolpresenceled,boolplacementled,boolloadled,boolunloadled;
               bool boolmanualled,boolalarmled,boolclampled,booldockled;
               bool boolpresence;
               TPanel *panel;
               len = cmdstr.Length();
               if(len == 44) {
                  sprintf(dibuf,"%s",cmdstr.SubString(12,16).c_str());
                  sprintf(dobuf,"%s",cmdstr.SubString(29,16).c_str());
                  for(int i=0 ; i<16 ; i++) {
                     if(dibuf[i] >= '0' && dibuf[i] <= '9')
                        dibuf[i] -= '0';
                     else {
                        dibuf[i] -= 'A';
                        dibuf[i] += 10;
                     }
                     if(dobuf[i] >= '0' && dobuf[i] <= '9')
                        dobuf[i] -= '0';
                     else {
                        dobuf[i] -= 'A';
                        dobuf[i] += 10;
                     }
                  }
                  // 0(63-60)0(59-56)0(55-52)1(51-48)0(47-44)0(43-40)0(39-36)0(35-32)0(31-28)8(27-24)0(23-20)0(19-16)0(15-12)0(11-8)8(7-4)1(3-0)
                  // aSTG1.GPIO:007F00204E161570/000000001E0000E1
                  // 由in決定狀態
                  LogInStatus(2,dibuf);
                  // 42 ~ 49
                  // 看DI
                  //boolclampled = dobuf[15-LOADPORT_CLAMP_BIT/4] & 0x01;                         // 48
                  //booldockled = dobuf[15-LOADPORT_DOCK_BIT/4] & 0x02;                           // 49
                  //boolpresenceled = dobuf[15-LOADPORT_PRESENCE_BIT/4] & 0x01;                   // 44
                  //boolplacementled = dobuf[15-LOADPORT_PLACEMENT_BIT/4] & 0x02;                 // 45
                  //boolloadled = dobuf[15-LOADPORT_LOAD_BIT/4] & 0x04;                           // 42
                  //boolunloadled = dobuf[15-LOADPORT_UNLOAD_BIT/4] & 0x08;                       // 43
                  //boolmanualled = dobuf[15-LOADPORT_MANUAL_BIT/4] & 0x04;                       // 46
                  //boolalarmled = dobuf[15-LOADPORT_ALARM_BIT/4] & 0x08;                         // 47
                  // Presence
                  //------------------------------------------------------------
                  bool boolpresenceleft,boolpresenceright,boolpresencemiddle,boolpresence;
                  //boolpresenceleft = dibuf[15-LOADPORT_PRESENCE_LEFT_BIT/4] & 0x04;             // 18
                  //boolpresenceright = dibuf[15-LOADPORT_PRESENCE_RIGHT_BIT/4] & 0x08;           // 19
                  //boolpresencemiddle = dibuf[15-LOADPORT_PRESENCE_MIDDLE_BIT/4] & 0x01;         // 20
                  boolpresenceleft = GetBitValue(dibuf, 18);
                  boolpresenceright = GetBitValue(dibuf, 19);
                  boolpresencemiddle = GetBitValue(dibuf, 20);
                  boolpresence = GetBitValue(dibuf, 25);

                  // 300mmDSC, 200mmDSC, 150mmDSC
                  bool bool300mmDSC,bool200mmDSC,bool150mmDSC;
                  bool300mmDSC = GetBitValue(dibuf, 48);
                  bool200mmDSC = GetBitValue(dibuf, 49);
                  bool150mmDSC = GetBitValue(dibuf, 50);
                  // 200mm,150mm,adapter,cover
                  bool boolcst,bool200mm,bool150mm,booladapter,boolcover;
                  boolcst = GetBitValue(dibuf, 51);
                  bool200mm = GetBitValue(dibuf, 52);
                  bool150mm = GetBitValue(dibuf, 53);
                  booladapter = GetBitValue(dibuf, 54);
                  boolcover = GetBitValue(dibuf, 55);
                  // Display
                  // Left
                  if(boolpresenceleft == true)
                     pnlLP2Left->Color = clLime;
                  else
                     pnlLP2Left->Color = clSilver;
                  // Right
                  if(boolpresenceright == true)
                     pnlLP2Right->Color = clLime;
                  else
                     pnlLP2Right->Color = clSilver;
                  // Middle
                  if(boolpresencemiddle == true)
                     pnlLP2Middle->Color = clLime;
                  else
                     pnlLP2Middle->Color = clSilver;
                  // Presence
                  if(boolpresence == true)
                     pnlLP2Presence->Color = clLime;
                  else
                     pnlLP2Presence->Color = clSilver;
                  // 300mmDSC
                  if(bool300mmDSC == true)
                     pnlLP2300DSC->Color = clLime;
                  else
                     pnlLP2300DSC->Color = clSilver;
                  // 200mmDSC
                  if(bool200mmDSC == true)
                     pnlLP2200DSC->Color = clLime;
                  else
                     pnlLP2200DSC->Color = clSilver;
                  // 150mmDSC
                  if(bool150mmDSC == true)
                     pnlLP2150DSC->Color = clLime;
                  else
                     pnlLP2150DSC->Color = clSilver;
                  // CST
                  if(boolcst == true)
                     pnlLP2CST->Color = clLime;
                  else
                     pnlLP2CST->Color = clSilver;
                  // 200mm
                  if(bool200mm == true)
                     pnlLP2200mm->Color = clLime;
                  else
                     pnlLP2200mm->Color = clSilver;
                  // 150mm
                  if(bool150mm == true)
                     pnlLP2150mm->Color = clLime;
                  else
                     pnlLP2150mm->Color = clSilver;
                  // Adapter
                  if(booladapter == true)
                     pnlLP2Adapter->Color = clLime;
                  else
                     pnlLP2Adapter->Color = clSilver;
                  // Cover
                  if(boolcover == true)
                     pnlLP2Cover->Color = clLime;
                  else
                     pnlLP2Cover->Color = clSilver;

                  // 2023 7 27 - chc 加入Presence: 25
                  // 由25決定Presence
                  if(boolpresence == true)
                     boolpresenceled = true;
                  else
                     boolpresenceled = false;

                  // 2023 7 27 - chc 決定Wafer Size & placement
                  // 12"
                  if(boolpresenceleft == true && boolpresenceright == true && boolpresencemiddle == true) {
                     rgLoadPort2WaferSize->ItemIndex = WAFER_SIZE_12;
                     boolplacementled = true;
                     pnlLP2Size->Caption = "12\"";
                     cbLP2E84->Enabled = true;
                  }
                  // 8"
                  else if(boolpresenceleft == true && boolpresenceright == false && boolpresencemiddle == true &&
                          bool300mmDSC == true && bool200mmDSC == true && bool150mmDSC == true && boolcst == true &&
                          bool200mm == true && bool150mm == true && booladapter == true && boolcover == true) {
                     rgLoadPort2WaferSize->ItemIndex = WAFER_SIZE_8;
                     boolplacementled = true;
                     pnlLP2Size->Caption = "8\"";
                     cbLP2E84->Checked = false;
                     cbLP2E84->Enabled = false;
                  }
                  else {
                     rgLoadPort2WaferSize->ItemIndex = WAFER_SIZE_NONE;
                     boolplacementled = false;
                     pnlLP2Size->Caption = "--";
                     cbLP2E84->Checked = false;
                     cbLP2E84->Enabled = false;
                  }

                  // Load
                  bool boolFOUPLeftDoor,boolFOUPRightDoor,boolCarrierClamp;
                  // FOUP Left Door: 9
                  // FOUP Right Door: 11
                  // Carrier Clamp: 17
                  //boolFOUPLeftDoor = dibuf[15-9/4] & 0x02;                      // 9
                  //boolFOUPRightDoor = dibuf[15-11/4] & 0x08;                    // 11
                  //boolCarrierClamp = dibuf[15-17/4] & 0x02;                     // 17
                  boolFOUPLeftDoor = GetBitValue(dibuf, 9);
                  boolFOUPRightDoor = GetBitValue(dibuf, 11);
                  boolCarrierClamp = GetBitValue(dibuf, 17);

                  // 2021 6 30 - chc 8"/12"不同
                  //=> 8"看Bit6: off=>Loaded, On=>UnLoaded
                  bool boolprotrusion;
                  if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_8) {
                     boolprotrusion = GetBitValue(dibuf, 6);
                     // Loaded
                     if(boolprotrusion == false) {
                        boolloadled = true;
                        boolunloadled = false;
                     }
                     else {
                        boolloadled = false;
                        boolunloadled = true;
                     }
                  }
                  // 12"
                  else {
                     // LOAD
                     if(boolFOUPLeftDoor == true && boolFOUPRightDoor == true && boolCarrierClamp == true) {
                        boolloadled = true;
                        boolunloadled = false;
                     }
                     else {
                        boolloadled = false;
                        boolunloadled = true;
                     }
                  }
                  // Clamp
                  if(boolCarrierClamp == true)
                     boolclampled = true;
                  else
                     boolclampled = false;

                  // 再確認Placement/Presence
                  if(boolpresenceled == false || boolplacementled == false) {
                     rgLoadPort2WaferSize->ItemIndex = WAFER_SIZE_NONE;
                     pnlLP2Size->Caption = "--";
                     cbLP2E84->Checked = false;
                     cbLP2E84->Enabled = false;
                  }

                  // 2023 7 25 - chc 區分12"/8"
                  // 12"
                  if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_12) {
                     if(pnlLoadPort2Title->Caption != "LP2(12\")") {
                        pnlLoadPort2Title->Caption = "LP2(12\")";
                        rgLoadPortSelect->Items->Strings[1] = "LP2(12\")";
                     }
                  }
                  // 8"
                  else if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_8) {
                     if(pnlLoadPort2Title->Caption != "LP2(8\")") {
                        pnlLoadPort2Title->Caption = "LP2(8\")";
                        rgLoadPortSelect->Items->Strings[1] = "LP2(8\")";
                     }
                  }
                  // None
                  else {
                     if(pnlLoadPort2Title->Caption != "LP2(--)") {
                        pnlLoadPort2Title->Caption = "LP2(--)";
                        rgLoadPortSelect->Items->Strings[1] = "LP2(--)";
                     }
                  }

                  bool boolcassette = false;

                  // 2023 7 27 - chc 不看boolcassette
                  //// Cassette(8")
                  //if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_8) {
                  //   if(bool200mm == true && bool150mm == true && booladapter == true)
                  //      boolcassette = true;
                  //}
                  boolcassette = true;

                  // 2021 5 6 - chc 設定Load button staus
                  //if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {

                     // 2021 7 17 - chc 要有CST才可Enable
                     //if(boolpresenceled == true && boolplacementled == true)
                     if(boolpresenceled == true && boolplacementled == true && boolcassette == true) {

                        // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
                        // 2023 2 21 - chc 不檢查WaferInSystem()
                        //if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false && WaferInSystem() == false) {
                        if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false) {

                           btnCassette2Load->Enabled = true;

                           // 2021 11 12 - ch cog
                           WriteSystemLog("=> set btnCassette2Load true-1");
                        }

                     }
                     else {
                        btnCassette2Load->Enabled = false;

                        // 2021 11 12 - ch cog
                        WriteSystemLog("=> set btnCassette2Load false-1");

                     }

                     if(boolpresenceled == true && boolplacementled == true && boolcassette == true) {
                        if(boolloadled == false && boolunloadled == true) {
                           btnCassette2Load->Caption = "Load";
                           btnLoadWafer->Enabled = false;
                           pnlLoadWafer->Color = clSilver;
                           MainForm->GreenLamp(false);
                           MainForm->YellowLamp(true);
                           btnCassette2Load->Enabled = true;
                           WriteSystemLog("=> set btnCassette2Load true-2");
                        }
                        else if(boolloadled == true && boolunloadled == false) {
                           btnCassette2Load->Caption = "UnLoad";
                           btnLoadWafer->Enabled = true;
                           MainForm->GreenLamp(true);
                           MainForm->YellowLamp(false);
                           btnCassette2Load->Enabled = true;
                           WriteSystemLog("=> set btnCassette2Load true-3");
                        }
                        else {
                           btnCassette2Load->Enabled = false;
                           WriteSystemLog("=> set btnCassette2Load false-2");
                        }
                     }

                  //}

// 2023 7 27 - chc 再檢查
//if(boolpresenceled == false || boolplacementled == false) {
//   if(btnCassette2Load->Enabled == true) {
//      btnCassette2Load->Enabled = false;
//      WriteSystemLog("=> set btnCassette2Load false-3");
//   }
//}

                  // Clamp
                  if(boolclampled == true) {
                     SetLoadPortClamp(2,true);
                     //WriteSystemLog("LP1 - GPIO = CLMP");
                  }
                  else {
                     SetLoadPortClamp(2,false);
                  }
                  // Dock
                  //if(booldockled == true) {
                  //   SetLoadPortDock(2,true)
                  //   WriteSystemLog("LP2 - GPIO = DOCK");
                  //}
                  //else {
                  //   SetLoadPortDock(2,false)
                  //}
                  // Presence
                  if(boolpresenceled == true) {

                     // 2021 5 4 - chc Cassette是否為置入

                     SetLoadPortPresence(2,true);
                     WriteSystemLog("LP2 - GPIO = Presence");
                  }
                  else {
                     SetLoadPortPresence(2,false);
                  }
                  // Placement
                  if(boolplacementled == true) {
                     SetLoadPortPlacement(2,true);
                     WriteSystemLog("LP2 - GPIO = Placement");
                  }
                  else {
                     SetLoadPortPlacement(2,false);
                  }
                  // Load
                  if(boolloadled == true) {
                     SetLoadPortLoad(2,true);
                     //WriteSystemLog("LP2 - GPIO = Load");
                  }
                  else {
                     SetLoadPortLoad(2,false);
                  }
                  // UnLoad
                  if(boolunloadled == true) {
                     SetLoadPortUnload(2,true);
                     //WriteSystemLog("LP2 - GPIO = UnLoad");
                  }
                  else {
                     SetLoadPortUnload(2,false);
                  }
                  // Manual
                  //if(boolmanualled == true) {
                  //   SetLoadPortManual(1,true);
                  //   WriteSystemLog("LP1 - GPIO = Manual");
                  //}
                  //else {
                  //   SetLoadPortManual(1,false);
                  //}
                  // Alarm
                  //if(boolalarmled == true) {
                  //   SetLoadPortAlarm(1,true);
                  //   WriteSystemLog("LP1 - GPIO = Alarm");
                  //}
                  //else {
                  //   SetLoadPortAlarm(1,false);
                  //}
                  //------------------------------------------------------------

/*
                  bool boolpresenceleft,boolpresenceright,boolpresencemiddle,boolpresence;
                  //boolpresenceleft = dibuf[15-LOADPORT_PRESENCE_LEFT_BIT/4] & 0x04;             // 18
                  //boolpresenceright = dibuf[15-LOADPORT_PRESENCE_RIGHT_BIT/4] & 0x08;           // 19
                  //boolpresencemiddle = dibuf[15-LOADPORT_PRESENCE_MIDDLE_BIT/4] & 0x01;         // 20
                  boolpresenceleft = GetBitValue(dibuf, 18);
                  boolpresenceright = GetBitValue(dibuf, 19);
                  boolpresencemiddle = GetBitValue(dibuf, 20);
                  boolpresence = GetBitValue(dibuf, 25);

                  // 12"
                  if(boolpresenceleft == true && boolpresenceright == true && boolpresencemiddle == true)
                     rgLoadPort2WaferSize->ItemIndex = 0;
                  // 8"
                  else if(boolpresenceleft == true && boolpresenceright == false && boolpresencemiddle == true)
                     rgLoadPort2WaferSize->ItemIndex = 1;
                  else
                     rgLoadPort2WaferSize->ItemIndex = -1;
                  // Presence
                  if(boolpresence == true)
                     boolpresenceled = true;
                  else
                     boolpresenceled = false;
                  // Placement
                  if(boolpresenceleft == true || boolpresenceright == true || boolpresencemiddle == true)
                     boolplacementled = true;
                  else
                     boolplacementled = false;
                  // Load
                  bool boolFOUPLeftDoor,boolFOUPRightDoor,boolCarrierClamp;
                  // FOUP Left Door: 9
                  // FOUP Right Door: 11
                  // Carrier Clamp: 17
                  //boolFOUPLeftDoor = dibuf[15-9/4] & 0x02;                      // 9
                  //boolFOUPRightDoor = dibuf[15-11/4] & 0x08;                    // 11
                  //boolCarrierClamp = dibuf[15-17/4] & 0x02;                     // 17
                  boolFOUPLeftDoor = GetBitValue(dibuf, 9);
                  boolFOUPRightDoor = GetBitValue(dibuf, 11);
                  boolCarrierClamp = GetBitValue(dibuf, 17);

                  // 2021 6 30 - chc 8"/12"不同
                  //=> 8"看Bit6: off=>Loaded, On=>UnLoaded
                  bool boolprotrusion;
                  if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_8) {
                     boolprotrusion = GetBitValue(dibuf, 6);
                     // Loaded
                     if(boolprotrusion == false) {
                        boolloadled = true;
                        boolunloadled = false;
                     }
                     else {
                        boolloadled = false;
                        boolunloadled = true;
                     }
                  }
                  // 12"
                  else {

                     // LOAD
                     if(boolFOUPLeftDoor == true && boolFOUPRightDoor == true && boolCarrierClamp == true) {
                        boolloadled = true;
                        boolunloadled = false;
                     }
                     else {
                        boolloadled = false;
                        boolunloadled = true;
                     }
                  }
                  // Clamp
                  if(boolCarrierClamp == true)
                     boolclampled = true;
                  else
                     boolclampled = false;
                  // 300mmDSC, 200mmDSC, 150mmDSC
                  bool bool300mmDSC,bool200mmDSC,bool150mmDSC;
                  //bool300mmDSC = dibuf[15-48/4] & 0x01;                         // 48
                  //bool200mmDSC = dibuf[15-49/4] & 0x02;                         // 49
                  //bool150mmDSC = dibuf[15-50/4] & 0x04;                         // 50
                  bool300mmDSC = GetBitValue(dibuf, 48);
                  bool200mmDSC = GetBitValue(dibuf, 49);
                  bool150mmDSC = GetBitValue(dibuf, 50);

                  // 2023 7 25 - chc Wafer Size
                  if(bool300mmDSC == true)
                     pnlLP2300->Color = clLime;
                  else
                     pnlLP2300->Color = clSilver;
                  if(bool200mmDSC == true)
                     pnlLP2200->Color = clLime;
                  else
                     pnlLP2200->Color = clSilver;
                  if(bool150mmDSC == true)
                     pnlLP2150->Color = clLime;
                  else
                     pnlLP2150->Color = clSilver;

                  // 12"
                  // 2023 7 25 - chc 無CST與12"一樣
                  //if(bool300mmDSC == true && bool200mmDSC == false && bool150mmDSC == false) {
                  if(boolpresenceled == false && boolplacementled == false) {
                     rgLoadPort2WaferSize->ItemIndex = -1;
                     pnlLP2Size->Caption = "--";
                     cbLP2E84->Checked = false;
                     cbLP2E84->Enabled = false;
                  }
                  else if(bool300mmDSC == true && bool200mmDSC == false && bool150mmDSC == false) {

                     rgLoadPort2WaferSize->ItemIndex = 0;
                     pnlLP2Size->Caption = "12\"";
                     cbLP2E84->Enabled = true;
                  }
                  // 8"
                  else if(bool300mmDSC == true && bool200mmDSC == true && bool150mmDSC == true) {
                     rgLoadPort2WaferSize->ItemIndex = 1;
                     pnlLP2Size->Caption = "8\"";
                     cbLP2E84->Checked = false;
                     cbLP2E84->Enabled = false;
                  }
                  else {
                     rgLoadPort2WaferSize->ItemIndex = -1;
                     pnlLP2Size->Caption = "--";
                     cbLP2E84->Checked = false;
                     cbLP2E84->Enabled = false;
                  }

                  // 2023 7 25 - chc 區分12"/8"
                  // 12"
                  if(rgLoadPort2WaferSize->ItemIndex == 0) {
                     if(pnlLoadPort2Title->Caption != "LP2(12\")") {
                        pnlLoadPort2Title->Caption = "LP2(12\")";
                        rgLoadPortSelect->Items->Strings[1] = "LP2(12\")";
                     }
                  }
                  // 8"
                  else if(rgLoadPort2WaferSize->ItemIndex == 1) {
                     if(pnlLoadPort2Title->Caption != "LP2(8\")") {
                        pnlLoadPort2Title->Caption = "LP2(8\")";
                        rgLoadPortSelect->Items->Strings[1] = "LP2(8\")";
                     }
                  }
                  // None
                  else {
                     if(pnlLoadPort2Title->Caption != "LP2(--)") {
                        pnlLoadPort2Title->Caption = "LP2(--)";
                        rgLoadPortSelect->Items->Strings[1] = "LP2(--)";
                     }
                  }

                  bool boolcassette = false;
                  bool bool200mm,bool150mm,booladapter;
                  //bool200mm = dibuf[15-52/4] & 0x01;                            // 52
                  //bool150mm = dibuf[15-53/4] & 0x02;                            // 53
                  //booladapter = dibuf[15-54/4] & 0x04;                          // 54
                  bool200mm = GetBitValue(dibuf, 52);
                  bool150mm = GetBitValue(dibuf, 53);
                  booladapter = GetBitValue(dibuf, 54);

                  // 2023 7 25 - chc Wafer Size
                  if(bool200mm == true)
                     pnlLP252->Color = clLime;
                  else
                     pnlLP252->Color = clSilver;
                  if(bool150mm == true)
                     pnlLP253->Color = clLime;
                  else
                     pnlLP253->Color = clSilver;
                  if(booladapter == true)
                     pnlLP254->Color = clLime;
                  else
                     pnlLP254->Color = clSilver;

                  // Cassette(8")
                  if(rgLoadPort2WaferSize->ItemIndex == 1) {
                     if(bool200mm == true && bool150mm == true && booladapter == true)
                        boolcassette = true;
                  }

                  // 2021 5 6 - chc 設定Load button staus
                  if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
                     if(boolpresenceled == true && boolplacementled == true) {

                        // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
                        // 2023 2 21 - chc 不檢查WaferInSystem()
                        //if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false && WaferInSystem() == false) {
                        if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false) {

                           btnCassetteLoad->Enabled = true;

                           // 2021 11 12 - ch cog
                           WriteSystemLog("LP2 Socket GPIO - 啟動Load Button");
                        }

                     }
                     else {
                        btnCassetteLoad->Enabled = false;
                     }
                     if(boolloadled == false && boolunloadled == true) {
                        btnCassetteLoad->Caption = "Load";
                        btnLoadWafer->Enabled = false;
                        pnlLoadWafer->Color = clSilver;
                        MainForm->GreenLamp(false);
                        MainForm->YellowLamp(true);
                     }
                     else if(boolloadled == true && boolunloadled == false) {
                        btnCassetteLoad->Caption = "UnLoad";
                        btnLoadWafer->Enabled = true;
                        MainForm->GreenLamp(true);
                        MainForm->YellowLamp(false);
                     }
                     else
                        btnCassetteLoad->Enabled = false;
                  }

                  //===
                  // Clamp
                  if(boolclampled == true) {
                     SetLoadPortClamp(2,true);
                     //WriteSystemLog("LP2 - GPIO = CLMP");
                  }
                  else {
                     SetLoadPortClamp(2,false);
                  }
                  // Dock
                  //if(booldockled == true) {
                  //   SetLoadPortDock(2,true);
                  //   WriteSystemLog("LP2 - GPIO = DOCK");
                  //}
                  //else {
                  //   SetLoadPortDock(2,false);
                  //}
                  // Presence
                  if(boolpresenceled == true) {
                     SetLoadPortPresence(2,true);
                     WriteSystemLog("LP2 - GPIO = Presence");
                  }
                  else {
                     SetLoadPortPresence(2,false);
                  }
                  // Placement
                  if(boolplacementled == true) {
                     SetLoadPortPlacement(2,true);
                     WriteSystemLog("LP2 - GPIO = Placement");
                  }
                  else {
                     SetLoadPortPlacement(2,false);
                  }
                  // Load
                  if(boolloadled == true) {
                     SetLoadPortLoad(2,true);
                     //WriteSystemLog("LP2 - GPIO = Load");
                  }
                  else {
                     SetLoadPortLoad(2,false);
                  }
                  // UnLoad
                  if(boolunloadled == true) {
                     SetLoadPortUnload(2,true);
                     //WriteSystemLog("LP2 - GPIO = UnLoad");
                  }
                  else {
                     SetLoadPortUnload(2,false);
                  }
                  // Manual
                  //if(boolmanualled == true) {
                  //   SetLoadPortManual(2,true);
                  //   WriteSystemLog("LP2 - GPIO = Manual");
                  //}
                  //else {
                  //   SetLoadPortManual(2,false);
                  //}
                  // Alarm
                  //if(boolalarmled == true) {
                  //   SetLoadPortAlarm(2,true);
                  //   WriteSystemLog("LP2 - GPIO = Alarm");
                  //}
                  //else {
                  //   SetLoadPortAlarm(2,false);
                  //}
                  //===
*/
               }
            }

            // 2021 4 26 - chc STAT
            // aSTG1.STAT:10000/0000
            // 123456789012345678901234567890
            //retcmd = cmdstr.SubString(7,4);
            else if(retcmd == "STAT") {
               AnsiString errcode,errcode1;
               errcode = cmdstr.SubString(18,4);
               errcode1 = cmdstr.SubString(20,2);
               if(errcode1 != "00") {
                  // LoadPort
                  //#define LOADPORT_ALARM_ORGN             0
                  //#define LOADPORT_ALARM_MOTOR_STALL      1
                  //#define LOADPORT_ALARM_SENSOR           2
                  //#define LOADPORT_ALARM_COMMUNICATION    3
                  //#define LOADPORT_ALARM_DRIVER           4
                  //#define LOADPORT_ALARM_MAPPING_SENSOR   5
                  //#define LOADPORT_ALARM_FAN              6
                  //#define LOADPORT_ALARM_POWER            7
                  //#define LOADPORT_ALARM_OVER_HEAT        8
                  //#define LOADPORT_ALARM_CABLE            9
                  //#define LOADPORT_ALARM_CARRY_IN         10
                  //#define LOADPORT_ALARM_CARRY_OUT        11
                  //#define LOADPORT_ALARM_BUSY_TIMEOUT     12
                  errorname = "異常";
                  if(errcode1 == "01") {
                     pnlLoadPort2ErrorCode1->Hint = "Motor stall";
                     errorname = "失步";
                     errorstate = LOADPORT_ALARM_MOTOR_STALL;
                  }
                  else if(errcode1 == "02") {
                     pnlLoadPort2ErrorCode1->Hint = "Sensor abnormal";
                     errorname = "Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "03") {
                     pnlLoadPort2ErrorCode1->Hint = "Emergency stop";
                     errorname = "急停";
                     errorstate = LOADPORT_ALARM_POWER;
                  }
                  else if(errcode1 == "04") {
                     pnlLoadPort2ErrorCode1->Hint = "Command error";
                     errorname = "指令異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "05") {
                     pnlLoadPort2ErrorCode1->Hint = "Communication error";
                     errorname = "通訊異常";
                     errorstate = LOADPORT_ALARM_COMMUNICATION;
                  }
                  else if(errcode1 == "06") {
                     pnlLoadPort2ErrorCode1->Hint = "Chucking sensor abnormal";
                     errorname = "Chucking Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "07") {
                     pnlLoadPort2ErrorCode1->Hint = "(Reserved)";
                     errorname = "預留";
                  }
                  else if(errcode1 == "08") {
                     pnlLoadPort2ErrorCode1->Hint = "Obstacle detection sensor error";
                     errorname = "障礙偵測Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "09") {
                     pnlLoadPort2ErrorCode1->Hint = "Second origin sensor abnormal";
                     errorname = "原點Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "0A") {
                     pnlLoadPort2ErrorCode1->Hint = "Mapping sensor abnormal";
                     errorname = "Mapping Sensor異常";
                     errorstate = LOADPORT_ALARM_MAPPING_SENSOR;
                  }
                  else if(errcode1 == "0B") {
                     pnlLoadPort2ErrorCode1->Hint = "Wafer protrusion detecting sensor abnormal";
                     errorname = "凸片偵測Sensor異常";
                     errorstate = LOADPORT_ALARM_SENSOR;
                  }
                  else if(errcode1 == "0E") {
                     pnlLoadPort2ErrorCode1->Hint = "Driver abnormal";
                     errorname = "驅動器異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "20") {
                     pnlLoadPort2ErrorCode1->Hint = "Control power abnormal";
                     errorname = "控制電源異常";
                     errorstate = LOADPORT_ALARM_POWER;
                  }
                  else if(errcode1 == "21") {
                     pnlLoadPort2ErrorCode1->Hint = "Driver power abnormal";
                     errorname = "驅動器電源異常";
                     errorstate = LOADPORT_ALARM_POWER;
                  }
                  else if(errcode1 == "22") {
                     pnlLoadPort2ErrorCode1->Hint = "EEPROM abnormal";
                     errorname = "驅動器異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "23") {
                     pnlLoadPort2ErrorCode1->Hint = "Z search error";
                     errorname = "驅動器異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "24") {
                     pnlLoadPort2ErrorCode1->Hint = "Overheat";
                     errorname = "過熱異常";
                     errorstate = LOADPORT_ALARM_OVER_HEAT;
                  }
                  else if(errcode1 == "25") {
                     pnlLoadPort2ErrorCode1->Hint = "Overcurrent";
                     errorname = "過電流異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "26") {
                     pnlLoadPort2ErrorCode1->Hint = "Motor cable abnormal";
                     errorname = "馬達線路異常";
                     errorstate = LOADPORT_ALARM_CABLE;
                  }
                  else if(errcode1 == "27") {
                     pnlLoadPort2ErrorCode1->Hint = "Motor stall(position deviation)";
                     errorname = "失步(位置)";
                     errorstate = ROBOT_ALARM_MOTOR_STALL;
                  }
                  else if(errcode1 == "28") {
                     pnlLoadPort2ErrorCode1->Hint = "Motor stall(time over)";
                     errorname = "失步(過時)";
                     errorstate = ROBOT_ALARM_MOTOR_STALL;
                  }
                  else if(errcode1 == "89") {
                     pnlLoadPort2ErrorCode1->Hint = "Exhaust fan abnormal";
                     errorname = "排風扇異常";
                     errorstate = LOADPORT_ALARM_FAN;
                  }
                  else if(errcode1 == "92") {
                     pnlLoadPort2ErrorCode1->Hint = "Foup clamp/rotation disabled";
                     errorname = "Foup Clamp異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "93") {
                     pnlLoadPort2ErrorCode1->Hint = "Foup unclam;/rotation disabled";
                     errorname = "Foup UnClamp異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "94") {
                     pnlLoadPort2ErrorCode1->Hint = "Latch key lock disabled";
                     errorname = "Latch Key Lock異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "96") {
                     pnlLoadPort2ErrorCode1->Hint = "Latch key release disabled";
                     errorname = "Latch Key Release異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "97") {
                     pnlLoadPort2ErrorCode1->Hint = "Mapping sensor preparation disabled";
                     errorname = "Mapping Sensor異常";
                     errorstate = LOADPORT_ALARM_MAPPING_SENSOR;
                  }
                  else if(errcode1 == "98") {
                     pnlLoadPort2ErrorCode1->Hint = "Mapping sensor containing disabled";
                     errorname = "Mapping Sensor異常";
                     errorstate = LOADPORT_ALARM_MAPPING_SENSOR;
                  }
                  else if(errcode1 == "99") {
                     pnlLoadPort2ErrorCode1->Hint = "Chucking on disabled";
                     errorname = "Chucking On異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "9A") {
                     pnlLoadPort2ErrorCode1->Hint = "Wafer protrusion";
                     errorname = "Wafer凸出異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9B") {
                     pnlLoadPort2ErrorCode1->Hint = "No door on FOUP/With door on FOSB";
                     errorname = "FOUP異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9C") {
                     pnlLoadPort2ErrorCode1->Hint = "Carrier improperly taken";
                     errorname = "Carrier異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9D") {
                     pnlLoadPort2ErrorCode1->Hint = "FOSB door detection";
                     errorname = "FOSB異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9E") {
                     pnlLoadPort2ErrorCode1->Hint = "Carrier improperly placed";
                     errorname = "Carrier位置異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "9F") {
                     pnlLoadPort2ErrorCode1->Hint = "Carrier detection error";
                     errorname = "Carrier偵測異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "A0") {
                     pnlLoadPort2ErrorCode1->Hint = "Cover lock disabled";
                     errorname = "Cover Lock異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "A1") {
                     pnlLoadPort2ErrorCode1->Hint = "Cover unlock disabled";
                     errorname = "Cover UnLock異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "B0") {
                     pnlLoadPort2ErrorCode1->Hint = "TR_REQ timeout";
                     errorname = "TR_REQ異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "B1") {
                     pnlLoadPort2ErrorCode1->Hint = "BUSY ON timeout";
                     errorname = "Busy or Timeout";
                     errorstate = LOADPORT_ALARM_BUSY_TIMEOUT;
                  }
                  else if(errcode1 == "B2") {
                     pnlLoadPort2ErrorCode1->Hint = "Carrier carry-in timeout";
                     errorname = "Carrier Carry-In異常";
                     errorstate = LOADPORT_ALARM_CARRY_IN;
                  }
                  else if(errcode1 == "B3") {
                     pnlLoadPort2ErrorCode1->Hint = "Carrier carry-out timeout";
                     errorname = "Carrier Carry-Out異常";
                     errorstate = LOADPORT_ALARM_CARRY_OUT;
                  }
                  else if(errcode1 == "B4") {
                     pnlLoadPort2ErrorCode1->Hint = "BUSY OFF timeout";
                     errorname = "BUSY off timeout異常";
                     errorstate = LOADPORT_ALARM_BUSY_TIMEOUT;
                  }
                  else if(errcode1 == "B5") {
                     pnlLoadPort2ErrorCode1->Hint = "(Reserved)";
                     errorname = "預留";
                  }
                  else if(errcode1 == "B6") {
                     pnlLoadPort2ErrorCode1->Hint = "VALID OFF timeout";
                     errorname = "VALID off timeout異常";
                     errorstate = LOADPORT_ALARM_BUSY_TIMEOUT;
                  }
                  else if(errcode1 == "B7") {
                     pnlLoadPort2ErrorCode1->Hint = "CONTINUE timeout";
                     errorname = "CONTINUE timeout異常";
                     errorstate = LOADPORT_ALARM_BUSY_TIMEOUT;
                  }
                  else if(errcode1 == "B8") {
                     pnlLoadPort2ErrorCode1->Hint = "Signal abnormal detected from VALID,CS_0=ON to TR_REQ=ON";
                     errorname = "Signal-1異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "B9") {
                     pnlLoadPort2ErrorCode1->Hint = "Signal abnormal detected from TR_REQ=ON to BUSY=ON";
                     errorname = "Signal-2異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "BA") {
                     pnlLoadPort2ErrorCode1->Hint = "Signal abnormal detected from BUSY=ON to Placement=ON";
                     errorname = "Signal-3異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "BB") {
                     pnlLoadPort2ErrorCode1->Hint = "Signal abnormal detected from Placement=ON to COMPLETE=ON";
                     errorname = "Signal-4異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "BC") {
                     pnlLoadPort2ErrorCode1->Hint = "Signal abnormal detected from COMPLETE=ON to VALID=OFF";
                     errorname = "Signal-5異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  else if(errcode1 == "BF") {
                     pnlLoadPort2ErrorCode1->Hint = "VALID,CS_0 signal abnormal";
                     errorname = "Signal-6異常";
                     errorstate = LOADPORT_ALARM_DRIVER;
                  }
                  pnlLoadPort2ErrorCode1->Caption = errcode;

                  // 2021 9 18 - chc Alarm
                  pnlLoadPort2ErrorCode1->Hint = "LP2: " + errorname;
                  pnlOpeationMessage->Caption = "LP2: " + errorname;
                  //RedLamp(true);
                  //???
                  AddLoadPort2Message(">Robot 異常原因: " + errorname);
                  //Beep(100);
                  //???

                  // 2021 9 16 - chc Alarm
                  //#define LOADPORT_ALARM_ORGN             0
                  //#define LOADPORT_ALARM_MOTOR_STALL      1
                  //#define LOADPORT_ALARM_SENSOR           2
                  //#define LOADPORT_ALARM_COMMUNICATION    3
                  //#define LOADPORT_ALARM_DRIVER           4
                  //#define LOADPORT_ALARM_MAPPING_SENSOR   5
                  //#define LOADPORT_ALARM_FAN              6
                  //#define LOADPORT_ALARM_POWER            7
                  //#define LOADPORT_ALARM_OVER_HEAT        8
                  //#define LOADPORT_ALARM_CABLE            9
                  //#define LOADPORT_ALARM_CARRY_IN         10
                  //#define LOADPORT_ALARM_CARRY_OUT        11
                  //#define LOADPORT_ALARM_BUSY_TIMEOUT     12
                  //static bool boolorgnerror = false;
                  //static bool boolmotorstall = false;
                  //static bool boolseneorerror = false;
                  //static bool boolcommunicationerror = false;
                  //static bool booldrivererror = false;
                  //static bool boolmappingsensorerror = false;
                  //static bool boolexhaustfanerror = false;
                  //static bool boolcontrolpowererror = false;
                  //static bool booloverheaterror = false;
                  //static bool boolmotorcableerror = false;
                  //static bool boolcarriercarryinerror = false;
                  //static bool boolcarriercarryouterror = false;
                  //static bool boolbusytimeouterror = false;
                  if(errorstate == LOADPORT_ALARM_ORGN) {
                     if(boolorgnerror == false) {
                        boolorgnerror = true;
                        SetSECSAlarm(33001,1,1,"LP1 ORGN Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_MOTOR_STALL) {
                     if(boolmotorstall == false) {
                        boolmotorstall = true;
                        SetSECSAlarm(33002,1,1,"LP1 Motor Stall");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_SENSOR) {
                     if(boolseneorerror == false) {
                        boolseneorerror = true;
                        SetSECSAlarm(33003,1,1,"LP1 Sensor Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_COMMUNICATION) {
                     if(boolcommunicationerror == false) {
                        boolcommunicationerror = true;
                        SetSECSAlarm(33004,1,1,"LP1 Controller Communication Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_DRIVER) {
                     if(booldrivererror == false) {
                        booldrivererror = true;
                        SetSECSAlarm(33005,1,1,"LP1 Driver Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_MAPPING_SENSOR) {
                     if(boolmappingsensorerror == false) {
                        boolmappingsensorerror = true;
                        SetSECSAlarm(33006,1,1,"LP1 Mapping Sensor Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_FAN) {
                     if(boolexhaustfanerror == false) {
                        boolexhaustfanerror = true;
                        SetSECSAlarm(33007,1,1,"LP1 Exhaust Fan Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_POWER) {
                     if(boolcontrolpowererror == false) {
                        boolcontrolpowererror = true;
                        SetSECSAlarm(33008,1,1,"LP1 Control Power Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_OVER_HEAT) {
                     if(booloverheaterror == false) {
                        booloverheaterror = true;
                        SetSECSAlarm(33009,1,1,"LP1 Overheat Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_CABLE) {
                     if(boolmotorcableerror == false) {
                        boolmotorcableerror = true;
                        SetSECSAlarm(33010,1,1,"LP1 Motor Cable Abnormal");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_CARRY_IN) {
                     if(boolcarriercarryinerror == false) {
                        boolcarriercarryinerror = true;
                        SetSECSAlarm(33011,1,0,"LP1 Carrier Carry-In Error");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_CARRY_OUT) {
                     if(boolcarriercarryouterror == false) {
                        boolcarriercarryouterror = true;
                        SetSECSAlarm(33012,1,0,"LP1 Carrier Carry-Out Error");
                     }
                  }
                  else if(errorstate == LOADPORT_ALARM_BUSY_TIMEOUT) {
                     if(boolbusytimeouterror == false) {
                        boolbusytimeouterror = true;
                        SetSECSAlarm(33013,1,0,"LP1 Busy or Timeout");
                     }
                  }
                  // 記錄Robot Error Code
                  errorcodeold = errorcode;

               }
               else {
                  pnlLoadPort2ErrorCode1->Caption = "";
                  // LoadPort
                  //static bool boolorgnerror = false;
                  //static bool boolmotorstall = false;
                  //static bool boolseneorerror = false;
                  //static bool boolcommunicationerror = false;
                  //static bool booldrivererror = false;
                  //static bool boolmappingsensorerror = false;
                  //static bool boolexhaustfanerror = false;
                  //static bool boolcontrolpowererror = false;
                  //static bool booloverheaterror = false;
                  //static bool boolmotorcableerror = false;
                  //static bool boolcarriercarryinerror = false;
                  //static bool boolcarriercarryouterror = false;
                  //static bool boolbusytimeouterror = false;
                  if(errorcodeold != errorcode)
                     AddLoadPort2Message(">12吋Port 恢復正常.");
                  errorname = "正常";
                  pnlLoadPort2ErrorCode1->Hint = errorname;
                  pnlLoadPort2ErrorCode1->Caption = "";
                  // Alarm Reset
                  if(boolorgnerror == true) {
                     SetSECSAlarm(33001,0,1,"LP1 ORGN Abnormal");
                  }
                  if(boolmotorstall == true) {
                     SetSECSAlarm(33002,0,1,"LP1 Motor Stall");
                  }
                  if(boolseneorerror == true) {
                     SetSECSAlarm(33003,0,1,"LP1 Sensor Abnormal");
                  }
                  if(boolcommunicationerror == true) {
                     SetSECSAlarm(33004,0,1,"LP1 Controller Communication Abnormal");
                  }
                  if(booldrivererror == true) {
                     SetSECSAlarm(33005,0,1,"LP1 Driver Abnormal");
                  }
                  if(boolmappingsensorerror == true) {
                     SetSECSAlarm(33006,0,1,"LP1 Mapping Sensor Abnormal");
                  }
                  if(boolexhaustfanerror == true) {
                     SetSECSAlarm(33007,0,1,"LP1 Exhaust Fan Abnormal");
                  }
                  if(boolcontrolpowererror == true) {
                     SetSECSAlarm(33008,0,1,"LP1 Control Power Abnormal");
                  }
                  if(booloverheaterror == true) {
                     SetSECSAlarm(33009,0,1,"LP1 Overheat Abnormal");
                  }
                  if(boolmotorcableerror == true) {
                     SetSECSAlarm(33010,0,1,"LP1 Motor Cable Error");
                  }
                  if(boolcarriercarryinerror == true) {
                     SetSECSAlarm(33011,0,0,"LP1 Carry-In Error");
                  }
                  if(boolcarriercarryouterror == true) {
                     SetSECSAlarm(33012,0,0,"LP1 Carry-Out Error");
                  }
                  if(boolbusytimeouterror == true) {
                     SetSECSAlarm(33013,0,0,"LP1 Busy or Timeout");
                  }
                  boolorgnerror = false;
                  boolmotorstall = false;
                  boolseneorerror = false;
                  boolcommunicationerror = false;
                  booldrivererror = false;
                  boolmappingsensorerror = false;
                  boolexhaustfanerror = false;
                  boolcontrolpowererror = false;
                  booloverheaterror = false;
                  boolmotorcableerror = false;
                  boolcarriercarryinerror = false;
                  boolcarriercarryouterror = false;
                  boolbusytimeouterror = false;

               }
            }

            // 2021 8 3 - chc LP2 - Parameter: Min/Max Thickness: LP2DPRMStep
            // aSTG1.DPRM.GTDT=0000
            // 123456789012345678901234567890
            else if(retcmd == "DPRM") {
               int no,len;
               len = cmdstr.Length();
               no = len - 16;
               AnsiString svalue;
               svalue = cmdstr.SubString(19,no);
               if(LP2DPRMStep == 2) {
                  pnlLoadPort2MinThickness->Caption = svalue;
                  LP2DPRMStep++;
               }
               else if(LP2DPRMStep == 4) {
                  pnlLoadPort2MaxThickness->Caption = svalue;
                  LP2DPRMStep++;
               }
            }

         }
         else {

            // 2021 10 12 - chc 位置不對
            //pnlLoadPort2Send->Color = clRed;

            if(cmdstr.SubString(1,1) == "c") {

               // 2021 10 12 - chc 位置不對
               pnlLoadPort2Send->Color = clRed;

               pnlLoadPort2CancelCode->Color = clRed;
               pnlLoadPort2CancelCode->Font->Color = clWhite;
               // cSTG1.ORGB:000F
               // 1234567890123456
               AnsiString cancelcode = cmdstr.SubString(12,4);
               if(cancelcode == "0200")
                  pnlLoadPort2CancelCode->Caption = "The Operation objective is not supported";
               else if(cancelcode == "0300")
                  pnlLoadPort2CancelCode->Caption = "The composition elements of command are too few";
               else if(cancelcode == "0310")
                  pnlLoadPort2CancelCode->Caption = "The composition elements of command are too many";
               else if(cancelcode == "0400")
                  pnlLoadPort2CancelCode->Caption = "Command not supported";
               else if(cancelcode == "0500")
                  pnlLoadPort2CancelCode->Caption = "Too few parameters";
               else if(cancelcode == "0510")
                  pnlLoadPort2CancelCode->Caption = "Too many parameters";
               else if(cancelcode == "0520")
                  pnlLoadPort2CancelCode->Caption = "Inproper number of parameters";
               else if(cancelcode == "060X")
                  pnlLoadPort2CancelCode->Caption = "The value of the No.(X+1)parameter is too small";
               else if(cancelcode == "061X")
                  pnlLoadPort2CancelCode->Caption = "The value of the No.(X+1)parameter is too large";
               else if(cancelcode == "062X")
                  pnlLoadPort2CancelCode->Caption = "The No.(X+1)parameter is not numerical number";
               else if(cancelcode == "063X")
                  pnlLoadPort2CancelCode->Caption = "The digit number of the No.(X+1)parameter is not proper";
               else if(cancelcode == "064X")
                  pnlLoadPort2CancelCode->Caption = "The No.(X+1)parameter is not a hexadecimal number";
               else if(cancelcode == "065X")
                  pnlLoadPort2CancelCode->Caption = "The No.(X+1)parameter is not proper";
               else if(cancelcode == "066X")
                  pnlLoadPort2CancelCode->Caption = "The No.(X+1)parameter is not pulse";
               else if(cancelcode == "0700")
                  pnlLoadPort2CancelCode->Caption = "Abnormal Mode: Not ready";
               else if(cancelcode == "0702")
                  pnlLoadPort2CancelCode->Caption = "Abnormal Mode: Not in the maintenance mode";
               else if(cancelcode == "08XX")
                  pnlLoadPort2CancelCode->Caption = "The setting data of the No(XX+1)is not proper";
               else if(cancelcode == "0920")
                  pnlLoadPort2CancelCode->Caption = "Inproper setting";
               else if(cancelcode == "0A00")
                  pnlLoadPort2CancelCode->Caption = "Origin search not completed";
               else if(cancelcode == "0A01")
                  pnlLoadPort2CancelCode->Caption = "Origin reset not completed";
               else if(cancelcode == "0B00")
                  pnlLoadPort2CancelCode->Caption = "Processing";
               else if(cancelcode == "0B01")
                  pnlLoadPort2CancelCode->Caption = "Moving";
               else if(cancelcode == "0D00")
                  pnlLoadPort2CancelCode->Caption = "Abnormal flash memory";
               else if(cancelcode == "0F00")
                  pnlLoadPort2CancelCode->Caption = "Error-occurred state";
               else if(cancelcode == "1000")
                  pnlLoadPort2CancelCode->Caption = "Movment is unable due to carrier presence";
               else if(cancelcode == "1001")
                  pnlLoadPort2CancelCode->Caption = "Movment is unable due to no carrier presence";
               else if(cancelcode == "1002")
                  pnlLoadPort2CancelCode->Caption = "Improper Setting";
               else if(cancelcode == "1003")
                  pnlLoadPort2CancelCode->Caption = "Improper current position";
               else if(cancelcode == "1004")
                  pnlLoadPort2CancelCode->Caption = "Movment is unable due to small designated posistion";
               else if(cancelcode == "1005")
                  pnlLoadPort2CancelCode->Caption = "Movment is unable due to large designated posistion";
               else if(cancelcode == "1006")
                  pnlLoadPort2CancelCode->Caption = "Presence of the adapter cannot be identified";
               else if(cancelcode == "1007")
                  pnlLoadPort2CancelCode->Caption = "Origin search cannot be perfomed due to abnormal presence state of the adspter";
               else if(cancelcode == "1008")
                  pnlLoadPort2CancelCode->Caption = "Adapter not prepared";
               else if(cancelcode == "1009")
                  pnlLoadPort2CancelCode->Caption = "Cover not closed";
               else if(cancelcode == "103X")
                  pnlLoadPort2CancelCode->Caption = "Interfering with the No.(X+1)axis";
               else if(cancelcode == "1100")
                  pnlLoadPort2CancelCode->Caption = "Emergency stop signal is ON";
               else if(cancelcode == "1200")
                  pnlLoadPort2CancelCode->Caption = "Pause signal is ON/Area sensor beam is blocked";
               else if(cancelcode == "1300")
                  pnlLoadPort2CancelCode->Caption = "Interlock signal is ON";
               else if(cancelcode == "1400")
                  pnlLoadPort2CancelCode->Caption = "Drive power is OFF";
               else if(cancelcode == "2000")
                  pnlLoadPort2CancelCode->Caption = "No response from the ID reader/writer";
               else if(cancelcode == "2100")
                  pnlLoadPort2CancelCode->Caption = "Command for the ID reader/writer is cancelled";
               pnlLoadPort2CancelCode->Hint = pnlLoadPort2CancelCode->Caption;
            }
         }

         if(boolWaitLoadPort2Complete == true) {
            AddLoadPort2Message("檢查STAT:11000...");
            // 12345/6789
            // D1: Operation mode 0-Initializing, 1-Remote, 2-Maintenance, 3-Recovery
            // D2: Origin Search Complete 0-Not Completed, 1-Completed
            // D3: Command Processing 0-Stop, 1-Processing
            // D4: Operation Status 0-Stop, 1-Moving, 2-Temporary Stop
            // D5: Motion Speed 0-Normal, 1-Maintenance
            // D6,D7: Identiofication code for the error-occurred controller(s)
            // D8,D9: Error Code
            if(cmdstr.Pos("STAT:11000") != 0 || cmdstr.Pos("STAT:10000") != 0) {
               AddLoadPort2Message("檢查STAT:11000 ok.");
               boolLoadPort2Complete = true;
               boolWaitLoadPort2Complete = false;

               // 221 9 20 - chc Log
               AddLoadPort2Message("檢查指令: " + retcmd + "已完成.");
               WriteSystemLog("檢查指令: " + retcmd + "已完成.");

            }
            else
               AddLoadPort2Message("檢查STAT:11000 fail!");

            // 221 9 20a - chc 是指令已被執行, 不應設為完成!
            if(AlignerCmd == retcmd && cmdstr.SubString(1,1) == "a") {
               AddLoadPort2Message("檢查指令: " + retcmd + "已執行.");
               WriteSystemLog("檢查指令: " + retcmd + "已執行.");
            }

         }
      }
      else
         break;
   }
   sprintf(receivestr,"%s",text.c_str());

   inactive = false;
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::WaitDelayTime(int timedelay)
{
int no;

   no = timedelay / 100;
   for(int i=0 ; i<no ; i++) {
      Sleep(100);
      Application->ProcessMessages();
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Wait Completed
// return: 0-ok, 1-fail
int __fastcall TMainForm::WaitAlignerComplete(int mode, int timeout)
{
int ret;
long StartTime,StopTime;
short StartMS,StopMS;
long elapsedms;
int cnt = 0;

   boolWaitAlignerComplete = true;
   boolAlignerComplete = false;
   GetTimeTic(&StartTime,&StartMS);
   if(mode == 1) {
      AddAlignerMessage("等待Home完成...");
      WriteSystemLog("等待Home完成...");
   }
   else if(mode == 2) {
      AddAlignerMessage("等待Alignment完成...");
      WriteSystemLog("等待Alignment完成...");
   }
   else if(mode == 3) {
      AddAlignerMessage("等待Origin Search完成...");
      WriteSystemLog("等待Origin Search完成...");
   }
   else if(mode == 4) {
      AddAlignerMessage("等待SetSize完成...");
      WriteSystemLog("等待SetSize完成...");
   }

   // 2021 9 11a - chc 加入UCLM
   else if(mode == 5) {
      AddAlignerMessage("等待UnClamp完成...");
      WriteSystemLog("等待UnClamp完成...");
   }
   else if(mode == 6) {
      AddAlignerMessage("等待Clamp完成...");
      WriteSystemLog("等待Clamp完成...");
   }

   while(1) {
      if(boolAlignerComplete == true) {
ok:
         if(mode == 1) {
            AddAlignerMessage("Home完成.");
            WriteSystemLog("Home完成.");
         }
         else if(mode == 2) {
            AddAlignerMessage("Alignment完成.");
            WriteSystemLog("Alignment完成.");
         }
         else if(mode == 3) {
            AddAlignerMessage("Origin Search完成.");
            WriteSystemLog("Origin Search完成.");
         }
         else if(mode == 4) {
            AddAlignerMessage("SetSize完成.");
            WriteSystemLog("SetSize完成.");
         }

         // 2021 9 11a - chc 加入UCLM
         else if(mode == 5) {
            AddAlignerMessage("UnClamp完成.");
            WriteSystemLog("UnClamp完成.");
         }
         else if(mode == 6) {
            AddAlignerMessage("Clamp完成.");
            WriteSystemLog("Clamp完成.");
         }

         ret = 0;
         break;
      }
      GetTimeTic(&StopTime,&StopMS);
      elapsedms = ((hyper)(StopTime*1000+StopMS) - (hyper)(StartTime*1000+StartMS));
      if(elapsedms > timeout) {
         ret = 1;

         // 2021 9 11a - chc 加入Timeout Log
         if(boolAlignerComplete == true) {
            goto ok;
         }
         else {
            if(mode == 1) {
               AddAlignerMessage("Home Timeout.");
               WriteSystemLog("Home Timeout.");
            }
            else if(mode == 2) {
               AddAlignerMessage("Alignment Timeout.");
               WriteSystemLog("Alignment Timeout.");
            }
            else if(mode == 3) {
               AddAlignerMessage("Origin Search Timeout.");
               WriteSystemLog("Origin Search Timeout.");
            }
            else if(mode == 4) {
               AddAlignerMessage("SetSize Timeout.");
               WriteSystemLog("SetSize Timeout.");
            }
            else if(mode == 5) {
               AddAlignerMessage("UnClamp Timeout.");
               WriteSystemLog("UnClamp Timeout.");
            }
            else if(mode == 6) {
               AddAlignerMessage("Clamp Timeout.");
               WriteSystemLog("Clamp Timeout.");
            }
         }

         break;
      }

      //btnAlignerINITClick(this);
      //WaitDelayTime(500);
      //btnAlignerSTATClick(this);
      // 2021 9 30b - chc 改成100ms, 否則反應太慢! 改用WaitTime();
      //WaitDelayTime(500);
      WaitTime(100);

      // 2021 9 25 - chc 若為zHome/SSIZ每秒要自行送出STAT
      // 2021 9 30 - chc 不需要, SSIZ不會有回應, zHome會有回應
      //cnt++;
      //if(cnt == 2) {
      //   cnt = 0;
      //   if(mode == 4 || mode == 1) {
      //      WriteSystemLog("Aligner(WaitAlignerComplete)送出STAT...");
      //      edAlignerCommand->Text = "STAT";
      //      btnAlignerSendClick(this);
      //      WriteSystemLog("Aligner(WaitAlignerComplete)送出STAT.");
      //   }
      //}

   }
   boolWaitAlignerComplete = false;
   return ret;

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Wait Robot Completed
// return: 0-ok, 1-fail
int __fastcall TMainForm::WaitRobotComplete(int mode, int timeout)
{
int ret;
long StartTime,StopTime;
short StartMS,StopMS;
long elapsedms;

   boolWaitRobotComplete = true;
   boolRobotComplete = false;
   GetTimeTic(&StartTime,&StartMS);
   if(mode == 1) {
      AddRobotMessage("等待Home完成...");

      // 2021 5 3 - chc Log
      WriteSystemLog("等待Home完成...");

   }
   else if(mode == 2) {
      AddRobotMessage("等待Origin Search完成...");

      // 2021 5 3 - chc Log
      WriteSystemLog("等待Origin Search完成...");

   }
   else if(mode == 3) {
      AddRobotMessage("等待Robot Get完成...");

      // 2021 5 3 - chc Log
      WriteSystemLog("等待Robot Get完成...");

   }
   else if(mode == 4) {
      AddRobotMessage("等待Robot Put完成...");

      // 2021 5 3 - chc Log
      WriteSystemLog("等待Robot Put完成...");

   }
   while(1) {
      if(boolRobotComplete == true) {
         if(mode == 1) {
            AddRobotMessage("Home完成.");

            // 2021 5 3 - chc Log
            WriteSystemLog("Home完成.");

         }
         else if(mode == 2) {
            AddRobotMessage("Origin Search完成.");

            // 2021 5 3 - chc Log
            WriteSystemLog("Origin Search完成.");

         }
         else if(mode == 3) {
            AddRobotMessage("Robot Get完成.");

            // 2021 5 3 - chc Log
            WriteSystemLog("Robot Get完成.");

         }
         else if(mode == 4) {
            AddRobotMessage("Robot Put完成.");

           // 2021 5 3 - chc Log
            WriteSystemLog("Robot Put完成.");

         }
         ret = 0;
         break;
      }
      GetTimeTic(&StopTime,&StopMS);
      elapsedms = ((hyper)(StopTime*1000+StopMS) - (hyper)(StartTime*1000+StartMS));
      if(elapsedms > timeout) {
         ret = 1;
         break;
      }
      WaitDelayTime(500);
   }
   boolWaitRobotComplete = false;
   return ret;

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// 點位: 1(LoadPort1-11-21)/2(LoadPort2-31-41/3(Aligner-1)/4(Chuck-6)
// 2021 6 30 - chc 分取放片: ROBOT_HOME_PUT, ROBOT_HOME_GET
//int __fastcall TMainForm::GetStageNo()
int __fastcall TMainForm::GetStageNo(int mode)

{
int stageno,startno,armno;

   // 0-UpArm, 1-LowArm
   armno = rgRobotArm->ItemIndex;
   // LP1/LP2/Aligner/Chuck
   stageno = rgRobotStage->ItemIndex + 1;
   switch(stageno) {
      // LP1 - 11~
      case 1:
         if(armno == ROBOT_ARM_UP) {

            // 2021 6 30 - chc 分取放片: ROBOT_HOME_PUT, ROBOT_HOME_GET
            if(mode == ROBOT_HOME_PUT)
               startno = 12;
            else

               startno = 12;
         }
         else {

            // 2021 6 30 - chc 分取放片: ROBOT_HOME_PUT, ROBOT_HOME_GET
            if(mode == ROBOT_HOME_PUT)
               startno = 2;
            else

               startno = 2;
         }
         break;
      // LP2 - 31~
      case 2:
         if(armno == ROBOT_ARM_UP) {

            // 2021 6 30 - chc 分取放片: ROBOT_HOME_PUT, ROBOT_HOME_GET
            if(mode == ROBOT_HOME_PUT)
               startno = 13;
            else

               startno = 13;
         }
         else {

            // 2021 6 30 - chc 分取放片: ROBOT_HOME_PUT, ROBOT_HOME_GET
            if(mode == ROBOT_HOME_PUT)
               startno = 3;
            else

               startno = 3;
         }
         break;
      // AL: 1~2
      case 3:
         // UpArm - 8"
         if(armno == ROBOT_ARM_UP)
            startno = 11;
         // LowArm - 12"
         else
            startno = 1;
         break;
      // Chuck: 6~7
      case 4:
         // UpArm - 8"
         if(armno == ROBOT_ARM_UP)
            startno = 14;
         // LowArm - 12"
         else
            startno = 4;
         break;
   }
   return startno;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Wait LoadPort1 Completed
// return: 0-ok, 1-fail
int __fastcall TMainForm::WaitLoadPort1Complete(int mode, int timeout)
{
int ret;
long StartTime,StopTime;
short StartMS,StopMS;
long elapsedms;

   boolWaitLoadPort1Complete = true;
   boolLoadPort1Complete = false;
   GetTimeTic(&StartTime,&StartMS);
   if(mode == 1)
      AddLoadPort1Message("等待Home完成...");
   else if(mode == 2)
      AddLoadPort1Message("等待Origin Search完成...");
   else if(mode == 3)
      AddLoadPort1Message("等待CLMP完成...");
   else if(mode == 4)
      AddLoadPort1Message("等待UCLM完成...");
   else if(mode == 5)
      AddLoadPort1Message("等待WMAP完成...");
   while(1) {
      if(boolLoadPort1Complete == true) {
         if(mode == 1)
            AddLoadPort1Message("Home完成.");
         else if(mode == 2)
            AddLoadPort1Message("Origin Search完成.");
         else if(mode == 3)
            AddLoadPort1Message("CLMP完成.");
         else if(mode == 4)
            AddLoadPort1Message("UCLM完成.");
         else if(mode == 5)
            AddLoadPort1Message("WMAP完成.");
         ret = 0;
         break;
      }
      GetTimeTic(&StopTime,&StopMS);
      elapsedms = ((hyper)(StopTime*1000+StopMS) - (hyper)(StartTime*1000+StartMS));
      if(elapsedms > timeout) {
         ret = 1;
         break;
      }
      WaitDelayTime(500);

      // 2021 4 29 - chc 要送STAT
      btnLoadPort1STATClick(this);

   }
   boolWaitLoadPort1Complete = false;
   return ret;

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Wait LoadPort2 Completed
// return: 0-ok, 1-fail
int __fastcall TMainForm::WaitLoadPort2Complete(int mode, int timeout)
{
int ret;
long StartTime,StopTime;
short StartMS,StopMS;
long elapsedms;

   boolWaitLoadPort2Complete = true;
   boolLoadPort2Complete = false;
   GetTimeTic(&StartTime,&StartMS);
   if(mode == 1)
      AddLoadPort2Message("等待Home完成...");
   else if(mode == 2)
      AddLoadPort2Message("等待Origin Search完成...");
   else if(mode == 3)
      AddLoadPort2Message("等待CLMP完成...");
   else if(mode == 4)
      AddLoadPort2Message("等待UCLM完成...");
   else if(mode == 5)
      AddLoadPort2Message("等待WMAP完成...");
   while(1) {
      if(boolLoadPort2Complete == true) {
         if(mode == 1)
            AddLoadPort2Message("Home完成.");
         else if(mode == 2)
            AddLoadPort2Message("Origin Search完成.");
         else if(mode == 3)
            AddLoadPort2Message("CLMP完成.");
         else if(mode == 4)
            AddLoadPort2Message("UCLM完成.");
         else if(mode == 5)
            AddLoadPort2Message("WMAP完成.");
         ret = 0;
         break;
      }
      GetTimeTic(&StopTime,&StopMS);
      elapsedms = ((hyper)(StopTime*1000+StopMS) - (hyper)(StartTime*1000+StartMS));
      if(elapsedms > timeout) {
         ret = 1;
         break;
      }
      WaitDelayTime(500);
   }
   boolWaitLoadPort2Complete = false;
   return ret;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// 10ms一次, 用於Robot
void __fastcall DelayTimeRobot(int no)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
int cnt = 0;

   MainForm->GetTimeTic(&starttime,&starttick);
   while(1) {
      Application->ProcessMessages();
      cnt++;
      if(cnt >= 20) {
         cnt = 0;
         MainForm->GetTimeTic(&stoptime,&stoptick);
         elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
         if(elapsedms > no)
            return;
      }
   }
}
//---------------------------------------------------------------------------
// 2021 9 8b - chc Read Status
bool boolRFIDRead = false;

// 2021 4 11 - chc Rorze
// RFID
// SOH 0  1  3  0  1  R  D  M  P  T  0  1  0  2  6  F  END
// Hex: 01  30 31 33 30 31 52 44 4D 50 54 30 31 30 32 36 46 0D
//   30h ExOR 30h ExOR 39h ExOR 30h ExOR 30h ExOR 52h ExOR 44h ExOR 52h ExOR 2Fh ExOR 4Fh = 1Dh
//   1Dh -> ASCII conversion -> "1"(31h)"D"(44h)"1D" = Check code
//
//   013: 13個byte要傳送, 不含End/SOH/BYTE, 但含CheckCode
//   01: Target Address(00-31: Dip Switch)
//   Command: RD		可讀R/O, R/W, MPT(Multi Page)
//   Parameter/Data: MPT0102(由Page1開始, 讀2個Page, 每個Page 8個byte, 共17個Page.
//             最多: MPT0117
//   Check Code: 026F(由BYTE到CheckCode之前)
// RS232: 9600/8/N/1, 不跳線(2/3/5)
//
// Ack: 00600TE27
//   006: 長度
//   00: Target Address
//   TE: Tag is not present near antenna at time of trugger commands execution.
//   27: check code
//
// 02200OKEE3Q076156
void __fastcall TMainForm::btnRFIDReadClick(TObject *Sender)
{
char buf[50],cmd[50],c1,c2;
AnsiString ack;
TYbCommDevice *ybRFID;
int loadport,wafersize,len;
TPanel *panel;

   if(rgRFIDTagType->ItemIndex == 0)
      sprintf(buf,"00900RDR/O");
   else if(rgRFIDTagType->ItemIndex == 1)
      sprintf(buf,"00900RDR/W");
   else
      sprintf(buf,"01300RDMPT0102");

   //sprintf(buf,"008~00RU*");

   GetRFIDCheckcode(buf,&c1,&c2);
   ack.sprintf("%s%c%c",buf,c1,c2);
   sprintf(cmd,"%c%s%c%c%c",0x01,buf,c1,c2,0x0d);

   loadport = rgRFIDLoadPort->ItemIndex + 1;
   wafersize = rgRFIDWaferSize->ItemIndex;
   if(wafersize == 0)
      wafersize = 8;
   else
      wafersize = 12;
   AddRFIDMessage("[>] " + IntToStr(loadport) + IntToStr(wafersize) + ": " + ack);
   ybRFID = (TYbCommDevice*)(FindComponent("ybRFID" + IntToStr(loadport) + IntToStr(wafersize)));
   panel = (TPanel*)(FindComponent("pnlRFID" + IntToStr(loadport) + IntToStr(wafersize)));

   // 2021 9 8a - chc Log
   WriteSystemLog("btnRFIDReadClick: Port(實際),Size= " + IntToStr(loadport) + "," + IntToStr(wafersize));

   if(panel->Color == clLime) {

      // 2021 10 15 - chc 應該Disable
      pnlRFID->Enabled = false;

      len = strlen(cmd);
      cmd[len] = 0x0;
      // delay 1ms再送
      //ybRFID->Write(cmd,len);
      for(int i=0 ; i<len ; i++) {
         Sleep(1);
         ybRFID->Write(&cmd[i],1);
      }
      pnlRFIDOperation->Caption = "Busy";
      pnlRFIDOperation->Refresh();

      // 2021 9 8b - chc 等完成
      boolRFIDRead = false;
      int cnt,timeout;
      cnt = 0;
      // 2sec
      timeout = 200;
      while(1) {
         Sleep(10);
         Application->ProcessMessages();
         if(boolRFIDRead == true) {
            WriteSystemLog("RFID Read完成.");
            break;
         }
         cnt++;
         if(cnt > timeout) {
            WriteSystemLog("RFID Read timeout!");
            break;
         }
      }

      // 2021 10 15 - chc 不應該Disable, 要Enable
      //pnlRFID->Enabled = false;
      pnlRFID->Enabled = true;

   }


}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
void __fastcall TMainForm::btnRFIDSerialNumberClick(TObject *Sender)
{
char buf[50],cmd[50],c1,c2;
AnsiString ack;
TYbCommDevice *ybRFID;
int loadport,wafersize,len;
TPanel *panel;


   sprintf(buf,"00600SN");
   GetRFIDCheckcode(buf,&c1,&c2);
   ack.sprintf("%s%c%c",buf,c1,c2);
   sprintf(cmd,"%c%s%c%c%c",0x01,buf,c1,c2,0x0d);
   pnlRFIDResult->Caption = ack;

   loadport = rgRFIDLoadPort->ItemIndex + 1;
   wafersize = rgRFIDWaferSize->ItemIndex;
   if(wafersize == 0)
      wafersize = 8;
   else
      wafersize = 12;
   AddRFIDMessage("[>] " + IntToStr(loadport) + IntToStr(wafersize) + ": " + ack);
   ybRFID = (TYbCommDevice*)(FindComponent("ybRFID" + IntToStr(loadport) + IntToStr(wafersize)));
   panel = (TPanel*)(FindComponent("pnlRFID" + IntToStr(loadport) + IntToStr(wafersize)));
   if(panel->Color == clLime) {
      len = strlen(cmd);
      cmd[len] = 0x0;
      // delay 1ms再送
      //ybRFID->Write(cmd,len);
      for(int i=0 ; i<len ; i++) {
         Sleep(1);
         ybRFID->Write(&cmd[i],1);
      }
      pnlRFIDOperation->Caption = "Busy";
      pnlRFIDOperation->Refresh();
      pnlRFID->Enabled = false;
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
void __fastcall TMainForm::btnRFIDInitClick(TObject *Sender)
{

   InitRFIDCom();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
void __fastcall TMainForm::btnRFIDTestClick(TObject *Sender)
{
int loop;

   pcEFEMR->Enabled = false;
   loop = edRFIDTest->Text.ToInt();
   for(int i=0 ; i<loop ; i++) {
      btnRFIDReadClick(this);
      for(int j=0 ; j<100 ; j++) {
         Sleep(15);
         Application->ProcessMessages();
      }
      pnlOpeationMessage->Caption = " RFID Read Test: " + edRFIDTest->Text + "-" + IntToStr(i+1);
   }
   pcEFEMR->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
void __fastcall TMainForm::pnlRFIDOperationClick(TObject *Sender)
{

   pnlRFID->Enabled = true;
   pnlRFIDOperation->Caption = "Idle";
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
void TMainForm::AddRFIDMessage(AnsiString msg)
{
AnsiString putmsg;
static AnsiString oldmsg = "";

   //if(oldmsg == msg)                            // 重複不收錄
   //   return;
   oldmsg = msg;
   putmsg = Now().FormatString("nn':'ss':'zzz'-> '") + msg;
   // 以Memo取代, 最多共470 Rows
   mmRFID->Lines->Insert(0,putmsg);
   mmRFID->Refresh();

   if(mmRFID->Lines->Count > 500) {
      for(int i=470 ; i<mmRFID->Lines->Count ; i++)
         mmRFID->Lines->Delete(i);
   }
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
void __fastcall TMainForm::GetRFIDCheckcode(char *buf,char *code1,char *code2)
{
char c1,c2;
int len;
unsigned char checkcode;

   len = strlen(buf);
   checkcode = 0;
   for(int i=0 ; i<len ; i++) {
      if(i == 0)
         checkcode = buf[i];
      else
         checkcode ^= buf[i];
   }
   // 6F
   c1 = (checkcode & 0xf0) >> 4;
   c2 = (checkcode & 0x0f);
   if(c1 < 10)
      c1 += '0';
   else
      c1 = (c1 - 10) + 'A';
   if(c2 < 10)
      c2 += '0';
   else
      c2 = (c2 - 10) + 'A';
   *code1 = c1;
   *code2 = c2;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// Init ComPort RFID
void __fastcall TMainForm::InitRFIDCom()
{
TPanel *panel;
TYbCommDevice *ybRFID;
AnsiString name;

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動RFID Com Port...";
   for(int i=0 ; i<4 ; i++) {
      switch(i) {
         case 0:
            panel = (TPanel*)(FindComponent("pnlRFID18"));
            ybRFID = (TYbCommDevice*)(FindComponent("ybRFID18"));
            name = "RFID1-8";
            break;
         case 1:
            panel = (TPanel*)(FindComponent("pnlRFID112"));
            ybRFID = (TYbCommDevice*)(FindComponent("ybRFID112"));
            name = "RFID1-12";
            break;
         case 2:
            panel = (TPanel*)(FindComponent("pnlRFID28"));
            ybRFID = (TYbCommDevice*)(FindComponent("ybRFID28"));
            name = "RFID2-8";
            break;
         case 3:
            panel = (TPanel*)(FindComponent("pnlRFID212"));
            ybRFID = (TYbCommDevice*)(FindComponent("ybRFID212"));
            name = "RFID2-12";
            break;
      }
      try {
         panel->Color = clSilver;
         ybRFID->Active = false;
         Sleep(200);
         // Baudrate
         if(combRFIDBaudrate->Text == "115200")
            ybRFID->Baud = ybRFID->br115200;
         else if(combRFIDBaudrate->Text == "57600")
            ybRFID->Baud = ybRFID->br57600;
         else if(combRFIDBaudrate->Text == "38400")
            ybRFID->Baud = ybRFID->br38400;
         else if(combRFIDBaudrate->Text == "19200")
            ybRFID->Baud = ybRFID->br19200;
         else if(combRFIDBaudrate->Text == "9600")
            ybRFID->Baud = ybRFID->br9600;
         // 由參數決定COM Port
         ybRFID->PortNo = combRFIDComport->ItemIndex+1+i;
         pnlSystemMessage->Caption = name + " COM" + IntToStr(ybRFID->PortNo);
         ybRFID->Active = true;
         panel->Color = clLime;
         boolRFIDStatus[i] = true;
      }
      catch(Exception &e) {
         pnlSystemMessage->Caption = name + ": " + e.Message;
         panel->Color = clRed;
         boolRFIDStatus[i] = false;
      }
      pnlSystemMessage->Caption = "啟動" + name + "Com Port.";
   }

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
#define STX             0x02
#define ETX             0x03

#define SOH             0x03
#define END             0x0d
// Ack: 00600TE27
//   006: 長度
//   00: Target Address
//   TE: Tag is not present near antenna at time of trugger commands execution.
//   27: check code
//
// LP1 - 8 BR4132-M45
// LP1 -12 BR4132-M45
// LP2 - 8 BR4132-M45
// LP2 -12 BR4132-M45
// Communication Error
//   PE - There is a parity error in the command received
//   FE - There is a framing error in the command received
//   OE - There is a overrun error in the command received
//   CE - the command formant is not suitable for the specification
//        EX) command section is not defined; page/address specificaation in incorrect, etc
//   LE - when the receiving frame exceeds 290 data of chaaracters.
//        When the intervals between the characters being received exceeded 500 ms
//   ME - When the receiving target address in the frame structure field is not match the
//        DIP-SW No.1 to No.5 setting
//   BE - the CID Read/Write controller is busy for it is accessing the R/O, R/W, MPT type Tag.
// Transmission Error
//   NE - Noise or other disruption occurred during communication with tag, and the command cannot be executed properly
//   TE - Tag is not present neaar antenna at time of Trigger commands execution
//   AE - Page address specification is incorrect
//   WE - there is a Tag in the area when reading is possible but writeing is not
//   UE - The Tag type is not specified specification of host
// Hardware Error
//   HE - There is hardware problem on the antenna
AnsiString ReplyStrRFID18 = "";
char Buf18[1024];
int Buf18No = 0;
void __fastcall TMainForm::ybRFID18CommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[1024+1],c;
AnsiString msg;
int len,pos,n,readno;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = 0;
      while(1) {
         readno = ybRFID18->Read(&c,1);
         if(readno == 0)
            break;
         // >10才放入buffer, 否則為Control code
         if(c > 10) {
            Buf18[Buf18No++] = c;
            n++;
         }
         Sleep(1);
      }
      if(Buf18No > 0) {
         pnlRFIDResult->Caption = "None";

         int sno = 0;
         for(int i=0 ; i<Buf18No ; i++) {
            // 0x0d
            if(Buf18[i] == END) {
               if(i == 0) {
                  Sleep(10);
                  continue;
               }
               sno = i;
               int rno = 0;
               for(int j=0 ; j<i ; j++) {
                  if(Buf18[j] > 10) {
                     Buf[rno++] = Buf18[j];
                  }
               }
               Buf[rno] = 0x0;
               msg.sprintf("%s",Buf);
               // Log
               WriteSystemLog("RFID18: " + msg);
               pnlRFIDResult->Caption = msg;

               // 2023 8 2 - chc 這時尚未截取CST ID
               //pnlSECSCSTID->Caption = msg;

               AddRFIDMessage("[<] 18: " + msg);

               // 2021 10 15 - chc 顯示CST ID
               int len = msg.Length();
               AnsiString scode;

               // 02200OKEE3Q076156
               // 12345678901234567890
               // 前面7碼是Header, 後面2碼是CheckSum
               // 2021 12 18 - chc RFID裡面要有OK, 也要送給Yuanli
               //if(len > 15) {
               // 2023 1 4 - chc 分離
               //if(len > 15 && msg.Pos("OK") > 0 && pnlOlympusStatus->Color == clLime) {
               if(len > 15 && msg.Pos("OK") > 0) {

                  // 2021 12 25 - chc 移到前面
                  scode = msg.SubString(8,len-9);
                  pnlCSTCode->Caption = scode;

                  // 2023 8 2 - chc 這時才截取CST ID
                  pnlSECSCSTID->Caption = pnlCSTCode->Caption;

                  // 2023 1 4 - chc 分離
                  if(pnlOlympusStatus->Color == clLime) {

                     pnlSystemMessage->Caption = "Cassette Load(8吋): YuanLi RFID...";
                     if(WaitYuanliCmd(CMD_RFID) != CMD_ACK_E) {
                        pnlAlarmMessage->Caption = "YuanLi RFID(8吋)傳送異常!";
                        WriteSystemLog(pnlAlarmMessage->Caption);
                     }
                     pnlSystemMessage->Caption = "";
                  }
                  // 2021 12 25 - chc 移到前面
                  //scode = msg.SubString(8,len-9);
                  //pnlCSTCode->Caption = scode;

               }

               // 2023 8 2 - chc Read Error
               else {
                  pnlCSTCode->Caption = "--------";
                  pnlSECSCSTID->Caption = pnlCSTCode->Caption;
               }

               // 2021 9 8a - chc Log
               WriteSystemLog("RFID18(實際)讀回 " + msg);
               boolRFIDRead = true;

            }
         }
         // 012345678901234567890       => 21
         //        S                    => 7
         if(sno > 0) {
            for(int i=0 ; i<Buf18No-sno-1 ; i++)
               Buf18[i] = Buf18[i+sno+1];
            Buf18No -= (sno+1);
         }
      }

   // 先不管
   //}

   pnlRFID->Enabled = true;
   pnlRFIDOperation->Caption = "Idle";
   pnlRFIDOperation->Refresh();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
AnsiString ReplyStrRFID112 = "";
char Buf112[1024];
int Buf112No = 0;
void __fastcall TMainForm::ybRFID112CommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[1024+1],c;
AnsiString msg;
int len,pos,n,readno;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = 0;
      while(1) {
         readno = ybRFID112->Read(&c,1);
         if(readno == 0)
            break;
         // >10才放入buffer, 否則為Control code
         if(c > 10) {
            Buf112[Buf112No++] = c;
            n++;
         }
         Sleep(1);
      }
      if(Buf112No > 0) {
         pnlRFIDResult->Caption = "None";

         int sno = 0;
         for(int i=0 ; i<Buf112No ; i++) {
            // 0x0d
            if(Buf112[i] == END) {
               if(i == 0) {
                  Sleep(10);
                  continue;
               }
               sno = i;
               int rno = 0;
               for(int j=0 ; j<i ; j++) {
                  if(Buf112[j] > 10) {
                     Buf[rno++] = Buf112[j];
                  }
               }
               Buf[rno] = 0x0;
               msg.sprintf("%s",Buf);
               WriteSystemLog("RFID112: " + msg);
               pnlRFIDResult->Caption = msg;

               // 2023 8 2 - chc 這時尚未截取CST ID
               //pnlSECSCSTID->Caption = msg;

               AddRFIDMessage("[<] 112: " + msg);

               // 2021 10 15 - chc 顯示CST ID
               int len = msg.Length();
               AnsiString scode;
               // 02200OKEE3Q076156
               // 12345678901234567890
               // 前面7碼是Header, 後面2碼是CheckSum
               // 2021 12 18 - chc 裡面要有OK, 也要送給Yuanli
               //if(len > 15) {
               // 2023 1 4 - chc 分離
               //if(len > 15 && msg.Pos("OK") > 0 && pnlOlympusStatus->Color == clLime) {
               if(len > 15 && msg.Pos("OK") > 0) {

                  // 2021 12 25 - chc 移到前面
                  scode = msg.SubString(8,len-9);
                  pnlCSTCode->Caption = scode;

                  // 2023 8 2 - chc 這時才截取CST ID
                  pnlSECSCSTID->Caption = pnlCSTCode->Caption;

                  // 2023 1 4 - chc 分離
                  if(pnlOlympusStatus->Color == clLime) {

                     pnlSystemMessage->Caption = "Cassette Load(12吋): YuanLi RFID...";
                     if(WaitYuanliCmd(CMD_RFID) != CMD_ACK_E) {
                        pnlAlarmMessage->Caption = "YuanLi RFID(12吋)傳送異常!";
                        WriteSystemLog(pnlAlarmMessage->Caption);
                     }
                     pnlSystemMessage->Caption = "";
                  }
                  // 2021 12 25 - chc 移到前面
                  //scode = msg.SubString(8,len-9);
                  //pnlCSTCode->Caption = scode;

               }

               // 2023 8 2 - chc Read Error
               else {
                  pnlCSTCode->Caption = "--------";
                  pnlSECSCSTID->Caption = pnlCSTCode->Caption;
               }

               // 2021 9 8a - chc Log
               WriteSystemLog("RFID112(實際)讀回 " + msg);
               boolRFIDRead = true;

            }
         }
         // 02200OKEE3Q076156
         // 12345678901234567890       => 21
         //        S                    => 7
         if(sno > 0) {
            for(int i=0 ; i<Buf112No-sno-1 ; i++)
               Buf112[i] = Buf112[i+sno+1];
            Buf112No -= (sno+1);
         }
      }

   // 先不管
   //}

   pnlRFID->Enabled = true;
   pnlRFIDOperation->Caption = "Idle";
   pnlRFIDOperation->Refresh();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
AnsiString ReplyStrRFID28 = "";
char Buf28[1024];
int Buf28No = 0;
void __fastcall TMainForm::ybRFID28CommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[1024+1],c;
AnsiString msg;
int len,pos,n,readno;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = 0;
      while(1) {
         readno = ybRFID28->Read(&c,1);
         if(readno == 0)
            break;
         // >10才放入buffer, 否則為Control code
         if(c > 10) {
            Buf28[Buf28No++] = c;
            n++;
         }
         Sleep(1);
      }
      if(Buf28No > 0) {
         pnlRFIDResult->Caption = "None";

         int sno = 0;
         for(int i=0 ; i<Buf28No ; i++) {
            // 0x0d
            if(Buf28[i] == END) {
               if(i == 0) {
                  Sleep(10);
                  continue;
               }
               sno = i;
               int rno = 0;
               for(int j=0 ; j<i ; j++) {
                  if(Buf28[j] > 10) {
                     Buf[rno++] = Buf28[j];
                  }
               }
               Buf[rno] = 0x0;
               msg.sprintf("%s",Buf);
               WriteSystemLog("RFID28: " + msg);
               pnlRFIDResult->Caption = msg;

               // 2023 8 2 - chc 尚未截取
               //pnlSECSCST2ID->Caption = msg;

               AddRFIDMessage("[<] 28: " + msg);

               // 2021 10 15 - chc 顯示CST ID
               int len = msg.Length();
               AnsiString scode;

               // 02200OKEE3Q076156
               // 12345678901234567890
               // 前面7碼是Header, 後面2碼是CheckSum
               // 2021 12 18 - chc 裡面要有OK, 也要送給Yuanli
               //if(len > 15) {
               // 2023 1 4 - chc 分離
               //if(len > 15 && msg.Pos("OK") > 0 && pnlOlympusStatus->Color == clLime) {
               if(len > 15 && msg.Pos("OK") > 0) {

                  // 2021 12 25 - chc 移到前面
                  scode = msg.SubString(8,len-9);
                  pnlCSTCode->Caption = scode;

                  // 2023 8 2 - chc 已截取
                  pnlSECSCST2ID->Caption = pnlCSTCode->Caption;

                  // 2023 1 4 - chc 分離
                  if(pnlOlympusStatus->Color == clLime) {

                     pnlSystemMessage->Caption = "Cassette Load(8吋): YuanLi RFID...";
                     if(WaitYuanliCmd(CMD_RFID) != CMD_ACK_E) {
                        pnlAlarmMessage->Caption = "YuanLi RFID(8吋)傳送異常!";
                        WriteSystemLog(pnlAlarmMessage->Caption);
                     }
                     pnlSystemMessage->Caption = "";
                  }
                  // 2021 12 25 - chc 移到前面
                  //scode = msg.SubString(8,len-9);
                  //pnlCSTCode->Caption = scode;

               }

               // 2023 8 2 - chc Error
               else {
                  pnlCSTCode->Caption = "--------";
                  pnlSECSCST2ID->Caption = pnlCSTCode->Caption;
               }

               // 2021 9 8a - chc Log
               WriteSystemLog("RFID28(實際)讀回 " + msg);
               boolRFIDRead = true;

            }
         }
         // 012345678901234567890       => 21
         //        S                    => 7
         if(sno > 0) {
            for(int i=0 ; i<Buf28No-sno-1 ; i++)
               Buf28[i] = Buf28[i+sno+1];
            Buf28No -= (sno+1);
         }
      }

   // 先不管
   //}

   pnlRFID->Enabled = true;
   pnlRFIDOperation->Caption = "Idle";
   pnlRFIDOperation->Refresh();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze
// RFID
AnsiString ReplyStrRFID212 = "";
char Buf212[1024];
int Buf212No = 0;
void __fastcall TMainForm::ybRFID212CommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[1024+1],c;
AnsiString msg;
int len,pos,n,readno;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = 0;
      while(1) {
         readno = ybRFID212->Read(&c,1);
         if(readno == 0)
            break;
         // >10才放入buffer, 否則為Control code
         if(c > 10) {
            Buf212[Buf212No++] = c;
            n++;
         }
         Sleep(1);
      }
      if(Buf212No > 0) {
         pnlRFIDResult->Caption = "None";

         int sno = 0;
         for(int i=0 ; i<Buf212No ; i++) {
            // 0x0d
            if(Buf212[i] == END) {
               if(i == 0) {
                  Sleep(10);
                  continue;
               }
               sno = i;
               int rno = 0;
               for(int j=0 ; j<i ; j++) {
                  if(Buf212[j] > 10) {
                     Buf[rno++] = Buf212[j];
                  }
               }
               Buf[rno] = 0x0;
               msg.sprintf("%s",Buf);
               WriteSystemLog("RFID212: " + msg);
               pnlRFIDResult->Caption = msg;

               // 2023 8 2 - chc 尚未截取
               //pnlSECSCST2ID->Caption = msg;

               AddRFIDMessage("[<] 212: " + msg);

               // 2021 10 15 - chc 顯示CST ID
               int len = msg.Length();
               AnsiString scode;

               // 02200OKEE3Q076156
               // 12345678901234567890
               // 前面7碼是Header, 後面2碼是CheckSum
               // 2021 12 18 - chc 裡面要有OK, 也要送給Yuanli
               //if(len > 15) {
               // 2023 1 4 - chc 分離RFID-Yuanli
               //if(len > 15 && msg.Pos("OK") > 0 && pnlOlympusStatus->Color == clLime) {
               if(len > 15 && msg.Pos("OK") > 0) {

                  // 2021 12 25 - chc 移到前面
                  scode = msg.SubString(8,len-9);
                  pnlCSTCode->Caption = scode;

                  // 2023 8 2 - chc 已截取
                  pnlSECSCST2ID->Caption = pnlCSTCode->Caption;

                  // 2023 1 4 - chc 分離
                  if(pnlOlympusStatus->Color == clLime) {

                     pnlSystemMessage->Caption = "Cassette Load(12吋): YuanLi RFID...";
                     if(WaitYuanliCmd(CMD_RFID) != CMD_ACK_E) {
                        pnlAlarmMessage->Caption = "YuanLi RFID(12吋)傳送異常!";
                        WriteSystemLog(pnlAlarmMessage->Caption);
                     }
                     pnlSystemMessage->Caption = "";
                  }
                  // 2021 12 25 - chc 移到前面
                  //scode = msg.SubString(8,len-9);
                  //pnlCSTCode->Caption = scode;

               }

               // 2023 8 2 - chc Read Error
               else {
                  pnlCSTCode->Caption = "--------";
                  pnlSECSCST2ID->Caption = pnlCSTCode->Caption;
               }

               // 2021 9 8a - chc Log
               WriteSystemLog("RFID212(實際)讀回 " + msg);
               boolRFIDRead = true;

            }
         }
         // 012345678901234567890       => 21
         //        S                    => 7
         if(sno > 0) {
            for(int i=0 ; i<Buf212No-sno-1 ; i++)
               Buf212[i] = Buf212[i+sno+1];
            Buf212No -= (sno+1);
         }
      }

   // 先不管
   //}

   pnlRFID->Enabled = true;
   pnlRFIDOperation->Caption = "Idle";
   pnlRFIDOperation->Refresh();
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc SetupEFEMSocket
void __fastcall TMainForm::SetupEFEMSocket()
{

   // 2021 4 26 - chc 改成Client
   // @@ 暫
   //ssYuanliSocket->Port = YuanliPort;
   //ssYuanliSocket->Active = true;

   csYuanliSocket->Port = YuanliPort;
   csYuanliSocket->Address = "192.168.0.3";
   csYuanliSocket->Active = true;

   // Aligner尚未init
   boolAlignerInit = false;
   csAlignerSocket->Port = 12100;
   csAlignerSocket->Address = "172.20.9.161";
   csAlignerSocket->Active = true;

   // Robot Socket : 172.20.9.151 / 12100
   // Robot尚未init
   boolRobotInit = false;
   csRobotSocket->Port = 12100;
   csRobotSocket->Address = "172.20.9.151";
   csRobotSocket->Active = true;
   //ssRobotSocket->Active = true;

   // LoadPort1
   boolLoadPort1Init = false;
   csLoadPort1Socket->Port = 12100;
   csLoadPort1Socket->Address = "172.20.9.101";
   csLoadPort1Socket->Active = true;
   // LoadPort2
   boolLoadPort2Init = false;
   csLoadPort2Socket->Port = 12100;
   csLoadPort2Socket->Address = "172.20.9.102";
   csLoadPort2Socket->Active = true;

   // RFID
   InitRFIDCom();

   // SECS init
   ssSECSSocket->Port = 5900;
   ssSECSSocket->Active = true;

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc YuanLi Socket
void __fastcall TMainForm::ssYuanliSocketClientConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlSocketConnect->Color = clLime;
   pnlOlympusStatus->Color = clLime;
   btnYuanliSend->Enabled = true;

   // 2023 2 21 - chc 取消
   if(pnlMoving->Caption == "YuanLi未連線")
      pnlMoving->Visible = false;

}
//---------------------------------------------------------------------------
// 2021 4 11 - chc YuanLi Socket
void __fastcall TMainForm::ssYuanliSocketClientDisconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlSocketConnect->Color = clSilver;
   pnlOlympusStatus->Color = clSilver;
   pnlSocketReady->Color = clSilver;
   btnYuanliSend->Enabled = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::combRFIDComportChange(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   RFIDComPort = combRFIDComport->ItemIndex + 1;
   pSystemFile->WriteInteger("Yuanli","RFID Com Port"                           ,RFIDComPort);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2021 4 11 - chc Rorze EFEM setup
void __fastcall TMainForm::btnRorzeEFEMSetupClick(TObject *Sender)
{

   if(SetupEFEM() == false) {
      pnlEFEMReady->Color = clRed;
      pnlSystemMessage->Caption = "EFEM Error! Unable to work.";
   }
   else {
      pnlEFEMReady->Color = clLime;
      pnlSystemMessage->Caption = "EFEM正常! 系統Ready.";
   }
}
//---------------------------------------------------------------------------
// 2021 4 19 - chc PCI-7856(APS_)
void __fastcall TMainForm::AxisSVON()
{
int hslret;
int rdycnt = 0;

   // I/O: 在InitMotion()中已建立
   if(bool_IO_Status == true) {
      // 初始Input點
      for(int i=0 ; i<16 ; i++)
         HSL_IO_InStatus[i] = false;
      // DO Reset 0
      MainForm->WriteSystemLog(">Motion : Reset DO");
      InitDO(1);
   }

   // 啟動Timer
   if(bool_IO_Status == true && tmMotionPolling->Enabled == false) {
      tmMotionPolling->Enabled = true;
      MainForm->WriteSystemLog(">Motion : DIO ok, Polling");
   }

   Sleep(500);
   // 啟動Motion: Servo on
   if(bool_APS_Status == true) {
      for(int axisno=0 ; axisno<MAX_AXIS_NO ; axisno++) {
         if(DOServoOnOff(axisno,3) == true)
            rdycnt++;
      }
   }

   if(rdycnt >= MAX_AXIS_NO) {

      // 2021 6 11 - chc 要到SVON後才能做
      if(CheckCDAVacuum() == false) {
         pnlAxisError->Caption = "CDA或Vacuum異常(無法作業)! 請重新啟動系統.";
         pnlAxisError->Visible = true;
         pnlSystemMessage->Caption = pnlAxisError->Caption;
      }
      else {
         pnlHome2->Visible = true;

         // 先等候SVON才做Home
         btnHome->Enabled = true;
         pnlStartMessage->Visible = true;
         pnlStartMessage->Caption = "Please execute homing...";
      }
   }
   else {
      btnHome->Enabled = false;
      pnlAxisError->Caption = "軸控異常(無法SVON)! 請重新啟動系統.";
      pnlAxisError->Visible = true;
      pnlSystemMessage->Caption = pnlAxisError->Caption;
   }

   // 軸編號: 0~5
   CurrentAxisNo = X_AXIS;
   combAxis->ItemIndex = 0;
}
//---------------------------------------------------------------------------
// 2021 4 19 - chc 先SERVO off, DO off 再 DO on, SERVO on
bool __fastcall TMainForm::DOServoOnOff(int axisno, int cnt)
{
I32 io_sts;

   // 2021 8 23 - chc 要先做一次
   io_sts = APS_motion_io_status(axisno+StartAxisNo);

   // 連做三次
   for(int i=0 ; i<cnt ; i++) {
      // Alm(Bit0): Fail
      if(io_sts & 0x0001) {
         MainForm->WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " ALM! 不做SVON.");
         // Servo Off
         APS_set_servo_on(axisno+StartAxisNo, 0);
         return false;
      }
      // Servo On
      APS_set_servo_on(axisno+StartAxisNo, 1);
      DelayTime(500);

      // 確認RDY(Bit8): IO Status
      io_sts = APS_motion_io_status(axisno+StartAxisNo);
      // 2021 4 23 - chc 也要檢查SVON: (io_sts & 0x0080)
      //if((io_sts & 0x0100) != 0) {
      //   MainForm->WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " RDY.");
      if((io_sts & 0x0100) != 0 && (io_sts & 0x0080) != 0) {
         MainForm->WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " RDY,SVON.");

         return true;
      }

      MainForm->WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " Not Ready! 再做一次.");
      // Servo Off
      APS_set_servo_on(axisno+StartAxisNo, 0);
      // 連做三次; 間隔1500ms
      DelayTime(1500);
   }
   MainForm->WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " SVON無法RDY!");
   // Servo Off
   APS_set_servo_on(axisno+StartAxisNo, 0);
   return false;

}
//---------------------------------------------------------------------------
// 2021 4 21 - chc
void __fastcall TMainForm::btnSaveWPositionClick(TObject *Sender)
{
TIniFile *pSystemFile;

   // ini檔名與目錄
   pSystemFile = new TIniFile(RobotWINIFilename);

   TLMDEdit *edit;
   for(int no=0 ; no<MAX_W_POSITION ; no++) {
      // 不區分8"/12"
      edit = (TLMDEdit *)(FindComponent("edWPosition" + IntToStr(no+1)));
      WPositionSet[no] = edit->Text.ToInt();
      pSystemFile->WriteInteger(ROBOTW_PARAMETER_SECTION,"W Position" + IntToStr(no+1)    ,WPositionSet[no]);
   }

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc Rorze
void __fastcall TMainForm::btnAlignerSaveRClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pnlSystemMessage->Caption = "Aligner參數更新中...";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   // Aligner
   AlignerSize = rgWaferSize->ItemIndex;
   pSystemFile->WriteInteger("Aligner Parameter" ,"Size"                        ,AlignerSize);
   AlignerDegree = rgWaferDegree->ItemIndex;
   pSystemFile->WriteInteger("Aligner Parameter" ,"Degree"                      ,AlignerDegree);

   delete pSystemFile;
   pnlSystemMessage->Caption = "Aligner: Parameter update complete.";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------

/*
X/Y/Z/T => 軸位改回來, 原是Z/T/L
Y: 前後, X:左右,

imCCD: DFKG33274(Color) + ScrollBar(H/V)

Chip Mapping

Motion: 6軸 X/Y/Z/T(Arc)/L/W(RX)

SECS/GEM

YuanLi

Run: 5點

Robot取放片動作: 8"/12"

RFID讀取?

Blue Lamp Meaning>
*/




//---------------------------------------------------------------------------
// 2021 4 21 - chc W
void __fastcall TMainForm::btnBackwardWClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為W軸, 做後退動作
   combAxis->ItemIndex = W_AXIS;
   btnBackwardClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc W
void __fastcall TMainForm::btnBackwardWMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = W_AXIS;
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc W
void __fastcall TMainForm::btnBackwardWMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc W
void __fastcall TMainForm::btnMoveWClick(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   // 設定為W軸, 做後退動作
   combAxis->ItemIndex = W_AXIS;
   btnMoveClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc W
void __fastcall TMainForm::btnMoveWMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = W_AXIS;
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc W
void __fastcall TMainForm::btnMoveWMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc 指定7/8/9/10何者為Enable/Disable
void __fastcall TMainForm::pnlJoystick7Click(TObject *Sender)
{

   JoystickEnabledKey = 7;
   SetJoystickEnabledKey();
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc 指定7/8/9/10何者為Enable/Disable
void __fastcall TMainForm::pnlJoystick8Click(TObject *Sender)
{

   JoystickEnabledKey = 8;
   SetJoystickEnabledKey();
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc 指定7/8/9/10何者為Enable/Disable
void __fastcall TMainForm::pnlJoystick9Click(TObject *Sender)
{

   JoystickEnabledKey = 9;
   SetJoystickEnabledKey();
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc 指定7/8/9/10何者為Enable/Disable
void __fastcall TMainForm::pnlJoystick10Click(TObject *Sender)
{

   JoystickEnabledKey = 10;
   SetJoystickEnabledKey();
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc 指定7/8/9/10何者為Enable/Disable
void __fastcall TMainForm::rgJoystickEnabledChange(TObject *Sender,
      int ButtonIndex)
{
TIniFile *pSystemFile;

   JoystickEnabledMode = rgJoystickEnabled->ItemIndex;
   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Joystick Enable Mode"   ,rgJoystickEnabled->ItemIndex);
   delete pSystemFile;

   SetJoystickEnabledName();
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc 指定7/8/9/10何者為Enable/Disable
void __fastcall TMainForm::SetJoystickEnabledKey()
{
TIniFile *pSystemFile;

   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(MainForm->SystemINIFilename);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Joystick Enable Key"   ,JoystickEnabledKey);
   delete pSystemFile;

   SetJoystickEnabledName();
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc 指定7/8/9/10何者為Enable/Disable
void __fastcall TMainForm::SetJoystickEnabledName()
{
AnsiString msg;
TLabel *label;

   for(int i=7 ; i<=10 ; i++) {
      msg.sprintf("%d",i);
      if(i == JoystickEnabledKey || JoystickEnabledMode == 1)
         msg += "(切換)";
      label = (TLabel*)(FindComponent("laJoystick" + IntToStr(i)));
      label->Caption = msg;
   }
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc T Move
void __fastcall TMainForm::btnMoveT1Click(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   combAxis->ItemIndex = T_AXIS;
   btnMoveClick(this);

}
//---------------------------------------------------------------------------
// 2021 4 21 - chc T Move
void __fastcall TMainForm::btnMoveT1MouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = T_AXIS;

   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc T Move
void __fastcall TMainForm::btnMoveT1MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2021 4 21 - chc 立即停止
   pnlAlarmMessage->Caption = "T軸停止.";
   pnlAlarmMessage->Refresh();
   StopOneAxis(T_AXIS);

}
//---------------------------------------------------------------------------
// 2021 4 21 - chc T Back
void __fastcall TMainForm::btnBackwardT1Click(TObject *Sender)
{

   if(cbContinueMove->Checked == true)
      return;

   combAxis->ItemIndex = T_AXIS;
   btnBackwardClick(this);
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc T Back
void __fastcall TMainForm::btnBackwardT1MouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = T_AXIS;
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// 2021 4 21 - chc T Back
void __fastcall TMainForm::btnBackwardT1MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // 2021 4 21 - chc 立即停止
   pnlAlarmMessage->Caption = "T軸停止.";
   pnlAlarmMessage->Refresh();
   StopOneAxis(T_AXIS);
}
//---------------------------------------------------------------------------
// 2021 9 27 - chc 原點位置
int GridNoX;
int GridNoY;

// 2021 8 24 - chc 偏移量
int COffsetX,COffsetY;
// 2021 4 23 - chc Wafer Mapping
void __fastcall TMainForm::imWaferMapMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy;

   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imWaferMap->Canvas->Pixels[X][Y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = X + sx;
   pnlCCDY->Caption = Y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",X,Y);
   sbSystemMessage->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystemMessage->Panels->Items[4]->Text = str;
   if(Wafer.boolSet == true) {
      int col,row;

      // 2021 8 24 - chc 偏移量
      //col = (X - Wafer.X) / Wafer.Dx;
      //row = (Y - Wafer.Y) / Wafer.Dy;
      col = (X - COffsetX - Wafer.X) / Wafer.Dx;
      row = (Y - COffsetY - Wafer.Y) / Wafer.Dy;
      if(X < (COffsetX + Wafer.X))
         col = -1;
      if(Y < (COffsetY + Wafer.Y))
         row = -1;

      // 2021 9 27 - chc 原點位置: GridNoY
      // 下: 180
      if(rgWaferDegree->ItemIndex == 2) {
         row = GridNoY - row - 1;

         // 2021 12 15 - chc 最小Row,Col
         col -= MinCol;
         row -= (GridNoY - MinRow - 1);

      }

      pnlColum->Caption = IntToStr(col);
      pnlRow->Caption = IntToStr(row);
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbZoomChange(TObject *Sender)
{
int no;
double fw,fh;

   //DrawBigImage();
   return;

   // 1 - 100
   no = tbZoom->Position;
   fw = (double)ZoomW / (100.0 / no);
   fh = (double)ZoomH / (100.0 / no);
   imWaferMap->Width = (int)fw;
   imWaferMap->Height = (int)fh;
}
//---------------------------------------------------------------------------
// 2021 4 23 - chc 測試Load Big Image
int ZoomW,ZoomH;
void __fastcall TMainForm::LoadFromFile()
{
int no,width,height,sx,sy,x,y,w,h;
AnsiString fname;

DoubleBuffered = true;
sbWaferMap->DoubleBuffered = true;

   opCCDImage->InitialDir = BaslerBitmapDirectory;
   if(opCCDImage->Execute()) {
      fname = opCCDImage->FileName;
      if(FileExists(fname)) {
         imWaferMap->Stretch = true;
         imWaferMap->AutoSize = true;
         imWaferMap->Picture->LoadFromFile(fname);
         w = imWaferMap->Picture->Bitmap->Width;
         h = imWaferMap->Picture->Bitmap->Height;
         ZoomW = w;
         ZoomH = h;
         pnlSystemMessage->Caption = "W,H-w,h=" + IntToStr(w) + "," + IntToStr(h) + "-" + IntToStr(imWaferMap->Width) + "," + IntToStr(imWaferMap->Height);
         imWaferMap->AutoSize = false;
         imWaferMap->Width = w / 2;
         imWaferMap->Height = h / 2;
         tbZoom->Position = 50;
         pnlAlarmMessage->Caption = "W,H-w,h=" + IntToStr(imWaferMap->Picture->Bitmap->Width) + "," + IntToStr(imWaferMap->Picture->Bitmap->Height) + "-" + IntToStr(imWaferMap->Width) + "," + IntToStr(imWaferMap->Height);
      }
   }
}
//---------------------------------------------------------------------------
// 2021 4 23 - chc 測試Load Big Image
// 12": 304.8mm
// Wafer: 708*708
// 外框: 864*725
// 300mm(12") => 430um/Pixel
// 5000*5000 => 11*11
// 目前外框: 1207*921
//
// 2021 6 16 - chc 存dx,sx,dy,sy
int MapOutDx;
int MapOutSx;
int MapOutDy;
int MapOutSy;
int MapCode[1000][1000];
#define MAX_ROW_NO      1000
#define MAX_COL_NO      1000
// 5 - 指定位置,紫
// 4 - 量測點(紅)
// 3 - Testable(綠)
// 2 - Type(2-half),黑
// 1 - Type(1-Out),黃
// 0 - Initial
// type: 0-Inner, 1-Out, 2-half
//
//
void __fastcall TMainForm::DrawBigImage()
{
int no,width,height,sx,sy,x,y,w,h,cx,cy,dx,dy,bw,bh,iw,ih,bx,by,ncx,ncy;
AnsiString fname,msg;

DoubleBuffered = true;
sbWaferMap->DoubleBuffered = true;
TRect Rect;
int factor = 2;

// 2021 6 15 - chc Die的起點: 依Die方向決定
int diex,diey;
bool boolfirst = true;

// 2021 10 24 - chc 第一次呼叫InMeasure
bool boolinmeasure = true;

// 2021 12 15 - chc 最小Row,Col
int minrow,mincol,maxrow,maxcol,minsx,minsy,minex,miney;
minrow = -1;
mincol = -1;
maxrow = -1;
maxcol = -1;

   if(boolfirst == true) {
      //boolfirst = false;
      for(int i=0 ; i<MAX_ROW_NO ; i++) {
         for(int j=0 ; j<MAX_COL_NO ; j++) {
            MapCode[i][j] = 0;
         }
      }
   }

   tsWaferMap->Enabled = false;
   factor = tbZoom->Position;
   imWaferMap->Picture->Bitmap->PixelFormat = pf4bit;

   // bw,bh: imWaferMap的大小
   bw = sbWaferMap->Width;
   bh = sbWaferMap->Height;

   // 304800 / 5000 = 60.96 => 61格, 正負2格共65格 => 畫在1207*921內
   // 限在850以內 => 850/65=13.07, 取整數13點
   // 原始影像: 65*13=845*845
   int gridnox,gridnoy,diew,dieh,ix,iy;
   double fx,fy;

   // 2021 6 16 - chc 改成小數及加入切割道: edDieSizeGapX
   //diew = edDieSizeX->Text.ToInt();
   //dieh = edDieSizeY->Text.ToDouble();
   diew = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
   dieh = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();

   // 2021 6 15 - chc 是300, 內縮6(左右各3mm)
   //gridnox = 304800 / diew + 4;
   //gridnoy = 304800 / dieh + 4;
   //fx = 304800.0 / diew;
   //ix = 304800.0 / diew;
   //if(fx > ix)
   //   gridnox++;
   //fy = 304800.0 / dieh;
   //iy = 304800.0 / dieh;
   //if(fy > iy)
   //   gridnoy++;
   double diameter = 300000;

   // 2021 11 26 - chc ignore改成8000
   //double ignore = 3000;
   double ignore = edIgnore->Text.ToInt();

   double realr = diameter - (ignore * 2);

   // 置中
   // 2021 8 23 - chc 固定為置中
   //if(rgWaferDieDirection->ItemIndex == 0) {
   if(true) {

      gridnox = (realr - diew) / diew + 1;
      gridnoy = (realr - dieh) / dieh + 1;

      // 2021 9 30 - chc Log
      msg.sprintf("realr,diew,dieh,nox,noy=%.1f,%d,%d,%d,%d",realr,diew,dieh,gridnox,gridnoy);
      WriteSystemLog(msg);

      // 2021 6 23 - chc 依計算值
      //gridnox = ((realr - diew) / diew)/2*2 + 1;
      //gridnoy = ((realr - dieh) / dieh)/2*2 + 1;
      int tmp;
      tmp = realr - diew;
      tmp = tmp / diew;
      tmp /= 2;
      tmp *= 2;
      tmp++;
      gridnox = tmp;
      tmp = realr - dieh;
      tmp = tmp / dieh;
      tmp /= 2;
      tmp *= 2;
      tmp++;
      gridnoy = tmp;
      // 外擴
      gridnox += 2;
      gridnoy += 2;

   }
   // 左上
   else if(rgWaferDieDirection->ItemIndex == 1) {
      gridnox = realr / diew;
      gridnoy = realr / dieh;
   }
   // 左下
   else if(rgWaferDieDirection->ItemIndex == 2) {
      gridnox = realr / diew;
      gridnoy = ((int(realr / 2)) / dieh) * 2 ;
   }
   // 右上
   else if(rgWaferDieDirection->ItemIndex == 3) {
      gridnox = ((int(realr / 2)) / diew) * 2 ;
      gridnoy = realr / dieh;
   }
   else {
      gridnox = ((int(realr / 2)) / diew) * 2 ;
      gridnoy = ((int(realr / 2)) / dieh) * 2 ;
   }
   // 2021 6 16 - chc 暫不用
   //fx = realr / diew;
   //ix = realr / diew;
   //if(fx > ix)
   //   gridnox += 2;
   //fy = realr / dieh;
   //iy = realr / dieh;
   //if(fy > iy)
   //   gridnoy += 2;

   // dx,dy: Die的實際大小(有倍率)
   dx = (850*factor) / gridnox;
   dy = (850*factor) / gridnoy;
   // width,height: Mapper圖的實際大小(有倍率)
   width = gridnox * dx;
   height = gridnoy * dy;

   // 2021 9 27 - chc 原點位置: GridNoY
   GridNoX = gridnox;
   GridNoY = gridnoy;

   // 100% - Full Wafer(12")
   // 影像框
   // Factor
   if(factor > 1) {
      // bx,by影像框起點: 有倍率則是(0,0)就可以開始畫
      bx = by = 0;
      // 整個imWaferMap區域均可以畫
      imWaferMap->Width = bw;
      imWaferMap->Height = bh;
      imWaferMap->Picture->Bitmap->Width = width;
      imWaferMap->Picture->Bitmap->Height = height;
      // iw,ih: 外擴: imWaferMap的繪圖區域
      iw = width;
      ih = height;
   }
   else {
      // iw,ih: 外擴: imWaferMap的繪圖區域
      iw = width + (bw - width) / 2;
      ih = height + (bh - height) /2;
      // imWaferMap內某區域內可以畫
      imWaferMap->Width = iw;
      imWaferMap->Height = ih;
      // bx,by影像框起點
      bx = (bw - iw) / 2;
      by = (bh - ih) / 2;
      imWaferMap->Picture->Bitmap->Width = iw * factor;
      imWaferMap->Picture->Bitmap->Height = ih * factor;

      // 2021 6 15 - chc Die的起點: 依Die方向決定
      // 置中
      if(rgWaferDieDirection->ItemIndex == 0) {
         diex = 0;
         diey = 0;
      }

      // 2021 6 23 - chc 正中
      bx = 0;
      by = 0;

   }

   imWaferMap->Top = by;
   imWaferMap->Left = bx;
   // sx,sy: die起點
   // iw,ih: 外擴: imWaferMap的繪圖區域
   // width,height: Mapper圖的實際大小(有倍率)
   // => sx,sy會改變Notch位置
   sx = (iw - width) / 2;
   sy = (ih - height) / 2;

   // 2021 6 23 - chc 正中
   // => 不需要
   //sx -= dx/2;
   //sy -= dy/2;

// 2021 12 9 - chc for Test
// 2021 12 18 - chc 先不用
//if(boolForTest == true) {
//   pnlCenterXFind->Caption = "0";
//   pnlCenterYFind->Caption = "0";
//   pnlWaferDieCenterX->Caption = "0";
//   pnlWaferDieCenterY->Caption = "0";
//}

   // 2021 10 6 - chc 若未定義用尋找中心
   // => 若偏移量太大就不做偏移量就好
   //if(pnlWaferDieCenterX->Caption == "0")
   //   pnlWaferDieCenterX->Caption = pnlCenterXFind->Caption;
   //if(pnlWaferDieCenterY->Caption == "0")
   //   pnlWaferDieCenterY->Caption = pnlCenterYFind->Caption;

   // 2021 8 24 - chc 計算Die中心/Wafer中心的偏移Pixel數
   // 1. 放入Wafer
   // 2. 找Wafer中心(cx,cy)
   // 3. 定中心Die的中心(dx,dy)
   // 4. 以Wafer中心畫出Wafer Mapping圖
   // 5. 標示Wafer中心與Die中心
   // 6.
   double coffsetx,coffsety;
   if(pnlCenterXFind->Caption == "" || pnlCenterXFind->Caption == "0")
      pnlCenterXFind->Caption = pnlWaferDieCenterX->Caption;
   if(pnlCenterYFind->Caption == "" || pnlCenterYFind->Caption == "0")
      pnlCenterYFind->Caption = pnlWaferDieCenterY->Caption;
   coffsetx = pnlWaferDieCenterX->Caption.ToInt() - pnlCenterXFind->Caption.ToInt();
   coffsety = pnlWaferDieCenterY->Caption.ToInt() - pnlCenterYFind->Caption.ToInt();

   // diew,diew: um
   // dx,dy: 每Die的Pixel數量
   // 偏移量(pulse)轉成um
   coffsetx *= X_RESOLUTION;
   coffsety *= Y_RESOLUTION;
   while(coffsetx > diew) {
      coffsetx -= diew;
   }
   while(coffsety > dieh) {
      coffsety -= dieh;
   }

   // 2021 10 6 - chc 若偏移量太大就不做偏移量就好
   if(fabs(coffsetx) > diew)
      coffsetx = 0;
   if(fabs(coffsety) > dieh)
      coffsety = 0;

   // 偏移量(um)轉成Pixel
   coffsetx = coffsetx * dx / (double)diew;
   coffsety = coffsety * dy / (double)dieh;
   coffsetx = 0 - coffsetx;
   coffsety = 0 - coffsety;
   // 2021 8 24 - chc 由Die中心點往外畫格線
   // sx,xy: 是整個Grid在TImage畫的開始位置與Die所在位置無關

   // 正常不可有
   //coffsetx = coffsety = 5;                                                     // ==> For Test

   coffsetx *= factor;
   coffsety *= factor;
   COffsetX = coffsetx;
   COffsetY = coffsety;

   Wafer.X = sx;
   Wafer.Y = sy;
   Wafer.Dx = dx;
   Wafer.Dy = dy;
   Wafer.boolSet = true;

   // 2021 8 24 - chc 計算中心Die的Col,Row: CenterDieCol,CenterDieRow
   // 直徑: realr(um)
   // diew,diew: um
   int real_cx,real_cy,centerdie_x,centerdie_y;
   double diffx,diffy;
   // pulse
   real_cx = pnlCenterXFind->Caption.ToInt();
   real_cy = pnlCenterYFind->Caption.ToInt();
   centerdie_x = pnlWaferDieCenterX->Caption.ToInt();
   centerdie_y = pnlWaferDieCenterY->Caption.ToInt();
   diffx = centerdie_x - real_cx;
   diffy = centerdie_y - real_cy;

   // 2021 10 24 - chc 只要有一者為0就無偏移
   if(real_cx == 0 || real_cy == 0 || centerdie_x == 0 || centerdie_y == 0) {
      diffx = 0;
      diffy = 0;
   }

   diffx = 0 - diffx;
   diffy = 0 - diffy;
   // pulse to um
   diffx *= X_RESOLUTION;
   diffy *= Y_RESOLUTION;
   //
   fx = realr / 2 + diffx;
   fy = realr / 2 + diffy;

   // 2021 12 18 - chc 中心點在Die的中心點上
   //CenterDieCol = fx / diew;
   //CenterDieRow = fy / dieh;
   CenterDieCol = (fx + diew/2) / diew;
   CenterDieRow = (fy + dieh/2) / dieh;

   // 2021 12 18 - chc 最小Row,Col: 切換Recipe後MinCol/MinRow第一次的DrawBigImage()不會有值 => 要呼叫兩次(否則無法畫出中心Die位置-藍色)
   if(MinCol != -1)
      CenterDieCol -= MinCol;
   if(MinRow != -1)
      CenterDieRow -= (GridNoY - MinRow - 1);

   pnlCenterCol->Caption = IntToStr(CenterDieCol);
   pnlCenterRow->Caption = IntToStr(CenterDieRow);

   // Zoom Bar
   // 202 4 27 - chc 不動
   //tbZoom->Top = sbWaferMap->Top + imWaferMap->Top + sy;
   //tbZoom->Left = sbWaferMap->Left + sbWaferMap->Width - tbZoom->Width - 10;
   //if(factor > 1)
   //   tbZoom->Height = sbWaferMap->Height;
   //else
   //   tbZoom->Height = imWaferMap->Height - sy*2;

   if(tbZoom->Visible == false)
      tbZoom->Visible = true;
   // 中心
   cx = iw / 2;
   cy = ih / 2 + 1;

   // 清空
   imWaferMap->Canvas->Brush->Color = clSilver;
   Rect.left = 0;
   Rect.top = 0;
   Rect.Right = iw - 1;
   Rect.Bottom = ih - 1;
   imWaferMap->Canvas->FillRect(Rect);
   // 畫外框
   imWaferMap->Canvas->Pen->Color = clNavy;
   imWaferMap->Canvas->Pen->Width = 2;
   imWaferMap->Canvas->MoveTo(0,0);
   imWaferMap->Canvas->LineTo(0,ih-1);
   imWaferMap->Canvas->LineTo(iw-1,ih-1);
   imWaferMap->Canvas->LineTo(iw-1,0);
   imWaferMap->Canvas->LineTo(0,0);

   // 格線
   imWaferMap->Canvas->Pen->Width = 1;
   imWaferMap->Canvas->Pen->Color = clBlack;
   // 2021 8 24 - chc 由Die中心點往外畫格線
   //for(int col=0 ; col<width ; col+=dx) {
   //  imWaferMap->Canvas->MoveTo(sx+col,sy+0);
   //  imWaferMap->Canvas->LineTo(sx+col,sy+height-1);
   //}
   //for(int row=0 ; row<height ; row+=dy) {
   //  imWaferMap->Canvas->MoveTo(sx+0,sy+row);
   // imWaferMap->Canvas->LineTo(sx+width-1,sy+row);
   //}
   for(int col=coffsetx ; col<width ; col+=dx) {
     imWaferMap->Canvas->MoveTo(sx+col,sy+0);
     imWaferMap->Canvas->LineTo(sx+col,sy+height-1);
   }
   for(int row=coffsety ; row<height ; row+=dy) {
     imWaferMap->Canvas->MoveTo(sx+0,sy+row);
     imWaferMap->Canvas->LineTo(sx+width-1,sy+row);
   }

   // 2021 6 23 - chc realr
   diameter = realr;

   // 畫圓: 300
   // X
   // 65*5000=325000
   // (325000 - 300000) / 2 = 12500
   // 325000 / width(845) = 384.65um/Pixel
   // 起點: 12500 / 384.65 = 32.49 => 取整數32
   // 總點數=300000 / 384.65 = 779.929 => 取整數779
   int esx,esy,ew,eh,maxw,maxh;
   double px,py;
   maxw = gridnox * diew;
   px = (double)maxw / width;

   // 2021 6 15 - chc 是300, 內縮6(左右各3mm): diameter
   //esx = ((double)(maxw - 300000) / 2) / px;
   //ew = 300000.0 / px;
   esx = ((double)(maxw - diameter) / 2) / px;
   ew = diameter / px;

   ew++;
   maxh = gridnoy * dieh;
   py = (double)maxh / height;

   // 2021 6 15 - chc 是300, 內縮6(左右各3mm): diameter
   //esy = ((double)(maxh - 300000) / 2) / py;
   //eh = 300000.0 / py;
   esy = ((double)(maxh - diameter) / 2) / py;
   eh = diameter / py;

   eh++;

   // 2021 12 9 - chc for test: esx1,ew1,esy1,eh1
   int esx1,esy1,ew1,eh1,maxw1,maxh1;
   double diameter1 = 300000;
   double realr1 = 300000;
   diameter1 = realr1;
   double px1,py1;
   maxw1 = gridnox * diew;
   px1 = (double)maxw1 / width;
   esx1 = ((double)(maxw1 - diameter1) / 2) / px1;
   ew1 = diameter1 / px1;
   ew1++;
   maxh1 = gridnoy * dieh;
   py1 = (double)maxh1 / height;
   esy1 = ((double)(maxh1 - diameter1) / 2) / py1;
   eh1 = diameter1 / py1;
   eh1++;

   // 各格狀態
   imWaferMap->Canvas->Pen->Color = clBlack;
   int gsx,gex,gsy,gey;
   double r,dsx,dex,dsy,dey,nr,rx,ry;
   double dsx1,dex1,dsy1,dey1;
   double squarex,squarey,squarexy;
   double fsx,fex,fsy,fey;
   int testno,inkno,skipno;
   ncx = cx;
   ncy = (sy+esy-6 + sy+esy+8) / 2;
   nr = (double)((sy+esy+8) - (sy+esy-6)) / 2;
   // 半徑
   // 2021 6 15 - chc 是300, 內縮6(左右各3mm): diameter
   //r = (300000 / 2) / px;
   //rx = (300000 / 2) / px;
   //ry = (300000 / 2) / py;
   r = (diameter / 2) / px;
   rx = (diameter / 2) / px;
   ry = (diameter / 2) / py;

   squarex = rx * rx;
   squarey = ry * ry;
   squarexy = squarex * squarey;
   // 每格四角距離是否均在r以內?
   imWaferMap->Canvas->Brush->Style = bsSolid;
   testno = inkno = skipno = 0;

   // 2021 6 16 - chc 存dx,sx,dy,sy
   MapOutDx = dx;
   MapOutSx = sx;
   MapOutDy = dy;
   MapOutSy = sy;

   for(int col=0 ; col<gridnox ; col++) {

      // 2021 8 24 - chc 由Die中心點往外畫格線
      //gsx = col * dx + sx;
      gsx = col * dx + sx + coffsetx;

      gex = gsx + dx + 1;
      // 縮小
      gsx++;
      gex--;
      for(int row=0 ; row<gridnoy ; row++) {

         // 2021 8 24 - chc 由Die中心點往外畫格線
         //gsy = row * dy + sy;
         gsy = row * dy + sy + coffsety;

         gey = gsy + dy + 1;
         // 縮小
         gsy++;
         gey--;

// 2021 12 9 - chc 重定
sy -= (dy/2);
cy -= (dy/2);

         // dsx(gsx,gsy)
         fx = abs(gsx - cx);
         fy = abs(gsy - cy);
         dsx = sqrt((fx*fx)+(fy*fy));
         dsx1 = squarey * (fx*fx) + squarex * (fy*fy);
         fsx = (fx*fx) / (rx*rx) + (fy*fy) / (ry*ry);
         // dex(gex,gsy)
         fx = abs(gex - cx);
         fy = abs(gsy - cy);
         dex = sqrt((fx*fx)+(fy*fy));
         dex1 = squarey * (fx*fx) + squarex * (fy*fy);
         fex = (fx*fx) / (rx*rx) + (fy*fy) / (ry*ry);
         // dsy(gsx,gey)
         fx = abs(gsx - cx);
         fy = abs(gey - cy);
         dsy = sqrt((fx*fx)+(fy*fy));
         dsy1 = squarey * (fx*fx) + squarex * (fy*fy);
         fsy = (fx*fx) / (rx*rx) + (fy*fy) / (ry*ry);
         // dey(gex,gey)
         fx = abs(gex - cx);
         fy = abs(gey - cy);
         dey = sqrt((fx*fx)+(fy*fy));
         dey1 = squarey * (fx*fx) + squarex * (fy*fy);
         fey = (fx*fx) / (rx*rx) + (fy*fy) / (ry*ry);

// 2021 12 9 - chc 重定
sy += (dy/2);
cy += (dy/2);

         //if(dsx <= r && dex <= r && dsy <= r && dey <= r) {
         //if(dsx1 <= squarexy && dex1 <= squarexy && dsy1 <= squarexy && dey1 <= squarexy) {
         if(fsx < 1 && fex < 1 && fsy < 1 && fey < 1) {
            // 綠色
            imWaferMap->Canvas->Brush->Color = (TColor)0x0002FF50;

            // 2021 12 15 - chc 最小Row,Col: minrow,mincol,minsx,minex,minsy,miney
            if(col < mincol || mincol == -1) {
               mincol = col;
               minsx = gsx;
               minex = gex;
            }
            if(row > minrow || minrow == -1) {
               minrow = row;
               minsy = gsy;
               miney = gey;
            }
            if(col > maxcol || maxcol == -1) {
               maxcol = col;
            }
            if(row > maxrow || maxrow == -1) {
               maxrow = row;
            }

            // 2021 6 16 - chc 量測點
            //if(MapCode[row][col] == 4)
            // 2021 10 24 - chc 第一次呼叫InMeasure
            //if(InMeasure(row,col) == true) {
            if(InMeasure(row,col,boolinmeasure) == true) {

               if(row < MAX_ROW_NO && col < MAX_COL_NO) {

                  // 2021 12 15 - chc 最小Row,Col
                  if(row < 0 || col < 0) {
                     int no;
                     no = 1;
                  }

                  MapCode[row][col] = 4;
               }
               imWaferMap->Canvas->Brush->Color = clRed;
            }

            // 2021 8 11 - chc 指定點
            else if(InSelect(row,col) == true) {
               if(row < MAX_ROW_NO && col < MAX_COL_NO) {

                  // 2021 12 15 - chc 最小Row,Col
                  if(row < 0 || col < 0) {
                     int no;
                     no = 1;
                  }

                  MapCode[row][col] = 5;
               }
               imWaferMap->Canvas->Brush->Color = clFuchsia;
            }

            // 2021 8 24 - chc Center Die
            // 2021 12 15 - chc 最小Row,Col
            //else if(InCenterDie(row,col) == true) {
            else if(InCenterDie1(row,col) == true) {

               if(row < MAX_ROW_NO && col < MAX_COL_NO) {

                  // 2021 12 15 - chc 最小Row,Col
                  // 下: 180
                  int r,c;
                  r = row;
                  c = col;
                  if(rgWaferDegree->ItemIndex == 2) {
                     r = GridNoY - row - 1;
                     c -= MinCol;
                     r -= (GridNoY - MinRow - 1);
                  }
                  if(CenterDieRow != r || CenterDieCol != c)
                     goto notcenter;
                  c = 0;

                  MapCode[row][col] = 6;
               }
               imWaferMap->Canvas->Brush->Color = clBlue;
            }

            else {
notcenter:
               // 2021 12 15a - chc 綠色
               imWaferMap->Canvas->Brush->Color = (TColor)0x0002FF50;

               // 填入code
               if(row < MAX_ROW_NO && col < MAX_COL_NO) {

                  // 2021 12 15 - chc 最小Row,Col
                  if(row < 0 || col < 0) {
                     int no;
                     no = 1;
                  }

                  MapCode[row][col] = 3;
               }
            }

            // 2021 10 24 - chc 第一次呼叫InMeasure
            boolinmeasure = false;

            // 外擴
            //imWaferMap->Canvas->Rectangle(gsx,gsy,gex,gey);
            imWaferMap->Canvas->Rectangle(gsx-1,gsy-1,gex+1,gey+1);
            testno++;
            if(factor > 3) {
               DrawRowCol(gsx,gsy,col,row,0,factor);
            }
         }
         //else if(dsx > r && dex > r && dsy > r && dey > r)
         //else if(dsx1 > squarexy && dex1 > squarexy && dsy1 > squarexy && dey1 > squarexy)
         else if(fsx > 1 && fex > 1 && fsy > 1 && fey > 1)
            continue;
         // 部份在邊界外, 檢查所有Pixel
         else {
            int outno,inno;
            double dis,dis1,fdis;
            outno = inno = 0;
            for(int col1=gsx ; col1<=gex ; col1++) {
               for(int row1=gsy ; row1<=gey ; row1++) {
                  fx = abs(col1 - cx);
                  fy = abs(row1 - cy);
                  dis = sqrt((fx*fx)+(fy*fy));
                  dis1 = squarey * (fx*fx) + squarex * (fy*fy);
                  fdis = (fx*fx) / (rx*rx) + (fy*fy) / (ry*ry);
                  //if(dis > r) {
                  //if(dis1 > squarexy) {
                  if(fdis > 1) {
                     outno++;
                  }
                  else {
                     // Notch
                     if((row >= 2 && row <= 4) && (col >= gridnox/2-2 && col <= gridnox/2+2)) {
                        fx = abs(col1 - ncx);
                        fy = abs(row1 - ncy);
                        dis = sqrt((fx*fx)+(fy*fy));
                        if(dis <= nr) {
                           outno++;
                           continue;
                        }
                     }

                     inno++;
                  }
               }
            }

// 2021 12 9 - chc 不畫黃與黑
/*
            if(outno >= inno) {
               // 黃色
               imWaferMap->Canvas->Brush->Color = (TColor)0x005BF7F2;    //0x007DFFFF;

               // 2021 6 16 - chc 填入code
               if(row < MAX_ROW_NO && col < MAX_COL_NO)
                  MapCode[row][col] = 1;

               // 外擴
               //imWaferMap->Canvas->Rectangle(gsx,gsy,gex,gey);
               imWaferMap->Canvas->Rectangle(gsx-1,gsy-1,gex+1,gey+1);
               skipno++;
               if(factor > 3) {
                  DrawRowCol(gsx,gsy,col,row,1,factor);
               }
            }
            else {
               // 黑色
               imWaferMap->Canvas->Brush->Color = clBlack;

               // 2021 6 16 - chc 填入code
               if(row < MAX_ROW_NO && col < MAX_COL_NO)
                  MapCode[row][col] = 2;

               // 外擴
               //imWaferMap->Canvas->Rectangle(gsx,gsy,gex,gey);
               imWaferMap->Canvas->Rectangle(gsx-1,gsy-1,gex+1,gey+1);
               inkno++;
               if(factor > 3) {
                  DrawRowCol(gsx,gsy,col,row,2,factor);
               }
            }
*/
         }
      }
   }
   pnlTestables->Caption = IntToStr(testno);
   pnlInkdies->Caption = IntToStr(inkno);
   pnlSkipdies->Caption = IntToStr(skipno);
   pnlTotaldies->Caption = IntToStr(testno+skipno+inkno);

   // 2021 12 15 - chc 最小Row,Col
   MinRow = minrow;
   MinCol = mincol;
   MaxRow = maxrow;
   MaxCol = maxcol;

   // 實際畫弧
   // The angles Angle and AngleLength are 1/16th of a degree. For example, a full circle equals 5760 (16*360).
   // Positive values of Angle and AngleLength mean counterclockwise while negative values mean clockwise direction.
   // Zero degrees is at the 3'o clock position.
   // Arc(int X, int Y, int W, int H, int Angle, int AngleLength);
   // -44 to 269
   imWaferMap->Canvas->Pen->Width = 3*factor;
   imWaferMap->Canvas->Brush->Style = bsClear;
   imWaferMap->Canvas->Pen->Color = (TColor)0x00457D7D;

// 2021 12 9 - chc 重定
sy -= (dy/2);
cy -= (dy/2);

   //imWaferMap->Canvas->Ellipse(sx+esx, sy+esy, sx+esx+ew, sy+esy+eh);
   // 2021 7 21 - chc Notch上或下
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      rgWaferAxisOrientation->ItemIndex = 1;

      // 畫Notch: 2.3030(W), 1.50(H)
// 2021 12 9 - chc for test: esx1,ew1,esy1,eh1
//      imWaferMap->Canvas->Arc(sx+esx,sy+esy,sx+esx+ew,sy+esy+eh,cx+7*factor,sy+esy+eh-6*factor,cx-7*factor,sy+esy+eh-6*factor);
//      imWaferMap->Canvas->Arc(cx-7*factor,sy+esy+eh-6*factor,cx+7*factor,sy+esy+eh+8*factor,cx+7*factor,sy+esy+eh-0*factor,cx-7*factor,sy+esy+eh-0*factor);
//
//      // 2021 9 27 - chc 0度是左上角, 180度是左下角
//      imWaferMap->Canvas->Ellipse(sx+coffsetx+3*factor, sy+coffsety+3*factor + dy*(gridnoy-1), sx+coffsetx+dx-2*factor, sy+coffsety+dy-2*factor + dy*(gridnoy-1));
      imWaferMap->Canvas->Arc(sx+esx,sy+esy,sx+esx+ew,sy+esy+eh,cx/*+7*factor*/,sy+esy+eh-6*factor,cx/*-7*factor*/,sy+esy+eh-6*factor);
      imWaferMap->Canvas->Pen->Color = clBlack;
      imWaferMap->Canvas->Arc(sx+esx1,sy+esy1,sx+esx1+ew1,sy+esy1+eh1,cx+7*factor,sy+esy1+eh1-6*factor,cx-7*factor,sy+esy1+eh1-6*factor);
      imWaferMap->Canvas->Arc(cx-7*factor,sy+esy1+eh1-6*factor,cx+7*factor,sy+esy1+eh1+8*factor,cx+7*factor,sy+esy1+eh1-0*factor,cx-7*factor,sy+esy1+eh1-0*factor);

      // 2021 12 15 - chc 最小Row,Col: minrow,mincol,minsx,minex,minsy,miney
      //imWaferMap->Canvas->Ellipse(sx+coffsetx+3*factor, sy+coffsety+3*factor + dy*(gridnoy-1), sx+coffsetx+dx-2*factor, sy+coffsety+dy-2*factor + dy*(gridnoy-1));
      imWaferMap->Canvas->Ellipse(minsx+coffsetx+3*factor, minsy+coffsety+3*factor, minsx+coffsetx+dx-2*factor, minsy+coffsety+dy-2*factor);

   }
   // 上: 0
   else {

      imWaferMap->Canvas->Arc(sx+esx, sy+esy, sx+esx+ew, sy+esy+eh,cx-7*factor,sy+esy+6*factor,cx+7*factor,sy+esy+6*factor);
      // 畫Notch: 2.3030(W), 1.50(H)
      imWaferMap->Canvas->Arc(cx-7*factor,sy+esy-6*factor,cx+7*factor,sy+esy+8*factor,cx-7*factor,sy+esy-0*factor,cx+7*factor,sy+esy-0*factor);

      // 2021 9 27 - chc 0度是左上角, 180度是左下角
      imWaferMap->Canvas->Ellipse(sx+coffsetx+3*factor, sy+coffsety+3*factor, sx+coffsetx+dx-2*factor, sy+coffsety+dy-2*factor);
      rgWaferAxisOrientation->ItemIndex = 0;

   }

   // 原點
   // 2021 8 24 - chc 偏移量
   //imWaferMap->Canvas->Ellipse(sx+3*factor, sy+3*factor, sx+dx-2*factor, sy+dy-2*factor);
   // 2021 9 27 - chc 0度是左上角, 180度是左下角
   //imWaferMap->Canvas->Ellipse(sx+coffsetx+3*factor, sy+coffsety+3*factor, sx+coffsetx+dx-2*factor, sy+coffsety+dy-2*factor);

   // 中心打標
   imWaferMap->Canvas->Pen->Width = 1*factor;
   imWaferMap->Canvas->Pen->Color = clRed;
   imWaferMap->Canvas->MoveTo(cx-5*factor,cy);
   imWaferMap->Canvas->LineTo(cx+5*factor,cy);
   imWaferMap->Canvas->MoveTo(cx,cy-5*factor);
   imWaferMap->Canvas->LineTo(cx,cy+5*factor);
   imWaferMap->Canvas->Pen->Width = 1;
   // 中心點的col,row
   int col,row;
   col = (cx - Wafer.X) / Wafer.Dx;
   row = (cy - Wafer.Y) / Wafer.Dy;

   // 2021 9 27 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      row = GridNoY - row - 1;
   }

// 2021 12 9 - chc 重定
sy += (dy/2);
cy += (dy/2);

   // 2021 12 18 - chc 最小Row,Col
   if(MinCol != -1)
      col -= MinCol;
   if(MinRow != -1)
      row -= (GridNoY - MinRow - 1);

   // 2021 12 18 - chc
/*
   CenterDieCol = col;
   CenterDieRow = row;

   // 2021 12 18 - chc 最小Row,Col
   pnlCenterCol->Caption = IntToStr(col);
   pnlCenterRow->Caption = IntToStr(row);
*/
   // 畫內框
   imWaferMap->Canvas->Pen->Width = 2;
   imWaferMap->Canvas->Pen->Color = clNavy;
   imWaferMap->Canvas->MoveTo(sx,sy);
   imWaferMap->Canvas->LineTo(sx,sy+height-1);
   imWaferMap->Canvas->LineTo(sx+width-1,sy+height-1);
   imWaferMap->Canvas->LineTo(sx+width-1,sy);
   imWaferMap->Canvas->LineTo(sx,sy);

   tsWaferMap->Enabled = true;
   return;


   //---------------------------------------------------------------------------
   width = 30000;
   height = 30000;
   cx = width / 2;
   cy = height / 2;
   dx = 100;
   dy = 100;
   imWaferMap->Picture->Bitmap->PixelFormat = pf4bit;
   imWaferMap->Picture->Bitmap->Width = width;
   imWaferMap->Picture->Bitmap->Height = height;

   imWaferMap->Stretch = true;
   imWaferMap->AutoSize = true;

   // Draw
   imWaferMap->Canvas->Pen->Color = clBlue;
   imWaferMap->Canvas->Brush->Color = clSilver;
   imWaferMap->Canvas->Pen->Width = 4;
   Rect.left = 0;
   Rect.top = 0;
   Rect.Right = width - 1;
   Rect.Bottom = height - 1;
   imWaferMap->Canvas->FillRect(Rect);
   for(int col=0 ; col<width ; col+=dx) {
     imWaferMap->Canvas->MoveTo(col,0);
     imWaferMap->Canvas->LineTo(col,height-1);
   }
   for(int row=0 ; row<height ; row+=dy) {
     imWaferMap->Canvas->MoveTo(0,row);
     imWaferMap->Canvas->LineTo(width-1,row);
   }

   w = imWaferMap->Picture->Bitmap->Width;
   h = imWaferMap->Picture->Bitmap->Height;
   ZoomW = w;
   ZoomH = h;
   imWaferMap->AutoSize = false;
   imWaferMap->Width = w / 2;
   imWaferMap->Height = h / 2;
   tbZoom->Position = 50;
   tsWaferMap->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::InitWaferMap()
{

   Wafer.boolSet = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::cbWaferMapClick(TObject *Sender)
{

   if(cbWaferMap->Checked == true) {
      sbWaferMap->Visible = cbWaferMap->Checked;
      if(Wafer.boolSet == true)
         tbZoom->Visible = cbWaferMap->Checked;
   }
   else {
      sbWaferMap->Visible = cbWaferMap->Checked;
      tbZoom->Visible = cbWaferMap->Checked;
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnGenerateMapClick(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   DrawBigImage();
}
//---------------------------------------------------------------------------
// 2021 4 25 - chc EFEM: Aligner
void __fastcall TMainForm::btnAlignerGPIOClick(TObject *Sender)
{

   edAlignerCommand->Text = "GPIO";
   AlignerCmd = "GPIO";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::btnRobotGPIOClick(TObject *Sender)
{
// 2021 9 11 - chc 加速: GPIO是否已取得
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;

   WriteSystemLog("Robot GPIO發出...");

   // 2021 9 11 - chc 加速: GPIO是否已取得
   boolRobotGPIO = false;

   edRobotCommand->Text = "GPIO";
   sRobotCmd = "GPIO";
   btnRobotSendClick(this);

   // 2021 9 11 - chc 加速: GPIO是否已取得 => 等完成
   // timeout : 1000ms
   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      Sleep(1);
      Application->ProcessMessages();
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));

      // 2021 9 23a - chc 延長到2000ms
      //if(Elapsedms > 1000) {
      if(Elapsedms > 2000) {

         WriteSystemLog("Robot GPIO Timeout!");
         break;
      }
      if(boolRobotGPIO == true)
         break;
   }

}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Aligner上是否有Wafer?
bool __fastcall TMainForm::IsAlignerWithWafer()
{
bool ret = false;

   pcEFEMR->Enabled = false;

   // 2023 8 1 - chc 無EFEM CDA/Vacuum
   //if(pnlBit11->Color != clLime || pnlBit12->Color != clLime) {
   //   pnlAlarmMessage->Caption = "EFEM CDA或Vacuum異常! 停止操作.";
   //
   //   // 2021 11 12 - chc Log
   //   WriteSystemLog(pnlAlarmMessage->Caption);
   //
   //   goto end;
   //}

   btnAlignerGPIOClick(this);
   WaitTime(1000);
   if(pnlAlignerWithWafer1->Color == clLime) {

      // 2021 11 12 - chc Log
      WriteSystemLog("Aligner上有Wafer.");

      ret = true;
   }
   pcEFEMR->Enabled = true;

end:

   // 2021 11 12 - chc Log
   WriteSystemLog("Aligner上無Wafer.");

   return ret;
}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Robot上是否有Wafer?
bool __fastcall TMainForm::IsRobotWithWafer()
{
bool ret = false;

   pcEFEMR->Enabled = false;

   // 2023 8 1 - chc 無EFEM CDA/Vacuum
   //if(pnlBit11->Color != clLime || pnlBit12->Color != clLime) {
   //   pnlAlarmMessage->Caption = "EFEM CDA或Vacuum異常! 停止操作.";
   //   goto end;
   //}

   // Exist?
   // GPIO
   btnRobotGPIOClick(this);

   // 2021 9 11 - chc 加速: GPIO是否已取得
   //WaitTime(1000);

   if(pnlRobotWithWaferUp->Color == clLime || pnlRobotWithWaferDown->Color == clLime)
      ret = true;
   else {

      // 2021 9 11 - chc Log
      WriteSystemLog("IsRobotWithWafer(無片): 做Fork吸放確認...");

      // Up Aam
      if(pnlRobotWithWaferUp->Color != clLime) {
         // CLMP
         edRobotCommand->Text = "CLMP(4)";
         sRobotCmd = "CLMP";

         // 2021 5 3 - chc Robot動作中
         // 2021 5 3 - chc 在btnRobotSendClick()中指定
         //RobotMoveState = ROBOT_IDLE;

         btnRobotSendClick(this);
         Sleep(500);
         // GPIO
         btnRobotGPIOClick(this);

         // 2021 9 11 - chc 加速: GPIO是否已取得
         //WaitTime(1000);

         if(pnlRobotWithWaferUp->Color == clLime)
            ret = true;
         // UCLM
         edRobotCommand->Text = "UCLM(1)";
         sRobotCmd = "UCLM";
         btnRobotSendClick(this);
      }
      if(pnlRobotWithWaferDown->Color != clLime) {
         edRobotCommand->Text = "CLMP(5)";
         sRobotCmd = "CLMP";
         btnRobotSendClick(this);

         // 2021 9 11 - chc 漏等待!
         Sleep(500);

         // GPIO
         btnRobotGPIOClick(this);

         // 2021 9 11 - chc 加速: GPIO是否已取得
         //WaitTime(1000);

         if(pnlRobotWithWaferDown->Color == clLime)
            ret = true;
         // UCLM
         edRobotCommand->Text = "UCLM(2)";
         sRobotCmd = "UCLM";
         btnRobotSendClick(this);
      }

      // 2021 9 11 - chc Log
      WriteSystemLog("IsRobotWithWafer(無片): 做Fork吸放確認.");

   }
   pcEFEMR->Enabled = true;

end:
   return ret;
}
//---------------------------------------------------------------------------
// Check上是否有Wafer
bool __fastcall TMainForm::IsChuckWithWafer()
{

   if(pnlBit7->Color == clLime)
      return true;
   else
      return false;
}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Yuanli socket
void __fastcall TMainForm::btnYuanliSendClick(TObject *Sender)
{
int no,sno,count,eno,timedelay;

   btnYuanliSend->Enabled = false;
   pnlSocketReady->Color = clSilver;
   int pos,len;
   AnsiString cmd,str;
   char buf[50];
   pnlYuanliSend->Color = clSilver;
   str = edYuanliCmd->Text;
   len = str.Length();
   if(len <= 0) {
      pnlYuanliSend->Color = clRed;
      return;
   }
   len += 1;
   cmd.sprintf("%02d,%s>",len,str.c_str());
   sprintf(buf,"%s",cmd.c_str());
   pnlYuanli->Caption = cmd;
   len = strlen(buf);
   AddYuanliMessage("[>] " + pnlYuanli->Caption);

   // 2021 4 26 - chc 改成Client
   //if(ssYuanliSocket->Active == true && ssYuanliSocket->Socket->ActiveConnections > 0) {
   //   pnlYuanliSend->Color = clLime;
   //   ssYuanliSocket->Socket->SendBuf(buf,len);
   //}
   if(csYuanliSocket->Active == true) {
      pnlYuanliSend->Color = clLime;
      csYuanliSocket->Socket->SendBuf(buf,len);
   }
   else {
      // 暫不用
      //if(cbSimlate->Checked == true) {
      //   sprintf(buf,"07,Motion>07,ToHome>",cmd.c_str());
      //   SimulateSocket(buf);
      //}
   }
   btnYuanliSend->Enabled = true;
   return;
}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Yuanli socket re-connect
void __fastcall TMainForm::btnYunliReConnectClick(TObject *Sender)
{

   try {
      // 2021 4 26 - chc 改成Client
      //ssYuanliSocket->Active = false;
      //WaitTime(1500);
      //ssYuanliSocket->Active = true;
      csYuanliSocket->Active = false;
      WaitTime(1500);
      csYuanliSocket->Active = true;
   }
   catch(Exception &e) {

      // 2023 1 4 - chc 寫錯SECS/Yunli
      //WriteSystemLog(">>Error(btnSECSReConnectClick): "+e.Message);
      //pnlSystemMessage->Caption = "SSECS Socket重連線失敗!";
      WriteSystemLog(">>Error(btnYunliReConnectClick): "+e.Message);
      pnlSystemMessage->Caption = "Yunli Socket重連線失敗!";

   }

}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Yuanli socket
void TMainForm::AddYuanliMessage(AnsiString msg)
{
AnsiString putmsg;
static AnsiString oldmsg = "";

   if(oldmsg == msg)                            // 重複不收錄
      return;
   oldmsg = msg;
   putmsg = Now().FormatString("hh':'nn':'ss':'zzz'-> '") + msg;
   // 最多共470 Rows
   mmYuanli->Lines->Insert(0,putmsg);
   // Realtime
   mmYuanli->Refresh();

   if(mmYuanli->Lines->Count > 500) {
      for(int i=470 ; i<mmYuanli->Lines->Count ; i++)
         mmYuanli->Lines->Delete(i);
   }
}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Yuanli socket re-connect
void __fastcall TMainForm::ssYuanliSocketClientError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   ErrorCode = 0;
   pnlSocketConnect->Color = clRed;
   pnlOlympusStatus->Color = clRed;
   pnlSocketReady->Color = clRed;
   btnYuanliSend->Enabled = false;
}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Yuanli socket
void __fastcall TMainForm::ssYuanliSocketClientRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
static AnsiString eceivestr;
static bool inactive = false;
AnsiString text,cmdstr,slen,scmd,spar[30];
bool flag,done;
int pos,parcnt;

   if(inactive == true) {
      AddYuanliMessage("[<] Re-Entrant!");
      return;
   }
   inactive = true;
   done = false;

   parcnt = 0;
   text = Socket->ReceiveText();
   AddYuanliMessage("[<] " + text);

// @@ 暫
//AddYuanliMessage("[#] " + text);

   // 分段
   while((pos = text.Pos(">")) != 0) {
      // 取得完整命令字串
      cmdstr = text.SubString(1,pos);
      pnlYuanli->Caption = cmdstr;
      text.Delete(1,pos);
      pos = cmdstr.Pos(",");
      if(pos == 0) {                                                         // No Parameter!
         AddYuanliMessage("[<] Invalid: " + cmdstr);
         flag = false;
         continue;
      }
      slen = cmdstr.SubString(1,pos-1);
      cmdstr.Delete(1,pos);
      // Cmd
      pos = cmdstr.Pos(",");
      if(pos == 0) {
         pos = cmdstr.Pos(">");
         if(pos == 0) {
            AddYuanliMessage("[<] Invalid");
            flag = false;
            continue;
         }
         else {
            scmd = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
            done = true;
         }
      }
      else {
         scmd = cmdstr.SubString(1,pos-1);
         cmdstr.Delete(1,pos);
      }
      AddYuanliMessage("[<] " + scmd);

      // Par
      while(done == false) {
         pos = cmdstr.Pos(",");
         if(pos == 0) {
            pos = cmdstr.Pos(">");
            if(pos == 0) {
               AddYuanliMessage("[<] Invalid");
               flag = false;
               continue;
            }
            else {
               spar[parcnt++] = cmdstr.SubString(1,pos-1);
               cmdstr.Delete(1,pos);
               done = true;
            }
         }
         else {
            spar[parcnt++] = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
         }

         // 2021 4 28 - chc parcnt > 0
         if(parcnt > 0)

            AddYuanliMessage("[LC] " + spar[parcnt-1] + " : " + IntToStr(parcnt));
      }
      Decode(scmd,spar,parcnt,1);
   }
   inactive = false;
}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Yuanli socket
// mode: 0-Simulate, 1-Socket
// Motion, ReadRecipe, GetErr
void __fastcall TMainForm::Decode(AnsiString scmd, AnsiString *spar, int parcnt, int mode)
{
int cmdno,parno,len;
AnsiString sack,astr;
bool boolresult = false;
char brf[500];
double par1,par2;

   cmdno = GetCmdSet(scmd);

   // 2021 5 7 - chc Log
   WriteSystemLog("Decode() cmd, cmdno, parcnt= " + scmd + "," + IntToStr(cmdno) + "," + IntToStr(parcnt));

   if(cmdno == -1) {
      AddYuanliMessage("Invalid");
      if(mode == 1) {
         SnedSocket("Invalid",0);
      }
      return;
   }

   // 12個
   switch(cmdno) {
      case CMD_YUANLI:
         WriteSystemLog("是YuanLi指令: " + scmd + "," + spar[0]);
         parno = 1;
         break;
      case CMD_MODE:
         parno = 1;
         break;
      case CMD_SET_RECIPE:
         parno = 1;
         break;
      case CMD_INIT:
         parno = 1;
         break;
      case CMD_START:
         parno = 1;
         break;
      case CMD_STOP:
         parno = 1;
         break;
      case CMD_BUSY:
         parno = 1;
         break;
      case CMD_INVALID:
         parno = 1;
         break;
      case CMD_INPOS:
         parno = 1;
         break;

      // 2022 12 8 - chc CMD_RFID
      case CMD_RFID:
         parno = 1;
         break;

      case CMD_MOTION:
         parno = 0;
         break;
      case CMD_READ_RECIPE:
         parno = 0;
         break;
      case CMD_GET_ERR:
         parno = 0;
         break;
   }
   if(parcnt != parno) {
      AddYuanliMessage("Invalid: 參數數量不對!");
      if(mode == 1) {
         SnedSocket("Invalid",0);
      }
      return;
   }

   // 2021 4 28 - chc
   if(parcnt == 1 && (spar[0] == "s" || spar[0] == "e" || spar[0] == "x"))
      // nothing
      len = 1;
   else
      sack.sprintf("%02d,%s,s>",scmd.Length()+3,scmd.c_str());
   AddYuanliMessage("[>] " + sack);
   if(mode == 1) {
      SnedSocket(sack,1);
   }
   pnlAIMessage->Caption = sack;
   pnlAIMessage->Refresh();
   Sleep(edDelayTime->Text.ToInt());
   // Do Parameter
   switch(cmdno) {
      case CMD_YUANLI:
         WriteSystemLog("是YuanLi指令, 參數= " + spar[0]);
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] YuanLi - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_YUANLI] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] YuanLi - x");
            YuanliCmdStatus[CMD_YUANLI] = CMD_ACK_X;
         }
         break;
      case CMD_MODE:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Mode - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_MODE] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Mode - x");
            YuanliCmdStatus[CMD_MODE] = CMD_ACK_X;
         }
         break;
      case CMD_SET_RECIPE:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] SetRecipe - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_SET_RECIPE] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] SetRecipe - x");
            YuanliCmdStatus[CMD_SET_RECIPE] = CMD_ACK_X;
         }
         break;
      case CMD_INIT:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Init - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_INIT] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Init - x");
            YuanliCmdStatus[CMD_INIT] = CMD_ACK_X;
         }
         break;
      case CMD_START:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Start - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_START] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Start - x");
            YuanliCmdStatus[CMD_START] = CMD_ACK_X;
         }
         break;
      case CMD_STOP:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Stop - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_STOP] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Stop - x");
            YuanliCmdStatus[CMD_STOP] = CMD_ACK_X;
         }
         break;
      case CMD_BUSY:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Busy - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_BUSY] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Busy - x");
            YuanliCmdStatus[CMD_BUSY] = CMD_ACK_X;
         }
         break;
      case CMD_INVALID:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Invalid - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_INVALID] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Invalid - x");
            YuanliCmdStatus[CMD_INVALID] = CMD_ACK_X;
         }
         break;
      case CMD_INPOS:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] InPos - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_INPOS] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] InPos - x");
            YuanliCmdStatus[CMD_INPOS] = CMD_ACK_X;
         }
         break;

      // 2022 12 8 - chc 漏CMD_RFID處理
      case CMD_RFID:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] InPos - " + spar[0]);
            if(spar[0] == "e")
               YuanliCmdStatus[CMD_RFID] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] InPos - x");
            YuanliCmdStatus[CMD_RFID] = CMD_ACK_X;
         }
         break;

      case CMD_MOTION:
         break;
      case CMD_READ_RECIPE:
         boolresult = true;
         break;
      case CMD_GET_ERR:
         boolresult = true;
         break;
   }

   // 2021 12 12 - chc 要將ToYuanli的指令避開
   //rgCommand->ItemIndex = cmdno;
   if(cmdno < CMD_MOTION)
      return;
   rgCommand->ItemIndex = cmdno - CMD_MOTION;

   if(boolresult == true) {
      if(cmdno == CMD_GET_ERR) {
         sack.sprintf("%02d,%s,%s>",scmd.Length()+6,scmd.c_str(),pnlErrorCode->Caption.c_str());
      }
      else if(cmdno == CMD_READ_RECIPE) {
         sack.sprintf("%02d,%s,%s>",scmd.Length()+2+edRecipeName->Text.Length() ,scmd.c_str(),edRecipeName->Text.c_str());
      }
      else {
         sack.sprintf("%02d,%s,e>",scmd.Length()+3,scmd.c_str());
      }
      AddYuanliMessage("[>] " + sack);
      if(mode == 1) {
         SnedSocket(sack,1);
      }
      pnlAIMessage->Caption = sack;
      pnlAIMessage->Refresh();
   }
}
//---------------------------------------------------------------------------
// YuanLi, Mode, SetRecipe, Init, Start, Stop, Busy, Invalid, InPos
void __fastcall TMainForm::rgYuanliCommandSetClick(TObject *Sender)
{
int no;
double t;
AnsiString cmd;
int zero;
AnsiString msg;

   no = rgYuanliCommandSet->ItemIndex;
   switch(no) {
      // YuanLi
      case CMD_YUANLI:
         cmd = "YuanLi";
         break;
      // Mode
      case CMD_MODE:
         if(rgMode->ItemIndex == 0)
            cmd = "Mode,Top";
         else
            cmd = "Mode,Side";
         break;
      // SetRecipe
      case CMD_SET_RECIPE:
         cmd = "SetRecipe," + edRecipeName->Text;
         break;
      // Init
      case CMD_INIT:
         cmd = "Init";
         break;
      // Start
      case CMD_START:

         // 2021 12 25 - chc 加入SlotNo: rgWaferNo
         //cmd = "Start," + edTotalPoint->Text + "," + edWaferID->Text;
         cmd = "Start," + edTotalPoint->Text + "," + edWaferID->Text + "," + IntToStr(25-rgWaferNo->ItemIndex);

         break;
      // Stop
      case CMD_STOP:
         cmd = "Stop," + pnlErrorCode->Caption;
         break;
      // Busy
      case CMD_BUSY:
         cmd = "Busy";
         break;
      // Invalid
      case CMD_INVALID:
         cmd = "Invalid";
         break;
      // InPos
      case CMD_INPOS:
         zero = edLoadT->Text.ToInt();
         t = edCounterT->Text.ToInt();
         t = t - zero;
         t *= T_RESOLUTION;
         msg.sprintf("%.3f",t);
         cmd = "InPos," + IntToStr(rgYuanliPoint->ItemIndex + 1) + "," +
               edCounterX->Text + "," +
               edCounterY->Text + "," +
               edCounterZ->Text + "," +
               msg;
         break;

      // RFID
      case CMD_RFID:
         if(rgLoadPortSelect->ItemIndex == 0) {
            if(rgLoadPort1WaferSize->ItemIndex == WAFER_SIZE_12)
               msg = "12";
            else
               msg = "8";
         }
         else {
            if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_12)
               msg = "12";
            else
               msg = "8";
         }
         cmd = "RFID," + pnlCSTCode->Caption + "," + msg;
         break;

   }
   edYuanliCmd->Text = cmd;
   AddYuanliMessage("[>] " + cmd);

   // 2021 5 5 - chc 是否送出Command : boolSendSCESCommand
   if(boolSendYuanliCommand == true) {
      boolSendYuanliCommand = false;
      btnYuanliSendClick(this);
   }

}
//---------------------------------------------------------------------------
// -1: Fail
int __fastcall TMainForm::GetCmdSet(AnsiString cmd)
{

   for(int i=0 ; i<CMD_MAX ; i++) {
      if(cmd == "Yuani")
         return CMD_YUANLI;
      if(CmdSet[i] == cmd) {
         return i;
      }
   }
   return -1;
}
//---------------------------------------------------------------------------
// to Motin: Motion, ReadRecipe, GetErr
// to YUANLI: YuanLi, Init, SetRecipe, Mode, Start, InPos, Stop, Busy, Invalid
void __fastcall TMainForm::SetCmdSet()
{

   CmdSet[0] = "YuanLi";
   CmdSet[1] = "Mode";
   CmdSet[2] = "SetRecipe";
   CmdSet[3] = "Init";
   CmdSet[4] = "Start";
   CmdSet[5] = "Stop";
   CmdSet[6] = "Busy";
   CmdSet[7] = "Invalid";
   CmdSet[8] = "InPos";

   CmdSet[9] = "Motion";
   CmdSet[10] = "ReadRecipe";
   CmdSet[11] = "GetErr";
}
//---------------------------------------------------------------------------
// mode: 0-未加入長度, 1-已加入長度
void __fastcall TMainForm::SnedSocket(AnsiString str, int mode)
{
AnsiString astr,sack;
int len;
char buf[500];

   astr = str;
   if(mode == 0) {
      len = astr.Length();
      sack.sprintf("%02d,%s>",len+1,astr.c_str());
      sprintf(buf,"%s",sack.c_str());
   }
   else {
      sprintf(buf,"%s",astr.c_str());
   }
   len = strlen(buf);

   // 2021 4 26 - chc 改成Client
   //for(int i=0 ; i<ssYuanliSocket->Socket->ActiveConnections ; i++) {
   //   ssYuanliSocket->Socket->Connections[i]->SendBuf(buf,len);
   //}
   csYuanliSocket->Socket->SendBuf(buf,len);

}
//---------------------------------------------------------------------------
// 2021 4 25 - chc Robot上是否有Wafer?
bool __fastcall TMainForm::IsEFEMCDAVacuumError()
{
bool ret = false;

   // 2023 8 1 - chc 無EFEM CDA/Vacuum
   return false;

   if(pnlBit11->Color != clLime || pnlBit12->Color != clLime) {
      return true;
   }
   return false;
}
//---------------------------------------------------------------------------


void __fastcall TMainForm::csYuanliSocketConnecting(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlSocketConnect->Color = clLime;
   pnlOlympusStatus->Color = clLime;
   btnYuanliSend->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::csYuanliSocketDisconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlSocketConnect->Color = clSilver;
   pnlOlympusStatus->Color = clSilver;
   pnlSocketReady->Color = clSilver;
   btnYuanliSend->Enabled = false;
   boolYuanliSocket = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::csYuanliSocketRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
static AnsiString eceivestr;
static bool inactive = false;
AnsiString text,cmdstr,slen,scmd,spar[30];
bool flag,done;
int pos,parcnt;

   if(inactive == true) {
      AddYuanliMessage("[<] Re-Entrant!");
      return;
   }
   inactive = true;
   text = Socket->ReceiveText();
   AddYuanliMessage("[<] " + text);

   // 2021 5 7 - chc 要移到while裡面
   //done = false;
   //parcnt = 0;

   // 分段
   // 07,Init,e>
   while((pos = text.Pos(">")) != 0) {

      // 2021 5 7 - chc 要移到while裡面
      done = false;
      parcnt = 0;

      // 取得完整命令字串
      cmdstr = text.SubString(1,pos);
      pnlYuanli->Caption = cmdstr;
      text.Delete(1,pos);
      pos = cmdstr.Pos(",");
      if(pos == 0) {                                                         // No Parameter!
         AddYuanliMessage("[<] Invalid: " + cmdstr);
         flag = false;
         continue;
      }
      slen = cmdstr.SubString(1,pos-1);
      cmdstr.Delete(1,pos);
      // Cmd
      pos = cmdstr.Pos(",");
      if(pos == 0) {
         pos = cmdstr.Pos(">");
         if(pos == 0) {
            AddYuanliMessage("[<] Invalid");
            flag = false;
            continue;
         }
         else {
            scmd = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
            done = true;
         }
      }
      else {
         scmd = cmdstr.SubString(1,pos-1);
         cmdstr.Delete(1,pos);
      }
      AddYuanliMessage("[<] " + scmd);

      // Par
      while(done == false) {
         pos = cmdstr.Pos(",");
         if(pos == 0) {
            pos = cmdstr.Pos(">");
            if(pos == 0) {
               AddYuanliMessage("[<] Invalid");
               flag = false;
               continue;
            }
            else {
               spar[parcnt++] = cmdstr.SubString(1,pos-1);
               cmdstr.Delete(1,pos);
               done = true;
            }
         }
         else {
            spar[parcnt++] = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
         }

         // 2021 4 28 - chc parcnt > 0
         if(parcnt > 0)

            AddYuanliMessage("[LC] " + spar[parcnt-1] + " : " + IntToStr(parcnt));
         if(cmdstr.Length() <= 0)
            break;
      }
      Decode(scmd,spar,parcnt,1);
   }
   inactive = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::csYuanliSocketConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlSocketConnect->Color = clLime;
   pnlOlympusStatus->Color = clLime;
   btnYuanliSend->Enabled = true;
   boolYuanliSocket = true;

   // 2023 2 21 - chc 取消
   if(pnlMoving->Caption == "YanLi未連線")
      pnlMoving->Visible = false;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::csYuanliSocketError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   ErrorCode = 0;
   pnlSocketConnect->Color = clRed;
   pnlOlympusStatus->Color = clRed;
   pnlSocketReady->Color = clRed;
   btnYuanliSend->Enabled = false;
   boolYuanliSocket = false;
}
//---------------------------------------------------------------------------
// 由in決定狀態
// aSTG1.GPIO:007F00204E161570/000000001E0000E1
void __fastcall TMainForm::LogInStatus(int no, char *dibuf)
{
AnsiString msg;

   // 2021 6 30 - chc 可設定是否要Log
   if(cbGPIOLog->Checked == false)

      return;

   WriteSystemLog("---------------------------------------------------------------");
   WriteSystemLog("LoadPort" + IntToStr(no) + " Status");
   WriteSystemLog("---------------------------------------------------------------");
   boolLogDateTime = false;
   // 0 - 3
   if(dibuf[15] & 0x01)
      WriteSystemLog("[ 0].Emergency stop: On");
   else
      WriteSystemLog("[ 0].Emergency stop: Off");
   if(dibuf[15] & 0x02)
      WriteSystemLog("[ 1].Temporarily stop: On");
   else
      WriteSystemLog("[ 1].Temporarily stop: Off");
   WriteSystemLog("[ 2].Not Connected");
   WriteSystemLog("[ 3].Not Connected");
   // 4 - 7
   if(dibuf[14] & 0x01)
      WriteSystemLog("[ 4].Exhaust FAN1: On");
   else
      WriteSystemLog("[ 4].Exhaust FAN1: Off");
   if(dibuf[14] & 0x02)
      WriteSystemLog("[ 5].Exhaust FAN2: On");
   else
      WriteSystemLog("[ 5].Exhaust FAN2: Off");
   if(dibuf[14] & 0x04)
      WriteSystemLog("[ 6].Protrusion: On");
   else
      WriteSystemLog("[ 6].Protrusion: Off");
   if(dibuf[14] & 0x08)
      WriteSystemLog("[ 7].Protrusion 2: On");
   else
      WriteSystemLog("[ 7].Protrusion 2: Off");
   // 8 - 11
   if(dibuf[13] & 0x01)
      WriteSystemLog("[ 8].FOUP door left close: On");
   else
      WriteSystemLog("[ 8].FOUP door left close: Off");
   if(dibuf[13] & 0x02)
      WriteSystemLog("[ 9].FOUP door left open: On");
   else
      WriteSystemLog("[ 9].FOUP door left open: Off");
   if(dibuf[13] & 0x04)
      WriteSystemLog("[10].FOUP door right close: On");
   else
      WriteSystemLog("[10].FOUP door right close: Off");
   if(dibuf[13] & 0x08)
      WriteSystemLog("[11].FOUP door right open: On");
   else
      WriteSystemLog("[11].FOUP door right open: Off");
   // 12 - 15
   if(dibuf[12] & 0x01)
      WriteSystemLog("[12].Mapping sensor containing: On");
   else
      WriteSystemLog("[12].Mapping sensor containing: Off");
   if(dibuf[12] & 0x02)
      WriteSystemLog("[13].Mapping sensor preparation: On");
   else
      WriteSystemLog("[13].Mapping sensor preparation: Off");
   if(dibuf[12] & 0x04)
      WriteSystemLog("[14].Upper presure limit: On");
   else
      WriteSystemLog("[14].Upper presure limit: Off");
   if(dibuf[12] & 0x08)
      WriteSystemLog("[15].Lower presure limit: On");
   else
      WriteSystemLog("[15].Lower presure limit: Off");
   // 16 - 19
   if(dibuf[11] & 0x01)
      WriteSystemLog("[16].Carrier clamp open: On");
   else
      WriteSystemLog("[16].Carrier clamp open: Off");
   if(dibuf[11] & 0x02)
      WriteSystemLog("[17].Carrier clamp close: On");
   else
      WriteSystemLog("[17].Carrier clamp close: Off");
   if(dibuf[11] & 0x04)
      WriteSystemLog("[18].Presence left: On");
   else
      WriteSystemLog("[18].Presence left: Off");
   if(dibuf[11] & 0x08)
      WriteSystemLog("[19].Presence right: On");
   else
      WriteSystemLog("[19].Presence right: Off");
   // 20 - 23
   if(dibuf[10] & 0x01)
      WriteSystemLog("[20].Presence Middle: On");
   else
      WriteSystemLog("[20].Presence Middle: Off");
   if(dibuf[10] & 0x02)
      WriteSystemLog("[21].Info pad A: On");
   else
      WriteSystemLog("[21].Info pad A: Off");
   if(dibuf[10] & 0x04)
      WriteSystemLog("[22].Info pad B: On");
   else
      WriteSystemLog("[22].Info pad B: Off");
   if(dibuf[10] & 0x08)
      WriteSystemLog("[23].Info pad C: On");
   else
      WriteSystemLog("[23].Info pad C: Off");
   // 24 - 27
   if(dibuf[9] & 0x01)
      WriteSystemLog("[24].Info pad D: On");
   else
      WriteSystemLog("[24].Info pad D: Off");
   if(dibuf[9] & 0x02)
      WriteSystemLog("[25].Presence: On");
   else
      WriteSystemLog("[25].Presence: Off");
   if(dibuf[9] & 0x04)
      WriteSystemLog("[26].FOSB identification sensor: On");
   else
      WriteSystemLog("[26].FOSB identification sensor: Off");
   if(dibuf[9] & 0x08)
      WriteSystemLog("[27].Obstacle detecting sensor: On");
   else
      WriteSystemLog("[27].Obstacle detecting sensor: Off");
   // 28 - 31
   if(dibuf[8] & 0x01)
      WriteSystemLog("[28].Door detection: On");
   else
      WriteSystemLog("[28].Door detection: Off");
   if(dibuf[8] & 0x02)
      WriteSystemLog("[29].Not Connected: On");
   else
      WriteSystemLog("[29].Not Connected: Off");
   if(dibuf[8] & 0x04)
      WriteSystemLog("[30].Open carrier detection sensor: On");
   else
      WriteSystemLog("[30].Open carrier detection sensor: Off");
   if(dibuf[8] & 0x08)
      WriteSystemLog("[31].Not Connected: On");
   else
      WriteSystemLog("[31].Not Connected: Off");
   // 32 - 35
   if(dibuf[7] & 0x01)
      WriteSystemLog("[32].Stage rotation: Backward: On");
   else
      WriteSystemLog("[32].Stage rotation: Backward: Off");
   if(dibuf[7] & 0x02)
      WriteSystemLog("[33].Stage rotation: Forward: On");
   else
      WriteSystemLog("[33].Stage rotation: Forward: Off");
   if(dibuf[7] & 0x04)
      WriteSystemLog("[34].BCR lifting");
   else
      WriteSystemLog("[34].BCR lifting: Off");
   if(dibuf[7] & 0x08)
      WriteSystemLog("[35].BCR lowering: On");
   else
      WriteSystemLog("[35].BCR lowering: Off");
   // 36 - 39
   if(dibuf[6] & 0x01)
      WriteSystemLog("[36].Cover lock: On");
   else
      WriteSystemLog("[36].Cover lock: Off");
   if(dibuf[6] & 0x02)
      WriteSystemLog("[37].Cover unlock: On");
   else
      WriteSystemLog("[37].Cover unlock: Off");
   if(dibuf[6] & 0x04)
      WriteSystemLog("[38].Carrier retainer: Lowering: On");
   else
      WriteSystemLog("[38].Carrier retainer: Lowering: Off");
   if(dibuf[6] & 0x08)
      WriteSystemLog("[39].Carrier retainer: Lifting: On");
   else
      WriteSystemLog("[39].Carrier retainer: Lifting: Off");
   // 40 - 43
   if(dibuf[5] & 0x01)
      WriteSystemLog("[40].External SW1(ACCESS/LOAD): On");
   else
      WriteSystemLog("[40].External SW1(ACCESS/LOAD): Off");
   if(dibuf[5] & 0x02)
      WriteSystemLog("[41].External SW2: On");
   else
      WriteSystemLog("[41].External SW2: Off");
   if(dibuf[5] & 0x04)
      WriteSystemLog("[42].External SW3(UNLOAD): On");
   else
      WriteSystemLog("[42].External SW3(UNLOAD): Off");
   if(dibuf[5] & 0x08)
      WriteSystemLog("[43].Not Connected: On");
   else
      WriteSystemLog("[43].Not Connected: Off");
   // 44 - 47
   if(dibuf[4] & 0x01)
      WriteSystemLog("[44].Not Connected: On");
   else
      WriteSystemLog("[44].Not Connected: Off");
   if(dibuf[4] & 0x02)
      WriteSystemLog("[45].Not Connected: On");
   else
      WriteSystemLog("[45].Not Connected: Off");
   if(dibuf[4] & 0x04)
      WriteSystemLog("[46].PFA L: On");
   else
      WriteSystemLog("[46].PFA L: Off");
   if(dibuf[4] & 0x08)
      WriteSystemLog("[47].PFA R: On");
   else
      WriteSystemLog("[47].PFA R: Off");
   // 48 - 51
   if(dibuf[3] & 0x01)
      WriteSystemLog("[48].300mm DSC: On");
   else
      WriteSystemLog("[48].300mm DSC: Off");
   if(dibuf[3] & 0x02)
      WriteSystemLog("[49].200mm DSC: On");
   else
      WriteSystemLog("[49].200mm DSC: Off");
   if(dibuf[3] & 0x04)
      WriteSystemLog("[50].150mm DSC: On");
   else
      WriteSystemLog("[50].150mm DSC: Off");
   if(dibuf[3] & 0x08)
      WriteSystemLog("[51].Common: On");
   else
      WriteSystemLog("[51].Common: Off");
   // 52 - 55
   if(dibuf[2] & 0x01)
      WriteSystemLog("[52].200mm: On");
   else
      WriteSystemLog("[52].200mm: Off");
   if(dibuf[2] & 0x02)
      WriteSystemLog("[53].150mm: On");
   else
      WriteSystemLog("[53].150mm: Off");
   if(dibuf[2] & 0x04)
      WriteSystemLog("[54].Adapter: On");
   else
      WriteSystemLog("[54].Adapter: Off");
   if(dibuf[2] & 0x08)
      WriteSystemLog("[55].Cover: On");
   else
      WriteSystemLog("[55].Cover: Off");
   // 56 - 59
   // 56 - 63: for E84
   if(dibuf[1] & 0x01)
      WriteSystemLog("[56].VALID: On");
   else
      WriteSystemLog("[56].VALID: Off");
   if(dibuf[1] & 0x02)
      WriteSystemLog("[57].CS_0: On");
   else
      WriteSystemLog("[57].CS_0: Off");
   if(dibuf[1] & 0x04)
      WriteSystemLog("[58].CS_1: On");
   else
      WriteSystemLog("[58].CS_1: Off");
   if(dibuf[1] & 0x08)
      WriteSystemLog("[59].: On");
   else
      WriteSystemLog("[59].: Off");
   // 60 - 63
   if(dibuf[0] & 0x01)
      WriteSystemLog("[60].TR_REQ: On");
   else
      WriteSystemLog("[60].TR_REQ: Off");
   if(dibuf[0] & 0x02)
      WriteSystemLog("[61].BUSY: On");
   else
      WriteSystemLog("[61].BUSY: Off");
   if(dibuf[0] & 0x04)
      WriteSystemLog("[62].COMPT: On");
   else
      WriteSystemLog("[62].COMPT: Off");
   if(dibuf[0] & 0x08)
      WriteSystemLog("[63].CONT: On");
   else
      WriteSystemLog("[63].CONT: Off");
   WriteSystemLog("---------------------------------------------------------------");
   boolLogDateTime = true;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnYuanliConnectClick(TObject *Sender)
{

   btnYunliReConnectClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::cbCCDFullImageChange(TObject *Sender)
{

   GetLensPrecision();
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tbZoomMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
int x,y;
static int oldfactor = 1;
static int newfactor = 1;

   newfactor = tbZoom->Position;
   x = sbWaferMap->VertScrollBar->Position;
   y = sbWaferMap->HorzScrollBar->Position;
   sbWaferMap->VertScrollBar->Position = 0;
   sbWaferMap->HorzScrollBar->Position = 0;

   DrawBigImage();

   sbWaferMap->VertScrollBar->Position = (x * newfactor)/oldfactor;
   sbWaferMap->HorzScrollBar->Position = (y * newfactor)/oldfactor;
   oldfactor = newfactor;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::sbWaferMapMouseWheelDown(TObject *Sender,
      TShiftState Shift, TPoint &MousePos, bool &Handled)
{

   sbWaferMap->VertScrollBar->Position += 10;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::sbWaferMapMouseWheel(TObject *Sender,
      TShiftState Shift, int WheelDelta, TPoint &MousePos, bool &Handled)
{

   sbWaferMap->VertScrollBar->Position -= 10;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlMovingClick(TObject *Sender)
{

   pnlMoving->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnWaferCenterClick(TObject *Sender)
{
int h,w;
double fh,fw;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();
   fw = (double)sbWaferMap->Width / sbWaferMap->HorzScrollBar->Range;
   w = fw * sbWaferMap->Width;
   fh = (double)sbWaferMap->Height / sbWaferMap->VertScrollBar->Range;
   h = fh * sbWaferMap->Height;
   w = sbWaferMap->Width;
   h = sbWaferMap->Height;
   sbWaferMap->VertScrollBar->Position = (sbWaferMap->VertScrollBar->Range / 2) - h / 2;
   sbWaferMap->HorzScrollBar->Position = (sbWaferMap->HorzScrollBar->Range / 2) - w / 2;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::ssSECSSocketClientConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlSECSConnect->Color = clLime;
   pnlSECSStatus->Color = clLime;
   btnSECSSend->Enabled = true;

   // 2023 1 28 - chc Local不亮
   if(cbOffLine->Checked == false)

      BlueLamp(true);
   boolSECSSocket = true;

   // 2023 1 3 - chc Log
   WriteSystemLog("SECS 連線.");

   // 2023 2 21 - chc 取消
   if(pnlMoving->Caption == "SECS未連線")
      pnlMoving->Visible = false;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::ssSECSSocketClientDisconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlSECSConnect->Color = clSilver;
   pnlSECSStatus->Color = clSilver;
   btnSECSSend->Enabled = false;
   BlueLamp(false);
   boolSECSSocket = false;

   // 2022 3 8 - chc SECS離線強制為Local
   //pnlLocal->Color = clBlue;
   //pnlRemote->Color = clSilver;
   btnLocal->Color = (TColor)0x00FFFFB0;
   btnRemote->Color = clSilver;
   cbOffLine->Checked = true;

   // 2023 1 3 - chc Log
   WriteSystemLog("SECS 斷線.");
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::ssSECSSocketClientError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   ErrorCode = 0;
   pnlSECSConnect->Color = clRed;
   pnlSECSStatus->Color = clRed;
   btnSECSSend->Enabled = false;
   BlueLamp(false);
   boolSECSSocket = false;

   // 2022 3 8 - chc SECS離線強制為Local
   //pnlLocal->Color = clBlue;
   //pnlRemote->Color = clSilver;
   btnLocal->Color = (TColor)0x00FFFFB0;
   btnRemote->Color = clSilver;
   cbOffLine->Checked = true;

   // 2023 1 3 - chc Log
   WriteSystemLog("SECS 異常.");
}
//---------------------------------------------------------------------------
// 2021 9 8b - chc 以timer來執行
// DecodeSECS(scmd,spar,parcnt,1);
AnsiString DecodeSCMD,DecodeSPAR[150];
int DecodePARCNT;

// SECS
void __fastcall TMainForm::ssSECSSocketClientRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
static AnsiString eceivestr;
static bool inactive = false;
AnsiString text,cmdstr,slen,scmd,spar[150];
bool flag,done;
int pos,parcnt,pos1;

   if(inactive == true) {
      AddSECSMessage("[<] Re-Entrant!");
      return;
   }
   inactive = true;

try {

   done = false;
   parcnt = 0;
   text = Socket->ReceiveText();
   AddSECSMessage("[<] " + text);

   // 分段
   while((pos1 = text.Pos("$")) != 0) {
      parcnt = 0;
      done = false;
      bool booltag = false;
      // 取得完整命令字串
      cmdstr = text.SubString(1,pos1);
      pnlSECS->Caption = cmdstr;
      WriteSystemLog("SECS Socket收到: " + cmdstr);
      text.Delete(1,pos1);
      // oSTAT^1$
      // 1234567890
      pos = cmdstr.Pos("^");
      if(pos == 0) {                                                            // No Parameter!
         scmd = cmdstr.SubString(1,pos1-1);
         pos = pos1 - 1;
      }
      else {
         scmd = cmdstr.SubString(1,pos-1);
         booltag = true;
      }
      if(scmd.Length() < 5) {
         AddSECSMessage("[<] Invalid: " + cmdstr);
         flag = false;
         continue;
      }
      if(pos > 0)
         cmdstr.Delete(1,pos);
      //done = true;
      AddSECSMessage("[<] " + scmd);

      // Par
      while(done == false) {
         pos = cmdstr.Pos("^");
         if(pos == 0) {
            pos = cmdstr.Pos("$");
            if(pos == 0) {
               AddSECSMessage("[<] Invalid");
               flag = false;
               continue;
            }
            else {
               if(pos <= 1 && booltag == true)
                  spar[parcnt++] = "";
               else if(pos > 1)                                 // @@
                  spar[parcnt++] = cmdstr.SubString(1,pos-1);
               cmdstr.Delete(1,pos);
               done = true;
            }
         }
         else {
booltag = true;
            spar[parcnt++] = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
         }

         // 2021 4 28 - chc parcnt > 0
         if(parcnt > 0)

            AddSECSMessage("[SECS] " + spar[parcnt-1] + " : " + IntToStr(parcnt));

         if(cmdstr.Length() <= 0)
            break;
      }

      // 2021 9 8b - chc 解譯
      WriteSystemLog("解譯: " + scmd);

      // 2021 9 8b - chc 用timer來做
      //DecodeSECS(scmd,spar,parcnt,1);
      if(tmDecodeSECS->Enabled == false) {
         DecodeSCMD = scmd;
         for(int i=0 ; i<parcnt ; i++) {
            DecodeSPAR[i] = spar[i];
         }
         DecodePARCNT = parcnt;
         tmDecodeSECS->Enabled = true;
      }
      else {
         DecodeSECS(scmd,spar,parcnt,1);
      }

   }
   inactive = false;

}
catch(Exception &e) {
   MainForm->WriteSystemLog(">>Error(ssSECSSocketClientRead): "+e.Message);
   inactive = false;
}

}
//---------------------------------------------------------------------------
// SECS
void __fastcall TMainForm::ssSECSClientReadTest(AnsiString cmd)
{
static AnsiString eceivestr;
static bool inactive = false;
AnsiString text,cmdstr,slen,scmd,spar[150];
bool flag,done;
int pos,parcnt,pos1;
bool booltag = false;

   inactive = true;
   done = false;

   parcnt = 0;
   text = cmd;
   AddSECSMessage("[<] " + text);

   // 分段
   while((pos1 = text.Pos("$")) != 0) {
      // 取得完整命令字串
      cmdstr = text.SubString(1,pos1);
      pnlSECS->Caption = cmdstr;
      text.Delete(1,pos1);

      pos = cmdstr.Pos("^");
      if(pos == 0) {                                                            // No Parameter!
         scmd = cmdstr.SubString(1,pos1-1);
         pos = pos1-1;                          // @@
      }
      else {
booltag = true;
         scmd = cmdstr.SubString(1,pos-1);
      }
      if(scmd.Length() < 5) {
         AddSECSMessage("[<] Invalid: " + cmdstr);
         flag = false;
         continue;
      }
      if(pos > 0)                               // @@
         cmdstr.Delete(1,pos);
      //done = true;
      AddSECSMessage("[<] " + scmd);

      // Par
      while(done == false) {
         pos = cmdstr.Pos("^");
         if(pos == 0) {
            pos = cmdstr.Pos("$");
            if(pos == 0) {
               AddSECSMessage("[<] Invalid");
               flag = false;
               continue;
            }
            else {
               if(pos <= 1 && booltag == true)
                  spar[parcnt++] = "";
               else if(pos > 1)                                 // @@
                  spar[parcnt++] = cmdstr.SubString(1,pos-1);
               cmdstr.Delete(1,pos);
               done = true;
            }
         }
         else {
booltag = true;
            spar[parcnt++] = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
         }

         // 2021 4 28 - chc parcnt > 0
         if(parcnt > 0)

            AddSECSMessage("[SECS] " + spar[parcnt-1] + " : " + IntToStr(parcnt));
         if(cmdstr.Length() <= 0)
            break;
      }
      DecodeSECS(scmd,spar,parcnt,1);
/*
      // oSTAT^1$
      // 1234567890
      pos = cmdstr.Pos("^");
      if(pos == 0) {                                                            // No Parameter!
         pos = cmdstr.Pos("$");
         if(pos == 0) {
            AddSECSMessage("[<] Invalid: " + cmdstr);
            flag = false;
            continue;
         }
         else {
            scmd = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
            done = true;
         }
      }
      else {
         scmd = cmdstr.SubString(1,pos-1);
         cmdstr.Delete(1,pos);
      }
      if(scmd.Length() < 5) {
         AddSECSMessage("[<] Invalid: " + cmdstr);
         flag = false;
         continue;
      }

      //done = true;
      AddSECSMessage("[<] " + scmd);

      // Par
      while(done == false) {
         pos = cmdstr.Pos("^");
         if(pos == 0) {
            pos = cmdstr.Pos("$");
            if(pos == 0) {
               AddSECSMessage("[<] Invalid");
               flag = false;
               continue;
            }
            else {
               spar[parcnt++] = cmdstr.SubString(1,pos-1);
               cmdstr.Delete(1,pos);
               done = true;
            }
         }
         else {
            spar[parcnt++] = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
         }

         // 2021 4 28 - chc parcnt > 0
         if(parcnt > 0)

            AddSECSMessage("[SECS] " + spar[parcnt-1] + " : " + IntToStr(parcnt));
      }
      DecodeSECS(scmd,spar,parcnt,1);
*/

   }
   inactive = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSECSReConnectClick(TObject *Sender)
{

   try {
      ssSECSSocket->Active = false;
      WaitTime(1500);
      ssSECSSocket->Active = true;
   }
   catch(Exception &e) {
      WriteSystemLog(">>Error(btnSECSReConnectClick): "+e.Message);
      pnlSystemMessage->Caption = "SSECS Socket重連線失敗!";
   }

}
//---------------------------------------------------------------------------
// 2021 4 27 - chc SECS socket
void __fastcall TMainForm::AddSECSMessage(AnsiString msg)
{
AnsiString putmsg;
static AnsiString oldmsg = "";

   if(oldmsg == msg)                            // 重複不收錄
      return;
   oldmsg = msg;
   putmsg = Now().FormatString("hh':'nn':'ss':'zzz'-> '") + msg;
   // 最多共470 Rows
   mmSECS->Lines->Insert(0,putmsg);
   // Realtime
   mmSECS->Refresh();

   if(mmSECS->Lines->Count > 500) {
      for(int i=470 ; i<mmSECS->Lines->Count ; i++)
         mmSECS->Lines->Delete(i);
   }
}
//---------------------------------------------------------------------------
// 2021 4 27 - chc SECS socket
// mode: 0-Simulate, 1-Socket
// STAT, PortNo, PID, RC, CRCP, Stop, DateT

void __fastcall TMainForm::DecodeSECS(AnsiString scmd, AnsiString *spar, int parcnt, int mode)
{
int cmdno,parno,len;
AnsiString sack,astr,msg;
bool boolresult = false;
char buf[500];
double par1,par2;

   // 2021 9 8b - chc 解譯
   WriteSystemLog("DecodeSECS()...");

   parno = 0;
   cmdno = GetSECSCmdSet(scmd);
   if(cmdno == -1) {
      AddSECSMessage("Invalid");
      if(mode == 1) {
         SendSECSSocket("Invalid",0);
      }
      return;
   }
   switch(cmdno) {
      case SECS_CMD_STAT:
         parno = 0;
         break;
      case SECS_CMD_PTST:
         parno = 1;
         break;
      case SECS_CMD_PIDN:
         parno = 99;
         break;
      case SECS_CMD_RCMD:
         parno = 3;
         break;
      case SECS_CMD_CRCP:
         parno = 0;
         break;
      case SECS_CMD_STOP:
         parno = 0;
         break;
      case SECS_CMD_DATE:
         parno = 1;
         break;
      // From SECS Ack
      case SECS_CMD_STAT_1:
         parno = 0;
         break;
      case SECS_CMD_PTST_1:
         parno = 0;
         break;
      case SECS_CMD_PREV:
         parno = 0;
         break;
      case SECS_CMD_WIDR:
         parno = 0;
         break;
      case SECS_CMD_RCPM:
         parno = 0;
         break;
      case SECS_CMD_ALRM:
         parno = 0;
         break;
      case SECS_CMD_STWR:
         parno = 0;
         break;
   }
   //if(cmdno == SECS_CMD_STAT && parcnt == 1) {
   //   cmdno = SECS_CMD_PTST;
   //   parno = 1;
   //}
   if(parcnt != parno && parno != 99) {
      msg.sprintf("Invalid: CMD,parcnt,parno= %s,%d,%d",scmd.c_str(),parcnt,parno);
      AddSECSMessage(msg);
      if(mode == 1) {
         SendSECSSocket("Invalid",0);
      }
      return;
   }
   pnlSECSMessage->Caption = sack;
   pnlSECSMessage->Refresh();
   Sleep(edDelayTime->Text.ToInt());
   // Do Parameter
   switch(cmdno) {
      // From SECS Command
      case SECS_CMD_STAT:
         boolresult = true;
         break;
      case SECS_CMD_PTST:
         boolresult = true;
         break;
      case SECS_CMD_PIDN:
         boolresult = true;
         break;
      case SECS_CMD_RCMD:
         boolresult = true;
         break;
      case SECS_CMD_CRCP:
         boolresult = true;
         break;
      case SECS_CMD_STOP:
         boolresult = true;
         break;
      case SECS_CMD_DATE:
         boolresult = true;
         break;

      // 2021 5 7 - chc From SECS Ack
      case SECS_CMD_STAT_1:
         boolSECS_STAT = true;
         break;
      case SECS_CMD_PTST_1:
         boolSECS_PTST = true;
         break;
      case SECS_CMD_PREV:
         boolSECS_PREV = true;
         break;
      case SECS_CMD_WIDR:
         boolSECS_WIDR = true;
         break;
      case SECS_CMD_RCPM:
         boolSECS_RCPM = true;
         break;
      case SECS_CMD_ALRM:
         boolSECS_ALRM = true;
         break;
      case SECS_CMD_STWR:
         boolSECS_STWR = true;
         break;
   }

   // 2021 5 7 - chc From SECS Ack
   if(cmdno >= SECS_CMD_STAT_1 && cmdno <= SECS_CMD_STWR)
      return;

   rgSECSCommand->ItemIndex = cmdno;
   // PortNo
   AnsiString portname;
   if(rgSECSPortNo->ItemIndex == 0) {
      portname = "1";
   }
   else {
      portname = "2";
   }
   if(boolresult == true) {
      if(cmdno == SECS_CMD_STAT) {
         sack.sprintf("eSTAT^%d^%d",rgEQStatus->ItemIndex+1,rgEQExist->ItemIndex);
         if(rgEQExist->ItemIndex == 1)

            // 2021 9 15 - chc 是WaferID才對: WorkingWaferID
            //sack += ("^" + edEQID->Text);
            sack += ("^" + WorkingWaferID);

         else
            sack += "^";
         sack += "^";
         sack += IntToStr(rgUpArmExist->ItemIndex);
         if(rgUpArmExist->ItemIndex == 1)
            sack += ("^" + edUpArmID->Text);
         else
            sack += "^";
         sack += "^";
         sack += IntToStr(rgLowArmExist->ItemIndex);
         if(rgLowArmExist->ItemIndex == 1)
            sack += ("^" + edLowArmID->Text);
         else
            sack += "^";
         sack += "$";
      }
      else if(cmdno == SECS_CMD_PTST) {
         // ePTST^01^1^
         AnsiString portstatus;

         // 2023 8 1 - chc LP1/LP2
         /*
         if(rgPortStatus->ItemIndex == 0)
            portstatus = "LR";
         else if(rgPortStatus->ItemIndex == 1)
            portstatus = "LC";
         else if(rgPortStatus->ItemIndex == 2)
            portstatus = "MAP";
         else if(rgPortStatus->ItemIndex == 3)
            portstatus = "PROC";
         else if(rgPortStatus->ItemIndex == 4)
            portstatus = "LOTEND";
         else if(rgPortStatus->ItemIndex == 5)
            portstatus = "UR";
         else if(rgPortStatus->ItemIndex == 6)
            portstatus = "UC";
         else if(rgPortStatus->ItemIndex == 7)
            portstatus = "CSTREAD";
         sack.sprintf("ePTST^%s^%s",spar[0].c_str(),portname.c_str());
         sack += "^";
         */

         // 2023 8 1 - chc  未取出PortNo !!   spar[0] - PIDN/PTST/RCMD 會帶入PortNo
         rgSECSPortNo->ItemIndex = spar[0].ToInt();

         // 2023 8 1 - chc 要看rgSECSPortNo, 是Status才對
         //if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
         //   sack += IntToStr(rgCSTExist->ItemIndex);
         //else
         //   sack += IntToStr(rgCST2Exist->ItemIndex);
         //if((rgLoadPortSelect->ItemIndex == LOADPORT_1 && rgCSTExist->ItemIndex == 1) ||
         //   (rgLoadPortSelect->ItemIndex == LOADPORT_2 && rgCST2Exist->ItemIndex == 1))
         //   sack += ("^" + pnlSECSCSTID->Caption);
         //else
         //   sack += "^";
         //sack += ("^" + edMapData->Text);
         //sprintf(buf,"%s",edMapData->Text.c_str());
         if(rgSECSPortNo->ItemIndex == LOADPORT_1) {
            portname = "1";
            if(rgPortStatus->ItemIndex == 0)
               portstatus = "LR";
            else if(rgPortStatus->ItemIndex == 1)
               portstatus = "LC";
            else if(rgPortStatus->ItemIndex == 2)
               portstatus = "MAP";
            else if(rgPortStatus->ItemIndex == 3)
               portstatus = "PROC";
            else if(rgPortStatus->ItemIndex == 4)
               portstatus = "LOTEND";
            else if(rgPortStatus->ItemIndex == 5)
               portstatus = "UR";
            else if(rgPortStatus->ItemIndex == 6)
               portstatus = "UC";
            else if(rgPortStatus->ItemIndex == 7)
               portstatus = "CSTREAD";
            sack.sprintf("ePTST^%s^%s",spar[0].c_str(),portstatus.c_str());
            sack += "^";
            sack += IntToStr(rgCSTExist->ItemIndex);
            if(rgCSTExist->ItemIndex == 1)
               sack += ("^" + pnlSECSCSTID->Caption);
            else
               sack += "^";
            sack += ("^" + edMapData->Text);
            sprintf(buf,"%s",edMapData->Text.c_str());
         }
         else {
            portname = "2";
            if(rgPortStatus2->ItemIndex == 0)
               portstatus = "LR";
            else if(rgPortStatus2->ItemIndex == 1)
               portstatus = "LC";
            else if(rgPortStatus2->ItemIndex == 2)
               portstatus = "MAP";
            else if(rgPortStatus2->ItemIndex == 3)
               portstatus = "PROC";
            else if(rgPortStatus2->ItemIndex == 4)
               portstatus = "LOTEND";
            else if(rgPortStatus2->ItemIndex == 5)
               portstatus = "UR";
            else if(rgPortStatus2->ItemIndex == 6)
               portstatus = "UC";
            else if(rgPortStatus2->ItemIndex == 7)
               portstatus = "CSTREAD";
            sack.sprintf("ePTST^%s^%s",spar[0].c_str(),portstatus.c_str());
            sack += "^";
            sack += IntToStr(rgCST2Exist->ItemIndex);
            if(rgCST2Exist->ItemIndex == 1)
               sack += ("^" + pnlSECSCST2ID->Caption);
            else
               sack += "^";
            sack += ("^" + edMapData2->Text);
            sprintf(buf,"%s",edMapData2->Text.c_str());
         }

         for(int i=0 ; i<25 ; i++) {
            sack += "^";
            if(buf[i] == '1') {
               // WaferBuffer
               //sack += ("WID" + IntToStr(i+1));
               sack += WaferBuffer[i].ID;
            }
         }
         sack += "$";
         pnlSECSPortNo->Caption = spar[0];

         // 2021 9 8a - chc 設定Port
         WriteSystemLog("SECS PTST要求Port: " + pnlSECSPortNo->Caption);

      }
      // aPIDN^result$
      else if(cmdno == SECS_CMD_PIDN) {
         // oPIDN^PortNo^CSTID^SlotNo^ID^RCP^Priority.....
         //       0      1     2      3  4   5
         // 取得WaferID/RecipeName/Priority
         int wno,slotno,sno;
         TPanel *panel,*panel1;
         wno = (parcnt - 2) / 4;
         sno = 2;

         // 2021 9 8b - chc 解譯
         WriteSystemLog("DecodeSECS(): PIDN各片資訊...");

         // 2021 9 8b - chc 不必做Clear, 否則會破壞Mapping結果
         //ClearWaferBuffer();

         // 2023 8 1 - chc  未取出PortNo !!   spar[0] - PIDN/PTST/RCMD 會帶入PortNo
         rgSECSPortNo->ItemIndex = spar[0].ToInt();

         for(int i=0 ; i<wno ; i++) {
            slotno = spar[sno].ToInt();
            WaferBuffer[slotno-1].ID = spar[sno+1];
            WaferBuffer[slotno-1].RecipeName = spar[sno+2];
            WaferBuffer[slotno-1].Priority = spar[sno+3].ToInt();
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(slotno)));
            panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(slotno) + "Select"));
            panel->Caption = WaferBuffer[slotno-1].ID;
            sno += 4;

            // 2021 9 8b - chc Priority不是0就是做的
            //if(WaferBuffer[slotno-1].ID == "")
            //   CassetteBuffer[slotno-1] = '0';
            //else
            //   CassetteBuffer[slotno-1] = '1';
            if(WaferBuffer[slotno-1].Priority == 0)
               panel1->Color = clSilver;
            else
               panel1->Color = clLime;

         }

         // 2021 9 8b - chc 解譯
         WriteSystemLog("DecodeSECS(): PIDN各片資訊.");

         // 2023 8 1 - chc LP1/LP2
         //CassetteBuffer[26] = 0x0;
         //sprintf(WorkingBuffer,"%s",CassetteBuffer);
         //edMapData->Text = CassetteBuffer;
         if(rgSECSPortNo->ItemIndex == LOADPORT_2) {
            CassetteBuffer[LOADPORT_2][26] = 0x0;
            sprintf(WorkingBuffer,"%s",CassetteBuffer[LOADPORT_2]);
            edMapData2->Text = CassetteBuffer[LOADPORT_2];
         }
         else {
            CassetteBuffer[LOADPORT_1][26] = 0x0;
            sprintf(WorkingBuffer,"%s",CassetteBuffer[LOADPORT_1]);
            edMapData->Text = CassetteBuffer[LOADPORT_1];
         }

         // Ack
         if(rgSECSPortNo->ItemIndex == LOADPORT_1)
            sack.sprintf("aPIDN^%d$",rgSECSResult->ItemIndex);
         else
            sack.sprintf("aPIDN^%d$",rgSECSResult2->ItemIndex);
         if(rgSECSPortNo->ItemIndex == LOADPORT_2)
            pnlSECSCST2ID->Caption = spar[1];
         else
            pnlSECSCSTID->Caption = spar[1];
         WriteSystemLog("PIDN(From SECS): " + pnlSECSCSTID->Caption);
         pnlSECSWaferID->Caption = spar[3];
         pnlSECSRCP->Caption = spar[4];
         pnlSECSPriority->Caption = spar[5];
         pnlSECSPortNo->Caption = spar[0];

         // 2021 9 8a - chc 設定Port
         WriteSystemLog("SECS PIDN要求Port: " + pnlSECSPortNo->Caption + ",CSTID=" + pnlSECSCSTID->Caption);

         // 2021 10 17 - chc 自動取片
         if(cbOffLine->Checked == false && cbSECSAtuo->Checked == true) {
            if(tmAutoLoadWafer->Enabled == false) {
               pnlSystemMessage->Caption = "SECS取得Mapping資料: 自動進行Timer取片作業.";
               WriteSystemLog(pnlSystemMessage->Caption);
               tmAutoLoadWafer->Enabled = true;
            }
         }

      }
      // oRCMD^3^1^CSTID$
      else if(cmdno == SECS_CMD_RCMD) {
         if(rgSECSPortNo->ItemIndex == LOADPORT_1)
            sack.sprintf("aRCMD^%d$",rgSECSResult->ItemIndex);
         else
            sack.sprintf("aRCMD^%d$",rgSECSResult2->ItemIndex);
         rgSECSType->ItemIndex = spar[0].ToInt() - 1;
         pnlSECSPortNo->Caption = spar[1];

         // CSTID
         if(rgSECSPortNo->ItemIndex == LOADPORT_2)
            pnlSECSCST2ID->Caption = spar[2];
         else
            pnlSECSCSTID->Caption = spar[2];
         WriteSystemLog("RCMD(From SECS): " + pnlSECSCSTID->Caption);
         // PortNo
         rgSECSPortNo->ItemIndex = spar[1].ToInt() - 1;

         // 2021 9 8a - chc 設定Port
         WriteSystemLog("SECS TCMD要求Port: " + pnlSECSPortNo->Caption + ",CSTID=" + pnlSECSCSTID->Caption);

         // Mapping
         // => 暫不做LOAD/Mapping, 因人員可能尚未離手!
         // => 要做, 等人員按下LOAD後才會收到.
         if(spar[0] == "3") {
            WriteSystemLog("RCMD(From SECS): Mapping");

            // 2021 9 8a - chc 設定PortNo
            if(rgSECSPortNo->ItemIndex == LOADPORT_1)
               rgLoadPortSelect->ItemIndex = LOADPORT_1;
            else
               rgLoadPortSelect->ItemIndex = LOADPORT_2;

            // 2021 5 6 - chc 先送出
            if(mode == 1) {
               WriteSystemLog("RCMD(From SECS Mapping): 送出aRCMD");
               SendSECSSocket(sack,1);
            }

            // 2021 6 2 - chc 連線下才做
            if(cbOffLine->Checked == false) {

               // 2021 9 8a - chc 要看rgLoadPortSelect
               //if(rgSECSPortNo->ItemIndex == LOADPORT_1) {
               // 2021 9 8b - chc 用timer做
               //if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
               //
               //   btnLoadPort1CLMPClick(this);
               //}
               //else {
               //   btnLoadPort2CLMPClick(this);
               //}
               WriteSystemLog("在DecodeSECS中使用Timer處理Load.");
               tmDoLoadUnload->Enabled = true;

            }
         }

         // 2022 2 13 - chc RCMD: 1-Cancel, 2-Abort SECSRemoteCommand
         else if(spar[0] == "1") {

            // 2022 3 11 - chc Log, 先送出
            WriteSystemLog("RCMD(From SECS): Cancel");
            // 先送出
            if(mode == 1) {
               WriteSystemLog("RCMD(From SECS Cancel): 送出aRCMD");
               SendSECSSocket(sack,1);
            }

            if(btnCassetteLoad->Enabled == true && btnCassetteLoad->Caption == "UnLoad") {
               SECSRemoteCommand = SECS_REMOTE_CANCEL;
               // 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
               if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false && WaferInSystem() == false) {
                  if(tmAutoUnload->Enabled == false) {
                     pnlSystemMessage->Caption = "RCMD(From SECS): Cancel: 自動進行Timer UnLoad作業.";
                     WriteSystemLog(pnlSystemMessage->Caption);
                     tmAutoUnload->Enabled = true;
                  }
               }
            }
         }
         else if(spar[0] == "2") {
            WriteSystemLog("RCMD(From SECS): Abort");
            SECSRemoteCommand = SECS_REMOTE_ABORT;

            // 2022 3 11 - chc 先送出
            if(mode == 1) {
               WriteSystemLog("RCMD(From SECS Abort): 送出aRCMD");
               SendSECSSocket(sack,1);
            }

         }

      }
      else if(cmdno == SECS_CMD_CRCP) {
         sack.sprintf("aCRCP^%s$",edSECSRecipeID->Text.c_str());
      }
      else if(cmdno == SECS_CMD_STOP) {
         if(rgSECSPortNo->ItemIndex == LOADPORT_1)
            sack.sprintf("aSTOP^%d$",rgSECSResult->ItemIndex);
         else
            sack.sprintf("aSTOP^%d$",rgSECSResult2->ItemIndex);
      }
      else if(cmdno == SECS_CMD_DATE) {
         sack.sprintf("aDATE$");
         pnlSECSDateTime->Caption = spar[0];
      }
      AddSECSMessage("[>] " + sack);
      if(mode == 1) {
         // SECS_CMD_RCMD已送過
         if(cmdno != SECS_CMD_RCMD)
            SendSECSSocket(sack,1);
      }
      pnlSECSMessage->Caption = sack;
      pnlSECSMessage->Refresh();
   }
}
//---------------------------------------------------------------------------
// -1: Fail
int __fastcall TMainForm::GetSECSCmdSet(AnsiString cmd)
{

   for(int i=0 ; i<SECS_CMD_MAX ; i++) {
      if(SECSCmdSet[i] == cmd) {
         return i;
      }
   }
   return -1;
}
//---------------------------------------------------------------------------
// to Motin: Motion, ReadRecipe, GetErr
// to YUANLI: STAT, PortNo, PID, RC, CRCP, Stop, DateT
void __fastcall TMainForm::SetSECSCmdSet()
{

   // from SECS
   SECSCmdSet[0] = "oSTAT";
   SECSCmdSet[1] = "oSTAT";
   SECSCmdSet[2] = "oPIDN";
   SECSCmdSet[3] = "oRCMD";
   SECSCmdSet[4] = "oCRCP";
   SECSCmdSet[5] = "oSTOP";
   SECSCmdSet[6] = "oDATE";
   // To SECS
   SECSCmdSet[7] = "aSTAT";
   SECSCmdSet[8] = "aPTST";
   SECSCmdSet[9] = "aPREV";
   SECSCmdSet[10] = "aWIDR";
   SECSCmdSet[11] = "aRCPM";
   SECSCmdSet[12] = "aALRM";
   SECSCmdSet[13] = "aSTWR";
}
//---------------------------------------------------------------------------
// mode: 0-未加入長度, 1-已加入長度
void __fastcall TMainForm::SendSECSSocket(AnsiString str, int mode)
{
AnsiString astr,sack;
int len;
char buf[500];

   // 2022 3 11 - chc 在Local下不送給SECS
   if(cbOffLine->Checked == true)
      return;

   astr = str;
   if(mode == 0) {
      sack.sprintf("%s$",len+1,astr.c_str());
      sprintf(buf,"%s",sack.c_str());
   }
   else {
      sprintf(buf,"%s",astr.c_str());
   }
   len = strlen(buf);

   // 2021 9 8 - chc SECS送出
   WriteSystemLog("SendSECSSocket SECS送出: " + str);

   for(int i=0 ; i<ssSECSSocket->Socket->ActiveConnections ; i++) {
      ssSECSSocket->Socket->Connections[i]->SendBuf(buf,len);
   }

}
//---------------------------------------------------------------------------
//  for tset
void __fastcall TMainForm::Label523Click(TObject *Sender)
{

   //ssSECSClientReadTest("oSTAT$");
   //ssSECSClientReadTest("oPTST^1$");
   ssSECSClientReadTest("oPIDN^1^^1^^^0^2^wafer02^rcp^1^3^^^0^4^wafer04^rcp^1^5^^^0^6^wafer06^rcp^1^7^^^0^8^wafer08^rcp^1^9^^^0^10^wafer10^rcp^1^11^^^0^12^wafer12^rcp^1^13^^^0^14^wafer14^rcp^1^15^^^0^16^wafer16^rcp^1^17^^^0^18^wafer18^rcp^1^19^^^0^20^wafer20^rcp^1^21^^^0^22^wafer22^rcp^1^23^^^0^24^wafer24^rcp^1^25^^^0$");
   //ssSECSClientReadTest("oPIDN^1^cstid^05^wd5^rcp5^2^07^wd7^rcp7^3$");
   //ssSECSClientReadTest("oRCMD^2^1^cstid-test$");
   //ssSECSClientReadTest("oCRCP$");
   //ssSECSClientReadTest("oCRCP$");
   //ssSECSClientReadTest("oSTOP$");
   //ssSECSClientReadTest("oDATE^20210427150000$");

}
//---------------------------------------------------------------------------
/*
#define SECS_CMD_STAT_1            7
#define SECS_CMD_PTST              8
#define SECS_CMD_PREV              9
#define SECS_CMD_WIDR              10
#define SECS_CMD_RCPM              11
#define SECS_CMD_ALRM              12
#define SECS_CMD_STWR              13
   SECSCmdSet[7] = "oSTAT";
   SECSCmdSet[8] = "oPTST";
   SECSCmdSet[9] = "oPREV";
   SECSCmdSet[10] = "oWIDR";
   SECSCmdSet[11] = "oRCPM";
   SECSCmdSet[12] = "oALRM";
   SECSCmdSet[13] = "oSTWR";
*/
// "eRCPM^Type^RecipeID$
// Type : 1-4 ( 1 : Change , 2 : Create , 3 : Modify , 4 : Delete)
// Type : 1-4 ( 1 : Change , 2 : Create , 3 : Modify , 4 : Delete)"
// To SECS
void __fastcall TMainForm::rgSecsCommandSetClick(TObject *Sender)
{
int cmdno;
AnsiString sack;
AnsiString portstatus,portno,status,occur,level,message,portname;
char buf[500];
AnsiString scode;
int len;

   // 2021 10 25 - chc Log
   WriteSystemLog("rgSecsCommandSetClick...");

   cmdno = rgSecsCommandSet->ItemIndex;

   // PortStatus
   // 2023 8 1 - chc LP1/LP2
   if(rgSECSPortNo->ItemIndex == LOADPORT_2) {
      if(rgPortStatus2->ItemIndex == 0)
         portstatus = "LR";
      else if(rgPortStatus2->ItemIndex == 1)
         portstatus = "LC";
      else if(rgPortStatus2->ItemIndex == 2)
         portstatus = "MAP";
      else if(rgPortStatus2->ItemIndex == 3)
         portstatus = "PROC";
      else if(rgPortStatus2->ItemIndex == 4)
         portstatus = "LOTEND";
      else if(rgPortStatus2->ItemIndex == 5)
         portstatus = "UR";
      else if(rgPortStatus2->ItemIndex == 6)
         portstatus = "UC";
      else if(rgPortStatus2->ItemIndex == 7)
         portstatus = "CSTREAD";
   }
   else {

      if(rgPortStatus->ItemIndex == 0)
         portstatus = "LR";
      else if(rgPortStatus->ItemIndex == 1)
         portstatus = "LC";
      else if(rgPortStatus->ItemIndex == 2)
         portstatus = "MAP";
      else if(rgPortStatus->ItemIndex == 3)
         portstatus = "PROC";
      else if(rgPortStatus->ItemIndex == 4)
         portstatus = "LOTEND";
      else if(rgPortStatus->ItemIndex == 5)
         portstatus = "UR";
      else if(rgPortStatus->ItemIndex == 6)
         portstatus = "UC";
      else if(rgPortStatus->ItemIndex == 7)
         portstatus = "CSTREAD";
   }

   // PortNo
   // 2021 9 8a - chc 要更換PortNo
   //if(rgSECSPortNo->ItemIndex == 0)
   // 2023 8 1 - chc 不變動
   //if(rgSECSPortNo->ItemIndex == LOADPORT_2)
   if(rgSECSPortNo->ItemIndex == LOADPORT_1)

      portname = "1";
   else
      portname = "2";

   // Status
   if(rgSECSStatus->ItemIndex == 0)
      status = "Fetch";
   else if(rgSECSStatus->ItemIndex == 1)
      status = "Store";
   else if(rgSECSStatus->ItemIndex == 2)
      status = "Receive";
   else if(rgSECSStatus->ItemIndex == 3)
      status = "Send";
   else if(rgSECSStatus->ItemIndex == 4)
      status = "ProcessEnd";
   // Occur
   if(rgSECSOccur->ItemIndex == 0)
      //occur = "Reset";
      occur = "0";
   else
      //occur = "Set";
      occur = "1";
   // Level
   if(rgSECSLevel->ItemIndex == 0)
      //level = "Light";
      level = "0";
   else
      //level = "High";
      level = "1";
   // Message
   message = "Motor Stall";
   switch(cmdno+7) {
      // eSTAT^
      case SECS_CMD_STAT_1:
         sack.sprintf("eSTAT^%d^%d",rgEQStatus->ItemIndex+1,rgEQExist->ItemIndex);
         if(rgEQExist->ItemIndex == 1)
            sack += ("^" + edSECSWaferID->Text);
         else
            sack += "^";
         sack += "^";
         sack += IntToStr(rgUpArmExist->ItemIndex);
         if(rgUpArmExist->ItemIndex == 1)
            sack += ("^" + edUpArmID->Text);
         else
            sack += "^";
         sack += "^";
         sack += IntToStr(rgLowArmExist->ItemIndex);
         if(rgLowArmExist->ItemIndex == 1)
            sack += ("^" + edLowArmID->Text);
         else
            sack += "^";
         sack += "$";
         break;
      case SECS_CMD_PTST_1:

         // 2021 9 8b - chc Log, CSTID正常為8碼, 前7碼 + 8碼 + 2碼
         // 02000OK12345678AB
         // 12345678901234567
         // 17 - 9 = 8
         // 2023 8 2 - chc 不用再截取, 已經放好了: 彰化是否有錯??
         /*
         WriteSystemLog("CSTID = " + pnlSECSCSTID->Caption);
         scode = pnlSECSCSTID->Caption;
         len = scode.Length();
         if(len > 15) {

            // 2021 10 15 - chc 改成總長度-9
            //scode = scode.SubString(8,8);
            scode = scode.SubString(8,len-9);

            if(rgSECSPortNo->ItemIndex == LOADPORT_2)
               pnlSECSCST2ID->Caption = scode;
            else
               pnlSECSCSTID->Caption = scode;
         }
         if(rgSECSPortNo->ItemIndex == LOADPORT_2)
            WriteSystemLog("CSTID = " + pnlSECSCST2ID->Caption);
         else
            WriteSystemLog("CSTID = " + pnlSECSCSTID->Caption);
         */

         // ePTST^01^1^
         sack.sprintf("ePTST^%s^%s",portname.c_str(),portstatus.c_str());
         sack += "^";
         if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
            sack += IntToStr(rgCSTExist->ItemIndex);
         else
            sack += IntToStr(rgCST2Exist->ItemIndex);

         // 2023 8 1 - chc 要看rgSECSPortNo
         //if((rgLoadPortSelect->ItemIndex == LOADPORT_1 && rgCSTExist->ItemIndex == 1) ||
         //   (rgLoadPortSelect->ItemIndex == LOADPORT_2 && rgCST2Exist->ItemIndex == 1)) {
         //      sack += ("^" + pnlSECSCSTID->Caption);
         //   else
         //      sack += "^";
         //   }
         //}
         //sack += ("^" + edMapData->Text);
         //sprintf(buf,"%s",edMapData->Text.c_str());
         if(rgSECSPortNo->ItemIndex == LOADPORT_1) {
            if(rgCSTExist->ItemIndex == 1)
               sack += ("^" + pnlSECSCSTID->Caption);
            else
               sack += "^";
            sack += ("^" + edMapData->Text);
            sprintf(buf,"%s",edMapData->Text.c_str());
         }
         else {
            if(rgCST2Exist->ItemIndex == 1)
               sack += ("^" + pnlSECSCST2ID->Caption);
            else
               sack += "^";
            sack += ("^" + edMapData2->Text);
            sprintf(buf,"%s",edMapData2->Text.c_str());
         }

         for(int i=0 ; i<25 ; i++) {
            sack += "^";
            if(buf[i] == '1') {
               // WaferBuffer
               //sack += ("WID" + IntToStr(i+1));
               sack += WaferBuffer[i].ID;
            }
         }
         sack += "$";
         break;
      case SECS_CMD_PREV:
         sack.sprintf("ePREV^%s^%s",status.c_str(),portname.c_str());

         // 2023 8 2 - chc LP1/LP2
         if(rgSECSPortNo->ItemIndex == LOADPORT_2)
            sack += ("^" + pnlSECSCST2ID->Caption);
         else

            sack += ("^" + pnlSECSCSTID->Caption);
         sack += ("^" + edSECSSlotNo->Text);
         sack += ("^" + edSECSWaferID->Text);
         sack += "$";
         break;
      case SECS_CMD_WIDR:
         if(rgSECSPortNo->ItemIndex == LOADPORT_1)
            sack.sprintf("eWIDR^%d^%s",rgSECSResult->ItemIndex,portname.c_str());
         else
            sack.sprintf("eWIDR^%d^%s",rgSECSResult2->ItemIndex,portname.c_str());

         if(rgSECSPortNo->ItemIndex == LOADPORT_2) 
            sack += ("^" + pnlSECSCST2ID->Caption);
         else

            sack += ("^" + pnlSECSCSTID->Caption);
         sack += ("^" + edSECSSlotNo->Text);
         sack += ("^" + edSECSSourceWID->Text);
         sack += ("^" + edSECSReadWID->Text);
         sack += "$";
         break;
      // eRCPM^Type^RecipeID$
      case SECS_CMD_RCPM:
         sack.sprintf("eRCPM^%d^%s$",rgSECSRecipe->ItemIndex+1,edSECSRecipeID->Text.c_str());
         break;
      case SECS_CMD_ALRM:
         message = SECSAlarmMessage;
         sack.sprintf("eALRM^%s^%s^%s^%s$",occur.c_str(),level.c_str(),pnlSECSAlarmCode->Caption.c_str(),message.c_str());
         break;
      // 0,0,1,1,0 - RYGBB
      case SECS_CMD_STWR:
         sack.sprintf("eSTWR^0^0^1^1^0$");
         break;
   }
   AddSECSMessage("[>] " + sack);
   edSECSCmd->Text = sack;

   // 2021 5 5 - chc 是否送出Command : boolSendSCESCommand
   if(boolSendSCESCommand == true) {
      boolSendSCESCommand = false;
      btnSECSSendClick(this);
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSECSSendClick(TObject *Sender)
{
int no,sno,count,eno,timedelay;

   // 2022 3 11 - chc 在Local下不送給SECS
   if(cbOffLine->Checked == true) {
      pnlSECSSend->Color = clRed;
      return;
   }

try {
   btnSECSSend->Enabled = false;
   int pos,len;
   AnsiString cmd,str;
   char buf[500];
   pnlSECSSend->Color = clSilver;
   str = edSECSCmd->Text;
   len = str.Length();
   if(len <= 0) {
      pnlSECSSend->Color = clRed;
      return;
   }

   // 2021 9 8 - chc SECS送出
   WriteSystemLog("btnSECSSendClick SECS送出: " + str);

   len += 1;
   cmd.sprintf("%s",str.c_str());
   sprintf(buf,"%s",cmd.c_str());
   pnlSECS->Caption = cmd;
   len = strlen(buf);
   AddSECSMessage("[>] " + pnlSECS->Caption);

   if(ssSECSSocket->Active == true) {
      pnlSECSSend->Color = clLime;
      for(int i=0 ; i<ssSECSSocket->Socket->ActiveConnections ; i++) {
         ssSECSSocket->Socket->Connections[i]->SendBuf(buf,len);
         break;
      }
   }
   //if(csSECSSocket->Active == true) {
   //   pnlSECSSend->Color = clLime;
   //   csSECSSocket->Socket->SendBuf(buf,len);
   //}
   else {
      // 暫不用
      //if(cbSimlate->Checked == true) {
      //   sprintf(buf,"07,Motion>07,ToHome>",cmd.c_str());
      //   SimulateSocket(buf);
      //}
   }
   btnSECSSend->Enabled = true;

}
catch(Exception &e) {
   MainForm->WriteSystemLog(">>Error(btnSECSSendClick): "+e.Message);
   btnSECSSend->Enabled = true;
}

   return;
}
//---------------------------------------------------------------------------
// to (col,row)
void __fastcall TMainForm::btnWaferChipClick(TObject *Sender)
{
int row,col,dx,dy,sx,sy,x,y,w,h,cx,cy,factor;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   row = edWaferRow->Text.ToInt();
   col = edWaferCol->Text.ToInt();

   dx = Wafer.Dx;
   dy = Wafer.Dy;
   sx = Wafer.X;
   sy = Wafer.Y;
   x = col * dx + dx/2;

   // 2021 9 30 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      y = (GridNoY - row - 1) * dy + dy/2;
   }
   else

      y = row * dy + dy/2;
   w = sbWaferMap->Width;
   h = sbWaferMap->Height;
   if(y < (h/2)) {
      sbWaferMap->VertScrollBar->Position = 0;
   }
   else {

      // 2021 9 30a - chc 大於總量
      if((y+h/2) >= sbWaferMap->VertScrollBar->Range) {
         sbWaferMap->VertScrollBar->Position = (y) - h;
      }
      else

         sbWaferMap->VertScrollBar->Position = (y) - h / 2;
   }
   if(x < (w/2))
      sbWaferMap->HorzScrollBar->Position = 0;
   else {

      // 2021 9 30a - chc 大於總量
      if((x+w/2) >= sbWaferMap->HorzScrollBar->Range) {
         sbWaferMap->HorzScrollBar->Position = (x) - w;
      }
      else

         sbWaferMap->HorzScrollBar->Position = (x) - w / 2;
   }

   // 中心打標
   cx = x + dx / 2;
   cy = y + dy / 2;
   factor = tbZoom->Position;
   imWaferMap->Canvas->Pen->Color = clNavy;
   imWaferMap->Canvas->Pen->Width = 1*factor;
   //imWaferMap->Canvas->Ellipse(cx+3*factor, cy+3*factor, cx+dx-2*factor, cy+dy-2*factor);
}
//---------------------------------------------------------------------------
// type : 0-Inner, 1-Out, 2-half
void __fastcall TMainForm::DrawRowCol(int sx,int sy,int col,int row,int type, int factor)
{
AnsiString msg,sdie;
int dy,gap;

   if(cbFontDisplay->Checked == false)
      return;
      
   if(factor < 6) {
      imWaferMap->Canvas->Font->Size = 8;
      dy = 12;
      gap = 2;
   }
   else if(factor < 10) {
      imWaferMap->Canvas->Font->Size = 11;
      dy = 14;
      gap = 4;
   }
   else if(factor < 15) {
      imWaferMap->Canvas->Font->Size = 13;
      dy = 18;
      gap = 4;
   }
   else {
      imWaferMap->Canvas->Font->Size = 15;
      dy = 20;
      gap = 4;
   }
   imWaferMap->Canvas->Font->Name = "Arial";                                 // Arial
   if(type == 0) {

                  // 2021 12 15 - chc 最小Row,Col
                  if(row < 0 || col < 0) {
                     int no;
                     no = 1;
                  }

      // 2021 6 16 - chc 看MapCode[][]
      if(MapCode[row][col] == 4)
         imWaferMap->Canvas->Font->Color = clWhite;

      // 2021 8 11 - chc 指定點
      else if(MapCode[row][col] == 5)
         imWaferMap->Canvas->Font->Color = clWhite;

      // 2021 8 24 - chc Center Die
      else if(MapCode[row][col] == 6)
         imWaferMap->Canvas->Font->Color = clWhite;

      else

         imWaferMap->Canvas->Font->Color = clBlack;
   }
   else if(type == 1)
      imWaferMap->Canvas->Font->Color = clBlack;
   else
      imWaferMap->Canvas->Font->Color = clWhite;
   msg.sprintf("X:%d / Y:%d",col,row);
   imWaferMap->Canvas->TextOut(sx+5,sy+5,msg);
   if(type == 0) {

      // 2021 6 16 - chc 看MapCode[][]
      if(MapCode[row][col] == 4)
         sdie = "Measure";

      // 2021 8 11 - chc 指定點
      else if(MapCode[row][col] == 5)
         sdie = "Selected";

      // 2021 8 11 - chc Center Die
      else if(MapCode[row][col] == 6)
         sdie = "Center Die";

      else

         sdie = "testable";
   }
   else if(type == 1)
      sdie = "skipdie";
   else if(type == 2)
      sdie = "inkdie";

   // 2021 9 30 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      row = GridNoY - row - 1;
   }

   msg.sprintf("X:%03d/Y:%03d",col,row);
   imWaferMap->Canvas->TextOut(sx+gap,sy+gap,msg);
   msg.sprintf("%-10s",sdie);
   imWaferMap->Canvas->TextOut(sx+gap,sy+gap+dy*1,msg);
   return;
}
//---------------------------------------------------------------------------
bool __fastcall TMainForm::GetBitValue(char *buf, int bitno)
{
int checkcode,bitmod;
bool result;

   bitmod = bitno % 4;
   checkcode = 0x01 << bitmod;
   result = buf[15-bitno/4] & checkcode;
   return result;
}
//---------------------------------------------------------------------------
// 2021 4 28 - chc Rorze
// LoadPort1: Presence
void __fastcall TMainForm::SetLoadPortPresence(int portno, bool mode)
{
TColor color;
AnsiString smode;

   if(mode == true) {
      color = clWhite;
      smode = "1";
   }
   else {
      color = clSilver;
      smode = "0";
   }

   if(portno == 1) {

      // SECS: 放入Cassette, LR => PTST 空
      if(pnlLoadPort1Presence->Color != clSilver && mode == 0) {

         // 2021 9 8 - chc 變更Port編號
         rgSECSPortNo->ItemIndex = LOADPORT_1;
         //rgSECSPortNo->ItemIndex = LOADPORT_2;

         // UC
         rgPortStatus->ItemIndex = PORT_STATUS_UC;
         edMapData->Text = "0000000000000000000000000";

         // 2021 9 8 - chc 變更Port編號
         WriteSystemLog("boolSendSCESCommand: LP1, UC");
         //WriteSystemLog("boolSendSCESCommand: LP2, UC");

         rgSecsCommandSet->ItemIndex = -1;
         boolSendSCESCommand = true;
         rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
         // LR
         rgPortStatus->ItemIndex = PORT_STATUS_LR;
         edMapData->Text = "0000000000000000000000000";

         // 2021 9 8 - chc 變更Port編號
         WriteSystemLog("boolSendSCESCommand: LP1, LR");
         //WriteSystemLog("boolSendSCESCommand: LP2, LR");

         rgSecsCommandSet->ItemIndex = -1;
         boolSendSCESCommand = true;
         rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      }
      // SECS: 放入Cassette, LC => PTST 放入
      else if(pnlLoadPort1Presence->Color == clSilver && mode == 1) {

         // 2021 9 8 - chc 變更Port編號
         rgSECSPortNo->ItemIndex = LOADPORT_1;
         //rgSECSPortNo->ItemIndex = LOADPORT_2;

         rgPortStatus->ItemIndex = PORT_STATUS_LC;
         WriteSystemLog("boolSendSCESCommand: 18");
         rgSecsCommandSet->ItemIndex = -1;
         boolSendSCESCommand = true;
         rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

         // 讀RFID
         // 送CSTREAD後, SECS會送MAP要求做LOAD動作
         // => 於人員LOAD時才做
         //rgRFIDLoadPort->ItemIndex = LOADPORT_1;
         //rgRFIDWaferSize->ItemIndex = 0;
         //rgRFIDTagType->ItemIndex = 2;
         //btnRFIDReadClick(this);
         //rgSECSPortNo->ItemIndex = LOADPORT_1;
         //rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
         //WriteSystemLog("boolSendSCESCommand: 19");
         //rgSecsCommandSet->ItemIndex = -1;
         //boolSendSCESCommand = true;
         //rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      }

      pnlLoadPort1Presence->Color = color;
      edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_PRESENCE_BIT) + "," + smode + ")";
      LoadPort1Cmd = "SPOT";
      btnLoadPort1SendClick(this);
   }
   else {

      // SECS: 放入Cassette, LR => PTST
      if(pnlLoadPort2Presence->Color != clSilver && mode == 0) {

         // 2021 9 8 - chc 變更Port編號
         rgSECSPortNo->ItemIndex = LOADPORT_2;
         //rgSECSPortNo->ItemIndex = LOADPORT_1;

         // UC
         // 2023 8 1 - chc LP1/LP2
         //rgPortStatus->ItemIndex = PORT_STATUS_UC;
         rgPortStatus2->ItemIndex = PORT_STATUS_UC;

         // 2023 8 1 - chc LP1/LP2
         //edMapData->Text = "0000000000000000000000000";
         edMapData2->Text = "0000000000000000000000000";

         // 2021 9 8 - chc 變更Port編號
         WriteSystemLog("boolSendSCESCommand: LP2, UC");
         //WriteSystemLog("boolSendSCESCommand: LP1, UC");

         rgSecsCommandSet->ItemIndex = -1;
         boolSendSCESCommand = true;
         rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

         // LR
         // 2023 8 1 - chc LP1/LP2
         //rgPortStatus->ItemIndex = PORT_STATUS_LR;
         rgPortStatus2->ItemIndex = PORT_STATUS_LR;

         // 2023 8 1 - chc LP1/LP2
         //edMapData->Text = "0000000000000000000000000";
         edMapData2->Text = "0000000000000000000000000";

         // 2021 9 8 - chc 變更Port編號
         WriteSystemLog("boolSendSCESCommand: LP2, LR");
         //WriteSystemLog("boolSendSCESCommand: LP1, LR");

         rgSecsCommandSet->ItemIndex = -1;
         boolSendSCESCommand = true;
         rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      }
      // SECS: 放入Cassette, LR => PTST
      else if(pnlLoadPort2Presence->Color == clSilver && mode == 1) {

         // 2021 9 8 - chc 變更Port編號
         rgSECSPortNo->ItemIndex = LOADPORT_2;
         //rgSECSPortNo->ItemIndex = LOADPORT_1;

         // 2023 8 1 - chc LP1/LP2
         //rgPortStatus->ItemIndex = PORT_STATUS_LC;
         rgPortStatus2->ItemIndex = PORT_STATUS_LC;

         WriteSystemLog("boolSendSCESCommand: 21");
         rgSecsCommandSet->ItemIndex = -1;
         boolSendSCESCommand = true;
         rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
         // 讀RFID
         // 送CSTREAD後, SECS會送MAP要求做LOAD動作
         // => 於人員LOAD時才做
         //rgRFIDLoadPort->ItemIndex = LOADPORT_2;
         //rgRFIDWaferSize->ItemIndex = 1;
         //rgRFIDTagType->ItemIndex = 2;
         //btnRFIDReadClick(this);
         //rgSECSPortNo->ItemIndex = LOADPORT_2;
         //rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
         //WriteSystemLog("boolSendSCESCommand: 22");
         //rgSecsCommandSet->ItemIndex = -1;
         //boolSendSCESCommand = true;
         //rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
      }

      pnlLoadPort2Presence->Color = color;
      edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_PRESENCE_BIT) + "," + smode + ")";
      LoadPort2Cmd = "SPOT";
      btnLoadPort2SendClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 28 - chc Rorze
// LoadPort1: Placement
void __fastcall TMainForm::SetLoadPortPlacement(int portno, bool mode)
{
TColor color;
AnsiString smode;

   if(mode == true) {
      color = clWhite;
      smode = "1";
   }
   else {
      color = clSilver;
      smode = "0";
   }

   if(portno == 1) {
      pnlLoadPort1Placement->Color = color;
      edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_PLACEMENT_BIT) + "," + smode + ")";
      LoadPort1Cmd = "SPOT";
      btnLoadPort1SendClick(this);
   }
   else {
      pnlLoadPort2Placement->Color = color;
      edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_PLACEMENT_BIT) + "," + smode + ")";
      LoadPort2Cmd = "SPOT";
      btnLoadPort2SendClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 28 - chc Rorze
// LoadPort1: Load
void __fastcall TMainForm::SetLoadPortLoad(int portno, bool mode)
{
TColor color;
AnsiString smode;

   if(mode == true) {
      color = clLime;
      smode = "1";
   }
   else {
      color = clSilver;
      smode = "0";
   }

   if(portno == 1) {
      pnlLoadPort1Load->Color = color;
      edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_LOAD_BIT) + "," + smode + ")";
      LoadPort1Cmd = "SPOT";
      btnLoadPort1SendClick(this);
   }
   else {
      pnlLoadPort2Load->Color = color;
      edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_LOAD_BIT) + "," + smode + ")";
      LoadPort2Cmd = "SPOT";
      btnLoadPort2SendClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 28 - chc Rorze
// LoadPort1: UnLoad
void __fastcall TMainForm::SetLoadPortUnload(int portno, bool mode)
{
TColor color;
AnsiString smode;

   if(mode == true) {
      color = clBlue;
      smode = "1";
   }
   else {
      color = clSilver;
      smode = "0";
   }

   if(portno == 1) {
      pnlLoadPort1Unload->Color = color;
      edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_UNLOAD_BIT) + "," + smode + ")";
      LoadPort1Cmd = "SPOT";
      btnLoadPort1SendClick(this);
   }
   else {
      pnlLoadPort2Unload->Color = color;
      edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_UNLOAD_BIT) + "," + smode + ")";
      LoadPort2Cmd = "SPOT";
      btnLoadPort2SendClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 28 - chc Rorze
// LoadPort1: Manual
void __fastcall TMainForm::SetLoadPortManual(int portno, bool mode)
{
TColor color;
AnsiString smode;

   if(mode == true) {
      color = clRed;
      smode = "1";
   }
   else {
      color = clSilver;
      smode = "0";
   }

   if(portno == 1) {
      pnlLoadPort1Manual->Color = color;
      edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_MANUAL_BIT) + "," + smode + ")";
      LoadPort1Cmd = "SPOT";
      btnLoadPort1SendClick(this);
   }
   else {
      pnlLoadPort2Manual->Color = color;
      edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_MANUAL_BIT) + "," + smode + ")";
      LoadPort2Cmd = "SPOT";
      btnLoadPort2SendClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 28 - chc Rorze
// LoadPort1: Alarm
void __fastcall TMainForm::SetLoadPortAlarm(int portno, bool mode)
{
TColor color;
AnsiString smode;

   if(mode == true) {
      color = clRed;
      smode = "1";
   }
   else {
      color = clSilver;
      smode = "0";
   }

   if(portno == 1) {
      pnlLoadPort1Alarm->Color = color;
      edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_ALARM_BIT) + "," + smode + ")";
      LoadPort1Cmd = "SPOT";
      btnLoadPort1SendClick(this);
   }
   else {
      pnlLoadPort2Alarm->Color = color;
      edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_ALARM_BIT) + "," + smode + ")";
      LoadPort2Cmd = "SPOT";
      btnLoadPort2SendClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 28 - chc Rorze
// LoadPort1: Clamp
void __fastcall TMainForm::SetLoadPortClamp(int portno, bool mode)
{
TColor color;
AnsiString smode;

   if(mode == true) {
      color = clWhite;
      smode = "1";
   }
   else {
      color = clSilver;
      smode = "0";
   }

   if(portno == 1) {
      pnlLoadPort1Clamp->Color = color;
      edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_CLAMP_BIT) + "," + smode + ")";
      LoadPort1Cmd = "SPOT";
      btnLoadPort1SendClick(this);
   }
   else {
      pnlLoadPort2Clamp->Color = color;
      edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_CLAMP_BIT) + "," + smode + ")";
      LoadPort2Cmd = "SPOT";
      btnLoadPort2SendClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 28 - chc Rorze
// LoadPort1: Dock
void __fastcall TMainForm::SetLoadPortDock(int portno, bool mode)
{
TColor color;
AnsiString smode;

   if(mode == true) {
      color = clWhite;
      smode = "1";
   }
   else {
      color = clSilver;
      smode = "0";
   }

   if(portno == 1) {
      pnlLoadPort1Dock->Color = color;
      edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_DOCK_BIT) + "," + smode + ")";
      LoadPort1Cmd = "SPOT";
      btnLoadPort1SendClick(this);
   }
   else {
      pnlLoadPort2Dock->Color = color;
      edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_DOCK_BIT) + "," + smode + ")";
      LoadPort2Cmd = "SPOT";
      btnLoadPort2SendClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 29 - chc 4個W點位
void __fastcall TMainForm::LoadWPosition()
{
TIniFile *pSystemFile;

   WriteSystemLog(AnsiString("LoadWPosition(): ") + RobotWINIFilename);
   if(!FileExists(RobotWINIFilename)) {
      WriteSystemLog("RobotW.ini Not Exist!");
      return;
   }

   // ini檔名與目錄
   pSystemFile = new TIniFile(RobotWINIFilename);

   // W Position
   TLMDEdit *edit;
   for(int no=0 ; no<MAX_W_POSITION ; no++) {
      WPositionSet[no] = pSystemFile->ReadInteger(ROBOTW_PARAMETER_SECTION,"W Position" + IntToStr(no+1)    ,100000);
      edit = (TLMDEdit *)(FindComponent("edWPosition" + IntToStr(no+1)));
      edit->Text = WPositionSet[no];
      WriteSystemLog(IntToStr(no+1) + ": WPosition=" + IntToStr(WPositionSet[no]));
   }

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetWPosition1Click(TObject *Sender)
{

   SetWPosition(1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetWPosition2Click(TObject *Sender)
{

   SetWPosition(2);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetWPosition3Click(TObject *Sender)
{

   SetWPosition(3);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSetWPosition4Click(TObject *Sender)
{

   SetWPosition(4);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnToWPosition1Click(TObject *Sender)
{

   ToWPositionFun(1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnToWPosition2Click(TObject *Sender)
{

   ToWPositionFun(2);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnToWPosition3Click(TObject *Sender)
{

   ToWPositionFun(3);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnToWPosition4Click(TObject *Sender)
{

   ToWPositionFun(4);
}
//---------------------------------------------------------------------------
// 指定下Arm(12")
// 1. LP2: Load
// 2. 取#1
// 3. Aligner Put/Alignment/Get
// 4. Chuck Input/Put/ToPoint1/Focus/ToLens/Input/Get
// 5. 放#1
// 6. done
void __fastcall TMainForm::btnRunTestClick(TObject *Sender)
{
int no;
int gap;
bool boolload = true;
int tno,pno;

   WriteSystemLog("流程測試: 開始...");
   pnlRunTest->Color = clSilver;
   pnlRunTest->Refresh();
   btnRunTest->Enabled = false;

   // Yuanli 是否連線?
   pnlOperationMessage->Caption = "流程測試: YuanLi 連線測試...";
   if(cbYuanliSimulate->Checked == true) {
      if(YuanLiConnect() == false) {
         pnlOperationMessage->Caption = "YuanLi無法連線(Timeout), 停止執行.";
         pnlRunTest->Color = clRed;
         goto end;
      }
   }

   // 測試的片數量
   tno = 1;
   if(cbTwoWafer->Checked == true)
      tno = 2;

   // Yuanli
   if(cbYuanliSimulate->Checked == true) {
      // Init
      boolTestFocusDone = false;
      WriteSystemLog("流程測試: Yuanli Init");
      //#define CMD_ACK_WAIT              0
      //#define CMD_ACK_E                 1
      //#define CMD_ACK_X                 2
      //#define CMD_ACK_TIMEOUT           3
      pnlSystemMessage->Caption = "流程測試: Yuanli Init...";
      if(WaitYuanliCmd(CMD_INIT) != CMD_ACK_E) {
         if(Application->MessageBox("Yuanli Socket測試: Init異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
      if(cbTestStep->Checked == true) {
         if(Application->MessageBox("Yuanli Socket測試: Init ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
      // 0 度
      WriteSystemLog("流程測試: 0度");
      pnlSystemMessage->Caption = "流程測試: T移到0度...";
      btnToLoadPositionClick(this);
      if(pnlToLoadPosition->Color != clLime) {
         if(Application->MessageBox("Yuanli Socket測試: T移到0度異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
      if(cbTestStep->Checked == true) {
         if(Application->MessageBox("Yuanli Socket測試: 0度, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
   }

   // 0. W到LP2
   WriteSystemLog("流程測試: W移動...");
   btnToWPosition2Click(this);
   Sleep(100);
   if(pnlToWStatus->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "W軸移動失敗!";
      WriteSystemLog("流程測試: W移動 Error!");
      goto end;
   }
   WriteSystemLog("流程測試: W移動.");

// 2021 5 7 - chc for test
if(cbFastTest->Checked == true)
   goto step1;

   // 1. LP2: Load
   WriteSystemLog("流程測試: LP2 Load...");
   pnlRunTest->Color = clSilver;
   //===========================================================================
   //btnLoadPort2CLMPClick(this);
   //if(pnlLoadPort2CLMP->Color != clLime) {
   //   pnlRunTest->Color = clRed;
   //   pnlSystemMessage->Caption = "LoadPort2 LOAD失敗!";
   //   WriteSystemLog("流程測試: LP2 Load Error!");
   //   goto end;
   //}
   //===========================================================================
   rgLoadPort2WaferSize->ItemIndex = 0;
   // 2021 5 5 - chc 送CSTREAD後, SECS會送MAP要求做LOAD動作
   // => 於人員LOAD時才做
   pnlLoadPort2CLMP->Color = clSilver;
   rgRFIDLoadPort->ItemIndex = LOADPORT_2;
   // 12"
   if(rgLoadPort2WaferSize->ItemIndex == 0)
      rgRFIDWaferSize->ItemIndex = 1;
   // 8"
   else
      rgRFIDWaferSize->ItemIndex = 0;
   rgRFIDTagType->ItemIndex = 2;
   btnRFIDReadClick(this);

   // 2021 9 8 - chc 變更Port編號
   rgSECSPortNo->ItemIndex = LOADPORT_2;
   //rgSECSPortNo->ItemIndex = LOADPORT_1;

   rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
   WriteSystemLog("boolSendSCESCommand: 19-1");
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

   // 2021 5 5 - chc 有連線時由SECS MAP觸發LOAD
   int timeout,cnt;

   // 2021 6 3 - chc 是否連線?
   //if(pnlSECSConnect->Color == clLime) {
   if(pnlSECSConnect->Color == clLime && cbOffLine->Checked == false) {

      WriteSystemLog("測試流程: 等MAP做LOAD.");
      timeout = 30;
   }
   else {
      timeout = 5;
      WriteSystemLog("測試流程: 直接LOAD, 不等MAP.");

      btnLoadPort2CLMPClick(this);

      // 2021 5 5 - chc 有連線時由SECS MAP觸發LOAD
   }
   cnt = 0;
   while(1) {
      WaitTime(1000);
      cnt++;
      if(cnt > timeout) {
         // 2021 6 30c - chc LP1/LP2: 吋
         //pnlOperationMessage->Caption = "LP2 Load Timeout失敗! " + IntToStr(timeout);
         pnlOperationMessage->Caption = "12吋Port Load Timeout失敗! " + IntToStr(timeout);

         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         boolload = false;
         break;
      }
      if(pnlLoadPort2CLMP->Color == clLime) {
         // 2021 6 30c - chc LP1/LP2: 吋
         //pnlOperationMessage->Caption = "LP2 Load完成.";
         pnlOperationMessage->Caption = "12吋Port Load完成.";

         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog("boolSendSCESCommand: 6");
         // 2021 5 4 - chc 進入Run
         // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
         //rgEQStatus->ItemIndex = EQ_STATUS_RUN;
         //rgSecsCommandSet->ItemIndex = -1;
         //boolSendSCESCommand = true;
         //rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;
         // 2021 10 27 - chc Load後為EXECUTING
         //SendSECSStatus(EQ_STATUS_IDLE);
         SendSECSStatus(EQ_STATUS_EXECUTING);

         break;
      }
      else if(pnlLoadPort2CLMP->Color == clRed) {
         // 2021 6 30c - chc LP1/LP2: 吋
         //pnlOperationMessage->Caption = "LP2 Load失敗!";
         pnlOperationMessage->Caption = "12吋Port Load失敗!";

         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         boolload = false;
         break;
      }
   }
   if(boolload == false) {
      pnlRunTest->Color = clRed;
      WriteSystemLog("流程測試: LP2 Load, 失敗!");
      goto end;
   }
   //===========================================================================
   WriteSystemLog("流程測試: LP2 Load.");

   // 2021 5 3 - chc 加做GMAP
   // CLMP中會做GMAP
   //WriteSystemLog("LP2完成CLMP, 進行GMAP...");
   //btnLoadPort2GMAPClick(this);
   //WriteSystemLog("LP2完成CLMP, 完成GMAP.");

// 2021 5 7 - chc for test
step1:

for(int loop=1 ; loop<=tno ; loop++) {

   // 2. 取#1
   WriteSystemLog("流程測試: Robot取#" + IntToStr(loop) + "片...");

   // 2021 5 6 - chc 可做2片
   // #1 - Slot1
   //combRobotSlot->ItemIndex = 0;
   //combRobotSlot->Text = "1";
   combRobotSlot->ItemIndex = loop-1;
   combRobotSlot->Text = IntToStr(loop);

// 2021 5 7 - chc for test
if(cbFastTest->Checked == true)
   goto step2;

   // 點位: LP2
   rgRobotStage->ItemIndex = ROBOT_STAGE_LP2;
   // LowArm
   rgRobotArm->ItemIndex = ROBOT_ARM_LOW;
   // Get
   rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
   // 確認 @@暫
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("準備由LoadPort2取片?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         WriteSystemLog("流程測試: Robot取片, 放棄.");
         goto end;
      }
   }
   // Do
   btnRorzeRobotGetClick(this);
   if(pnlRorzeRobotGet->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "LoadPort2 取片失敗!";
      WriteSystemLog("流程測試: Robot取#1 Error");
      goto end;
   }
   WriteSystemLog("流程測試: Robot取#1.");

   WriteSystemLog("流程測試: Stage到入料點...");
   // 3. Aligner 入料點/Put/Alignment/Get
   // 點位: Aligner
   rgRobotStage->ItemIndex = ROBOT_STAGE_ALIGNER;
   // 12"
   rgWaferSize->ItemIndex = 0;
   // 入料點: 要先設WaferSize
   btnInputClick(this);
   if(pnlInput->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Aligner 入料點移動失敗!";
      WriteSystemLog("流程測試: Stage到入料點 Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Stage到入料點.");
   WriteSystemLog("流程測試: Robot放片到Aligner...");
   // Put
   rgRobotOperation->ItemIndex = ROBOT_HOME_PUT;
   // 確認 @@暫
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("準備放片到Aligner?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         WriteSystemLog("流程測試: Robot放片到Aligner, 放棄!");
         goto end;
      }
   }
   // Do
   btnRorzeRobotPutClick(this);
   if(pnlRorzeRobotPut->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Aligner 放片失敗!";
      WriteSystemLog("流程測試: Robot放片到Aligner Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Robot放片到Aligner.");
   WriteSystemLog("流程測試: Aligner do Alignment...");
   // Alignment
   btnAlignerDoClick(this);
   if(pnlAlignerDo->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Aligner Alignment失敗!";
      WriteSystemLog("流程測試: Aligner do Alignment Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Aligner do Alignment.");
   WriteSystemLog("流程測試: Robot由Aligner取片...");
   // Get
   rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
   // 確認 @@暫
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("準備由Aligner取片?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         WriteSystemLog("流程測試: Robot由Aligner取片, 放棄!");
         goto end;
      }
   }
   // Do
   btnRorzeRobotGetClick(this);
   if(pnlRorzeRobotGet->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Aligner 取片失敗!";
      WriteSystemLog("流程測試: Robot由Aligner取片 Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Robot由Aligner取片.");
   WriteSystemLog("流程測試: Stage移動到入料點...");
   // 4. Chuck Input/L-Up/Put/Vacuum-On/L-Down/ToPoint1/Focus/ToLens/Input/Get
   // 點位: Stage
   rgRobotStage->ItemIndex = ROBOT_STAGE_STAGE;
   // Stage到入料點
   btnToOriginalPositionClick(this);
   if(pnlToOriginalPosition->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Stage 入料點移動失敗!";
      WriteSystemLog("流程測試: Stage移動到入料點 Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Stage移動到入料點.");

   // 2021 5 6 - chc 在Put中會做
   /*
   WriteSystemLog("流程測試: Stage Pin上升...");
   // L-Up
   btnDemoLFUpClick(this);
   if(boolLFUpState == false) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Lift pin上升失敗!";
      WriteSystemLog("流程測試: Stage Pin上升 Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Stage Pin上升.");
   */

   WriteSystemLog("流程測試: Robot Stage放片...");
   // Put
   rgRobotOperation->ItemIndex = ROBOT_HOME_PUT;
   // 確認 @@暫
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("準備放片到Stage?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         WriteSystemLog("流程測試: Robot Stage放片, 放棄!");
         goto end;
      }
   }
   // Do
   btnRorzeRobotPutClick(this);
   if(pnlRorzeRobotPut->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Stage 放片失敗!";
      WriteSystemLog("流程測試: Robot Stage放片 Error");
      goto end;
   }
   WriteSystemLog("流程測試: Robot Stage放片.");

   // 2021 5 6 - chc 在Put中會做
   /*
   WriteSystemLog("流程測試: Stage Vacuum On...");
   // Vacuum-On
   if(pnlStageVacuum->Color != clLime) {
      pnlStageVacuumClick(this);
   }

   // 2021 6 3 - chc 12"
   if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
      if(pnlStageVacuum1->Color != clLime)
         pnlStageVacuum1Click(this);
   }

   WriteSystemLog("流程測試: Stage Pin到下位點...");
   // L-Down
   // 2021 4 29 - chc 到真空點
   btnDemoLFDownClick(this);
   //btnDemoLFVacuumOffClick(this);

   if(boolLFUpState == false) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Lift pin下降失敗!";
      WriteSystemLog("流程測試: Stage Pin到下位點 Error");
      goto end;
   }
   WriteSystemLog("流程測試: Stage Pin到下位點.");
   */

   // 2021 5 5 - chc 到Stage要做中心點尋找
   // 在Robot Put時已完成, 這裡不做
   //WaitTime(1000);
   //if(rgRobotStage->ItemIndex == ROBOT_STAGE_STAGE) {
   //   pnlCenterXFind->Caption = "0";
   //   pnlCenterYFind->Caption = "0";
   //   btnFindCenterClick(this);
   //}

// 2021 5 7 - chc for test
step2:;

   // Yuanli
   if(cbYuanliSimulate->Checked == true) {
      // to 50x, Wait Focus done
      pnlOperationMessage->Caption = "按下Run開始量測作業";
      btnFocusDone->Caption = " Run";
      btnFocusDone->Hint = "按下後開始執行量測作業";
      btnFocusDone->Visible = true;
      pcSystem->Enabled = false;

      // 2021 9 23b - chc 顯示
      pnlSideNo->Visible = true;
      pnlDotNoRun1->Visible = true;

      // 2021 8 13 - chc 操作指示
      pnlFocusDone->Caption = pnlOperationMessage->Caption;
      pnlFocusDone->Visible = true;

      // 2022 1 3 - chc 定義pnlFocusDoneE
      pnlFocusDoneE->Caption = "Press Run to start the measurement operation";
      pnlFocusDoneE->Visible = true;

      // 2021 7 19 - chc 改用runabort
      WriteSystemLog("關閉作業頁面9.");

      boolTestFocusDone = false;
      while(1) {
         WaitTime(500);
         if(boolTestFocusDone == true)
            break;
      }
      pcSystem->Enabled = true;
      btnFocusDone->Visible = false;

      // 2021 9 23b - chc 顯示
      pnlSideNo->Visible = false;
      pnlDotNoRun1->Visible = false;

      // 2021 8 13 - chc 操作指示
      pnlFocusDone->Visible = false;

      // 2022 1 3 - chc 定義pnlFocusDoneE
      pnlFocusDoneE->Visible = false;

      // Set Recipe
      //edRecipeName->Text = "A_Type01";
      WriteSystemLog("流程測試: Yuanli SetRecipe");
      // SetRecipe
      pnlSystemMessage->Caption = "流程測試: Yuanli SetRecipe...";
      if(WaitYuanliCmd(CMD_SET_RECIPE) != CMD_ACK_E) {
         if(Application->MessageBox("Yuanli Socket測試: SetRecipe異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
      if(cbTestStep->Checked == true) {
         if(Application->MessageBox("Yuanli Socket測試: SetRecipe Ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
      WriteSystemLog("流程測試: Yuanli Start");
      // Start,N,WaferID
      rgYuanliPoint->ItemIndex = 4;
      edWaferID->Text = WaferBuffer[0].ID;
      pnlSystemMessage->Caption = "流程測試: Yuanli Start...";
      if(WaitYuanliCmd(CMD_START) != CMD_ACK_E) {
         if(Application->MessageBox("Yuanli Socket測試: Start,5異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
      if(cbTestStep->Checked == true) {
         if(Application->MessageBox("Yuanli Socket測試: Start,5 OK 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
      WriteSystemLog("流程測試: Yuanli Mode");
      // Mode = Top
      rgMode->ItemIndex = 0;
      pnlSystemMessage->Caption = "流程測試: Yuanli Mode.Top...";
      if(WaitYuanliCmd(CMD_MODE) != CMD_ACK_E) {
         if(Application->MessageBox("Yuanli Socket測試: Mode.Top異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
      if(cbTestStep->Checked == true) {
         if(Application->MessageBox("Yuanli Socket測試: Mode.Top Ok, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRunTest->Color = clRed;
            goto end;
         }
      }
   }

   // 量測的點數量
   if(cbYuanliSimulate->Checked == true) {
      pno = 5;
      // 中斷量測作業: boolDoMeasure, btnMeasureStop
      boolDoMeasure = true;
      btnMeasureStop->Visible = true;
   }
   else
      pno = 1;
   // Top & Tilt
   for(int side=0 ; side<2 ; side++) {
      for(int pt=0 ; pt<pno ; pt++) {
         boolInMeasure = true;

         // To Point1 - Z為對焦點
         if(pnlStartMessage->Visible == false) {
            pnlStartMessage->Visible = true;
         }
         pnlStartMessage->Caption = "To #" + IntToStr(pt+1) + "(4x)";
         WriteSystemLog("流程測試: Stage到量測點#" + IntToStr(pt+1) + "...");
         pnlSystemMessage->Caption = pnlStartMessage->Caption;
         // 2021 5 7 - chc 45度不需要
         // 需要到MotionCCD
         if(side == 0 && cbAutoFocus->Checked == true) {
            if(pt == 0)
               btnPos1GoClick(this);
            else if(pt == 1)
               btnPos2GoClick(this);
            else if(pt == 2)
               btnPos3GoClick(this);
            else if(pt == 3)
               btnPos4GoClick(this);
            else if(pt == 4)
               btnPos5GoClick(this);
            DelayTime(2000);
            boolInMeasure = false;
            // ToLens
            mnToLensClick(this);
            // 是否要Focus & Pattern Match
         }
         // 不需要到MotionCCD
         else {
            // 使用第10點
            int ox,oy,oz,dx,dy,dz;
            TLMDEdit *edx,*edy,*edz;
            edx = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(pt+1) + "X"));
            edy = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(pt+1) + "Y"));
            edz = (TLMDEdit *)(MainForm->FindComponent("edPos" + IntToStr(pt+1) + "Z"));
            ox = edx->Text.ToInt();
            oy = edy->Text.ToInt();
            oz = edz->Text.ToInt();
            // Offset
            dx = edLens3X->Text.ToInt() - edCCDX->Text.ToInt();
            dy = edLens3Y->Text.ToInt() - edCCDY->Text.ToInt();
            dz = edLens3Z->Text.ToInt() - edCCDZ->Text.ToInt();
            dx = 0 - dx;
            if(cbCCDXDirection->Checked == true)
               dx = 0 - dx;
            if(cbCCDYDirection->Checked == false)
               dy = 0 - dy;
            // Move value
            ox = ox + dx;
            oy = oy + dy;
            oz = oz + dz;
            // Set #10
            edPos10X->Text = IntToStr(ox);
            edPos10Y->Text = IntToStr(oy);
            edPos10Z->Text = IntToStr(oz);
            // go
            SimulatePoint = pt+1;
            btnPos10GoClick(this);
            boolInMeasure = false;
         }
         pnlSystemMessage->Caption = "到量測點#" + IntToStr(pt+1) + "(50x)";
         WriteSystemLog("流程測試: Stage到量測點#" + IntToStr(pt+1) + "(ToLens)...");

         if(cbYuanliSimulate->Checked == true) {
            if(StopMeasure() == true) {
               pnlRunTest->Color = clRed;
               goto stop;
            }
            if(side > 0 && pt == 0) {
               // Init
               WriteSystemLog("流程測試: Yuanli Init");
               pnlSystemMessage->Caption = "流程測試: Yuanli Init...";
               if(WaitYuanliCmd(CMD_INIT) != CMD_ACK_E) {
                  if(Application->MessageBox("Yuanli Socket測試: Init異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                     pnlRunTest->Color = clRed;
                     goto end;
                  }
               }
               if(cbTestStep->Checked == true) {
                  if(Application->MessageBox("Yuanli Socket測試: Init OK, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                     pnlRunTest->Color = clRed;
                     goto end;
                  }
               }
            }
         }

         // Yuanli
         if(cbYuanliSimulate->Checked == true) {
            if(StopMeasure() == true) {
               pnlRunTest->Color = clRed;
               goto stop;
            }
            // Z
            if(pt > 0) {
               pnlSystemMessage->Caption = "流程測試: 到Z對焦點= " + IntToStr(TestFocusZ) + "...";

               // 2021 9 11 - chc 加速: MOVE_WAIT
               //MoveToZ(TestFocusZ);
               MoveToZ(TestFocusZ,MOVE_WAIT);

               if(cbTestStep->Checked == true) {
                  if(Application->MessageBox("Yuanli Socket測試: 到Z對焦點 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                     pnlRunTest->Color = clRed;
                     goto end;
                  }
               }
            }
            // Focus: 第1點
            if(pt == 0) {
               // to 50x, Wait Focus done
               if(side == 0) {

                  // 2022 1 3 - chc 改Message
                  //pnlOperationMessage->Caption = "請開始對焦(物鏡切換至50x)，對焦完畢後請按[對焦完成]";
                  pnlSystemMessage->Caption = "物鏡依序由5x切換至50x，完成後請按[對焦完成]";
                  pnlSystemRun->Caption = "0度:量測前置作業";

               }
               else {
                  // Z Up
                  // 上升1000um
                  WriteSystemLog("流程測試: Z上升1000um");
                  pnlSystemMessage->Caption = "流程測試: Z上升1000um...";
                  gap = (1000.0 / Z_RESOLUTION);
                  if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
                     WriteSystemLog("流程測試: Z上升1000um失敗!");
                     pnlSystemMessage->Caption = "流程測試: Z上升1000um失敗!";
                  }
                  // 45
                  WriteSystemLog("流程測試: 45度");
                  pnlSystemMessage->Caption = "流程測試: Yuanli 45度...";
                  btnToAOIPositionClick(this);
                  if(pnlToAOIPosition->Color != clLime) {
                     if(Application->MessageBox("Yuanli Socket測試: T移到45度異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                        pnlRunTest->Color = clRed;
                        goto end;
                     }
                  }
                  if(cbTestStep->Checked == true) {
                     if(Application->MessageBox("Yuanli Socket測試: 45度, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                        pnlRunTest->Color = clRed;
                        goto end;
                     }
                  }
                  // 下降1000um
                  WriteSystemLog("流程測試: Z下降1000um");
                  pnlSystemMessage->Caption = "流程測試: Z下降1000um...";
                  gap = (1000.0 / Z_RESOLUTION);
                  if(MoveToAxisGap(Z_AXIS, gap) == false) {
                     WriteSystemLog("流程測試: Z下降1000um失敗!");
                     pnlSystemMessage->Caption = "流程測試: Z下降1000um失敗!";
                     if(Application->MessageBox("Yuanli Socket測試: Z下降1000um失敗, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                        pnlRunTest->Color = clRed;
                        goto end;
                     }
                  }
                  // Mode: Side
                  WriteSystemLog("流程測試: Yuanli Mode");
                  rgMode->ItemIndex = 1;
                  pnlSystemMessage->Caption = "流程測試: Yuanli Mode.Side...";
                  if(WaitYuanliCmd(CMD_MODE) != CMD_ACK_E) {
                     if(Application->MessageBox("Yuanli Socket測試: Mode.Side異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                        pnlRunTest->Color = clRed;
                        goto end;
                     }
                  }
                  if(cbTestStep->Checked == true) {
                     if(Application->MessageBox("Yuanli Socket測試: Mode.Side, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                        pnlRunTest->Color = clRed;
                        goto end;
                     }
                  }
                  // LM 50x
                  pnlOperationMessage->Caption = "請將物鏡切換至LM 50x, 切換完畢後請按[LM 50x]";
                  btnFocusDone->Caption = "LM 50x";
                  btnFocusDone->Hint = pnlOperationMessage->Caption;
                  btnFocusDone->Visible = true;
                  pcSystem->Enabled = false;

                  // 2021 9 23b - chc 顯示
                  pnlSideNo->Visible = true;
                  pnlDotNoRun1->Visible = true;

                  // 2021 8 13 - chc 操作指示
                  pnlFocusDone->Caption = pnlOperationMessage->Caption;
                  pnlFocusDone->Visible = true;

                  // 2022 1 3 - chc 定義pnlFocusDoneE
                  pnlFocusDoneE->Caption = "Switch to LM 50x, Then press [LM 50x]";
                  pnlFocusDoneE->Visible = true;

                  // 2021 7 19 - chc 改用runabort
                  WriteSystemLog("關閉作業頁面10.");

                  boolTestFocusDone = false;
                  while(1) {
                     WaitTime(500);
                     if(boolTestFocusDone == true)
                        break;
                  }
                  btnFocusDone->Visible = false;
                  pcSystem->Enabled = true;

                  // 2021 9 23b - chc 顯示
                  pnlSideNo->Visible = false;
                  pnlDotNoRun1->Visible = false;

                  // 2021 8 13 - chc 操作指示
                  pnlFocusDone->Visible = false;

                  // 2022 1 3 - chc 定義pnlFocusDoneE
                  pnlFocusDoneE->Visible = false;

                  // Z Down
                  // => 不做
                  /*
                  WriteSystemLog("流程測試: Z下降1000um");
                  pnlSystemMessage->Caption = "流程測試: Z下降1000um...";
                  gap = (1000.0 / Z_RESOLUTION);
                  if(MoveToAxisGap(Z_AXIS, gap) == false) {
                     WriteSystemLog("流程測試: Z下降1000um失敗!");
                     pnlSystemMessage->Caption = "流程測試: Z下降1000um失敗!";
                  }
                  if(Application->MessageBox("Yuanli Socket測試: Z下降, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                     pnlRunTest->Color = clRed;
                     goto end;
                  }
                  */
                  pnlOperationMessage->Caption = "請開始對焦(維持LM 50X物鏡)，對焦完畢後請按[對焦完成]";
               }

               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "對焦完成";
               btnFocusDone->Caption = "對焦完成 Complete";

               btnFocusDone->Hint = pnlOperationMessage->Caption;
               btnFocusDone->Visible = true;
               pcSystem->Enabled = false;

               // 2021 9 23b - chc 顯示
               pnlSideNo->Visible = true;
               pnlDotNoRun1->Visible = true;

               // 2021 8 13 - chc 操作指示
               pnlFocusDone->Caption = pnlOperationMessage->Caption;
               pnlFocusDone->Visible = true;

               // 2022 1 3 - chc 定義pnlFocusDoneE
               if(side == 0)
                  pnlFocusDoneE->Caption = "Switch from 5x to 50x, Then press [Complete]";
               else
                  pnlFocusDoneE->Caption = "Focus (LM 50X) and zooming 1.5x, Press [Complete]";
               pnlFocusDoneE->Visible = true;

               // 2021 7 19 - chc 改用runabort
               WriteSystemLog("關閉作業頁面11.");

               boolTestFocusDone = false;
               while(1) {
                  WaitTime(500);
                  if(boolTestFocusDone == true)
                     break;
               }
               pcSystem->Enabled = true;
               btnFocusDone->Visible = false;

               // 2021 9 23b - chc 顯示
               pnlSideNo->Visible = false;
               pnlDotNoRun1->Visible = false;

               // 2021 8 13 - chc 操作指示
               pnlFocusDone->Visible = false;

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Visible = false;

               TestFocusZ = edCounterZ->Text.ToInt();
               pnlSystemMessage->Caption = "流程測試: 設定Z對焦點= " + IntToStr(TestFocusZ);
               if(cbTestStep->Checked == true) {
                  if(Application->MessageBox("Yuanli Socket測試: 存Z對焦點 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                     pnlRunTest->Color = clRed;
                     goto end;
                  }
               }
               if(StopMeasure() == true) {
                  pnlRunTest->Color = clRed;
                  goto stop;
               }
            }
            // InPos
            WriteSystemLog("流程測試: Yuanli InPos");
            rgYuanliPoint->ItemIndex = pt;
            pnlSystemMessage->Caption = "流程測試: Yuanli InPos...";
            if(WaitYuanliCmd(CMD_INPOS) != CMD_ACK_E) {
               if(Application->MessageBox("Yuanli Socket測試: InPos異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                  pnlRunTest->Color = clRed;
                  goto end;
               }
            }
            if(cbTestStep->Checked == true) {
               if(Application->MessageBox("Yuanli Socket測試: InPos OK, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                  pnlRunTest->Color = clRed;
                  goto end;
               }
            }
            if(StopMeasure() == true) {
               pnlRunTest->Color = clRed;
               goto stop;
            }
            // Wait Next
            boolTestFocusDone = false;
            if(pt == pno-1 && side == 0) {

               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "45度量測";
               btnFocusDone->Caption = "45度量測 45Measure";

               pnlOperationMessage->Caption = "請開始量測，量測完畢後請按[45度量測]";

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Caption = "Start the measurement, Then press [45 Measure]";

            }
            else if(pt == pno-1 && side == 1) {

               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "結束量測";
               btnFocusDone->Caption = "結束量測 EndMeasure";

               pnlOperationMessage->Caption = "請開始量測，量測完畢後請按[結束量測]";

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Caption = "Start the measurement, Then press [End Measurement]";

            }
            else {

               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "下一點";
               btnFocusDone->Caption = "點位: " + IntToStr(pt+2) + " Point: " + IntToStr(pt+2);

               pnlOperationMessage->Caption = "請開始量測，量測完畢後請按[下一點]";

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Caption = "Start measuring point " + IntToStr(pt+1) + ", Then press [Point " + IntToStr(pt+2) + "]";

            }
            btnFocusDone->Hint = pnlOperationMessage->Caption;
            pcSystem->Enabled = false;

            // 2021 8 13 - chc 操作指示
            pnlFocusDone->Caption = pnlOperationMessage->Caption;
            pnlFocusDone->Visible = true;

            // 2022 1 3 - chc 定義pnlFocusDoneE
            pnlFocusDoneE->Visible = true;

            // 2021 7 19 - chc 改用runabort
            WriteSystemLog("關閉作業頁面12.");

            btnFocusDone->Visible = true;

            // 2021 9 23b - chc 顯示
            pnlSideNo->Visible = true;
            pnlDotNoRun1->Visible = true;

            while(1) {
               WaitTime(500);
               if(boolTestFocusDone == true)
                  break;
            }
            pcSystem->Enabled = true;
            btnFocusDone->Visible = false;

            // 2021 9 23b - chc 顯示
            pnlSideNo->Visible = false;
            pnlDotNoRun1->Visible = false;

            // 2021 8 13 - chc 操作指示
            pnlFocusDone->Visible = false;

            // 2022 1 3 - chc 定義pnlFocusDoneE
            pnlFocusDoneE->Visible = false;

            // Z Up
            // 結束: 上升10mm
            if(pt == pno-1 && side == 1) {
               WriteSystemLog("流程測試: Z上升10000um");
               pnlSystemMessage->Caption = "流程測試: Z上升10000um...";
               gap = (10000.0 / Z_RESOLUTION);
               if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
                  WriteSystemLog("流程測試: Z上升10000um失敗!");
                  pnlSystemMessage->Caption = "流程測試: Z上升10000um失敗!";
                  if(Application->MessageBox("Yuanli Socket測試: Z上升10000um失敗, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                     pnlRunTest->Color = clRed;
                     goto end;
                  }
               }
            }
            else {
               WriteSystemLog("流程測試: Z上升1000um");
               pnlSystemMessage->Caption = "流程測試: Z上升1000um...";
               gap = (1000.0 / Z_RESOLUTION);
               if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
                  WriteSystemLog("流程測試: Z上升1000um失敗!");
                  pnlSystemMessage->Caption = "流程測試: Z上升1000um失敗!";
                  if(Application->MessageBox("Yuanli Socket測試: Z上升1000um失敗, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                     pnlRunTest->Color = clRed;
                     goto end;
                  }
               }
            }
            if(cbTestStep->Checked == true) {
               if(Application->MessageBox("Yuanli Socket測試: Z上升, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                  pnlRunTest->Color = clRed;
                  goto end;
               }
            }
            if(StopMeasure() == true) {
               pnlRunTest->Color = clRed;
               goto stop;
            }
            // 提示5x
            if(pt == pno-1 && side == 0) {
               boolTestFocusDone = false;

               // 2022 1 3 - chc English
               //btnFocusDone->Caption = "切換到5x";
               btnFocusDone->Caption = "切換到5x To: 5x";

               pnlOperationMessage->Caption = "物鏡請切換至5x，切換完畢後請按[切換到5x]";
               btnFocusDone->Hint = pnlOperationMessage->Caption;
               pcSystem->Enabled = false;

               // 2021 8 13 - chc 操作指示
               pnlFocusDone->Caption = pnlOperationMessage->Caption;
               pnlFocusDone->Visible = true;

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Caption = "Switch to 5x, Then press [Switch to 5x]";
               pnlFocusDoneE->Visible = true;

               // 2021 7 19 - chc 改用runabort
               WriteSystemLog("關閉作業頁面13.");

               btnFocusDone->Visible = true;

               // 2021 9 23b - chc 顯示
               pnlSideNo->Visible = true;
               pnlDotNoRun1->Visible = true;

               while(1) {
                  WaitTime(500);
                  if(boolTestFocusDone == true)
                     break;
               }
               pcSystem->Enabled = true;
               btnFocusDone->Visible = false;

               // 2021 9 23b - chc 顯示
               pnlSideNo->Visible = false;
               pnlDotNoRun1->Visible = false;

               // 2021 8 13 - chc 操作指示
               pnlFocusDone->Visible = false;

               // 2022 1 3 - chc 定義pnlFocusDoneE
               pnlFocusDoneE->Visible = false;

            }
            WaitTime(1000);
         }
      }
      DelayTime(2000);
   }
   boolInMeasure = false;

   WriteSystemLog("流程測試: 0度");
   pnlOperationMessage->Caption = "流程測試: 0度";
   btnToLoadPositionClick(this);
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("Yuanli Socket測試: 0度, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         goto end;
      }
   }

   // ProcessEnd: 量測完成
   rgSECSStatus->ItemIndex = STATUS_PROCESSEND;
   WriteSystemLog("boolSendSCESCommand: 11-1");
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_PREV - SECS_CMD_STAT_1;

   if(pnlStartMessage->Visible == true && pnlStartMessage->Caption == "To #1(50x)")
      pnlStartMessage->Caption = "To Load Location...";
   WriteSystemLog("流程測試: Stage到入料點...");
   // Stage到入料點
   btnToOriginalPositionClick(this);
   if(pnlToOriginalPosition->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Stage 入料點移動失敗!";
      WriteSystemLog("流程測試: Stage到入料點 Error!");
      goto end;
   }

   WriteSystemLog("流程測試: Stage到入料點.");
   if(pnlStartMessage->Visible == true && pnlStartMessage->Caption == "To Load Location...")
      pnlStartMessage->Visible = false;

// 2021 5 7 - chc for test
if(cbFastTest->Checked == true)
   goto step3;

   // 2021 5 6 - chc 在Get中會做
   /*
   // L-Vacuum of Position
   WriteSystemLog("流程測試: Stage Pin到真空點...");
   btnDemoLFVacuumOffClick(this);
   if(boolLFUpState == false) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Lift 到解真空位置失敗!";
      WriteSystemLog("流程測試: Stage Pin到真空點 Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Stage Pin到真空點.");
   WriteSystemLog("流程測試: Stage關真空...");
   // Vacuum Off
   if(pnlStageVacuum->Color == clLime) {
      pnlStageVacuumClick(this);
   }

   // 2021 6 3 - chc 12"
   if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
      if(pnlStageVacuum1->Color == clLime)
         pnlStageVacuum1Click(this);
   }

   // L-Up
   WriteSystemLog("流程測試: Stage Pin上升...");
   btnDemoLFUpClick(this);
   if(boolLFUpState == false) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Lift pin上升失敗!";
      WriteSystemLog("流程測試: Stage Pin上升 Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Stage Pin上升.");
   */

   // Get
   WriteSystemLog("流程測試: Robot由Stage取片...");
   rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
   rgRobotStage->ItemIndex = ROBOT_STAGE_STAGE;
   // 確認 @@暫
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("準備由Stage取片?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         WriteSystemLog("流程測試: Robot由Stage取片, 放棄!");
         goto end;
      }
   }
   // Do
   btnRorzeRobotGetClick(this);
   if(pnlRorzeRobotGet->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Stage 取片失敗!";
      WriteSystemLog("流程測試: Robot由Stage取片 Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Robot由Stage取片.");

   // 2021 5 6 - chc 在Get中會做
   /*
   // L下降
   WriteSystemLog("流程測試: Stage Pin到下位點...");
   // L-Down
   btnDemoLFDownClick(this);
   if(boolLFUpState == false) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Lift pin下降失敗!";
      WriteSystemLog("流程測試: Stage Pin到下位點 Error");
      goto end;
   }
   WriteSystemLog("流程測試: Stage Pin到下位點.");
   */

   // 5. 放#1
   // 點位: LoadPort2
   rgRobotStage->ItemIndex = ROBOT_STAGE_LP2;
   // Put
   rgRobotOperation->ItemIndex = ROBOT_HOME_PUT;
   // 確認 @@暫
   WriteSystemLog("流程測試: Robot 放片到LP2...");
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("準備放片到LoadPort2?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         WriteSystemLog("流程測試: Robot 放片到LP2, 放棄!");
         goto end;
      }
   }
   // Do
   btnRorzeRobotPutClick(this);
   if(pnlRorzeRobotPut->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "LoadPort2 放片失敗!";
      WriteSystemLog("流程測試: Robot 放片到LP2, Error!");
      goto end;
   }
   WriteSystemLog("流程測試: Robot 放片到LP2.");

// 2021 5 7 - chc for test
step3:

   // 2021 5 6 - chc 最後一片送出Idle
   if(loop == tno) {

      WriteSystemLog("boolSendSCESCommand: 最後1片, Idle");

      // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
      //rgEQStatus->ItemIndex = EQ_STATUS_IDLE;
      //rgSecsCommandSet->ItemIndex = -1;
      //boolSendSCESCommand = true;
      //rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;
      // 2021 10 27 - chc unLoad後才為Idle, 不用切換狀態
      //SendSECSStatus(EQ_STATUS_IDLE);

   }
}

// 2021 5 7 - chc for test
if(cbFastTest->Checked == true)
   goto step4;

   // 確認 @@暫
   if(cbTestStep->Checked == true) {
      if(Application->MessageBox("準備LP2做UnLoad?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         WriteSystemLog("流程測試: LP2 UnLoad, 放棄!");
         goto end;
      }
   }
   else {
      DelayTime(2000);
   }

   WriteSystemLog("流程測試: LP2 UnLoad...");
   // 6. LP2: UnLoad
   pnlRunTest->Color = clSilver;
   btnLoadPort2UCLMClick(this);
   if(pnlLoadPort2UCLM->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "LoadPort2 UnLOAD失敗!";
      WriteSystemLog("流程測試: LP2 UnLoad Error!");
      goto end;
   }

   WriteSystemLog("流程測試: LP2 UnLoad.");

// 2021 5 7 - chc for test
step4:

   WriteSystemLog("流程測試: 完成.");

   // 6. done
   pnlRunTest->Color = clLime;
end:
   btnFocusDone->Visible = false;

   // 2021 9 23b - chc 顯示
   pnlSideNo->Visible = false;
   pnlDotNoRun1->Visible = false;

   btnRunTest->Enabled = true;
   boolInMeasure = false;
   btnMeasureStop->Visible = true;

   // 2021 8 13 - chc 操作指示
   pnlFocusDone->Visible = false;

   // 2022 1 3 - chc 定義pnlFocusDoneE
   pnlFocusDoneE->Visible = false;

   return;

// 2021 5 9 - chc Z上升, 0度, 到入料點
stop:
   WriteSystemLog("流程測試: Z上升10000um");
   // Z上升
   pnlSystemMessage->Caption = "流程測試: Z上升10000um...";
   gap = (10000.0 / Z_RESOLUTION);
   if(MoveToAxisGap(Z_AXIS, 0-gap) == false) {
      WriteSystemLog("流程測試: Z上升10000um失敗!");
      pnlSystemMessage->Caption = "流程測試: Z上升10000um失敗!";
      if(Application->MessageBox("Yuanli Socket測試: Z上升10000um失敗, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         goto stop1;
      }
   }
   // 到0 度
   WriteSystemLog("流程測試: 0度");
   pnlSystemMessage->Caption = "流程測試: T移到0度...";
   btnToLoadPositionClick(this);
   if(pnlToLoadPosition->Color != clLime) {
      if(Application->MessageBox("Yuanli Socket測試: T移到0度異常, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRunTest->Color = clRed;
         goto stop1;
      }
   }
   // 到入料點
   WriteSystemLog("流程測試: Stage到入料點...");
   // Stage到入料點
   btnToOriginalPositionClick(this);
   if(pnlToOriginalPosition->Color != clLime) {
      pnlRunTest->Color = clRed;
      pnlSystemMessage->Caption = "Stage 入料點移動失敗!";
      WriteSystemLog("流程測試: Stage到入料點 Error!");
      goto stop1;
   }
stop1:
   btnFocusDone->Visible = false;

   // 2021 9 23b - chc 顯示
   pnlSideNo->Visible = false;
   pnlDotNoRun1->Visible = false;

   btnRunTest->Enabled = true;
   boolInMeasure = false;
   btnMeasureStop->Visible = true;

   // 2021 8 13 - chc 操作指示
   pnlFocusDone->Visible = false;

   // 2022 1 3 - chc 定義pnlFocusDoneE
   pnlFocusDoneE->Visible = false;

   return;

}
//---------------------------------------------------------------------------
// 2021 4 30 - chc LoadPort改用Timer同時作業
void __fastcall TMainForm::tmLoadPort2ORGNTimer(TObject *Sender)
{

   tmLoadPort2ORGN->Enabled = false;
   pnlSystemMessage->Caption = "EFEM Init: LP2 Homing...";
   btnLoadPort2ORGNClick(this);
   if(pnlLoadPort2ORGN->Color != clLime) {
      WriteSystemLog("SetupEFEM() LoadPort2 ORGN Fail");
      pnlAlarmMessage->Caption = "LP2 ORGN Error!";
   }
   // GPIO
   else {
      btnLoadPort2GPIOClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 30 - chc LoadPort改用Timer同時作業
void __fastcall TMainForm::tmLoadPort1ORGNTimer(TObject *Sender)
{

   tmLoadPort1ORGN->Enabled = false;
   pnlSystemMessage->Caption = "EFEM Init: LP1 Homing...";
   btnLoadPort1ORGNClick(this);
   if(pnlLoadPort1ORGN->Color != clLime) {
      WriteSystemLog("SetupEFEM() LP1 ORGN Fail");
      pnlAlarmMessage->Caption = "LP1 ORGN Error!";
   }
   // GPIO
   else {
      btnLoadPort1GPIOClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 4 30 - chc aligner改用Timer同時作業
void __fastcall TMainForm::tmAlignerORGNTimer(TObject *Sender)
{

   tmAlignerORGN->Enabled = false;
   pnlSystemMessage->Caption = "EFEM Init: Aligner Homing...";
   btnRorzeAlignerORGNClick(this);
   if(pnlAlignerORGN1->Color != clLime) {
      WriteSystemLog("SetupEFEM() Aligner ORGN Fail");
      pnlAlarmMessage->Caption = "Aligner ORGN Error!";
   }
}
//---------------------------------------------------------------------------
   // 2021 5 3 - chc Center Position
void __fastcall TMainForm::btnRealCenterPositionClick(TObject *Sender)
{

   SetRealCenterPosition();
}
//---------------------------------------------------------------------------
   // 2021 5 3 - chc Center Position
void __fastcall TMainForm::btnToRealCenterPositionClick(TObject *Sender)
{

   pnlToRealCenterPosition->Color = clSilver;
   MotionStatus(false);

   pnlStartMessage->Caption = "To Center location...";
   pnlStartMessage->Visible = true;
   ToRealCenterPosition();

err:
   pnlStartMessage->Visible = false;
   MotionStatus(true);
}
//---------------------------------------------------------------------------
// 2021 5 3 - chc 尋找中心點, 外面為全黑
// 1. Stage上是否有Wafer?
// 2. 到中心點, NotchOffset(5000um,5000um)
// 3. X- : Left
// 4. X+: Right
// 5. Y-: Down
// 6. Y+: Up
// 7. OK or NG
// 8. 到中心點
void __fastcall TMainForm::btnFindCenterClick(TObject *Sender)
{
double foffset = 5000.0;                                                        // um
int ioffset = 5000;                                                             // um
int r = 150000;
int move = 10000;
int dr,leftx,rightx,upy,downy,right,left,up,down,cx,cy;
int centerx,centery;
bool ret = true;

   // 2021 7 22 - chc Reset ToLens/ToCCD動作
   ToLensToCCDMode = -1;

   ClearEdgeMark();
   btnFindCenter->Color = clSilver;
   // 1. Stage上是否有Wafer?
   if(IsChuckWithWafer() == false) {
      WriteSystemLog("到中心: Stage上無Wafer!");
      pnlSystemMessage->Caption = "No Wafer on Stage!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }
   // 2. 到中心點, NotchOffset(5000um,5000um)
   btnToRealCenterPositionClick(this);
   if(pnlToRealCenterPosition->Color != clLime) {
      WriteSystemLog("到中心: Stage移動失敗!");
      pnlSystemMessage->Caption = "Stage center point movement failed!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }
   if(cbCenterStep->Checked == true) {
      if(Application->MessageBox("Reached the center point, continue?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         btnFindCenter->Color = clRed;
         goto end;
      }
   }
   centerx = edRealCenterX->Text.ToInt();
   centery = edRealCenterY->Text.ToInt();

   // 2. 到中心點, NotchOffset(5000um,5000um)
   /*
   foffset /= X_RESOLUTION;
   ioffset = foffset;
   if(MoveToAxisGap(X_AXIS, ioffset) == false) {
      WriteSystemLog("到中心X偏移: Stage移動失敗!");
      pnlSystemMessage->Caption = "Stage中心點X偏移移動失敗!";
      btnFindCenter->Color = clRed;
      goto end;
   }
   if(MoveToAxisGap(Y_AXIS, ioffset) == false) {
      WriteSystemLog("到中心Y偏移: Stage移動失敗!");
      pnlSystemMessage->Caption = "Stage中心點Y偏移移動失敗!";
      btnFindCenter->Color = clRed;
      goto end;
   }

   if(cbCenterStep->checked == true) {
      if(Application->MessageBox("已到中心偏移點, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         btnFindCenter->Color = clRed;
         goto end;
      }
   }
   */

   // 3. X- : Right
   // 150mm, FOV=(1120*834),(1232um*917.4um)
   // 2021 6 3 - chc 分8"/12"
   // 8": 100mm
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
      r = 100000;
   // 12" 150mm
   else

      r = 150000;
   // 少100um
   // 2021 6 9 - chc edWaferSizeAdjust
   //r -= 100;
   r -= edWaferCenterSize->Text.ToDouble();

   dr = (double)r / X_RESOLUTION;
   move = 0 - dr;
   if(MoveToAxisGap(X_AXIS, move) == false) {
      WriteSystemLog("到右邊界: Stage移動失敗!");
      pnlSystemMessage->Caption = "右邊界觀測點移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }

   // 0-Right, 1-Left, 2-Up, 3-Down
   DelayTime(2000);
   right = FindEdge(0);
   if(right == -1) {
      WriteSystemLog("右邊界尋找失敗!");
      pnlSystemMessage->Caption = "右邊界尋找失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }

   if(cbCenterStep->Checked == true) {
      if(Application->MessageBox("已到右邊界觀測點, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         btnFindCenter->Color = clRed;
         goto end;
      }
   }
   else
      DelayTime(1000);
   ClearEdgeMark();

   // 3. X+ : Left
   move = dr*2;
   if(MoveToAxisGap(X_AXIS, move) == false) {
      WriteSystemLog("到左邊界: Stage移動失敗!");
      pnlSystemMessage->Caption = "左邊界觀測點移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }

   // 0-Right, 1-Left, 2-Up, 3-Down
   DelayTime(2000);
   left = FindEdge(1);
   if(left == -1) {
      WriteSystemLog("左邊界尋找失敗!");
      pnlSystemMessage->Caption = "左邊界尋找失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }
   if(cbCenterStep->Checked == true) {
      if(Application->MessageBox("已到左邊界觀測點, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         btnFindCenter->Color = clRed;
         goto end;
      }
   }
   else
      DelayTime(1500);
   ClearEdgeMark();

   // 回到中心
   btnToRealCenterPositionClick(this);
   if(pnlToRealCenterPosition->Color != clLime) {
      WriteSystemLog("到中心: Stage移動失敗!");
      pnlSystemMessage->Caption = "Stage中心點移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }

   // 中心參考點: X+5000um(5mm)
   // 2021 6 9 - chc edWaferSizeAdjust
   //move = 5000.0 / X_RESOLUTION;
   move = edWaferCenterOffset->Text.ToDouble() / X_RESOLUTION;

   if(MoveToAxisGap(X_AXIS, move) == false) {
      WriteSystemLog("到中心參考點X: Stage移動失敗!");
      pnlSystemMessage->Caption = "Stage中心參考點X移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }
   if(cbCenterStep->Checked == true) {
      if(Application->MessageBox("已到X中心參考點, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         btnFindCenter->Color = clRed;
         goto end;
      }
   }
   else
      DelayTime(1500);

   // 3. Y+ : Up
   move = dr;
   if(MoveToAxisGap(Y_AXIS, move) == false) {
      WriteSystemLog("到上邊界: Stage移動失敗!");
      pnlSystemMessage->Caption = "上邊界觀測點移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }

   // 0-Right, 1-Left, 2-Up, 3-Down
   DelayTime(2000);
   up = FindEdge(2);
   if(up == -1) {
      WriteSystemLog("上邊界尋找失敗!");
      pnlSystemMessage->Caption = "上邊界尋找失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }

   if(cbCenterStep->Checked == true) {
      if(Application->MessageBox("已到上邊界觀測點, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         btnFindCenter->Color = clRed;
         goto end;
      }
   }
   else
      DelayTime(1000);
   ClearEdgeMark();

   // 3. Y- : Down
   move = 0 - dr*2;
   if(MoveToAxisGap(Y_AXIS, move) == false) {
      WriteSystemLog("到下邊界: Stage移動失敗!");
      pnlSystemMessage->Caption = "下邊界觀測點移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }

   // 0-Right, 1-Left, 2-Up, 3-Down
   DelayTime(2000);
   down = FindEdge(3);
   if(down == -1) {
      WriteSystemLog("下邊界尋找失敗!");
      pnlSystemMessage->Caption = "下邊界尋找失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }

   if(cbCenterStep->Checked == true) {
      if(Application->MessageBox("已到下邊界觀測點, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         btnFindCenter->Color = clRed;
         goto end;
      }
   }
   else
      DelayTime(1000);
   ClearEdgeMark();
   cx = (left + right) / 2;
   cy = (up + down) / 2;
   pnlCenterXFind->Caption = IntToStr(cx);
   pnlCenterYFind->Caption = IntToStr(cy);

   // 回到中心
   btnToRealCenterPositionClick(this);
   if(pnlToRealCenterPosition->Color != clLime) {
      WriteSystemLog("到中心: Stage移動失敗!");
      pnlSystemMessage->Caption = "Stage中心點移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }
   btnFindCenter->Color = clLime;
   WriteSystemLog("中心尋找: 完成");
   pnlSystemMessage->Caption = "中心尋找: 完成";
   if(cbCenterStep->Checked == true) {
      if(Application->MessageBox("已回到中心點, 繼續?     ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         btnFindCenter->Color = clRed;
         goto end;
      }
   }
   DelayTime(1000);
   move = cx - centerx;
   if(MoveToAxisGap(X_AXIS, move) == false) {
      WriteSystemLog("到X實際中心: Stage移動失敗!");
      pnlSystemMessage->Caption = "X實際中心點移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }
   move = cy - centery;
   if(MoveToAxisGap(Y_AXIS, move) == false) {
      WriteSystemLog("到X實際中心: Stage移動失敗!");
      pnlSystemMessage->Caption = "X實際中心點移動失敗!";
      btnFindCenter->Color = clRed;
      ret = false;
      goto end;
   }
   WriteSystemLog("實際中心移動: 完成");
   pnlSystemMessage->Caption = "實際中心移動: 完成";

   // 2021 5 8 - chc 更新中心點偏移量
   UpdateCenterOffset();

end:
   if(btnFindCenter->Color == clRed) {
      pnlCenterXFind->Caption = edRealCenterX->Text;
      pnlCenterYFind->Caption = edRealCenterY->Text;
      pnlCenterXFind->Color = (TColor)0x001B4E70;
      pnlCenterYFind->Color = (TColor)0x001B4E70;
   }
   else {
      pnlCenterXFind->Color = (TColor)0x003C9F82;
      pnlCenterYFind->Color = (TColor)0x003C9F82;
   }

   // 2021 9 20a - chc alarm
   if(ret == false) {
      if(boolCenterPointError == false) {
         boolCenterPointError = true;
         SetSECSAlarm(43001,1,0,"Center Point setting Abnormal");
      }
   }
   else {
      if(boolCenterPointError == true) {
         boolCenterPointError = false;
         SetSECSAlarm(43001,0,0,"Center Point setting Abnormal");
      }
   }

   return;
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc 若是在傾斜位置, 要補償X/Y/Z
bool __fastcall TMainForm::IsHeadTilt()
{
int currt,sett;
AnsiString msg;

   currt = MainForm->edCounterT->Text.ToInt();
   sett = MainForm->edAOIT->Text.ToInt();
   msg.sprintf("IsHeadTilt() currt,sett = %d,%d",currt,sett);
   WriteSystemLog(msg);

   // 2022 5 18 - chc 改成80000
   //if(abs(currt - sett) < 1000) {
   if(abs(currt - sett) < 80000) {

      WriteSystemLog("在傾斜位置: Yes");
      return true;
   }
   else {
      WriteSystemLog("在傾斜位置: No");
      return false;
   }
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc 若是在水平位置, 要補償X/Y/Z
bool __fastcall TMainForm::IsHeadHorizontal()
{
int currt,sett;
AnsiString msg;

   currt = MainForm->edCounterT->Text.ToInt();
   sett = MainForm->edLoadT->Text.ToInt();
   msg.sprintf("IsHeadHorizontal() currt,sett = %d,%d",currt,sett);
   WriteSystemLog(msg);

   // 2022 5 18 - chc 改成80000
   //if(abs(currt - sett) < 1000) {
   if(abs(currt - sett) < 80000) {

      WriteSystemLog("在水平位置: Yes");
      return true;
   }
   else {
      WriteSystemLog("在水平位置: No");
      return false;
   }
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc 定上邊界
void __fastcall TMainForm::btnSetUpClick(TObject *Sender)
{
I32 posy;
F64 fcmd;

   if(MotionMode == MOTION_MODE_APS)
      APS_get_position(Y_AXIS+StartAxisNo,&posy);
   pnlYUp->Caption = IntToStr(posy);
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc 定下邊界
void __fastcall TMainForm::btnSetDownClick(TObject *Sender)
{
I32 posy;
F64 fcmd;

   if(MotionMode == MOTION_MODE_APS)
      APS_get_position(Y_AXIS+StartAxisNo,&posy);
   pnlYDown->Caption = IntToStr(posy);
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc 定左邊界
void __fastcall TMainForm::btnSetLeftClick(TObject *Sender)
{
I32 posx;
F64 fcmd;

   if(MotionMode == MOTION_MODE_APS)
      APS_get_position(X_AXIS+StartAxisNo,&posx);
   pnlXLeft->Caption = IntToStr(posx);
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc 定右邊界
void __fastcall TMainForm::btnSetRightClick(TObject *Sender)
{
I32 posx;
F64 fcmd;

   if(MotionMode == MOTION_MODE_APS)
      APS_get_position(X_AXIS+StartAxisNo,&posx);
   pnlXRight->Caption = IntToStr(posx);
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc 設定中心點
void __fastcall TMainForm::btnSetCenterClick(TObject *Sender)
{
int up,down,left,right,cx,cy;

   up = pnlYUp->Caption.ToInt();
   down = pnlYDown->Caption.ToInt();
   left = pnlXLeft->Caption.ToInt();
   right = pnlXRight->Caption.ToInt();
   cx = (left + right) / 2;
   cy = (up + down) / 2;
   pnlCenterX->Caption = IntToStr(cx);
   pnlCenterY->Caption = IntToStr(cy);

}
//---------------------------------------------------------------------------
// 2021 5 4 - chc 到中心點
void __fastcall TMainForm::btnToCenterPositionClick(TObject *Sender)
{
int cx,cy;

   pnlToCenterPosition->Color = clSilver;
   cx = pnlCenterX->Caption.ToInt();
   cy = pnlCenterY->Caption.ToInt();

   // 2021 9 11 - chc 加速: MOVE_WAIT
   //if(MoveToXY(cx,cy) == true)
   if(MoveToXY(cx,cy,MOVE_WAIT) == true)

      pnlToCenterPosition->Color = clLime;
   else
      pnlToCenterPosition->Color = clRed;
   Sleep(100);
}
//---------------------------------------------------------------------------
// 0-Right, 1-Left, 2-Up, 3-Down
// ret : -1 Error
// BaslerCaptureNoAry[no]
int __fastcall TMainForm::FindEdge(int mode)
{
unsigned char r,g,b;
TColor color;
int width,height,sx,ex,sy,ey,gap,row,col,offset,edge[5],pos,cx,cy,adjustx,adjusty;
int dx,dy,ipos;
I32 posx,posy;
AnsiString msg;
int cnt = 0;
bool booladjust = false;
int mv,maxno;

// 2021 9 15 - chc 將灰階量改成參數: WaferEdgeGray
int waferedgegray;
   waferedgegray = edWaferEdgeGray->Text.ToInt();

   maxno = edWaferCenterCnt->Text.ToInt();
   shVertEdge->Visible = false;
   shHorzEdge->Visible = false;
   DelayTime(300);

   width = imCCD->Width;
   height = imCCD->Height;
   gap = 50;
   row = height / 2;
   col = width / 2;
   cx = col;
   cy = row;
   offset = 50;

   adjustx = ((width / 2) * MotionCCDPrecision) / X_RESOLUTION;
   adjusty = ((height / 2) * MotionCCDPrecision) / Y_RESOLUTION;

   switch(mode) {
      // Right(X+)
      case 0:
rightagain:
         booladjust = false;
         row = height / 2;
         col = width / 2;
         cx = col;
         cy = row;
         sx = width - gap;
         ex = gap;
         row -= offset;
         edge[0] = edge[1] = edge[2] = -1;
         for(int i=0 ; i<3 ; i++) {
            for(int j=sx ; j>ex ; j--) {
               color = imCCD->Canvas->Pixels[j][row];
               b = (color & 0xff0000) >> 16;
               g = (color & 0x00ff00) >> 8;
               r = color & 0x0000ff;

               // 2021 9 15 - chc 將灰階量改成參數: waferedgegray
               //if(g > 50) {
               if(g > waferedgegray) {

                  edge[i] = j;
                  break;
               }
            }
            row += offset;
         }
         pos = (edge[0] + edge[1] + edge[2]) / 3;
         // 移動量太多, 少1/2
         if(pos < 100) {
            WriteSystemLog("調整右邊界: " + IntToStr(adjustx));
            booladjust = true;
            mv = adjustx;
         }
         else if(pos > (sx-10)) {
            WriteSystemLog("調整右邊界: " + IntToStr(0-adjustx));
            booladjust = true;
            mv = 0-adjustx;
         }
         if(booladjust == true) {
            cnt++;
            if(cnt > maxno) {
               WriteSystemLog("調整: 找不到右邊界!");
               pnlSystemMessage->Caption = "調整: 找不到右邊界!";
               return(-1);
            }
            pnlSystemMessage->Caption = "調整右邊界";
            if(MoveToAxisGap(X_AXIS, mv) == false) {
               WriteSystemLog("調整右邊界: Stage移動失敗!");
               pnlSystemMessage->Caption = "調整右邊界觀測點移動失敗!";
               return(-1);
            }
            // BaslerCaptureNoAry[no]
            //DelayTime(1200);
            if(WaitMoreFrame(5,2000) == false) {
               WriteSystemLog("調整右邊界: CCD取像異常!");
               pnlSystemMessage->Caption = "調整右邊界: CCD取像異常!";
               return(-1);
            }
            goto rightagain;
         }
         shVertEdge->Top = cy + imCCD->Top - shVertEdge->Height / 2;
         shVertEdge->Left = imCCD->Left + pos;
         shVertEdge->Visible = true;
         shVertEdge->Refresh();
         APS_get_position(X_AXIS+StartAxisNo,&posx);
         dx = ((double)(pos - cx) * MotionCCDPrecision) / X_RESOLUTION;

         // 2021 6 10 - chc 減才對
         //ipos = posx + dx;
         ipos = posx - dx;

         msg.sprintf("右: Edge,cx,dx,posx,nposx= %d,%d,%d,%d",pos,cx,dx,(int)posx,ipos);
         WriteSystemLog(msg);

         DoubleClickX = pos;
         DoubleClickY = cy;
         if(cbEdgeLog->Checked == true) {
            msg.sprintf("右邊界(+): x, cx, dx, x軸, 新x軸 = %d,%d,%d,%d,%d", pos, cx, dx, (int)posx, ipos);
            WriteSystemLog(msg);
            Application->MessageBox(msg.c_str(), " Center", MB_OK);
         }
         imCCDDblClick(this);
         APS_get_position(X_AXIS+StartAxisNo,&posx);
         if(cbEdgeLog->Checked == true) {
            msg.sprintf("右邊界(+): x, cx, dx, x軸, 新x軸 = %d,%d,%d,%d,%d", pos, cx, dx, (int)posx, ipos);
            WriteSystemLog(msg);
            Application->MessageBox(msg.c_str(), " Center", MB_OK);
         }
         ipos = posx;

         return ipos;
         break;
      // Left
      case 1:
leftagain:
         booladjust = false;
         row = height / 2;
         col = width / 2;
         cx = col;
         cy = row;
         ex = width - gap;
         sx = gap;
         row -= offset;
         edge[0] = edge[1] = edge[2] = -1;
         for(int i=0 ; i<3 ; i++) {
            for(int j=sx ; j<ex ; j++) {
               color = imCCD->Canvas->Pixels[j][row];
               b = (color & 0xff0000) >> 16;
               g = (color & 0x00ff00) >> 8;
               r = color & 0x0000ff;

               // 2021 9 15 - chc 將灰階量改成參數: waferedgegray
               //if(g > 50) {
               if(g > waferedgegray) {

                  edge[i] = j;
                  break;
               }
            }
            row += offset;
         }

         // 2021 9 15 - chc 無邊
         if(edge[0] == -1 || edge[1] == -1 || edge[2] == -1) {
            goto toleft;
         }

         pos = (edge[0] + edge[1] + edge[2]) / 3;
         // 移動量太多, 少1/2
         if(pos > (width-100)) {
toleft:
            WriteSystemLog("調整左邊界: " + IntToStr(0-adjustx));
            booladjust = true;
            mv = 0- adjustx;
         }
         else if(pos < 100) {
            WriteSystemLog("調整左邊界: " + IntToStr(adjustx));
            booladjust = true;
            mv = adjustx;
         }
         if(booladjust == true) {
            cnt++;
            if(cnt > maxno) {
               WriteSystemLog("調整: 找不到左邊界!");
               pnlSystemMessage->Caption = "調整: 找不到左邊界!";
               return(-1);
            }
            pnlSystemMessage->Caption = "調整左邊界";
            if(MoveToAxisGap(X_AXIS, mv) == false) {
               WriteSystemLog("調整左邊界: Stage移動失敗!");
               pnlSystemMessage->Caption = "調整左邊界觀測點移動失敗!";
               return(-1);
            }
            // BaslerCaptureNoAry[no]
            //DelayTime(1200);
            if(WaitMoreFrame(5,2000) == false) {
               WriteSystemLog("調整左邊界: CCD取像異常!");
               pnlSystemMessage->Caption = "調整左邊界: CCD取像異常!";
               return(-1);
            }
            goto leftagain;
         }
         shVertEdge->Top = cy + imCCD->Top - shVertEdge->Height / 2;
         shVertEdge->Left = imCCD->Left + pos;
         shVertEdge->Visible = true;
         shVertEdge->Refresh();
         APS_get_position(X_AXIS+StartAxisNo,&posx);
         dx = ((double)(pos - cx) * MotionCCDPrecision) / X_RESOLUTION;

         // 2021 6 9a - chc 要減
         //ipos = posx + dx;
         ipos = posx - dx;

         msg.sprintf("左: Edge,cx,dx,posx= %d,%d,%d,%d",pos,cx,dx,ipos);
         WriteSystemLog(msg);

         DoubleClickX = pos;
         DoubleClickY = cy;
         if(cbEdgeLog->Checked == true) {
            msg.sprintf("左邊界(-): x, cx, dx, x軸, 新x軸 = %d,%d,%d,%d,%d", pos, cx, dx, (int)posx, ipos);
            WriteSystemLog(msg);
            Application->MessageBox(msg.c_str(), " Center", MB_OK);
         }
         imCCDDblClick(this);
         APS_get_position(X_AXIS+StartAxisNo,&posx);
         if(cbEdgeLog->Checked == true) {
            msg.sprintf("左邊界(-): x, cx, dx, x軸, 新x軸 = %d,%d,%d,%d,%d", pos, cx, dx, (int)posx, ipos);
            WriteSystemLog(msg);
            Application->MessageBox(msg.c_str(), " Center", MB_OK);
         }
         ipos = posx;

         return ipos;
         break;
      // Up
      case 2:
upagain:
         booladjust = false;
         row = height / 2;
         col = width / 2;
         // 修正
         cx = col;
         cy = row;
         sy = gap;
         ey = height - gap;
         col -= offset;
         edge[0] = edge[1] = edge[2] = -1;
         for(int i=0 ; i<3 ; i++) {
            for(int j=sy ; j<ey ; j++) {
               color = imCCD->Canvas->Pixels[col][j];
               b = (color & 0xff0000) >> 16;
               g = (color & 0x00ff00) >> 8;
               r = color & 0x0000ff;

               // 2021 9 15 - chc 將灰階量改成參數: waferedgegray
               //if(g > 50) {
               if(g > waferedgegray) {

                  edge[i] = j;
                  break;
               }
            }
            col += offset;
         }

         // 2021 7 22 - chc 無偵測
         if(edge[0] == -1 || edge[1] == -1 || edge[2] == -1) {
            goto todown;
         }

         pos = (edge[0] + edge[1] + edge[2]) / 3;
         // 移動量太多, 少1/2
         if(pos > (height-100)) {
todown:
            WriteSystemLog("調整上邊界: " + IntToStr(0-adjusty));
            booladjust = true;

            // 2021 6 9 - chc 相反
            //mv = 0- adjusty;
            // 2021 7 22 - chc 相反
            //mv = adjusty;
            mv = 0- adjusty;

         }
         else if(pos < 100) {
            WriteSystemLog("調整上邊界: " + IntToStr(adjusty));
            booladjust = true;

            // 2021 6 9 - chc 相反
            //mv = adjusty;
            // 2021 7 22 - chc 相反
            //mv = 0-adjusty;
            mv = adjusty;

         }
         if(booladjust == true) {
            cnt++;
            if(cnt > maxno) {
               WriteSystemLog("調整: 找不到上邊界!");
               pnlSystemMessage->Caption = "調整: 找不到上邊界!";
               return(-1);
            }
            pnlSystemMessage->Caption = "調整上邊界";
            if(MoveToAxisGap(Y_AXIS, mv) == false) {
               WriteSystemLog("調整上邊界: Stage移動失敗!");
               pnlSystemMessage->Caption = "調整上邊界觀測點移動失敗!";
               return(-1);
            }
            // BaslerCaptureNoAry[no]
            //DelayTime(1200);
            if(WaitMoreFrame(5,2000) == false) {
               WriteSystemLog("調整上邊界: CCD取像異常!");
               pnlSystemMessage->Caption = "調整上邊界: CCD取像異常!";
               return(-1);
            }
            goto upagain;
         }
         shHorzEdge->Left = cx + imCCD->Left - shHorzEdge->Width / 2;
         shHorzEdge->Top = imCCD->Top + pos;
         shHorzEdge->Visible = true;
         shHorzEdge->Refresh();
         APS_get_position(Y_AXIS+StartAxisNo,&posy);
         dy = ((double)(pos - cy) * MotionCCDPrecision) / Y_RESOLUTION;

         // 2021 6 9 - chc 改向
         //ipos = posy + dy;
         ipos = posy - dy;

         msg.sprintf("上: Edge,cy,dx,posx= %d,%d,%d,%d",pos,cy,dy,ipos);
         WriteSystemLog(msg);

         DoubleClickX = cx;
         DoubleClickY = pos;
         if(cbEdgeLog->Checked == true) {
            msg.sprintf("上邊界(-): y, cy, dy, y軸, 新y軸 = %d,%d,%d,%d,%d", pos, cy, dy, (int)posy, ipos);
            WriteSystemLog(msg);
            Application->MessageBox(msg.c_str(), " Center", MB_OK);
         }
         imCCDDblClick(this);
         APS_get_position(Y_AXIS+StartAxisNo,&posy);
         if(cbEdgeLog->Checked == true) {
            msg.sprintf("上邊界(-): y, cy, dy, y軸, 新y軸 = %d,%d,%d,%d,%d", pos, cy, dy, (int)posy, ipos);
            WriteSystemLog(msg);
            Application->MessageBox(msg.c_str(), " Center", MB_OK);
         }
         ipos = posy;

         return ipos;
         break;
      // Down
      case 3:
downagain:
         booladjust = false;
         row = height / 2;
         col = width / 2;
         cx = col;
         cy = row;
         ey = gap;
         sy = height - gap;
         col -= offset;
         edge[0] = edge[1] = edge[2] = -1;
         for(int i=0 ; i<3 ; i++) {
            for(int j=sy ; j>ey ; j--) {
               color = imCCD->Canvas->Pixels[col][j];
               b = (color & 0xff0000) >> 16;
               g = (color & 0x00ff00) >> 8;
               r = color & 0x0000ff;

               // 2021 9 15 - chc 將灰階量改成參數: waferedgegray
               //if(g > 50) {
               if(g > waferedgegray) {

                  edge[i] = j;
                  break;
               }
            }
            col += offset;
         }


         pos = (edge[0] + edge[1] + edge[2]) / 3;
         // 移動量太多, 少1/2
         if(pos < 100) {
            WriteSystemLog("調整下邊界: " + IntToStr(adjusty));
            booladjust = true;
            mv = adjusty;
         }
         else if(pos > (height-100)) {
            WriteSystemLog("調整下邊界: " + IntToStr(0-adjusty));
            booladjust = true;
            mv = 0-adjusty;
         }
         if(booladjust == true) {
            cnt++;
            if(cnt > maxno) {
               WriteSystemLog("調整: 找不到下邊界!");
               pnlSystemMessage->Caption = "調整: 找不到下邊界!";
               return(-1);
            }
            pnlSystemMessage->Caption = "調整下邊界";
            if(MoveToAxisGap(Y_AXIS, mv) == false) {
               WriteSystemLog("調整下邊界: Stage移動失敗!");
               pnlSystemMessage->Caption = "調整下邊界觀測點移動失敗!";
               return(-1);                           
            }
            // BaslerCaptureNoAry[no]
            //DelayTime(1200);
            if(WaitMoreFrame(5,2000) == false) {
               WriteSystemLog("調整下邊界: CCD取像異常!");
               pnlSystemMessage->Caption = "調整下邊界: CCD取像異常!";
               return(-1);
            }
            goto downagain;
         }
         shHorzEdge->Left = cx + imCCD->Left - shHorzEdge->Width / 2;
         shHorzEdge->Top = imCCD->Top + pos;
         shHorzEdge->Visible = true;
         shHorzEdge->Refresh();
         APS_get_position(Y_AXIS+StartAxisNo,&posy);
         dy = ((double)(pos - cy) * MotionCCDPrecision) / Y_RESOLUTION;

         // 2021 6 10 - chc 減才對
         //ipos = posy + dy;
         ipos = posy - dy;

         msg.sprintf("下: Edge,cy,dy,posx= %d,%d,%d,%d",pos,cy,dy,ipos);
         WriteSystemLog(msg);

         DoubleClickX = cx;
         DoubleClickY = pos;
         if(cbEdgeLog->Checked == true) {
            msg.sprintf("下邊界(+): y, cy, dy, y軸, 新y軸 = %d,%d,%d,%d,%d", pos, cy, dy, (int)posy, ipos);
            WriteSystemLog(msg);
            Application->MessageBox(msg.c_str(), " Center", MB_OK);
         }
         imCCDDblClick(this);
         APS_get_position(Y_AXIS+StartAxisNo,&posy);
         if(cbEdgeLog->Checked == true) {
            msg.sprintf("下邊界(+): y, cy, dy, y軸, 新y軸 = %d,%d,%d,%d,%d", pos, cy, dy, (int)posy, ipos);
            WriteSystemLog(msg);
            Application->MessageBox(msg.c_str(), " Center", MB_OK);
         }
         ipos = posy;

         return ipos;
         break;
   }
   shVertical->Visible = true;
   shHorizontal->Visible = true;
   return -1;
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::ClearEdgeMark()
{

   shVertEdge->Visible = false;
   shHorzEdge->Visible = false;
}
//---------------------------------------------------------------------------
// BaslerCaptureNoAry[no]
bool __fastcall TMainForm::WaitMoreFrame(int frameno, int timeout)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int sno;

   GetTimeTic(&StartTime,&StartTick);
   sno = BaslerCaptureNoAry[0];
   while(1) {
      Sleep(50);
      Application->ProcessMessages();
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > timeout) 
         return false;
      if((BaslerCaptureNoAry[0] - sno) > frameno)
         return true;
   }
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc EFEM
void __fastcall TMainForm::btnRorzeAlignerEnableClick(TObject *Sender)
{

   pnlRorzeAligner->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc EFEM
void __fastcall TMainForm::btnRorzeRobotEnableClick(TObject *Sender)
{

   pnlRorzeRobot->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc EFEM
void __fastcall TMainForm::btnRorzeLoadPort1EnableClick(TObject *Sender)
{

   pnlLoadPort1->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc EFEM
void __fastcall TMainForm::btnRorzeLoadPort2EnableClick(TObject *Sender)
{

   pnlLoadPort2->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc Measure
void __fastcall TMainForm::btnMeasureClick(TObject *Sender)
{
int no;

   // Chuck With Wafer?
   if(IsChuckWithWafer() == false) {
      WriteSystemLog("To Measure: Satge上無Wafer!");
      pnlAlarmMessage->Caption = "Satge上無Wafer!";
      pnlOperationMessage->Caption = pnlAlarmMessage->Caption;
      return;
   }
   pcSystem->ActivePage = tsSystem;
   pcOP->ActivePage = tsRun;
}
//---------------------------------------------------------------------------
// 2021 5 4 - chc SEC init
void __fastcall TMainForm::InitSECSStatus()
{

   // 2021 9 8b - chc Log
   WriteSystemLog("Clear SECS Data");

   // Idle
   // 2021 10 21 - chc 送出Status: Init/Idle/Setup/Ready/Execution/Pause
   //rgEQStatus->ItemIndex = EQ_STATUS_IDLE;                                    // SendSECSStatus(EQ_STATUS_IDLE)

   rgEQExist->ItemIndex = WAFER_EXIST_NO;
   rgUpArmExist->ItemIndex = WAFER_EXIST_NO;
   rgLowArmExist->ItemIndex = WAFER_EXIST_NO;
   rgCSTExist->ItemIndex = WAFER_EXIST_NO;
   rgCST2Exist->ItemIndex = WAFER_EXIST_NO;
   WriteSystemLog("boolSendSCESCommand: 23");
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;
}
//---------------------------------------------------------------------------
// for test
void __fastcall TMainForm::pnlSECSAlarmCodeClick(TObject *Sender)
{
AnsiString text,cmdstr,scmd,spar[100];
int pos1,pos,parcnt;
bool booltag = false;
bool flag;

bool done = false;
   parcnt = 0;

   pnlSECSAlarmCode->Caption = "";
   return;

   text = "aPTST$oRCMD^3^2^$";
   //rgSecsCommandSet->ItemIndex = SECS_CMD_RCPM - SECS_CMD_STAT_1;
   // 分段
   while((pos1 = text.Pos("$")) != 0) {
      booltag = false;
      done = false;
      parcnt = 0;
      // 取得完整命令字串
      cmdstr = text.SubString(1,pos1);
//      pnlSECS->Caption = cmdstr;
      text.Delete(1,pos1);
      // oSTAT^1$
      // 1234567890
      pos = cmdstr.Pos("^");
      if(pos == 0) {                                                            // No Parameter!
         scmd = cmdstr.SubString(1,pos1-1);
         pos = pos1 - 1;
      }
      else {
         scmd = cmdstr.SubString(1,pos-1);
         booltag = true;
      }
      if(scmd.Length() < 5) {
         AddSECSMessage("[<] Invalid: " + cmdstr);
         flag = false;
         continue;
      }
      if(pos > 0)
         cmdstr.Delete(1,pos);
      //done = true;
//      AddSECSMessage("[<] " + scmd);

      // Par
      while(done == false) {
         pos = cmdstr.Pos("^");
         if(pos == 0) {
            pos = cmdstr.Pos("$");
            if(pos == 0) {
               AddSECSMessage("[<] Invalid");
               flag = false;
               continue;
            }
            else {
               if(pos <= 1 && booltag == true)
                  spar[parcnt++] = "";
               else if(pos > 1)                                 // @@
                  spar[parcnt++] = cmdstr.SubString(1,pos-1);
               cmdstr.Delete(1,pos);
               done = true;
            }
         }
         else {
            booltag = true;
            spar[parcnt++] = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
         }

         // 2021 4 28 - chc parcnt > 0
         if(parcnt > 0)

            AddSECSMessage("[SECS] " + spar[parcnt-1] + " : " + IntToStr(parcnt));

         if(cmdstr.Length() <= 0)
            break;
      }
      DecodeSECS(scmd,spar,parcnt,1);
   }

}
//---------------------------------------------------------------------------
//   struct WAFER_STRU {
//      AnsiString ID;
//      int Priority;
//      AnsiString RecipeName;
//   };
//  struct WAFER_STRU WaferBuffer[25];
//
// 2023 8 1 - chc 加入Portno
//void __fastcall TMainForm::ClearWaferBuffer()
void __fastcall TMainForm::ClearWaferBuffer(int portno)
{
int no;

   for(no=0 ; no<25 ; no++) {
      WaferBuffer[no].ID = "";
      WaferBuffer[no].RecipeName = "";
      WaferBuffer[no].Priority = -1;
      WaferBuffer[no].Status = -1;
      WorkingBuffer[no] = '0';

      // 2023 8 1 - chc LP1/LP2
      //CassetteBuffer[no] = '0';
      CassetteBuffer[portno][no] = '0';

   }

   // 2023 8 1 - chc LP1/LP2
   //CassetteBuffer[26] = 0x0;
   CassetteBuffer[portno][26] = 0x0;

   WorkingBuffer[26] = 0x0;

   // 2023 8 1 - chc LP1/LP2
   if(portno == LOADPORT_2)
      edMapData2->Text = WorkingBuffer;
   else

      edMapData->Text = WorkingBuffer;

   // 2023 8 2 - chc LP1/LP2
   //UpdateCassetteState(0);
   UpdateCassetteState(portno,0);

}
//---------------------------------------------------------------------------
//
void __fastcall TMainForm::btnFocusDoneClick(TObject *Sender)
{

   // 2021 10 27 - chc Log
   WriteSystemLog("按下下一步確認");

   boolTestFocusDone = true;
   btnFocusDone->Visible = false;

   // 2021 9 23b - chc 顯示
   pnlSideNo->Visible = false;
   pnlDotNoRun1->Visible = false;

   pnlOperationMessage->Caption = "";

   // 2021 8 13 - chc 操作指示
   pnlFocusDone->Visible = false;

   // 2022 1 3 - chc 定義pnlFocusDoneE
   pnlFocusDoneE->Visible = false;

}
//---------------------------------------------------------------------------
// 2021 5 5 - chc 檢查W
// mode 0 - Get, 1 - Put
bool __fastcall TMainForm::GoRobotWAxis(int mode)
{
int stageno,pos;
AnsiString msg;

   // 先做點位Home
   rgRobotOperation->ItemIndex = mode;
   btnRobotStageHomeClick(this);
   if(pnlRobotStageHome->Color != clLime) {

      // 2021 9 20a - chc Alarm
      if(boolWAxisPositionError == false) {
         boolWAxisPositionError = true;
         SetSECSAlarm(41004,1,1,"W-Axis Position Abnormal");
      }

      return false;
   }

   // 2021 9 20a - chc Alarm
   if(boolWAxisPositionError == true) {
      boolWAxisPositionError = false;
      SetSECSAlarm(41004,0,1,"W-Axis Position Abnormal");
   }

   // 2023 8 2 - chc 確認 @@暫
   if(cbRobotStep->Checked == true) {
      if(stageno == 0)
         msg.sprintf("Robot W to: LP1?");
      else if(stageno == 1)
         msg.sprintf("Robot W to: LP2?");
      else if(stageno == 2)
         msg.sprintf("Robot W to: Aligner?");
      else if(stageno == 3)
         msg.sprintf("Robot W to: Chuck?");
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return false;
      }
   }

   stageno = rgRobotStage->ItemIndex;
   switch(stageno) {
      // LD1
      case 0:
         btnToWPosition1Click(this);
         break;
      // LD2
      case 1:
         btnToWPosition2Click(this);
         break;
      // AL
      case 2:
         btnToWPosition3Click(this);
         break;
      // Chuck
      case 3:
         btnToWPosition4Click(this);
         break;
   }
   if(pnlToWStatus->Color == clLime) {

      // 2021 9 20a - chc Alarm
      if(boolWAxisPositionError == true) {
         boolWAxisPositionError = false;
         SetSECSAlarm(41004,0,1,"W-Axis Position Abnormal");
      }

      return true;
   }

   // 2021 9 20a - chc Alarm
   if(boolWAxisPositionError == false) {
      boolWAxisPositionError = true;
      SetSECSAlarm(41004,1,1,"W-Axis Position Abnormal");
   }

   return false;
}
//---------------------------------------------------------------------------
// 202 5 5 - chc Reset
void __fastcall TMainForm::btnMotionResetClick(TObject *Sender)
{

   if(btnMotionReset->Caption == "Reset") {
      WriteSystemLog("按下Reset.");
      pnlSystemMessage->Caption = "Press Reset.";
      btnSvonClick(this);
      WriteSystemLog("按下Reset: 完成SVON");
      pnlSystemMessage->Caption = " Press Reset: to do SVON";
      btnMotionReset->Caption = "Do Home";
      pnlAxisError->Caption = "Please execute homing...";
   }
   else {
      WriteSystemLog("按下原點復歸.");
      pnlSystemMessage->Caption = "Press HOME.";
      MainForm->btnMotionReset->Visible = false;
      MainForm->btnMotionReset->Refresh();
      btnHomeClick(this);
      WriteSystemLog("按下原點復歸: 完成Home");
      pnlSystemMessage->Caption = "Press HOME: do Home";
   }
}
//---------------------------------------------------------------------------
// mode
//#define CMD_YUANLI              0
//#define CMD_MODE                1
//#define CMD_SET_RECIPE          2
//#define CMD_INIT                3
//#define CMD_START               4
//#define CMD_STOP                5
//#define CMD_BUSY                6
//#define CMD_INVALID             7
//#define CMD_INPOS               8
// ret s/e/x
//#define CMD_ACK_WAIT              0
//#define CMD_ACK_E                 1
//#define CMD_ACK_X                 2
//#define CMD_ACK_TIMEOUT           3
//int YuanliCmdStatus[YUANLI_CMD_NO];
// Send and wait
int __fastcall TMainForm::WaitYuanliCmd(int mode)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
// 30sec
int timeout = 30000;

   // 2021 12 18 - chc 先確認YuanLi是否連線?
   if(pnlOlympusStatus->Color != clLime) {
      YuanliCmdStatus[mode] = CMD_ACK_X;
      return YuanliCmdStatus[mode];
   }

   // Set init status
   YuanliCmdStatus[mode] = CMD_ACK_WAIT;

   // Send
   rgYuanliCommandSet->ItemIndex = -1;
   boolSendYuanliCommand = true;
   rgYuanliCommandSet->ItemIndex = mode;

   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      WaitTime(100);
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > timeout) {
         WriteSystemLog("YuanLi Socket Command Timeout!");
         return CMD_ACK_TIMEOUT;
      }
      if(YuanliCmdStatus[mode] == CMD_ACK_E || YuanliCmdStatus[mode] == CMD_ACK_X)
         return YuanliCmdStatus[mode];
   }
}
//---------------------------------------------------------------------------
// 2021 5 7 - chc YuanLi是否連線
bool __fastcall TMainForm::YuanLiConnect()
{
int no;
bool boolreconnect = false;

   if(pnlSocketConnect->Color != clLime) {
again:
      boolreconnect = true;
      pnlOperationMessage->Caption = "YuanLi未連線, 重連線中...";
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      btnYunliReConnectClick(this);
      no = 0;
      while(1) {
         if(pnlSocketConnect->Color == clLime) {
            pnlOperationMessage->Caption = "YuanLi已連線, 測試通訊...";
            pnlSystemMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            break;
         }
         WaitTime(100);
         no++;
         // 10sec
         if(no > 100) {
            pnlOperationMessage->Caption = "YuanLi通訊失敗(Timeout)!";
            pnlSystemMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            boolYuanliSocket = false;
            return false;
         }
      }
   }
   // YuanLi Command
   if(WaitYuanliCmd(CMD_YUANLI) != CMD_ACK_E) {
      if(boolreconnect == false) {
         pnlOperationMessage->Caption = "YuanLi通訊失敗! 重連線中...";
         pnlSystemMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         pnlSocketConnect->Color = clSilver;
         WaitTime(500);
         goto again;
      }
      pnlOperationMessage->Caption = "YuanLi通訊失敗!";
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      boolYuanliSocket = false;
      return false;
   }
   pnlOperationMessage->Caption = "YuanLi通訊ok.";
   pnlSystemMessage->Caption = pnlOperationMessage->Caption;
   WriteSystemLog(pnlOperationMessage->Caption);
   boolYuanliSocket = true;
   return true;
}
//---------------------------------------------------------------------------
// 2021 5 7 - chc SECS是否連線
bool __fastcall TMainForm::SECSConnect()
{
int no;
bool boolreconnect = false;

   if(pnlSECSConnect->Color != clLime) {
again:
      boolreconnect = true;
      pnlOperationMessage->Caption = "SECS is no connected, Connecting...";
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      btnSECSReConnectClick(this);
      no = 0;
      while(1) {
         if(pnlSECSConnect->Color == clLime) {
            pnlOperationMessage->Caption = "SECS connected, test communication...";
            pnlSystemMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            break;
         }
         WaitTime(100);
         no++;
         // 10sec
         if(no > 100) {
            BlueLamp(false);
            boolSECSSocket = false;
            pnlOperationMessage->Caption = "SECS communication failed!";
            pnlSystemMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            return false;
         }
      }
   }
   // SECS Command: STWR
   boolSECS_STWR = false;
   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_STWR - SECS_CMD_STAT_1;
   no = 0;
   while(1) {
      if(boolSECS_STWR == true) {
         pnlOperationMessage->Caption = "SECS通訊ok.";
         pnlSystemMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);

         // 2023 1 28 - chc Local不亮
         if(cbOffLine->Checked == false)

            BlueLamp(true);
         boolSECSSocket = true;
         return true;
      }
      WaitTime(100);
      no++;
      // 10sec
      if(no > 100) {
         BlueLamp(false);
         boolSECSSocket = false;
         pnlOperationMessage->Caption = "SECS通訊失敗(Timeout)!";
         pnlSystemMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         return false;
      }
   }
   BlueLamp(false);
   boolSECSSocket = false;
   pnlOperationMessage->Caption = "SECS communication failed!";
   pnlSystemMessage->Caption = pnlOperationMessage->Caption;
   WriteSystemLog(pnlOperationMessage->Caption);
   return false;
}
//---------------------------------------------------------------------------
// 2021 5 8 - chc 更新中心點偏移量
// Recipe: pnlAreaX, pnlAreaY
// New:    pnlCenterXFind, pnlCenterYFind
// Value:  pnlOffsetXArea, pnlOffsetYArea
void __fastcall TMainForm::UpdateCenterOffset()
{
double fdx,fdy;
AnsiString msg;

   // 是否已指定Recipe?
   // => sgArea->Cells[1][recno]
   if(sgArea->RowCount > 2) {
      fdx = pnlCenterXFind->Caption.ToInt() - sgArea->Cells[1][1].ToInt();
      fdy = pnlCenterYFind->Caption.ToInt() - sgArea->Cells[2][1].ToInt();
   }
   else {
      fdx = pnlCenterXFind->Caption.ToInt() - pnlAreaX->Caption.ToInt();
      fdy = pnlCenterYFind->Caption.ToInt() - pnlAreaY->Caption.ToInt();
   }

   fdx *= X_RESOLUTION;
   fdy *= Y_RESOLUTION;
   msg.sprintf("%.1f",fdx);
   pnlOffsetXArea->Caption = msg;
   msg.sprintf("%.1f",fdy);
   pnlOffsetYArea->Caption = msg;
   // >500um要警示
   if(fdx > 500)
      pnlOffsetXArea->Color = (TColor)0x001B4E70;
   else
      pnlOffsetXArea->Color = (TColor)0x003C9F82;
   if(fdy > 500)
      pnlOffsetYArea->Color = (TColor)0x001B4E70;
   else
      pnlOffsetYArea->Color = (TColor)0x003C9F82;

}
//---------------------------------------------------------------------------
// 2021 5 8 - chc 設定Row,Col
void __fastcall TMainForm::mnSetMeasurePointClick(TObject *Sender)
{

   if(Wafer.boolSet == false)
      return;
   pnlColumSet->Caption = pnlColum->Caption;
   pnlRowSet->Caption = pnlRow->Caption;
}
//---------------------------------------------------------------------------
// 2021 5 8 - chc 到Row,Col
void __fastcall TMainForm::mnToMeasurePointClick(TObject *Sender)
{
int x,y,row,col,cx,cy,dx,dy,ccol,crow,dcol,drow;
int waferw,waferh;
AnsiString msg;

   if(Wafer.boolSet == false)
      return;

   // 中心Col,Row
   ccol = pnlCenterCol->Caption.ToInt();
   crow = pnlCenterRow->Caption.ToInt();

   // 目前Col,Row
   col = pnlColum->Caption.ToInt();
   row = pnlRow->Caption.ToInt();

   // x,y
   dcol = col - ccol;
   drow = row - crow;

   // Wafer Size(um)
   waferw = edDieSizeX->Text.ToDouble();
   waferh = edDieSizeY->Text.ToDouble();
   // to Pulse
   waferw /= X_RESOLUTION;
   waferh /= Y_RESOLUTION;

   // 與中心之距離
   dx = dcol * waferw;
   dy = drow * waferh;

   // 中心點
   cx = pnlCenterXFind->Caption.ToInt();
   cy = pnlCenterYFind->Caption.ToInt();

   // x,y
   x = cx - dx;
   y = cy - dy;
   // 使用XY同動
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   msg.sprintf("ToColRow: ccol,crow-col,row-dx,dy-cx,cy-x,y= ",ccol,crow,col,row,dx,dy,cx,cy,x,y);
   WriteSystemLog(msg);

}
//---------------------------------------------------------------------------
// 中斷量測作業: boolDoMeasure, btnMeasureStop
void __fastcall TMainForm::btnMeasureStopClick(TObject *Sender)
{

   boolDoMeasure = false;
   btnMeasureStop->Visible = false;
   btnFocusDone->Visible = false;

   // 2021 9 23b - chc 顯示
   pnlSideNo->Visible = false;
   pnlDotNoRun1->Visible = false;

   // 2021 8 13 - chc 操作指示
   pnlFocusDone->Visible = false;

   // 2022 1 3 - chc 定義pnlFocusDoneE
   pnlFocusDoneE->Visible = false;

   // 2021 7 19 - chc 改用runabort
   WriteSystemLog("[中斷量測]1");

   // 2021 7 22 - chc 要Reset boolTestFocusDone
   boolTestFocusDone = true;

   // 2021 10 27 - chc Log
   WriteSystemLog("中斷: 視同按下下一步確認");

}
//---------------------------------------------------------------------------
bool __fastcall TMainForm::StopMeasure()
{

   if(boolDoMeasure == false) {

      // 2021 7 19 - chc 改用runabort
      WriteSystemLog("[中斷量測]2");

      return true;
   }
   return false;
}
//---------------------------------------------------------------------------


void __fastcall TMainForm::pnlAlignerErrorCode1Click(TObject *Sender)
{

   pnlAlignerErrorCode1->Caption = "";
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlRobotErrorCode1Click(TObject *Sender)
{

   pnlRobotErrorCode1->Caption = "";
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlLoadPortErrorCode1Click(TObject *Sender)
{

   pnlLoadPortErrorCode1->Caption = "";
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlLoadPort2ErrorCode1Click(TObject *Sender)
{

   pnlLoadPort2ErrorCode1->Caption = "";
}
//---------------------------------------------------------------------------
// 2021 5 26 - chc Joystick-AI
void __fastcall TMainForm::btnJoystickSaveAIClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(MainForm->SystemINIFilename);

   AISpeedStart = edAISpeedStart->Text.ToInt();
   AISpeedChange = edAISpeedChange->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,AISPEED_START                  ,AISpeedStart);
   pSystemFile->WriteInteger("System Parameter" ,AISPEED_CHANGE                 ,AISpeedChange);
   boolAISpeed = cbAISpeed->Checked;
   pSystemFile->WriteBool("System Parameter" ,BOOL_AISPEED                      ,boolAISpeed);

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnSaveAlarmParameterClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString fname;
bool boolset;

   // ini檔名與目錄: Alarm.ini
   fname = SystemDirectory + "\\Alarm.ini" ;
   pSystemFile = new TIniFile(fname);

   // PC Door
   boolset = cbPCDoorRed->Checked;
   pSystemFile->WriteBool("Alarm","PC Door Red"                        ,boolset);
   boolset = cbPCDoorAlarm->Checked;
   pSystemFile->WriteBool("Alarm","PC Door Alarm"                      ,boolset);
   // EFEM Left Door
   boolset = cbEFEMLeftDoorRed->Checked;
   pSystemFile->WriteBool("Alarm","EFEM Left Door Red"                  ,boolset);
   boolset = cbEFEMLeftDoorAlarm->Checked;
   pSystemFile->WriteBool("Alarm","EFEM Left Door Alarm"                ,boolset);
   // EFEM Right Door
   boolset = cbEFEMRightDoorRed->Checked;
   pSystemFile->WriteBool("Alarm","EFEM Right Door Red"                ,boolset);
   boolset = cbEFEMRightDoorAlarm->Checked;
   pSystemFile->WriteBool("Alarm","EFEM Right Door Alarm"              ,boolset);
   // Maintenance Mode
   boolset = cbMaintenanceModeRed->Checked;
   pSystemFile->WriteBool("Alarm","Maintenance Mode Red"               ,boolset);
   boolset = cbMaintenanceModeAlarm->Checked;
   pSystemFile->WriteBool("Alarm","Maintenance Mode Alarm"             ,boolset);
   // Stage Door
   boolset = cbStageDoorRed->Checked;
   pSystemFile->WriteBool("Alarm","Stage Door Red"                     ,boolset);
   boolset = cbStageDoorAlarm->Checked;
   pSystemFile->WriteBool("Alarm","Stage Door Alarm"                   ,boolset);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2021 6 3 - chc Alarm
void __fastcall TMainForm::LoadAlarmParameter()
{
TIniFile *pSystemFile;
AnsiString fname;
bool boolset;

   // ini檔名與目錄: Alarm.ini
   fname = SystemDirectory + "\\Alarm.ini" ;
   pSystemFile = new TIniFile(fname);

   // PC Door
   boolset = pSystemFile->ReadBool("Alarm","PC Door Red"                        ,true);
   cbPCDoorRed->Checked = boolset;
   boolset = pSystemFile->ReadBool("Alarm","PC Door Alarm"                      ,false);
   cbPCDoorAlarm->Checked = boolset;
   // EFEM Left Door
   boolset = pSystemFile->ReadBool("Alarm","EFEM Left Door Red"                  ,true);
   cbEFEMLeftDoorRed->Checked = boolset;
   boolset = pSystemFile->ReadBool("Alarm","EFEM Left Door Alarm"                ,false);
   cbEFEMLeftDoorAlarm->Checked = boolset;
   // EFEM Right Door
   boolset = pSystemFile->ReadBool("Alarm","EFEM Right Door Red"                ,true);
   cbEFEMRightDoorRed->Checked = boolset;
   boolset = pSystemFile->ReadBool("Alarm","EFEM Right Door Alarm"              ,false);
   cbEFEMRightDoorAlarm->Checked = boolset;
   // Maintenance Mode
   boolset = pSystemFile->ReadBool("Alarm","Maintenance Mode Red"               ,true);
   cbMaintenanceModeRed->Checked = boolset;
   boolset = pSystemFile->ReadBool("Alarm","Maintenance Mode Alarm"             ,false);
   cbMaintenanceModeAlarm->Checked = boolset;
   // Stage Door
   boolset = pSystemFile->ReadBool("Alarm","Stage Door Red"                     ,true);
   cbStageDoorRed->Checked = boolset;
   boolset = pSystemFile->ReadBool("Alarm","Stage Door Alarm"                   ,false);
   cbStageDoorAlarm->Checked = boolset;

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2021 6 3 - chc Test Panel
void __fastcall TMainForm::btnTestClick(TObject *Sender)
{

   pnlTest->Visible = true;
   pnlTest->Left = 679;
   pnlTest->Top = 88;
}
//---------------------------------------------------------------------------
// 2021 6 3 - chc Test Panel
void __fastcall TMainForm::btnTestCloseClick(TObject *Sender)
{

   pnlTest->Visible = false;
}
//---------------------------------------------------------------------------
// 2021 6 3 - chc Test Panel
bool boolTestMove = false;
int TestX,TestY;
void __fastcall TMainForm::pnlTestMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolTestMove = true;
   TestX = X;
   TestY = Y;
}
//---------------------------------------------------------------------------
// 2021 6 3 - chc Test Panel
void __fastcall TMainForm::pnlTestMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{

   if(boolTestMove == true) {
      pnlTest->Left += (X - TestX);
      pnlTest->Top += (Y - TestY);
   }
}
//---------------------------------------------------------------------------
// 2021 6 3 - chc Test Panel
void __fastcall TMainForm::pnlTestMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolTestMove = false;
   TestX = X;
   TestY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRobotCLMPClick(TObject *Sender)
{

   if(rgRobotArm->ItemIndex == ROBOT_ARM_UP)
      edRobotCommand->Text = "CLMP(1)";
   else
      edRobotCommand->Text = "CLMP(2)";

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // Robot動作
   btnRobotSendClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnRobotUCLMClick(TObject *Sender)
{

   if(rgRobotArm->ItemIndex == ROBOT_ARM_UP)
      edRobotCommand->Text = "UCLM(1)";
   else
      edRobotCommand->Text = "UCLM(2)";

   // 2023 8 2 - chc 在btnRobotSendClick中做
   //AddRobotMessage(edRobotCommand->Text);

   // Robot動作
   btnRobotSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 6 11 - chc 管理者
void __fastcall TMainForm::pnlWidthValueClick(TObject *Sender)
{

   // 2021 10 27a - chc 要更新ItemIndex
   if(boolForTest == true) {

      // 2021 1 15 - chc 測試Robot Wafer
      // aTRB1.GPIO:00AC00E0/EE040241(Yes-Lower Arm)
      // aTRB1.GPIO:00A000E0/EE080241(No-Lower Arm)
      char dibuf[10];
      dibuf[0] = '0';
      dibuf[1] = '0';
      dibuf[2] = 'A';
      dibuf[3] = 'C';
      dibuf[4] = '0';
      dibuf[5] = '0';
      dibuf[6] = 'E';
      dibuf[7] = '0';
      int up,down;
      bool boolwithwaferup,boolwithwaferdown;
      for(int i=0 ; i<8 ; i++) {
         if(dibuf[i] >= '0' && dibuf[i] <= '9')
            dibuf[i] -= '0';
         else {
            dibuf[i] -= 'A';
            dibuf[i] += 10;
         }
      }
      // 8個4Bit(32bits), inBit8,9(Up Arm), inBit18,19(Down Arm)
      up = dibuf[7-8/4] & 0x03;
      if(up == 0x3)
         boolwithwaferup = true;
      else
         boolwithwaferup = false;

      down = dibuf[7-18/4] & 0x0c;
      if(down == 0x0c)
         boolwithwaferdown = true;
      return;

      cbRecipe->Text = "test_0005";
      int no;
      no = cbRecipe->Items->IndexOf(cbRecipe->Text);
      if(no >= 0)
         cbRecipe->ItemIndex = no;
      cbRecipeSelect(this);
   }

   if(PriorityLevel >= PRIORITY_AD) {
      pcSystem->Enabled = true;

      // 2021 6 16 - chc btnSystemRun Enable
      btnSystemRun->Enabled = true;

      // 2021 7 21 - chc 可做EFEM單操
      pcEFEMR->Enabled = true;
      tsAligner->Enabled = true;
      pnlRorzeAligner->Enabled = true;

      // 2021 8 24 - chc 啟動Start
      tsRun->Enabled = true;

      // 2021 10 21 - chc 啟動T & Z
      pnlMoveTCounterclockwise->Enabled = true;
      pnlMoveTClockwise->Enabled = true;
      pnlMoveLeft->Enabled = true;

      pcMotion->Enabled = true;

   }
}
//---------------------------------------------------------------------------
// 2021 6 16 - chc 頂Pin上升
void __fastcall TMainForm::tmPinLiftUpTimer(TObject *Sender)
{

   tmPinLiftUp->Enabled = false;
   WriteSystemLog("Robot放片: Stage Pin上升...");
   // L-Up
   btnDemoLFUpClick(this);
   if(boolLFUpState == false) {
      pnlRorzeRobotPut->Color = clRed;
      pnlSystemMessage->Caption = "Lift pin上升失敗!";
      WriteSystemLog("Robot放片: Stage Pin上升 Error!");
      return;
   }
   WriteSystemLog("Put: Stage Pin上升.");
}
//---------------------------------------------------------------------------
// 2021 6 16 - chc 頂Pin下降
void __fastcall TMainForm::tmPinLiftDownTimer(TObject *Sender)
{

   tmPinLiftDown->Enabled = false;
   // L下降
   WriteSystemLog("流程測試: Stage Pin到下位點...");
   // L-Down
   btnDemoLFDownClick(this);
   if(boolLFUpState == false) {
      pnlRorzeRobotGet->Color = clRed;
      pnlSystemMessage->Caption = "Lift pin下降失敗!";
      WriteSystemLog("Robot取片: Stage Pin到下位點 Error");
      return;
   }
   WriteSystemLog("Robot取片: Stage Pin到下位點.");
}
//---------------------------------------------------------------------------
// 2021 6 16 - chc 計算Die座標
void __fastcall TMainForm::ComputeRowCol(int x,int y,int *row,int *col)
{
int cx,cy,dx,dy,crow,ccol;

   crow = pnlCenterRow->Caption.ToInt();
   ccol = pnlCenterCol->Caption.ToInt();

   // 中
   // Die中心點在中心點上
   cx = pnlCenterXFind->Caption.ToInt();
   cy = pnlCenterYFind->Caption.ToInt();
   dx = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
   dy = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();

   *col = ccol - (x - cx) / dx;

   // 2021 9 27 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      *row = crow + (y - cy) / dy;
   }
   else

      *row = crow - (y - cy) / dy;

}
//---------------------------------------------------------------------------
// 2021 6 16 - chc 將量測點位Map到Wafer上
void __fastcall TMainForm::btnDotMapClick(TObject *Sender)
{
int no,x,y,row,col,cx,cy,w,h,srow,scol,dx,dy;
double fw,fh;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   no = sgArea->RowCount - 2;
   if(no <= 0) {
      pnlSystemMessage->Caption = "無點位資料!";
      return;
   }
   cx = sgArea->Cells[1][1].ToInt();
   cy = sgArea->Cells[2][1].ToInt();
   fw = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
   fh = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();
   // um to pulse
   fw = fw / X_RESOLUTION;
   fh = fh / Y_RESOLUTION;
   w = fw;
   h = fh;
   // 中心Die座標
   scol = pnlCenterCol->Caption.ToInt();
   srow = pnlCenterRow->Caption.ToInt();

   no = sgDot->RowCount - 2;
   for(int i=0 ; i<no ; i++) {
      x = sgDot->Cells[1][i+1].ToInt();
      y = sgDot->Cells[2][i+1].ToInt();
      dx = x - cx - w/2;
      dy = y - cy - h/2;
      col = scol - (dx / w);
      row = srow - (dy / h);

      // 2021 10 6 - chc 原點位置: GridNoY
      // 下: 180
      if(rgWaferDegree->ItemIndex == 2) {
         row = GridNoY - row - 1;
      }

      if(col < MAX_COL_NO && row < MAX_ROW_NO && col >= 0 && row >= 0) {
         sgDot->Cells[6][i+1] = IntToStr(row);
         sgDot->Cells[7][i+1] = IntToStr(col);
         MapCode[row][col] = 4;
      }
   }
   if(no > 0)
      DrawBigImage();

}
//---------------------------------------------------------------------------
// 2021 6 16 - chc 點位Map圖輸出
void __fastcall TMainForm::btnMapOutputClick(TObject *Sender)
{
AnsiString path,bmpfname,txtfname,datetime;
FILE *fp;
int ccol,crow,code,row,col;

   pnlSystemMessage->Caption = "輸出檔產生中...";
   // 1x
   tbZoom->Position = 1;
   sbWaferMap->VertScrollBar->Position = 0;
   sbWaferMap->HorzScrollBar->Position = 0;
   DrawBigImage();

   DateTimeToString(datetime,"yyyymmddhhnn",Now());
   path = ExportDirectory;
   bmpfname = path + "\\" + datetime + "-" + cbRecipe->Text + "-Map.bmp";
   txtfname = path + "\\" + datetime + "-" + cbRecipe->Text + "-Map.txt";
   imWaferMap->Picture->SaveToFile(bmpfname);

   if((fp = fopen(txtfname.c_str(),"w+t")) == NULL)
      return;
   crow = pnlCenterRow->Caption.ToInt();
   ccol = pnlCenterCol->Caption.ToInt();
   row = crow * 2 - 1;
   col = ccol * 2 - 1;
   code = 1;
   for(int i=0 ; i<row ; i++) {
      for(int j=0 ; j<col ; j++) {
         code = MapCode[i][j];
         fprintf(fp,"%d",code);
         if(j != col-1)
            fprintf(fp,",");
      }
      fprintf(fp,"\n");
   }
   fclose(fp);
   pnlSystemMessage->Caption = "輸出檔: " + txtfname + " 產生完成";
}
//---------------------------------------------------------------------------
// 2021 10 24 - chc 第一次呼叫InMeasure
//bool __fastcall TMainForm::InMeasure(int row,int col)
bool __fastcall TMainForm::InMeasure(int row,int col, bool first)
{
int no,r,c;

// 2021 10 7 - chc 由XY重產生
int x,y,cx,cy,w,h,srow,scol,dx,dy;
double fw,fh;

   // 2021 9 30 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      row = GridNoY - row - 1;

      // 2021 12 15 - chc 最小Row,Col
      col -= MinCol;
      row -= (GridNoY - MinRow - 1);

   }

   // 2021 10 7 - chc 由XY重產生
   cx = sgArea->Cells[1][1].ToInt();
   cy = sgArea->Cells[2][1].ToInt();
   fw = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
   fh = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();
   // um to pulse
   fw = fw / X_RESOLUTION;
   fh = fh / Y_RESOLUTION;
   w = fw;
   h = fh;
   // 中心Die座標
   scol = pnlCenterCol->Caption.ToInt();
   srow = pnlCenterRow->Caption.ToInt();

   no = sgDot->RowCount - 2;
   for(int i=0 ; i<no ; i++) {

      // 2021 10 7 - chc 由XY重產生
      // 2021 10 24 - chc (0,0)時才要變更
      if(first == false) {
         r = sgDot->Cells[6][i+1].ToInt();
         c = sgDot->Cells[7][i+1].ToInt();
      }
      else {

         x = sgDot->Cells[1][i+1].ToInt();
         y = sgDot->Cells[2][i+1].ToInt();
         dx = x - cx - w/2;
         dy = y - cy - h/2;
         c = scol - (dx / w);
         r = srow - (dy / h);
         // 下: 180
         if(rgWaferDegree->ItemIndex == 2) {
            r = GridNoY - r - 1;
         }
      }

      if(c < MAX_COL_NO && r < MAX_ROW_NO && c >= 0 && r >= 0) {

         // 2021 10 24 - chc (0,0)時才要變更
         if(first == true) {

            sgDot->Cells[6][i+1] = IntToStr(r);
            sgDot->Cells[7][i+1] = IntToStr(c);
         }
      }

      if(r == row && c == col) {
         return true;
      }

   }
   return false;
}
//---------------------------------------------------------------------------
// 2021 6 16 - chc 加註文字
void __fastcall TMainForm::cbFontDisplayClick(TObject *Sender)
{

   DrawBigImage();
}
//---------------------------------------------------------------------------
// 2021 6 16 - chc 位置
int MapX,MapY;
int MapAdjustX = 0;
int MapAdjustY = 0;
void __fastcall TMainForm::imWaferMapDblClick(TObject *Sender)
{
int x,y,col,row,dx,dy,w,h,scol,srow,cx,cy,rx,ry,cdx,cdy,nx,ny,ax,ay;
double fw,fh;
AnsiString msg;

   if(tbZoom->Position != 1) {
      pnlSystemMessage->Caption = "要在1X下才能做座標移動!";
      return;
   }
   // Mouse位置
   x = MapX;
   y = MapY;
   // 目前Die座標
   col = pnlColum->Caption.ToInt();
   row = pnlRow->Caption.ToInt();

   // 2021 8 11 - chc 指定點
   // 2021 10 6 - chc Table Die位置
   /*
   SelectRow = row;
   SelectCol = col;

   // 2021 10 4 - chc Select Row/Col
   pnlColumSelect->Caption = IntToStr(SelectCol);
   pnlRowSelect->Caption = IntToStr(SelectRow);
   */

//要考量傾斜角度 & Die的基準位置(中,左上....)
//=> 由中心Die計算
//void __fastcall TMainForm::GetAdjustXY(int mx, int my, int *nx,int *ny)

   // Die size: um
   fw = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
   fh = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();
   // um to pulse
   fw = fw / X_RESOLUTION;
   fh = fh / Y_RESOLUTION;
   w = fw;
   h = fh;
   // 中心Die座標
   scol = pnlCenterCol->Caption.ToInt();
   srow = pnlCenterRow->Caption.ToInt();
   // 實際中心點: Pulse
   rx = pnlCenterXFind->Caption.ToInt();
   ry = pnlCenterYFind->Caption.ToInt();
   // Recipe中心點: Pulse
   cx = sgArea->Cells[1][1].ToInt();
   cy = sgArea->Cells[2][1].ToInt();

   // 2021 10 15 - chc 檢查中心, 若是0則用指定: 設定的中心點
   if(rx == 0 && ry == 0) {
      rx = cx;
      ry = cy;
   }

   // 中心偏移量: pulse
   cdx = rx - cx;
   cdy = ry - cy;

   // 2021 10 7 - chc for test
   if(boolForTest == true) {
      cdx = 0;
      cdy = 0;
      rx = cx;
      ry = cy;
   }

   // 座標
   dx = cdx - (col - scol) * w;

   // 2021 9 27 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      dy = cdy + (row - srow) * h;
   }
   else

      dy = cdy - (row - srow) * h;

   // 2021 8 24 - chc 以Die中心來換算
   if(pnlWaferDieCenterX->Caption != "" && pnlWaferDieCenterX->Caption != "0") {
      rx = pnlWaferDieCenterX->Caption.ToInt();
      ry = pnlWaferDieCenterY->Caption.ToInt();
      ax = rx - (col - scol) * w;

      // 2021 10 7 - chc 未做180度校正
      // 下: 180
      if(rgWaferDegree->ItemIndex == 2)
         ay = ry + (row - srow) * h;
      else

         ay = ry - (row - srow) * h;

   }
   // 尚未做Die中心定義
   else {

      // Motion XY: (rx,ry)尋找中心位置
      nx = rx + dx;
      ny = ry + dy;

      if(cbMapAdjust->Checked == true) {
         ax = nx + MapAdjustX;
         ay = ny + MapAdjustY;
      }
      else {
         ax = nx;
         ay = ny;
      }
   }

   // 2021 8 24 - chc 角度校正
   // 2021 12 18 - chc 初始是中上, 不是中心
   /*
   // 左上
   if(rgWaferDieDirection->ItemIndex == 1) {
      ax += w/2;
      ay += h/2;
   }
   // 左下
   else if(rgWaferDieDirection->ItemIndex == 2) {
      ax += w/2;
      ay -= h/2;
   }
   // 右上
   else if(rgWaferDieDirection->ItemIndex == 3) {
      ax -= w/2;
      ay += h/2;
   }
   // 右下
   else if(rgWaferDieDirection->ItemIndex == 4) {
      ax -= w/2;
      ay -= h/2;
   }
   */
   // 中心
   if(rgWaferDieDirection->ItemIndex == 0) {
      ay -= h/2;
   }
   // 左上
   else if(rgWaferDieDirection->ItemIndex == 1) {
      ax += w/2;
      ay -= h/2;
   }
   // 左下
   else if(rgWaferDieDirection->ItemIndex == 2) {
      ax += w/2;
      ay += h/2;
   }
   // 右上
   else if(rgWaferDieDirection->ItemIndex == 3) {
      ax -= w/2;
      ay -= h/2;
   }
   // 右下
   else if(rgWaferDieDirection->ItemIndex == 4) {
      ax -= w/2;
      ay += h/2;
   }

   nx = ax;
   ny = ay;

   // 2021 10 26 - chc 分mode: 1-(col,row)to(X,Y), 2-(X,Y)to(col,row)
   //GetAdjustXY(nx, ny, &ax, &ay);
   GetAdjustXY(nx, ny, &ax, &ay,1);

   // 2021 8 23 - chc 有Motion才要做
   if(boolMotion == true) {

      // X/Y Axis absolute move
      msg.sprintf(" 確認移動到(col,row),(x,y),(x,y) : (%d,%d),(%d,%d),(%d,%d) ?      ",col,row,nx,ny,ax,ay);
      if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDYES) {
         //MoveToXY(nx,ny);
         // 2021 9 11 - chc 加速: MOVE_WAIT
         //MoveToXY(ax,ay);
         MoveToXY(ax,ay,MOVE_WAIT);

         // 2021 10 27 - chc 強制顯示Col,Row
         WaitTime(500);
         MapCode[row][col] = 4;
         SelectRow = row;
         SelectCol = col;
         // Select Row/Col
         pnlColumSelect->Caption = IntToStr(SelectCol);
         pnlRowSelect->Caption = IntToStr(SelectRow);
         DrawBigImage();

      }
   }

   // 2021 8 23 - chc 立即ReDraw
   DrawBigImage();

}
//---------------------------------------------------------------------------
//

void __fastcall TMainForm::imWaferMapMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   MapX = X;
   MapY = Y;
}
//---------------------------------------------------------------------------
// 2021 6 16 - chc 以第一點來校正座標
//int MapAdjustX = 0;
//int MapAdjustY = 0;
void __fastcall TMainForm::btnMapAdjustClick(TObject *Sender)
{
int x,y,col,row,dx,dy,w,h,scol,srow,cx,cy,rx,ry,cdx,cdy,nx,ny;
double fw,fh;
AnsiString msg;

   // 第1個量測點的Die座標
   row = sgDot->Cells[6][1].ToInt();
   col = sgDot->Cells[7][1].ToInt();
   // Die size: um
   fw = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
   fh = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();
   fw = fw / X_RESOLUTION;
   fh = fh / Y_RESOLUTION;
   w = fw;
   h = fh;
   // 中心Die座標
   scol = pnlCenterCol->Caption.ToInt();
   srow = pnlCenterRow->Caption.ToInt();
   // 實際中心點: Pulse
   rx = pnlCenterXFind->Caption.ToInt();
   ry = pnlCenterYFind->Caption.ToInt();
   // Recipe中心點: Pulse
   cx = sgArea->Cells[1][1].ToInt();
   cy = sgArea->Cells[2][1].ToInt();
   // 中心偏移量: pulse
   cdx = rx - cx;
   cdy = ry - cy;
   // 座標
   dx = cdx - (col - scol) * w;
   dy = cdy - (row - srow) * h;

   // Motion XY
   nx = rx + dx;
   ny = ry + dy;

   // 第1點的XY
   int px,py;
   px = sgDot->Cells[1][1].ToInt();
   py = sgDot->Cells[2][1].ToInt();
   MapAdjustX = px - nx;
   MapAdjustY = py - ny;

}
//---------------------------------------------------------------------------
// 2021 6 24 - chc License code
AnsiString __fastcall TMainForm::GetPasswordCode(AnsiString password)
{
AnsiString licensecode;

   WVCodeGenerate *GetLicenseCode = NULL;
   AnsiString LicenseCode;
   GetLicenseCode = new WVCodeGenerate();
   GetLicenseCode->SetCode(password);
   licensecode = GetLicenseCode->GetCode(0);
   return licensecode;
}
//---------------------------------------------------------------------------
// LP1 Lock
void __fastcall TMainForm::btnLoadPort1LockClick(TObject *Sender)
{
AnsiString smode;

   smode = "0";
   edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_UNLOCK_BIT) + "," + smode + ")";
   LoadPort1Cmd = "SPOT";
   btnLoadPort1SendClick(this);

   Sleep(100);

   smode = "1";
   edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_LOCK_BIT) + "," + smode + ")";
   LoadPort1Cmd = "SPOT";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPort1UnlockClick(TObject *Sender)
{

AnsiString smode;

   smode = "0";
   edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_LOCK_BIT) + "," + smode + ")";
   LoadPort1Cmd = "SPOT";
   btnLoadPort1SendClick(this);

   Sleep(100);

   smode = "1";
   edLoadPort1Command->Text = "SPOT(" + IntToStr(LOADPORT_UNLOCK_BIT) + "," + smode + ")";
   LoadPort1Cmd = "SPOT";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------

// 2021 6 24 - chc 寫入Recipe Name: 切換時就寫入更新
void __fastcall TMainForm::SaveRecipeName()
{
TIniFile *pSystemFile;

   pSystemFile = new TIniFile(SystemINIFilename);
   RecipeName = cbType->Text;
   pSystemFile->WriteString("System Parameter",RECIPE_NAME                   ,RecipeName);
   pSystemFile->UpdateFile();

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2021 6 30 - chc Carrier CLMP: Docking
void __fastcall TMainForm::btnLoadPort1CarrierDockClick(TObject *Sender)
{

   // CLMP
   edLoadPort1Command->Text = "CLMP(A)";
   LoadPort1Cmd = "CLMP(A)";
   btnLoadPort1SendClick(this);

}
//---------------------------------------------------------------------------
// 2021 6 30 - chc Carrier UCLM: UnDocking
void __fastcall TMainForm::btnLoadPort1CarrierUnDockClick(TObject *Sender)
{

   // UCLM
   edLoadPort1Command->Text = "UCLM(A)";
   LoadPort1Cmd = "UCLM";
   btnLoadPort1SendClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPort2LockClick(TObject *Sender)
{
AnsiString smode;

   smode = "0";
   edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_UNLOCK_BIT) + "," + smode + ")";
   LoadPort2Cmd = "SPOT";
   btnLoadPort2SendClick(this);

   Sleep(100);

   smode = "1";
   edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_LOCK_BIT) + "," + smode + ")";
   LoadPort2Cmd = "SPOT";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPort2UnlockClick(TObject *Sender)
{
AnsiString smode;

   smode = "0";
   edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_LOCK_BIT) + "," + smode + ")";
   LoadPort2Cmd = "SPOT";
   btnLoadPort2SendClick(this);

   Sleep(100);

   smode = "1";
   edLoadPort2Command->Text = "SPOT(" + IntToStr(LOADPORT_UNLOCK_BIT) + "," + smode + ")";
   LoadPort2Cmd = "SPOT";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPort2CarrierDockClick(TObject *Sender)
{

   // CLMP: Docking
   edLoadPort2Command->Text = "CLMP(A)";
   LoadPort2Cmd = "CLMP(A)";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPort2CarrierUnDockClick(TObject *Sender)
{

   // UCLM: UnDocking
   edLoadPort2Command->Text = "UCLM(A)";
   LoadPort2Cmd = "UCLM";
   btnLoadPort2SendClick(this);
}
//---------------------------------------------------------------------------
// 2021 6 30 - chc Aligner GPRS
void __fastcall TMainForm::btnAlignerGPRSClick(TObject *Sender)
{

   WriteSystemLog("btnAlignerGPRSClick...");
   edAlignerCommand->Text = "GPRS";
   AlignerCmd = "GPRS";
   btnAlignerSendClick(this);
}
//---------------------------------------------------------------------------
// 2021 6 30a - chc
void __fastcall TMainForm::btnAlignerCrashClick(TObject *Sender)
{

   // DPRS.STDT[1]=500
   // Aligner Vacuum 變化量超過500mpa

   edAlignerCommand->Text = "DPRS.STDT[1]=500";
   AlignerCmd = "DPRS.STDT[5]";
   btnAlignerSendClick(this);
   WaitDelayTime(1000);

   edAlignerCommand->Text = "EVNT(5,1)";
   AlignerCmd = "EVNT";
   btnAlignerSendClick(this);
   WaitDelayTime(1000);

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnAllCancelClick(TObject *Sender)
{
TPanel *panel,*panel1;

   for(int i=1 ; i<=25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i)));
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
      if(panel->Color == clLime)
         panel1->Color = clSilver;
      else
         panel1->Color = clGray;
   }

   // 2021 7 17 -  chc 記錄為Load後的第一片
   boolFirstAfterLoad = true;
   
}
//---------------------------------------------------------------------------
// 2021 7 17 - chc for test
void __fastcall TMainForm::Panel129Click(TObject *Sender)
{
TPanel *panel,*panel1;

   if(boolForTest == false)
      return;
   pnlCassetteStatus->Enabled = true;
   for(int i=1 ; i<=25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i)));
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
      if((i % 2) == 0) {
         panel->Color = clLime;
         panel1->Color = clLime;
         panel1->Enabled = true;
      }
      else {
         panel->Color = clSilver;
         panel1->Color = clSilver;
      }
   }
   btnLoadWafer->Enabled = true;
   // 記錄為Load後的第一片
   boolFirstAfterLoad = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmAlatmTimer(TObject *Sender)
{

   tmAlatm->Enabled = false;

   // 2021 9 25 - chc 在Load/UnLoad/Measure中不可以取消
   if(boolInLoad == false && boolInUnLoad == false && boolInMeasureRun == false)

      pnlMoving->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::rgWaferDegreeClick(TObject *Sender)
{

   // 2021 7 22 - chc update
   rgWaferOrientation->ItemIndex = rgWaferDegree->ItemIndex;
}
//---------------------------------------------------------------------------
// 2021 8 3 - chc LP2 - Parameter: Min/Max Thickness
//int LP2DPRMStep = 0;
void __fastcall TMainForm::btnLoadPort2DPRMClick(TObject *Sender)
{

   btnLoadPort2DPRM->Enabled = false;
   LP2DPRMStep = 1;
   tmLP2DPRM->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 8 3 - chc LP2 - Parameter: Min/Max Thickness: LP2DPRMStep
void __fastcall TMainForm::tmLP2DPRMTimer(TObject *Sender)
{

   // Min
   if(LP2DPRMStep == 1) {
      tmLP2DPRM->Enabled = false;
      LP2DPRMStep++;
      edLoadPort2Command->Text = "DPRM.GTDT[0][5]";
      LoadPort2Cmd = "DPRM";
      btnLoadPort2SendClick(this);
      tmLP2DPRM->Enabled = true;
   }
   // Max
   else if(LP2DPRMStep == 3) {
      tmLP2DPRM->Enabled = false;
      LP2DPRMStep++;
      edLoadPort2Command->Text = "DPRM.GTDT[0][6]";
      LoadPort2Cmd = "DPRM";
      btnLoadPort2SendClick(this);
      tmLP2DPRM->Enabled = true;
   }
   else if(LP2DPRMStep >= 5) {
      LP2DPRMStep = 0;
      tmLP2DPRM->Enabled = false;
      btnLoadPort2DPRM->Enabled = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmLP1DPRMTimer(TObject *Sender)
{

   // Min
   if(LP1DPRMStep == 1) {
      tmLP1DPRM->Enabled = false;
      LP1DPRMStep++;
      edLoadPort1Command->Text = "DPRM.GTDT[0][5]";
      LoadPort1Cmd = "DPRM";
      btnLoadPort1SendClick(this);
      tmLP1DPRM->Enabled = true;
   }
   // Max
   else if(LP1DPRMStep == 3) {
      tmLP1DPRM->Enabled = false;
      LP1DPRMStep++;
      edLoadPort1Command->Text = "DPRM.GTDT[0][6]";
      LoadPort1Cmd = "DPRM";
      btnLoadPort1SendClick(this);
      tmLP1DPRM->Enabled = true;
   }
   else if(LP1DPRMStep >= 5) {
      LP1DPRMStep = 0;
      tmLP1DPRM->Enabled = false;
      btnLoadPort1DPRM->Enabled = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnLoadPort1DPRMClick(TObject *Sender)
{

   btnLoadPort1DPRM->Enabled = false;
   LP1DPRMStep = 1;
   tmLP1DPRM->Enabled = true;
}
//---------------------------------------------------------------------------
// pnlCenterXFind, pnlCenterYFind
// pnlWaferPositionCol, pnlWaferPositionRow
void __fastcall TMainForm::btnWaferPositionClick(TObject *Sender)
{
int row,col,dx,dy,sx,sy,x,y,w,h,cx,cy,factor;
int rcx,rcy,scol,srow;
double fdx,fdy,fw,fh;
AnsiString msg;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   pnlWaferPositionCol->Caption = "";
   pnlWaferPositionRow->Caption = "";
   btnWaferPosition->Enabled = false;

   // Recipe Wafer中心點 => 未用到
   rcx = sgArea->Cells[1][1].ToInt();
   rcy = sgArea->Cells[2][1].ToInt();

   // um
   fdx = edWaferPositionX->Text.ToDouble();
   fdy = edWaferPositionY->Text.ToDouble();
   // um => pulse
   fdx /= X_RESOLUTION;
   fdy /= Y_RESOLUTION;
   dx = fdx;
   dy = fdy;
   // pulse
   cx = pnlCenterXFind->Caption.ToInt();
   cy = pnlCenterYFind->Caption.ToInt();
   // 右: +, 上: +
   x = cx - dx;
   y = cy + dy;

   // 2021 8 24 - chc 未計算w,h - 相為於Wafer中心的移動量
   w = abs(dx);
   h = abs(dy);

   // 不在設定中, 要補償
   if(cbWaferDefine->Checked == false) {
      int x1,y1,x2,y2,x3,y3,x4,y4,dx,dy,value;
      double fvalue;
      x1 = pnlWaferPosition1X->Caption.ToInt();
      y1 = pnlWaferPosition1Y->Caption.ToInt();
      x2 = pnlWaferPosition2X->Caption.ToInt();
      y2 = pnlWaferPosition2Y->Caption.ToInt();
      fvalue = 1;
      // X
      if(dx < 0) {
         if(x2 < x1) {
            dx = x1 - x2;
            dy = y2 - y1;
            if(dx > 0)
               fvalue = double(w * dy) / dx;
         }
         else {
            dx = x2 - x1;
            dy = y1 - y2;
            if(dx > 0)
               fvalue = double(w * dy) / dx;
         }
      }
      else {
         if(x2 < x1) {
            dx = x1 - x2;
            dy = y1 - y2;
            if(dx > 0)
               fvalue = double(w * dy) / dx;
         }
         else {
            dx = x2 - x1;
            dy = y2 - y1;
            if(dx > 0)
               fvalue = double(w * dy) / dx;
         }
      }
      y += fvalue;
      // Y
      if(dy > 0) {
         if(y3 < y4) {
            dx = x4 - x3;
            dy = y4 - y3;
            if(dy > 0)
               fvalue = double(h * dx) / dy;
         }
         else {
            dx = x3 - x4;
            dy = y3 - y4;
            if(dx > 0)
               fvalue = double(h * dx) / dy;
         }
      }
      else {
         if(y3 < y4) {
            dx = x3 - x4;
            dy = y4 - y3;
            if(dy > 0)
               fvalue = double(h * dx) / dy;
         }
         else {
            dx = x4 - x3;
            dy = y3 - y4;
            if(dx > 0)
               fvalue = double(h * dx) / dy;
         }
      }
      x += fvalue;
   }

   // Move to
   msg.sprintf(" 確認移動到(x,y),(cx,cy) : (%d,%d),(%d,%d) ?      ",x,y,cx,cy);
   if(Application->MessageBox(msg.c_str(), "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDYES) {

      // 2021 8 10 - chc 禁用Motion
      pcSystem->Enabled = false;

      // 2021 8 23 - chc 有Motion才要做
      if(boolMotion == true)

         // 2021 9 11 - chc 加速: MOVE_WAIT
         //MoveToXY(x,y);
         MoveToXY(x,y,MOVE_WAIT);

      // 2021 8 10 - chc 禁用Motion
      pcSystem->Enabled = true;

   }

   // to (col,row)
   fw = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
   fh = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();
   // um to pulse
   fw = fw / X_RESOLUTION;
   fh = fh / Y_RESOLUTION;
   w = fw;
   h = fh;
   // 中心Die座標
   scol = pnlCenterCol->Caption.ToInt();
   srow = pnlCenterRow->Caption.ToInt();
   // x,y => col,row
   if(dx > 0) {
      dx = dx - w/2;
      col = scol + (dx / w);
   }
   else {
      dx = (0 - dx) - w/2;
      col = scol - (dx / w);
   }
   if(dy > 0) {
      dy = dy - h/2;
      row = srow - (dy / h);
   }
   else {
      dy = (0 - dy) - h/2;
      row = srow + (dy / h);
   }
   pnlWaferPositionCol->Caption = IntToStr(col);
   pnlWaferPositionRow->Caption = IntToStr(row);

   // 2021 8 11 - chc 指定點
   // 2021 10 6 - chc Table Die位置, 與Go無關
   //SelectRow = row;
   //SelectCol = col;

   btnWaferPosition->Enabled = true;

}
//---------------------------------------------------------------------------
// 2021 8 4 - chc 設定第1點
void __fastcall TMainForm::btnWaferPositinoX1Click(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   pnlWaferPosition1X->Caption = edCounterX->Text;
   pnlWaferPosition1Y->Caption = edCounterY->Text;
}
//---------------------------------------------------------------------------
// 2021 8 4 - chc 設定第2點
void __fastcall TMainForm::btnWaferPositinoX2Click(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   pnlWaferPosition2X->Caption = edCounterX->Text;
   pnlWaferPosition2Y->Caption = edCounterY->Text;
}
//---------------------------------------------------------------------------
// 2021 8 4 - chc 設定第3點
void __fastcall TMainForm::btnWaferPositinoY1Click(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   pnlWaferPosition3X->Caption = edCounterX->Text;
   pnlWaferPosition3Y->Caption = edCounterY->Text;
}
//---------------------------------------------------------------------------
// 2021 8 4 - chc 設定第4點
void __fastcall TMainForm::btnWaferPositinoY2Click(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   pnlWaferPosition4X->Caption = edCounterX->Text;
   pnlWaferPosition4Y->Caption = edCounterY->Text;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnWaferMoveLeftClick(TObject *Sender)
{
int x,y,w,h;
double fw,fh;

   gbWaferPosition->Enabled = false;

   fw = edDieSizeX->Text.ToDouble();
   fw += edDieSizeGapX->Text.ToDouble();
   fw /= X_RESOLUTION;

   double ratio;
   if(combDieNo->ItemIndex == 0)
      ratio = 0.5;
   else if(combDieNo->ItemIndex == 1)
      ratio = 1.0;
   else if(combDieNo->ItemIndex == 2)
      ratio = 2.0;
   else if(combDieNo->ItemIndex == 3)
      ratio = 5.0;
   else
      ratio = 10.0;
   fw *= ratio;

   w = fw;
   // pulse
   x = edCounterX->Text.ToInt();
   y = edCounterY->Text.ToInt();
   x += w;

   // 不在設定中, 要補償
   if(cbWaferDefine->Checked == false) {
     int x1,y1,x2,y2,dx,dy,value;
     double fdx,fdy,fvalue;
     x1 = pnlWaferPosition1X->Caption.ToInt();
     y1 = pnlWaferPosition1Y->Caption.ToInt();
     x2 = pnlWaferPosition2X->Caption.ToInt();
     y2 = pnlWaferPosition2Y->Caption.ToInt();
     fvalue = 1;
     if(x2 < x1) {
        dx = x1 - x2;
        dy = y1 - y2;
        if(dx > 0)
           fvalue = double(w * dy) / dx;
     }
     else {
        dx = x2 - x1;
        dy = y2 - y1;
        if(dx > 0)
           fvalue = double(w * dy) / dx;
     }
     y += fvalue;
   }

   // Move to
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   gbWaferPosition->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnWaferMoveRearClick(TObject *Sender)
{
int x,y,w,h;
double fw,fh;

   gbWaferPosition->Enabled = false;

   fh = edDieSizeY->Text.ToDouble();
   fh += edDieSizeGapY->Text.ToDouble();
   fh /= Y_RESOLUTION;

   double ratio;
   if(combDieNo->ItemIndex == 0)
      ratio = 0.5;
   else if(combDieNo->ItemIndex == 1)
      ratio = 1.0;
   else if(combDieNo->ItemIndex == 2)
      ratio = 2.0;
   else if(combDieNo->ItemIndex == 3)
      ratio = 5.0;
   else
      ratio = 10.0;
   fh *= ratio;

   h = fh;
   // pulse
   x = edCounterX->Text.ToInt();
   y = edCounterY->Text.ToInt();
   y += h;

   // 不在設定中, 要補償
   if(cbWaferDefine->Checked == false) {
     int x3,y3,x4,y4,dx,dy,value;
     double fdx,fdy,fvalue;
     x3 = pnlWaferPosition3X->Caption.ToInt();
     y3 = pnlWaferPosition3Y->Caption.ToInt();
     x4 = pnlWaferPosition4X->Caption.ToInt();
     y4 = pnlWaferPosition4Y->Caption.ToInt();
     fvalue = 1;
     if(y3 < y4) {
        dx = x4 - x3;
        dy = y4 - y3;
        if(dy > 0)
           fvalue = double(h * dx) / dy;
     }
     else {
        dx = x3 - x4;
        dy = y3 - y4;
        if(dy > 0)
           fvalue = double(h * dx) / dy;
     }
     x += fvalue;
   }

   // Move to
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   gbWaferPosition->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnWaferMoveCenterClick(TObject *Sender)
{
int x,y;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   gbWaferPosition->Enabled = false;

   // pulse
   x = pnlCenterXFind->Caption.ToInt();
   y = pnlCenterYFind->Caption.ToInt();

   // Move to
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   gbWaferPosition->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnWaferMoveRightClick(TObject *Sender)
{
int x,y,w,h;
double fw,fh;

   gbWaferPosition->Enabled = false;

   fw = edDieSizeX->Text.ToDouble();
   fw += edDieSizeGapX->Text.ToDouble();
   fw /= X_RESOLUTION;

   double ratio;
   if(combDieNo->ItemIndex == 0)
      ratio = 0.5;
   else if(combDieNo->ItemIndex == 1)
      ratio = 1.0;
   else if(combDieNo->ItemIndex == 2)
      ratio = 2.0;
   else if(combDieNo->ItemIndex == 3)
      ratio = 5.0;
   else
      ratio = 10.0;
   fw *= ratio;

   w = fw;
   // pulse
   x = edCounterX->Text.ToInt();
   y = edCounterY->Text.ToInt();
   x -= w;

   // 不在設定中, 要補償
   if(cbWaferDefine->Checked == false) {
     int x1,y1,x2,y2,dx,dy,value;
     double fdx,fdy,fvalue;
     x1 = pnlWaferPosition1X->Caption.ToInt();
     y1 = pnlWaferPosition1Y->Caption.ToInt();
     x2 = pnlWaferPosition2X->Caption.ToInt();
     y2 = pnlWaferPosition2Y->Caption.ToInt();
     fvalue = 1;
     if(x2 < x1) {
        dx = x1 - x2;
        dy = y2 - y1;
        if(dx > 0)
           fvalue = double(w * dy) / dx;
     }
     else {
        dx = x2 - x1;
        dy = y1 - y2;
        if(dx > 0)
           fvalue = double(w * dy) / dx;
     }
     y += fvalue;
   }

   // Move to
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   gbWaferPosition->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnWaferMoveFrontClick(TObject *Sender)
{
int x,y,w,h;
double fw,fh;

   gbWaferPosition->Enabled = false;

   fh = edDieSizeY->Text.ToDouble();
   fh += edDieSizeGapY->Text.ToDouble();
   fh /= Y_RESOLUTION;

   double ratio;
   if(combDieNo->ItemIndex == 0)
      ratio = 0.5;
   else if(combDieNo->ItemIndex == 1)
      ratio = 1.0;
   else if(combDieNo->ItemIndex == 2)
      ratio = 2.0;
   else if(combDieNo->ItemIndex == 3)
      ratio = 5.0;
   else
      ratio = 10.0;
   fh *= ratio;

   h = fh;
   // pulse
   x = edCounterX->Text.ToInt();
   y = edCounterY->Text.ToInt();
   y -= h;

   // 不在設定中, 要補償
   if(cbWaferDefine->Checked == false) {
     int x3,y3,x4,y4,dx,dy,value;
     double fdx,fdy,fvalue;
     x3 = pnlWaferPosition3X->Caption.ToInt();
     y3 = pnlWaferPosition3Y->Caption.ToInt();
     x4 = pnlWaferPosition4X->Caption.ToInt();
     y4 = pnlWaferPosition4Y->Caption.ToInt();
     fvalue = 1;
     if(y3 < y4) {
        dx = x3 - x4;
        dy = y4 - y3;
        if(dy > 0)
           fvalue = double(h * dx) / dy;
     }
     else {
        dx = x4 - x3;
        dy = y3 - y4;
        if(dy > 0)
           fvalue = double(h * dx) / dy;
     }
     x += fvalue;
   }

   // Move to
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   gbWaferPosition->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 8 4 - chc 計算Wafer角度
void __fastcall TMainForm::btnWaferDegreeClick(TObject *Sender)
{
double degreex,degreey,fdx,fdy;
int p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y;
AnsiString msg;

   // 2021 8 9 - chc for test
   if(boolForTest == true) {
      pnlWaferPosition1X->Caption = "2711806";
      pnlWaferPosition1Y->Caption = "1541825";
      pnlWaferPosition2X->Caption = "2641996";
      pnlWaferPosition2Y->Caption = "1543102";
      pnlWaferPosition3X->Caption = "2713538";
      pnlWaferPosition3Y->Caption = "1546746";
      pnlWaferPosition4X->Caption = "2714439";
      pnlWaferPosition4Y->Caption = "1596816";
   }

   p1x = pnlWaferPosition1X->Caption.ToInt();
   p1y = pnlWaferPosition1Y->Caption.ToInt();
   p2x = pnlWaferPosition2X->Caption.ToInt();
   p2y = pnlWaferPosition2Y->Caption.ToInt();
   p3x = pnlWaferPosition3X->Caption.ToInt();
   p3y = pnlWaferPosition3Y->Caption.ToInt();
   p4x = pnlWaferPosition4X->Caption.ToInt();
   p4y = pnlWaferPosition4Y->Caption.ToInt();

   // X
   fdx = abs(p2x - p1x);
   fdy = abs(p2y - p1y);

   // 2021 9 8c - chc 是fdx才對
   //if(fdy == 0) {
   if(fdx == 0) {

      degreex = 0;
   }
   else {
      degreex = atan(fdy / fdx);
      degreex = (360 * degreex) / (2*M_PI);
   }
   if(fdy < 0)
      degreex = 0 - degreex;
   msg.sprintf("%.4f",degreex);
   pnlWaferDegreeX->Caption = msg;

   // Y
   fdx = abs(p4x - p3x);
   fdy = abs(p4y - p3y);

   // 2021 9 8c - chc 是fdy才對
   //if(fdx == 0) {
   if(fdy == 0) {

      degreey = 0;
   }
   else {
      degreey = atan(fdx / fdy);
      degreey = (360 * degreey) / (2*M_PI);
   }
   if(fdx < 0)
      degreex = 0 - degreex;
   msg.sprintf("%.4f",degreey);
   pnlWaferDegreeY->Caption = msg;

   // 中心Die位置: pnlWaferDieCenterX/pnlWaferDieCenterY
   double fh,fw;
   int w,h;
   fh = edDieSizeY->Text.ToDouble();
   fw = edDieSizeX->Text.ToDouble();
   fh /= Y_RESOLUTION;
   fw /= X_RESOLUTION;
   w = fw / 2;
   h = fh / 2;
   pnlWaferDieCenterX->Caption = pnlWaferPosition3X->Caption.ToInt() - w;
   pnlWaferDieCenterY->Caption = pnlWaferPosition1Y->Caption.ToInt() + h;

   // 2021 8 24 - chc 計算Col,Row: CenterDieCol,CenterDieRow
   int x,y;
   x = pnlWaferDieCenterX->Caption.ToInt();
   y = pnlWaferDieCenterY->Caption.ToInt();

   // 2021 9 8c - chc 要檢查Wafer.Dx, Wafer.Dx(有做過"產生Map"才有值)
   if(Wafer.Dx > 0)
      CenterDieCol = (x - COffsetX - Wafer.X) / Wafer.Dx;
   if(Wafer.Dy > 0) {
      CenterDieRow = (y - COffsetY - Wafer.Y) / Wafer.Dy;

      // 2021 9 27 - chc 原點位置: GridNoY
      // 下: 180
      if(rgWaferDegree->ItemIndex == 2) {
         CenterDieRow = GridNoY - CenterDieRow - 1;
      }

   }

   // 2021 8 24 - chc 立即ReDraw, 在DrawBigInmage()會再重計算CenterDieCol,CenterDieRow
   DrawBigImage();

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::cbAlignerActiveClick(TObject *Sender)
{

   // 2021 8 9 - chc 不做
   //csAlignerSocket->Active = cbAlignerActive->Checked;

   // 要Disable Aligner Status
   if(cbAlignerActive->Checked == false) {
      pnlAlignerSocketConnect->Color = clSilver;
      // 若為True則要等eTRB1.CNCT(一開機時也要等 - Robot Connect)
      btnRorzeAlignerORGN->Enabled = false;

      // Disable Robot Socket
      // 2021 8 9 - chc 改用Close
      //csAlignerSocket->Active = false;
      csAlignerSocket->Close();

   }
   // Enable Aligner Socket
   else {
      csAlignerSocket->Active = true;
      // 恢復
      btnRorzeAlignerORGN->Enabled = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::cbLoadPort2ActiveClick(TObject *Sender)
{

   // 2021 8 9 - chc 改用Close
   //csLoadPort2Socket->Active = cbLoadPort2Active->Checked;

   // 要Disable LoadPort2 Status
   if(cbLoadPort2Active->Checked == false) {
      pnlLoadPort2SocketConnect->Color = clSilver;
      // 若為True則要等eTRB1.CNCT(一開機時也要等 - Robot Connect)
      btnLoadPort2ORGN->Enabled = false;

      // Disable Robot Socket
      // 2021 8 9 - chc 改用Close
      //csLoadPort2Socket->Active = false;
      csLoadPort2Socket->Close();

   }
   // Enable LoadPort2 Socket
   else {
      csLoadPort2Socket->Active = true;
      // 恢復
      btnLoadPort2ORGN->Enabled = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::cbLoadPort1ActiveClick(TObject *Sender)
{

   // 2021 8 9 - chc 改用Close
   //csLoadPort1Socket->Active = cbLoadPort1Active->Checked;

   // 要Disable LoadPort1 Status
   if(cbLoadPort1Active->Checked == false) {
      pnlLoadPort1SocketConnect->Color = clSilver;
      // 若為True則要等eTRB1.CNCT(一開機時也要等 - Robot Connect)
      btnLoadPort1ORGN->Enabled = false;

      // Disable Robot Socket
      // 2021 8 9 - chc 改用Close
      //csLoadPort1Socket->Active = false;
      csLoadPort1Socket->Close();

   }
   // Enable LoadPort1 Socket
   else {
      csLoadPort1Socket->Active = true;
      // 恢復
      btnLoadPort1ORGN->Enabled = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::btnDieCenterClick(TObject *Sender)
{
int x,y;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   btnDieCenter->Enabled = false;

   // 2021 8 10 - chc 禁用Motion
   pcSystem->Enabled = false;

   x = pnlWaferDieCenterX->Caption.ToInt();
   y = pnlWaferDieCenterY->Caption.ToInt();

   // Move to
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   btnDieCenter->Enabled = true;

   // 2021 8 10 - chc 禁用Motion
   pcSystem->Enabled = true;

}
//---------------------------------------------------------------------------
// 2021 8 10 - chc 移到Wafer中心點
void __fastcall TMainForm::btnToWaferCenterClick(TObject *Sender)
{
int x,y;

   btnToWaferCenter->Enabled = false;
   pcSystem->Enabled = false;

   x = pnlCenterXFind->Caption.ToInt();
   y = pnlCenterYFind->Caption.ToInt();

   // Move to
   // 2021 9 11 - chc 加速: MOVE_WAIT
   //MoveToXY(x,y);
   MoveToXY(x,y,MOVE_WAIT);

   btnToWaferCenter->Enabled = true;
   pcSystem->Enabled = true;
}
//---------------------------------------------------------------------------
// 2021 8 11 - chc 指定點
bool __fastcall TMainForm::InSelect(int row,int col)
{

   // 2021 9 30 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      row = GridNoY - row - 1;

      // 2021 12 15 - chc 最小Row,Col
      col -= MinCol;
      row -= (GridNoY - MinRow - 1);

   }

   if(SelectRow == -1 || SelectCol == -1)
      return false;
   if(SelectRow == row && SelectCol == col)
      return true;
}
//---------------------------------------------------------------------------
// 2021 8 23 - chc Center Die
bool __fastcall TMainForm::InCenterDie(int row,int col)
{
// 2021 12 15 - chc 最小Row,Col
int r,c;

//return false;

   // 2021 12 15 - chc 最小Row,Col
   c = col;
   r = row;

   // 2021 9 30 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {

      // 2021 12 15 - chc 最小Row,Col
      //row = GridNoY - row - 1;
      r = GridNoY - row - 1;

      // 2021 12 15 - chc 最小Row,Col
      //col -= MinCol;
      //row -= (GridNoY - MinRow - 1);
      c -= MinCol;
      r -= (GridNoY - MinRow - 1);

   }

   if(CenterDieRow == -1 || CenterDieCol == -1)
      return false;

   // 2021 12 15 - chc 最小Row,Col
   //if(CenterDieRow == row && CenterDieCol == col)
   if(CenterDieRow == r && CenterDieCol == c)

      return true;
}
//---------------------------------------------------------------------------
// 2021 12 15 - chc 最小Row,Col
bool __fastcall TMainForm::InCenterDie1(int row,int col)
{
int no;

   // 2021 9 30 - chc 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      row = GridNoY - row - 1;
      col -= MinCol;
      row -= (GridNoY - MinRow - 1);
   }

   if(CenterDieRow == -1 || CenterDieCol == -1)
      return false;

   if(CenterDieRow == row && CenterDieCol == col) {

      no = 1;

      return true;
   }
}
//---------------------------------------------------------------------------
// mx,my: pulse
// 2021 10 26 - chc 分mode: 1-(col,row)to(X,Y), 2-(X,Y)to(col,row)
//void __fastcall TMainForm::GetAdjustXY(int mx, int my, int *nx,int *ny)
void __fastcall TMainForm::GetAdjustXY(int mx, int my, int *nx,int *ny,int mode)
{
int x,y,w,h,dx,dy,cx,cy;
double fw,fh;

   // pulse: 中心Die
   cx = pnlWaferDieCenterX->Caption.ToInt();
   cy = pnlWaferDieCenterY->Caption.ToInt();

   // 2021 10 26 - chc 瑞尚未設中心則不用做
   if(cx == 0 && cy == 0)
      return;

   // 右: +, 上: +
   dx = cx - mx;
   dy = my - cy;
   x = mx;
   y = my;
   // 計算w,h - 相對於Wafer中心的移動量
   w = abs(dx);
   h = abs(dy);
   {
      int x1,y1,x2,y2,x3,y3,x4,y4,dx,dy,value;
      double fvalue;
      x1 = pnlWaferPosition1X->Caption.ToInt();
      y1 = pnlWaferPosition1Y->Caption.ToInt();
      x2 = pnlWaferPosition2X->Caption.ToInt();
      y2 = pnlWaferPosition2Y->Caption.ToInt();
      fvalue = 1;
      // X
      if(dx < 0) {
         if(x2 < x1) {
            dx = x1 - x2;
            dy = y2 - y1;
            if(dx > 0)
               fvalue = double(w * dy) / dx;
         }
         else {
            dx = x2 - x1;
            dy = y1 - y2;
            if(dx > 0)
               fvalue = double(w * dy) / dx;
         }
      }
      else {
         if(x2 < x1) {
            dx = x1 - x2;
            dy = y1 - y2;
            if(dx > 0)
               fvalue = double(w * dy) / dx;
         }
         else {
            dx = x2 - x1;
            dy = y2 - y1;
            if(dx > 0)
               fvalue = double(w * dy) / dx;
         }
      }

      // 2021 10 26 - chc 分mode: 1-(col,row)to(X,Y), 2-(X,Y)to(col,row)
      if(mode == 2)
         y -= fvalue;
      else

         y += fvalue;
      // Y
      if(dy > 0) {
         if(y3 < y4) {
            dx = x4 - x3;
            dy = y4 - y3;
            if(dy > 0)
               fvalue = double(h * dx) / dy;
         }
         else {
            dx = x3 - x4;
            dy = y3 - y4;
            if(dx > 0)
               fvalue = double(h * dx) / dy;
         }
      }
      else {
         if(y3 < y4) {
            dx = x3 - x4;
            dy = y4 - y3;
            if(dy > 0)
               fvalue = double(h * dx) / dy;
         }
         else {
            dx = x4 - x3;
            dy = y3 - y4;
            if(dx > 0)
               fvalue = double(h * dx) / dy;
         }
      }

      // 2021 10 26 - chc 分mode: 1-(col,row)to(X,Y), 2-(X,Y)to(col,row)
      if(mode == 2)
         x -= fvalue;
      else

         x += fvalue;
   }
   *nx = x;
   *ny = y;
}
//---------------------------------------------------------------------------
// 2021 8 27 - chc 修正總點數
void __fastcall TMainForm::rgYuanliPointClick(TObject *Sender)
{

   edTotalPoint->Text = IntToStr(rgYuanliPoint->ItemIndex + 1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmDecodeSECSTimer(TObject *Sender)
{

   tmDecodeSECS->Enabled = false;
   DecodeSECS(DecodeSCMD,DecodeSPAR,DecodePARCNT,1);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmDoLoadUnloadTimer(TObject *Sender)
{

   tmDoLoadUnload->Enabled = false;
   WriteSystemLog("Timer SECS處理Load...");
   if(rgLoadPortSelect->ItemIndex == LOADPORT_1)
      btnLoadPort1CLMPClick(this);
   else
      btnLoadPort2CLMPClick(this);
   WriteSystemLog("Timer SECS處理Load.");
}
//---------------------------------------------------------------------------
// 2021 9 11a - chc 於robot取Cassette時就做Aligner的入料點動作
void __fastcall TMainForm::tmAlignerToInPositionTimer(TObject *Sender)
{

   // 2021 9 25 - chc Log
   WriteSystemLog("Timer啟動Aligner到入料點...");

   tmAlignerToInPosition->Enabled = false;
   // 入料點: 要先設WaferSize
   btnInputClick(this);

   // 2021 9 25 - chc Log
   WriteSystemLog("Timer啟動Aligner到入料點.");

}
//---------------------------------------------------------------------------
// Code,Set/Reset,Level,Message
void __fastcall TMainForm::SetSECSAlarm(int code,int resetset,int level,AnsiString message)
{

   // 2023 7 19 - chc Alarm
   AnsiString msg,sset,slevel;
   if(resetset == 0)
      sset = "Off";
   else
      sset = "On ";
   if(level == 0)
      slevel = "Light";
   else
      slevel = "High ";
   msg.sprintf(" %05d  %s  %s : %s",code, sset,slevel,message);
   AddAlarmLog(msg);

   // 離線
   if(cbOffLine->Checked == true)
      return;

   // 2021 10 15 - chc 異常進入DOWN, Reset進入Idle or Run
   // 2021 10 27 - chc Alarm不切換狀態
   /*
   if(resetset == 1 && level == 1) {

      // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
      //rgEQStatus->ItemIndex = EQ_STATUS_DOWN;
      rgEQStatus->ItemIndex = EQ_STATUS_IDLE;

      // 2021 10 25 - chc 在這裡做
      SendSECSStatus(rgEQStatus->ItemIndex);
      Sleep(500);

   }
   else if(resetset == 0 && level == 1) {
      if(pnlWaferRobotInformation->Color == clLime || pnlWaferAlignerInformation->Color == clLime || pnlWaferChuckInformation->Color == clLime)

         // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
         //rgEQStatus->ItemIndex = EQ_STATUS_RUN;
         rgEQStatus->ItemIndex = EQ_STATUS_EXECUTING;

      else
         rgEQStatus->ItemIndex = EQ_STATUS_IDLE;

      // 2021 10 25 - chc 在這裡做
      SendSECSStatus(rgEQStatus->ItemIndex);
      Sleep(500);

   }
   */

   // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
   // 2021 10 25 - chc 不在這裡做
   //SendSECSStatus(rgEQStatus->ItemIndex);

   SECSAlarmCode = code;
   SECSAlarmMessage = message;
   SECSAlarmLevel = level;
   SECSAlarmOccur = resetset;

   rgSECSOccur->ItemIndex = MainForm->SECSAlarmOccur;
   rgSECSLevel->ItemIndex = MainForm->SECSAlarmLevel;
   pnlSECSAlarmCode->Caption = IntToStr(MainForm->SECSAlarmCode);

   rgSecsCommandSet->ItemIndex = -1;
   boolSendSCESCommand = true;
   rgSecsCommandSet->ItemIndex = SECS_CMD_ALRM - SECS_CMD_STAT_1;

   if(resetset == 0 && pnlSECSAlarmCode->Caption.ToInt() == SECSAlarmCode)
      pnlSECSAlarmCode->Caption = "";
   else
      pnlSECSAlarmCode->Caption = IntToStr(SECSAlarmCode);


}
//---------------------------------------------------------------------------
// 2021 9 23b - chc SetButtonDelay
void __fastcall TMainForm::SetButtonDelay(int no)
{
int tcnt;

   if(no == 1)
      tcnt = edButtonDelay1->Text.ToInt() * 1000;
   else if(no == 2)
      tcnt = edButtonDelay2->Text.ToInt() * 1000;
   else if(no == 3)
      tcnt = edButtonDelay3->Text.ToInt() * 1000;
   else if(no == 4)
      tcnt = edButtonDelay4->Text.ToInt() * 1000;
   btnFocusDone->Enabled = false;
   tmButtonDelay->Interval = tcnt;
   tmButtonDelay->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::tmButtonDelayTimer(TObject *Sender)
{

   tmButtonDelay->Enabled = false;
   btnFocusDone->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pcRecipeChange(TObject *Sender)
{
TLMDTabSheet *ts;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   ts = pcRecipe->ActivePage;
   if(ts == tsWaferMap)
      cbWaferMap->Checked = true;
   else
      cbWaferMap->Checked = false;
   cbWaferMapClick(this);

   // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
   // 在點位設定頁面 & Chuck有片
   if(ts == tsRecipeSetting) {
      if(pnlWaferChuckInformation->Color == clLime) {
         if(rgEQStatus->ItemIndex != EQ_STATUS_SETUP) {
            SendSECSStatus(EQ_STATUS_SETUP);
         }
      }
   }
   else {
      if(pnlWaferChuckInformation->Color == clLime) {
         if(rgEQStatus->ItemIndex == EQ_STATUS_SETUP) {
            SendSECSStatus(EQ_STATUS_EXECUTING);
         }
      }
   }

}
//---------------------------------------------------------------------------
// 2021 10 6 - chc 顯示目前Table所在的Die Col/Row
void __fastcall TMainForm::UpdateDiePosition()
{
int axisno,x,y,row,col,cx,cy,w,h,dx,dy,scol,srow;
double fcmd,fw,fh;
I32 cmd;
bool bchange = false;
AnsiString msg;

// 2021 1 27 - chc 記錄xy
static int oldx = 0;
static int oldy = 0;

   // Col/Row = 21/18 => 21/19
   if(boolForTest == true) {
      x = edTestX->Text.ToInt();
      y = edTestY->Text.ToInt();
      //pnlWaferDieCenterX->Caption = "0";
      //pnlWaferDieCenterY->Caption = "0";
      //pnlWaferDegreeX->Caption = "0";
      //pnlWaferDegreeY->Caption = "0";
   }
   else {
      axisno = X_AXIS;
      GetPosition(axisno, &fcmd);
      x = fcmd;
      axisno = Y_AXIS;
      GetPosition(axisno, &fcmd);
      y = fcmd;

      // 2021 1 27 - chc 記錄xy
      if(abs(x-oldx) < 100 && abs(y-oldy) < 100) {
         return;
      }

   }

   // 2021 12 18 - chc 直接考慮中心點XY來換算可能會對
   if(cbNewMode->Checked == true) {
      if((pnlWaferDieCenterX->Caption == "" || pnlWaferDieCenterX->Caption == "0") &&
         (pnlWaferDieCenterY->Caption == "" || pnlWaferDieCenterY->Caption == "0")) {
         pnlWaferDieCenterX->Caption = pnlCenterXFind->Caption;
         pnlWaferDieCenterY->Caption = pnlCenterYFind->Caption;
         if((pnlWaferDieCenterX->Caption == "" || pnlWaferDieCenterX->Caption == "0") &&
            (pnlWaferDieCenterY->Caption == "" || pnlWaferDieCenterY->Caption == "0")) {
            goto old;
         }
      }

      // New: 目前位置(x,y)
      dx = x - pnlWaferDieCenterX->Caption.ToInt();
      dy = y - pnlWaferDieCenterY->Caption.ToInt();
      // 中心Die座標
      scol = pnlCenterCol->Caption.ToInt();
      srow = pnlCenterRow->Caption.ToInt();
      // Die Size
      fw = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
      fh = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();
      // um to pulse
      fw = fw / X_RESOLUTION;
      fh = fh / Y_RESOLUTION;

      // 2023 7 24a - chc Log 彰化是srow,scol
      //col = col - (dx+fw/2) / fw;
      //row = row + (dy+fh/2) / fh;
      col = scol - (dx+fw/2) / fw;
      row = srow + (dy+fh/2) / fh;

      // 若為垂直/水平線運動只能改變一軸
      // 2023 7 24a - chc Log 彰化是srow,scol
      if(SelectRow != -1) {

         if(abs(oldy-y) < 100)
            row = SelectRow;
      }

      // 2023 7 24a - chc Log 彰化是srow,scol
      if(SelectCol != -1) {

         if(abs(oldx-x) < 100)
            col = SelectCol;
      }
      if(SelectRow != row || SelectCol != col)
         bchange = true;
      SelectRow = row;
      SelectCol = col;

      // 2023 7 24a - chc Check
      if(row >= 1000 || col >= 1000) {
         WriteSystemLog("UpdateDiePosition(row,col): Error, set to 999");
         if(SelectRow >= 1000)
            SelectRow = 999;
         if(SelectCol >= 1000)
            SelectCol = 999;
      }

      MapCode[SelectRow][SelectCol] = 4;
      // Select Row/Col
      pnlColumSelect->Caption = IntToStr(SelectCol);
      pnlRowSelect->Caption = IntToStr(SelectRow);

      // 重畫?
      if(bchange == true && pcRecipe->ActivePage == tsWaferMap && cbWaferMap->Checked == true && Wafer.boolSet == true && sbWaferMap->Visible == true) {
         DrawBigImage();
      }
      // 記錄xy
      oldx = x;
      oldy = y;
      return;
   }

old:

   // 2021 10 26 - chc 分mode: 1-(col,row)to(X,Y), 2-(X,Y)to(col,row)
   int ox,oy;
   ox = x;
   oy = y;
   GetAdjustXY(ox, oy, &x, &y,2);

   cx = sgArea->Cells[1][1].ToInt();
   cy = sgArea->Cells[2][1].ToInt();
   fw = edDieSizeX->Text.ToDouble() + edDieSizeGapX->Text.ToDouble();
   fh = edDieSizeY->Text.ToDouble() + edDieSizeGapY->Text.ToDouble();
   // um to pulse
   fw = fw / X_RESOLUTION;
   fh = fh / Y_RESOLUTION;
   w = fw;
   h = fh;
   // 中心Die座標
   scol = pnlCenterCol->Caption.ToInt();
   srow = pnlCenterRow->Caption.ToInt();

   // 2021 10 15 - chc 除0!
   if(w <= 0 || h <= 0)

      // 2021 1 27 - chc 記錄xy
      //return;
      goto end;

   dx = x - cx - w/2;
   dy = y - cy - h/2;
   col = scol - (dx / w);
   row = srow - (dy / h);

   // 2021 11 22 - chc Log
   // 2022 1 3 - chc 不Log
   //msg.sprintf("[即時轉換col,row]Motion X,Y=%d,%d, 角度轉換後X,Y=%d,%d, col,row=%d,%d",ox,oy,x,y,col,row);
   //WriteSystemLog(msg);

   // 原點位置: GridNoY
   // 下: 180
   if(rgWaferDegree->ItemIndex == 2) {
      row = GridNoY - row - 1;

      // 2021 10 27 - chc 若有偏移, 總量要加1
      if(COffsetY > 0)
         row++;

   }

   // 2021 10 15 - chc 校正(col,row)
   if(abs(x - cx) > w/2 || abs(y - cy) > h/2) {
      // 左上
      //if(x > cx && y > cy) {
      if((x - cx) > w/2 && (y - cy) > h/2) {

         col--;
         if(rgWaferDegree->ItemIndex == 0)
            row--;
         else if(rgWaferDegree->ItemIndex == 2)
            row++;
      }
      // 右上
      //else if(x < cx && y > cy) {
      else if((cx - x) > w/2 && (y - cy) > h/2) {

         if(rgWaferDegree->ItemIndex == 0)
            row--;
         else if(rgWaferDegree->ItemIndex == 2)
            row++;
      }
      // 左下
      //else if(x > cx && y < cy) {
      else if((x - cx) > w/2 && (cy - y) > h/2) {

         col--;
      }
   }

   // 2021 10 27 - chc col,row校正
   if(rgWaferDegree->ItemIndex == 2) {
      // 整齊: 中心線左邊會在右 =>col要減1
      if(COffsetX == 0) {
         if(row == srow && col < scol)
            col--;
      }
      // 中心線上面會在下 =>row要加1
      if(col == scol) {
         if(row > srow)
            row++;
      }

   }

   // 2021 11 22 - chc Log
   // 2022 1 3 - chc 不Log
   //msg.sprintf("[即時轉換col,row]最後col,row=%d,%d",col,row);
   //WriteSystemLog(msg);

   if(col < MAX_COL_NO && row < MAX_ROW_NO && col >= 0 && row >= 0) {

      // 2021 10 27 - chc 若為垂直/水平線運動只能改變一軸
      if(abs(oldy-y) < 100)
         row = SelectRow;
      if(abs(oldx-x) < 100)
         col = SelectCol;

      if(SelectRow != row || SelectCol != col)
         bchange = true;
      SelectRow = row;
      SelectCol = col;
      MapCode[SelectRow][SelectCol] = 4;
      // Select Row/Col
      pnlColumSelect->Caption = IntToStr(SelectCol);
      pnlRowSelect->Caption = IntToStr(SelectRow);
   }
   if(bchange == true && pcRecipe->ActivePage == tsWaferMap && cbWaferMap->Checked == true && Wafer.boolSet == true && sbWaferMap->Visible == true)
      DrawBigImage();

// 2021 1 27 - chc 記錄xy
end:
   oldx = x;
   oldy = y;

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pcSystemChange(TObject *Sender)
{
TLMDTabSheet *no;

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

   no = pcSystem->ActivePage;
   if(no != tsParameter) {
      if(cbWaferMap->Checked == true || sbWaferMap->Visible == true) {
         sbWaferMap->Visible = false;
         cbWaferMap->Checked = false;
         tbZoom->Visible = false;
         cbWaferMapClick(this);
      }

      // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
      if(pnlWaferChuckInformation->Color == clLime) {
         if(rgEQStatus->ItemIndex == EQ_STATUS_SETUP) {
            SendSECSStatus(EQ_STATUS_EXECUTING);
         }
      }

   }
   else {
      if(pcRecipe->ActivePage == tsWaferMap && cbWaferMap->Checked == false) {
         cbWaferMap->Checked = true;
         cbWaferMapClick(this);
      }

      // 2021 10 25 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
      if(pcRecipe->ActivePage == tsRecipeSetting) {
         // 在點位設定頁面 & Chuck有片
         if(pnlWaferChuckInformation->Color == clLime) {
            if(rgEQStatus->ItemIndex != EQ_STATUS_SETUP) {
               SendSECSStatus(EQ_STATUS_SETUP);
            }
         }
      }
      else {
         if(pnlWaferChuckInformation->Color == clLime) {
            if(rgEQStatus->ItemIndex == EQ_STATUS_SETUP) {
               SendSECSStatus(EQ_STATUS_EXECUTING);
            }
         }
      }

   }

   // 2021 11 21 - chc 不是EFEM就取消
   if(no != tsRorzeEFEM) {
      if(cbAutoCancel->Checked == true)
         cbRobotStep->Checked = false;
   }

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::Panel23Click(TObject *Sender)
{

   if(boolForTest == true) {
      UpdateDiePosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::cbOffLineClick(TObject *Sender)
{

   // SECS離線
   if(cbOffLine->Checked == true) {
      cbSECSAtuo->Visible = false;
      cbSECSAtuo->Checked = false;

      // 2021 10 27 - chc change color
      pnlStatus->Color = clSilver;

      // 2021 11 11 - chc 離線也可以
      cbOffLineAtuo->Visible = true;
      cbOffLineAtuo->Checked = true;

   }
   // SECS連線
   else {
      cbSECSAtuo->Visible = true;
      cbSECSAtuo->Checked = true;
      cbAutoLoad->Checked = true;

      // 2021 11 11 - chc 離線也可以
      cbOffLineAtuo->Visible = false;
      cbOffLineAtuo->Checked = false;

      // 2021 10 27 - chc change color
      if(pnlStatus->Caption == "Init")
         pnlStatus->Color = (TColor)0x0076CBB1;
      else if(pnlStatus->Caption == "Idle")
         pnlStatus->Color = (TColor)0x0076CBB1;
      else if(pnlStatus->Caption == "Setup")
         pnlStatus->Color = clAqua;
      else if(pnlStatus->Caption == "Ready")
         pnlStatus->Color = (TColor)0x0076CBB1;
      else if(pnlStatus->Caption == "Executing")
         pnlStatus->Color = clYellow;
      else if(pnlStatus->Caption == "Pause")
         pnlStatus->Color = (TColor)0x0076CBB1;
      else
         pnlStatus->Color = (TColor)0x0076CBB1;
   }
}
//---------------------------------------------------------------------------
// 2021 10 17 - chc AutoLoadWafer
void __fastcall TMainForm::tmAutoLoadWaferTimer(TObject *Sender)
{

   tmAutoLoadWafer->Enabled = false;
   if(btnLoadWafer->Enabled == true) {
      pnlSystemMessage->Caption = "自動Timer取片作業: 進行...";
      WriteSystemLog(pnlSystemMessage->Caption);
      btnLoadWaferClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 10 17 - chc SECS連線且自動時自動退片
void __fastcall TMainForm::tmAutoUnloadWaferTimer(TObject *Sender)
{

   tmAutoUnloadWafer->Enabled = false;
   if(btnUnloadWafer->Enabled == true) {
      pnlSystemMessage->Caption = "自動Timer退片作業: 進行...";
      WriteSystemLog(pnlSystemMessage->Caption);
      btnUnloadWaferClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 10 17 - chc 記錄為最後一片完成退片 => UnLoad
void __fastcall TMainForm::tmAutoUnloadTimer(TObject *Sender)
{

   tmAutoUnload->Enabled = false;
   if(btnCassetteLoad->Enabled == true && btnCassetteLoad->Caption == "UnLoad") {
      pnlSystemMessage->Caption = "自動Timer UnLoad作業: 進行...";
      WriteSystemLog(pnlSystemMessage->Caption);
      btnCassetteLoadClick(this);
   }
}
//---------------------------------------------------------------------------
// 2021 10 20 - chc 自動Start
void __fastcall TMainForm::tmAutoStartTimer(TObject *Sender)
{

   tmAutoStart->Enabled = false;
   pcSystem->ActivePage = tsSystem;
   pcOP->ActivePage = tsRun;
   pnlSystemMessage->Caption = "自動Timer Start作業: 進行...";
   WriteSystemLog(pnlSystemMessage->Caption);
   btnSystemRunClick(this);
}
//---------------------------------------------------------------------------
// 2021 10 21 - chc 送出Status: Init/Idle/Setup/Ready/Execution/Pause
//   #define EQ_STATUS_INIT             0
//   #define EQ_STATUS_IDLE             1
//   #define EQ_STATUS_SETUP            2
//   #define EQ_STATUS_READY            3
//   #define EQ_STATUS_EXECUTING        4
//   #define EQ_STATUS_PAUSE            5
void __fastcall TMainForm::SendSECSStatus(int status)
{
AnsiString msg;
TColor color;

   // 2021 10 26 - chc Status
   switch(status) {
      case EQ_STATUS_INIT:
         msg = "Init";
         color = (TColor)0x0076CBB1;
         break;
      case EQ_STATUS_IDLE:
         msg = "Idle";
         color = (TColor)0x0076CBB1;
         break;
      case EQ_STATUS_SETUP:
         msg = "Setup";
         color = clAqua;
         break;
      case EQ_STATUS_READY:
         msg = "Ready";
         color = (TColor)0x0076CBB1;
         break;
      case EQ_STATUS_EXECUTING:
         msg = "Executing";
         color = clYellow;
         break;
      case EQ_STATUS_PAUSE:
         msg = "Pause";
         color = (TColor)0x0076CBB1;
         break;
   }
   pnlStatus->Caption = msg;

   if(cbOffLine->Checked == false && pnlSECSStatus->Color == clLime) {
      rgEQStatus->ItemIndex = status;
      WriteSystemLog("Send SECS Status: " + IntToStr(status+1));
      rgSecsCommandSet->ItemIndex = -1;
      boolSendSCESCommand = true;
      rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;

      // 2021 10 26 - chc Status
      pnlStatus->Color = color;

   }

   // 2021 10 26 - chc Status
   else {
      pnlStatus->Color = clSilver;

      // 2021 10 27 - chc 也要設定
      rgEQStatus->ItemIndex = status;
   }

}
//---------------------------------------------------------------------------
// 2021 10 26 - chc for test
void __fastcall TMainForm::pnlWaferDegreeXClick(TObject *Sender)
{

   if(boolForTest == true) {
      UpdateDiePosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlWaferChuckInformationClick(TObject *Sender)
{

   if(boolForTest == true) {
      if(pnlWaferChuckInformation->Color == (TColor)0x0068C6AA) {
         pnlWaferChuckInformation->Color = clLime;
         pnlWaferChuckInformation1->Color = clLime;
         pnlWaferChuckInformation2->Color = clLime;
         MainForm->pnlWaferChuckInformation->Refresh();
         MainForm->pnlWaferChuckInformation1->Refresh();
         MainForm->pnlWaferChuckInformation2->Refresh();
      }
      else {
         pnlWaferChuckInformation->Color = (TColor)0x0068C6AA;
         pnlWaferChuckInformation1->Color = clSilver;
         pnlWaferChuckInformation2->Color = clSilver;
         MainForm->pnlWaferChuckInformation->Refresh();
         MainForm->pnlWaferChuckInformation1->Refresh();
         MainForm->pnlWaferChuckInformation2->Refresh();
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlWaferDegreeYClick(TObject *Sender)
{

   if(boolForTest == true)
      pnlCenterYFind->Caption = IntToStr(pnlWaferDieCenterY->Caption.ToInt() - 1000);
}
//---------------------------------------------------------------------------
// 2021 10 27 - chc Log刪除
void __fastcall TMainForm::btnLogDeleteClick(TObject *Sender)
{
int dayno,duration,delno;

   dayno = edLogReservedDay->Text.ToInt();
   if(dayno < 60) {
      pnlSystemMessage->Caption = "至少應保留天數: 60!";
      return;
   }
   TSearchRec sr;
   AnsiString fname,findname,syear,smonth,sday,delfname;
   int iAttributes = 0;
   int rno = 0;
   //faReadOnly	  $00000001	  Read-only files
   //faHidden	  $00000002	  Hidden files
   //faSysFile	  $00000004	  System files
   //faVolumeID	  $00000008	  Volume ID files
   //faDirectory  $00000010	  Directory files
   //faArchive	  $00000020	  Archive files
   //faAnyFile	  $0000003F	  Any file
   findname = LogDirectory + "\\*.log";
   iAttributes |= faArchive;
   delno = 0;
   if(FindFirst(findname, iAttributes, sr) == 0) {
      do {
         if((sr.Attr & iAttributes) == sr.Attr) {                               // 檔名在sr.Name
            // 20211025111546.log
            // 12345678901234567890
            fname = sr.Name.SubString(1,sr.Name.Length()-4);                    // 全檔名
            syear = fname.SubString(1,4);
            smonth = fname.SubString(5,2);
            sday = fname.SubString(7,2);
            duration = int(Date()-EncodeDate(syear.ToInt(),smonth.ToInt(),sday.ToInt()));
            if(duration > dayno) {
               delfname = LogDirectory + "\\" + sr.Name;
               if(FileExists(delfname)) {
                  DeleteFile(delfname.c_str());
                  delno++;
                  pnlSystemMessage->Caption = IntToStr(delno) + ":" + delfname;
                  if((delno % 200) == 0) {
                     Application->ProcessMessages();
                  }
               }
            }
         }
      } while (FindNext(sr) == 0);
   }
}
//---------------------------------------------------------------------------
// 2021 11 12 - chc 確認系統內是否有Wafer
bool __fastcall TMainForm::WaferInSystem()
{

   // 2021 11 22 - chc 加入Chuck Sensor: IsChuckWithWafer
   //if(pnlWaferRobotInformation->Color == clLime || pnlWaferAlignerInformation->Color == clLime || pnlWaferChuckInformation->Color == clLime)
   if(pnlWaferRobotInformation->Color == clLime || pnlWaferAlignerInformation->Color == clLime ||
      pnlWaferChuckInformation->Color == clLime || IsChuckWithWafer() == true)

      return true;
   return false;
}
//---------------------------------------------------------------------------
// 2021 11 25 - chc Local mode
void __fastcall TMainForm::btnLocalClick(TObject *Sender)
{

   //if(pnlLocal->Color != clBlue) {
   //   pnlLocal->Color = clBlue;
   //   pnlRemote->Color = clSilver;
   if(btnLocal->Color == clSilver) {
      btnLocal->Color = (TColor)0x00FFFFB0;
      btnRemote->Color = clSilver;
      cbOffLine->Checked = true;

      // 2023 1 28 - chc Local不亮
      BlueLamp(false);
   }
}
//---------------------------------------------------------------------------
// 2021 11 25 - chc Remote mode
void __fastcall TMainForm::btnRemoteClick(TObject *Sender)
{

   //if(pnlRemote->Color != clBlue) {
   if(btnRemote->Color == clSilver) {

      // 2022 3 8 - chc 檢查SECS是否連線?
      if(pnlSECSConnect->Color != clLime) {

         // 2023 1 28 - chc 重連線
         WriteSystemLog("SECS未連線: 切換為[Remote]重連線...");
         btnSECSReConnectClick(this);
         WaitTime(1000);
         if(pnlSECSConnect->Color == clLime) {
            WriteSystemLog("SECS未連線: 切換為[Remote]乙連線.");
         }
         else {

            WriteSystemLog("SECS未連線: 不能切換為[Remote]!");
            pnlAlarmMessage->Caption = "SECS is no Connected: cannot switch to [Remote]!";
            //AddAlarmLog(pnlAlarmMessage->Caption);
            return;
         }
      }

      //pnlRemote->Color = clBlue;
      //pnlLocal->Color = clSilver;
      btnRemote->Color = (TColor)0x00FFFFB0;
      btnLocal->Color = clSilver;
      cbOffLine->Checked = false;
   }
}
//---------------------------------------------------------------------------
// 2021 11 25 - chc Aligner切換有無片
void __fastcall TMainForm::pnlWaferAlignerInformation2Click(
      TObject *Sender)
{

   if(pnlWaferAlignerInformation2->Color == clLime) {
      if(Application->MessageBox("Aligner切換為無片?      ", "EFEM單動作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      pnlWaferAlignerInformation->Color = (TColor)0x0068C6AA;
      pnlWaferAlignerInformation1->Color = clSilver;
      pnlWaferAlignerInformation2->Color = clSilver;
      pnlWaferAlignerInformation->Refresh();
      pnlWaferAlignerInformation1->Refresh();
      pnlWaferAlignerInformation2->Refresh();
   }
   else {
      if(pnlWaferChuckInformation2->Color == clLime || pnlWaferRobotInformation2->Color == clLime) {
         pnlAlarmMessage->Caption = "Chuck或Robot上有片! 無法設定Aligner為有片.";
         return;
      }
      // 若已UnLoad就不可以有片
      if(btnCassetteLoad->Caption == "Load") {
         pnlAlarmMessage->Caption = "CST尚未Load! 無法設定Aligner為有片.";
         return;
      }

      if(Application->MessageBox("Aligner切換為有片?      ", "EFEM單動作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      pnlWaferAlignerInformation->Color = clLime;
      pnlWaferAlignerInformation1->Color = clLime;
      pnlWaferAlignerInformation2->Color = clLime;
      pnlWaferAlignerInformation->Refresh();
      pnlWaferAlignerInformation1->Refresh();
      pnlWaferAlignerInformation2->Refresh();
   }
}
//---------------------------------------------------------------------------
// 2021 11 25 - chc Robot切換有無片
void __fastcall TMainForm::pnlWaferRobotInformation2Click(TObject *Sender)
{

   if(pnlWaferRobotInformation2->Color == clLime) {
      if(Application->MessageBox("Robot切換為無片?      ", "EFEM單動作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      pnlWaferRobotInformation->Color = (TColor)0x0068C6AA;
      pnlWaferRobotInformation1->Color = clSilver;
      pnlWaferRobotInformation2->Color = clSilver;
      pnlWaferRobotInformation->Refresh();
      pnlWaferRobotInformation1->Refresh();
      pnlWaferRobotInformation2->Refresh();
   }
   else {
      if(pnlWaferChuckInformation2->Color == clLime || pnlWaferAlignerInformation2->Color == clLime) {
         pnlAlarmMessage->Caption = "Chuck或Aligner上有片! 無法設定Robot為有片.";
         return;
      }
      // 若已UnLoad就不可以有片
      if(btnCassetteLoad->Caption == "Load") {
         pnlAlarmMessage->Caption = "CST尚未Load! 無法設定Robot為有片.";
         return;
      }
      if(Application->MessageBox("Robot切換為有片?      ", "EFEM單動作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      pnlWaferRobotInformation->Color = clLime;
      pnlWaferRobotInformation1->Color = clLime;
      pnlWaferRobotInformation2->Color = clLime;
      pnlWaferRobotInformation->Refresh();
      pnlWaferRobotInformation1->Refresh();
      pnlWaferRobotInformation2->Refresh();
   }
}
//---------------------------------------------------------------------------
// 2021 11 25 - chc Chuck切換有無片
void __fastcall TMainForm::pnlWaferChuckInformation2Click(TObject *Sender)
{

   if(pnlWaferChuckInformation2->Color == clLime) {
      if(Application->MessageBox("Chuck切換為無片?      ", "EFEM單動作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      pnlWaferChuckInformation->Color = (TColor)0x0068C6AA;
      pnlWaferChuckInformation1->Color = clSilver;
      pnlWaferChuckInformation2->Color = clSilver;
      pnlWaferChuckInformation->Refresh();
      pnlWaferChuckInformation1->Refresh();
      pnlWaferChuckInformation2->Refresh();

      // 2023 2 21 - chc 將btnLoad解開 : pnlLoadPort2Presence, pnlLoadPort2Placement
      if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
         if(pnlLoadPort1Placement->Color == clLime && pnlLoadPort1Presence->Color == clLime) {
            if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false) {
               if(btnCassetteLoad->Enabled == false) {
                  btnCassetteLoad->Enabled = true;
                  WriteSystemLog("Chuck切換為無片(8): 啟動Load Button");
               }
            }
         }
      }
      else {
         if(pnlLoadPort2Placement->Color == clLime && pnlLoadPort2Presence->Color == clLime) {
            if(boolInLoadWafer == false && boolInUnloadWafer == false && boolInMeasureRun == false) {
               if(btnCassetteLoad->Enabled == false) {
                  btnCassetteLoad->Enabled = true;
                  WriteSystemLog("Chuck切換為無片(12): 啟動Load Button");
               }
            }
         }
      }

   }
   else {
      if(pnlWaferRobotInformation2->Color == clLime || pnlWaferAlignerInformation2->Color == clLime) {
         pnlAlarmMessage->Caption = "Robot或Aligner上有片! 無法設定Chuck為有片.";
         return;
      }
      // 若已UnLoad就不可以有片
      if(btnCassetteLoad->Caption == "Load") {
         pnlAlarmMessage->Caption = "CST尚未Load! 無法設定Chuck為有片.";
         return;
      }
      if(Application->MessageBox("Chuck切換為有片?      ", "EFEM單動作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      pnlWaferChuckInformation->Color = clLime;
      pnlWaferChuckInformation1->Color = clLime;
      pnlWaferChuckInformation2->Color = clLime;
      pnlWaferChuckInformation->Refresh();
      pnlWaferChuckInformation1->Refresh();
      pnlWaferChuckInformation2->Refresh();
   }
}
//---------------------------------------------------------------------------
// 2021 11 29 - chc Read INF
//      XDIES:6.418102
//      YDIES:6.237720
//DEVICE:MEDIATEK-21P-A0S1-1586
//LOT:29MBC554.1-BPFV
//WAFER:TFUG85-01
//FNLOC:180
//ROWCT:45
//COLCT:45
//BCEQU:000
//REFPX:1
//REFPY:45
//DUTMS:MM
//XDIES:6.418102
//YDIES:6.237720
void __fastcall TMainForm::btnReadINFClick(TObject *Sender)
{
AnsiString fname,str,temp;
int rowno,colno,topno,bottomno,leftno,rightno;
double width,height;

   if(odINF->Execute()) {
      // Full path
      fname = odINF->FileName;
      rowno = 45;
      colno = 45;
      topno = 13;
      bottomno = 9;
      leftno = 7;
      rightno = 5;
      width = 6418.102;                         // 288814.59
      height = 6237.720;                         // 280697.4

      if(FileExists(fname)) {
         FILE *fp;
         char buf[500];
         int pos,len;
         int cnt = 0;
         if((fp = fopen(fname.c_str(),"rt")) != NULL) {
            while(fgets(buf, 400, fp) != NULL) {
               cnt++;
               str.sprintf("%s",buf);
               //ROWCT:45
               //COLCT:45
               //1234567890
               pos = str.Pos("ROWCT:");
               if(pos > 0) {
                  len = str.Length();
                  temp = str.SubString(pos+6,len-(pos+6));
                  pnlNFRow->Caption = temp;
               }
               else {
                  pos = str.Pos("COLCT:");
                  if(pos > 0) {
                     len = str.Length();
                     temp = str.SubString(pos+6,len-(pos+6));
                     pnlNFCol->Caption = temp;
                     break;
                  }
                  else {
                     //LOT:29MBC554.1-BPFV
                     pos = str.Pos("LOT:");
                     if(pos > 0) {
                        len = str.Length();
                        temp = str.SubString(pos+4,len-(pos+4));
                        pnlNFLot->Caption = temp;
                     }
                  }
               }
            }
            fclose(fp);
         }
      }
   }
}
//---------------------------------------------------------------------------
// 2021 12 18 - chc Load Mode Parameter
void __fastcall TMainForm::LoadModeParameter()
{
TIniFile *pSystemFile;
bool bmode;
AnsiString fname;

   // Read Mode.ini
   pnlSystemMessage->Caption = "載入Mode參數...";

   // ini檔名與目錄
   fname = SystemDirectory + "\\Mode.ini";
   pSystemFile = new TIniFile(fname);

   bmode = pSystemFile->ReadBool("Mode","Value"                                 ,false);
   cbNewMode->Checked = bmode;

   delete pSystemFile;
   pnlSystemMessage->Caption = "載入Mode參數完成.";
}
//---------------------------------------------------------------------------
// 2021 12 18 - chc Mode.ini
void __fastcall TMainForm::cbNewModeClick(TObject *Sender)
{
TIniFile *pSystemFile;
bool bmode;
AnsiString fname;

   // Write Mode.ini
   pnlSystemMessage->Caption = "寫入Mode參數...";

   // ini檔名與目錄
   fname = SystemDirectory + "\\Mode.ini";
   pSystemFile = new TIniFile(fname);

   bmode = cbNewMode->Checked;
   pSystemFile->WriteBool("Mode","Value"                                        ,bmode);

   delete pSystemFile;
   pnlSystemMessage->Caption = "寫入Mode參數完成.";

   DrawBigImage();

}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pcOPChange(TObject *Sender)
{

   // 2022 5 17 - chc 是PE: 固定10秒後切換到操作員等級
   if(PriorityLevel == PRIORITY_PE)
      ChangePriorityCount = edPasswordSwitchSecond->Text.ToInt();

}
//---------------------------------------------------------------------------
// 2022 5 17 - chc 調整Z值
void __fastcall TMainForm::btnZAdjustClick(TObject *Sender)
{

   pcSystem->Enabled = false;

   // Adjust
   pnlZAdjust->Visible = true;
   pnlZAdjust->Left = 679;
   pnlZAdjust->Top = 360;

}
//---------------------------------------------------------------------------
// 2022 5 17 - chc 調整Z值
void __fastcall TMainForm::btnZAdjustCancelClick(TObject *Sender)
{

   pnlZAdjust->Visible = false;
   pcSystem->Enabled = true;
}
//---------------------------------------------------------------------------
// 2022 5 17 - chc 調整Z值
void __fastcall TMainForm::btnZAdjustOKClick(TObject *Sender)
{
int ano,dno,offset,value;

   ano = edAreaTNo->Text.ToInt();
   dno = edDotTNo->Text.ToInt();
   offset = edZAdjustOffset->Text.ToInt();
   if(offset == 0)
      goto end;

   for(int i=0 ; i<ano ; i++) {
      value = sgArea->Cells[3][i+1].ToInt();
      sgArea->Cells[3][i+1] = IntToStr(value + offset);
   }

   for(int i=0 ; i<dno ; i++) {
      value = sgDot->Cells[3][i+1].ToInt();
      sgDot->Cells[3][i+1] = IntToStr(value + offset);
   }

end:
   pnlZAdjust->Visible = false;
   pcSystem->Enabled = true;
}
//---------------------------------------------------------------------------
unsigned char *svptr;
// 2023 6 5 - chc init ViewWorks CCD
UINT		        m_imagebuffernumber;
VWSDK::VWGIGE_HANDLE    m_pvwGigE;
VWSDK::HCAMERA	        m_pCamera;
VWSDK::OBJECT_INFO*     m_pobjectInfo;
VWSDK::IMAGE_INFO*      pImageInfo;
BITMAPINFO*		m_pBmpInfo1;    				  //Bitmap object : 1
BYTE*			m_pUnpackedImage;
UINT                    m_curFPS = 0;
HDC			m_hdc1;
UINT                    m_Width,m_Height;
UINT                    m_nFrame;
// 1024*1200
//Image capture event
//void __fastcall TMainForm::DrawImage( VWSDK::OBJECT_INFO* pObjectInfo, VWSDK::IMAGE_INFO* pImageInfo )
static void DrawImage( VWSDK::OBJECT_INFO* pObjectInfo, VWSDK::IMAGE_INFO* pImageInfo )
//void __fastcall TMainForm::DrawImage(OBJECT_INFO* m_pobjectInfo,IMAGE_INFO* pImageInfo)
{
static int cnt = 0;
AnsiString msg;
unsigned char *dptr,*sptr;
int sindex,dindex;
static bfirst = true;

// Re-Entrant
int sum = 0;
static int incnt = 0;
static bool active = false;
   if(active == true) {
      incnt++;
      MainForm->pnlInCnt->Caption = IntToStr(incnt);
      MainForm->WriteSystemLog("Re-Entrant: DrawImage()");
      return;
   }
   active = true;

   MainForm->pnlCCDRun->Caption = "1:" + IntToStr(m_Width) + "," + IntToStr(m_Height);
   MainForm->WriteSystemLog(MainForm->pnlCCDRun->Caption);

   if(MainForm->rgCCDSource->ItemIndex == 0) {
      goto end;
   }

   cnt++;
   MainForm->pnlCCDCount->Caption = IntToStr(cnt);
   msg.sprintf("%ld", pObjectInfo->pUserPointer);
   MainForm->pnlVieworksMessage->Caption = msg;

   if(bfirst == true) {
      bfirst = false;

// 有設定W/H會無法取像, DMK也會無法顯示??? 三個都沒有會有Out of Resource!! Error
// => 可能用自己的TImage
//      MainForm->imVieworks->Picture->Bitmap->PixelFormat = pf24bit;

      MainForm->imVieworks->Picture->Bitmap->Width = m_Width;
      MainForm->imVieworks->Picture->Bitmap->Height = m_Height;
      // eVsion
      MainForm->EImageAry.SetSize(m_Width,m_Height);

      // 2023 8 2 - chc ROI
      MainForm->EImageAryROI.Attach(&MainForm->EImageAry);
   }
   sptr = (unsigned char *)pImageInfo->pImage;
   svptr = (unsigned char *)pImageInfo->pImage;
   MainForm->pnlW->Caption = IntToStr(pImageInfo->width);
   MainForm->pnlH->Caption = IntToStr(pImageInfo->height);

   /*
   sindex = 0;
   for(int row=0; row<m_Height ; row++) {
      // bitmap
      if(MainForm->rgImageType->ItemIndex == 0) {
         dptr = (Byte *) MainForm->imVieworks->Picture->Bitmap->ScanLine[row];        //讀取第 row 列
         //dindex = 0;
         //for(int col=0; col<m_Width; col++) {
         //   dptr[dindex++] = sptr[sindex++];                                       // 藍色分量
         //   dptr[dindex++] = sptr[sindex++];                                       // 綠色分量
         //   dptr[dindex++] = sptr[sindex++];                                       // 紅色分量
         //   //sindex += 3;
         //}
         // 由sptr到dptr
         memcpy(dptr, sptr,m_Width*3);
      }
      // eVision
      else if(MainForm->rgImageType->ItemIndex == 1 || MainForm->rgImageType->ItemIndex == 2) {
         dptr = (unsigned char *)MainForm->EImageAry.GetImagePtr(0,row);
         memcpy(dptr, sptr,m_Width*3);
      }
      // pattern
      else if(MainForm->rgImageType->ItemIndex == 3) {
         dptr = (unsigned char *)MainForm->EImageAry.GetImagePtr(0,row);
         for(int i=0 ; i<m_Width*3 ; i++) {
            if((cnt % 10) < 5)
               dptr[i] = 0x99;
            else
               dptr[i] = 0x55;
         }
      }
      sum += sptr[10];
      sptr += m_Width*3;

      //MainForm->pnlCCDRun->Caption = "2a:" + IntToStr(m_Width) + "," + IntToStr(m_Height) + "," + IntToStr(row+1);
      //MainForm->WriteSystemLog(MainForm->pnlCCDRun->Caption);

   }

   MainForm->pnlCCDRun->Caption = "3:" + IntToStr(m_Width) + "," + IntToStr(m_Height);
   MainForm->WriteSystemLog(MainForm->pnlCCDRun->Caption);

   if(MainForm->rgImageType->ItemIndex == 1) {
      //MainForm->EImageAry.Draw(MainForm->imVieworks->Canvas->Handle);
      MainForm->EImageAryROI.SetPlacement(0,0,m_Width,m_Height);
      MainForm->EImageAryROI.Draw(MainForm->imVieworks->Canvas->Handle);
   }
   // file
   else if(MainForm->rgImageType->ItemIndex == 2 || MainForm->rgImageType->ItemIndex == 3) {
      MainForm->EImageAry.Save("D:\\Test.bmp",E_FILE_FORMAT_COLOR_BMP);
      MainForm->imVieworks->Picture->LoadFromFile("D:\\Test.bmp");
   }
   MainForm->imVieworks->Refresh();
   MainForm->pnlSum->Caption = IntToStr(sum);
   */
   MainForm->DisplayVCCD(cnt);

end:
   active = false;

}
//---------------------------------------------------------------------------
// 2023 6 5 - chc init ViewWorks CCD
void __fastcall TMainForm::InitVworks()
{
int ccdindex = 1;

   SetupVieworksView();
   ccdindex = edCCDIndex->Text.ToInt();
   WriteSystemLog("Setup CCD: ViewWorks...");
   m_pobjectInfo = new VWSDK::OBJECT_INFO;

   //VwCamera*	m_pCamera;
   VWSDK::RESULT result = VWSDK::RESULT_ERROR;
   m_imagebuffernumber = 2;

   if(VWSDK::RESULT_SUCCESS != VWSDK::OpenVwGigE( &m_pvwGigE )) {
      //Application->MessageBox("Open failed!", MB_OK);
   }
   else {
      //Application->MessageBox("VworkCCD Open Succ.", MB_OK);
   }

   //VWSDK::VwUserLogging(m_pvwGigE, "Sample Code", __VWFILE__, __VWFUNCTION__, __VWLINE__,
   //		"You can see this message in a tool called SpiderLogger.exe");

   //FUNCTION_IMPORTEXPORT RESULT VwOpenCameraByIndex(VWGIGE_HANDLE hVwGigE, UINT nCameraIndex, HCAMERA* phCamera, UINT nNumBuffer, UINT nWidth, UINT nHeight,
   //		UINT nPacketSize, void* pUserPointer, ImageCallbackFn* pImageCallbackFn, DisconnectCallbackFn* pDisconnectCallbackFn = NULL);

   //result = VWSDK::VwOpenCameraByIndex( m_pvwGigE, ccdindex, &m_pCamera, m_imagebuffernumber, 0, 0, 0, m_pobjectInfo, DrawImage, NULL);
   result = VWSDK::VwOpenCameraByIndex( m_pvwGigE, ccdindex, &m_pCamera, m_imagebuffernumber, 0, 0, 0, m_pobjectInfo, DrawImage);

   //Application->MessageBox((AnsiString("VworkCCD Open= ") + IntToStr(result)).c_str() , MB_OK);

   if(result != VWSDK::RESULT_SUCCESS) {
      WriteSystemLog("Setup CCD: ViewWorks fail: " + IntToStr(result));
      switch(result) {
         default:
	    Application->MessageBox("ERROR : Default error code returned", MB_OK);
	    break;
	 case VWSDK::RESULT_ERROR_DEVCREATEDATASTREAM:
	    Application->MessageBox("ERROR : RESULT_ERROR_DEVCREATESTREAM was returned", MB_OK);
	    break;
	 case VWSDK::RESULT_ERROR_NO_CAMERAS:
	    Application->MessageBox("ERROR : RESULT_ERROR_NO_CAMERAS was returned", MB_OK);
	    Application->MessageBox("CHECK : NIC properties", MB_OK);
	    break;
	 case VWSDK::RESULT_ERROR_VWCAMERA_CAMERAINDEX_OVER:
	    Application->MessageBox("ERROR : RESULT_ERROR_VWCAMERA_CAMERAINDEX_OVER was returned", MB_OK);
	    Application->MessageBox("CHECK : Zero-based camera index", MB_OK);
	    break;
	 case VWSDK::RESULT_ERROR_DATASTREAM_MTU:
	    Application->MessageBox("ERROR : RESULT_ERROR_STREAM_MTU was returned", MB_OK);
	    Application->MessageBox("CHECK : Check NIC MTU", MB_OK);
	    break;
	 case VWSDK::RESULT_ERROR_INSUFFICIENT_RESOURCES:
	    Application->MessageBox("ERROR : RESULT_ERROR_BUFFER_TOO_SMALL was returned", MB_OK);
	    Application->MessageBox("CHECK : Check system resources", MB_OK);
	    break;
	 case VWSDK::RESULT_ERROR_MEMORY_ALLOCATION:
	    Application->MessageBox("ERROR : RESULT_ERROR_MEMORY_ALLOCATION was returned", MB_OK);
	    Application->MessageBox("CHECK : Check system resources", MB_OK);
	    break;
      }
      return;
   }

   //---------------------------------------------------------------------------
   m_pobjectInfo->pUserPointer = this;
   m_pobjectInfo->pVwCamera = m_pCamera;

   //Get image width,height
   UINT nWidth = 0;
   UINT nHeight = 0;
   VWSDK::PIXEL_FORMAT pixelFormat = VWSDK::PIXEL_FORMAT_BGR8;

   GetCustomCommand(m_pCamera, "Width", &nWidth, VWSDK::GET_CUSTOM_COMMAND_VALUE);
   GetCustomCommand(m_pCamera, "Height", &nHeight, VWSDK::GET_CUSTOM_COMMAND_VALUE);
   pnlWidth->Caption = IntToStr(nWidth);
   pnlHeight->Caption = IntToStr(nHeight);

   // 2023 8 2 - chc Set Width/Height/OffsetX/Offset(712*424)
   VWSDK::RESULT ret1 = VWSDK::CameraSetCustomCommand(m_pCamera, "Width", "1024");
   VWSDK::RESULT ret2 = VWSDK::CameraSetCustomCommand(m_pCamera, "Height", "1200");
   VWSDK::RESULT ret3 = VWSDK::CameraSetCustomCommand(m_pCamera, "OffsetX", "712");
   VWSDK::RESULT ret4 = VWSDK::CameraSetCustomCommand(m_pCamera, "OffsetY", "424");

   // 直接設為"RGB8"
   VWSDK::RESULT ret = VWSDK::CameraSetCustomCommand(m_pCamera, "PixelFormat", "BGR8");
   //VWSDK::RESULT ret = VWSDK::CameraSetCustomCommand(m_pCamera, "PixelFormat", "BayerRG8");
   switch(ret) {
      case VWSDK::RESULT_SUCCESS:
      	 break;
      case VWSDK::RESULT_ERROR_INVALID_PARAMETER:
	 Application->MessageBox("Invalid pixelformat.", MB_OK);
	 break;
      default:
	 Application->MessageBox("Can't change the pixelformat.", MB_OK);
	 break;
   }

   // Update Pixel Size
   UINT nPixelSize = 0;
   GetCustomCommand(m_pCamera, "PixelSize", &nPixelSize,  VWSDK::GET_CUSTOM_COMMAND_VALUE);
   pnlPixelSize->Caption = "Bpp" + IntToStr(nPixelSize);

   AnsiString  strVendorName, strModelName, strVersion, strID;
   GetDeviceInfo( ccdindex, &strVendorName, &strModelName, &strVersion, &strID );
   pnlVendor->Caption = strVendorName;
   pnlModel->Caption = strModelName;
   pnlVersion->Caption = strVersion;
   pnlID->Caption = strID;

   //Application->MessageBox("InitVworks: info", MB_OK);

   //---------------------------------------------------------------------------

   boolVworksCCD = true;
   WriteSystemLog("Setup CCD: ViewWorks ok: " + IntToStr(result));

}
//---------------------------------------------------------------------------
// 2023 7 19 - chc alarm Log
// SystemAlarm.log
void __fastcall TMainForm::LoadAlarmLog()
{
AnsiString fname;

   fname = AlarmLogFileName;
   if(FileExists(fname)) {
      mmAlarmLog->Lines->LoadFromFile(fname);
   }

}
//---------------------------------------------------------------------------
// 2023 7 19 - chc Error Log
// SystemAlarm.log
void __fastcall TMainForm::AddAlarmLog(AnsiString msg)
{
AnsiString temp;
static AnsiString omsg = "";

   if(msg == omsg)
      return;
   omsg = msg;

   DateTimeToString(temp,"yyyy'/'mm'/'dd hh':'nn':'ss",Now());
   msg = temp + "> " + msg + "\n";
   mmAlarmLog->Lines->Append(msg);

   FILE *logFile;
   logFile = fopen(AlarmLogFileName.c_str(),"a+t");
   fprintf(logFile,msg.c_str());
   fclose(logFile);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::pnlWaferRobotInformationLow2Click(
      TObject *Sender)
{

   if(pnlWaferRobotInformationLow2->Color == clLime) {
      if(Application->MessageBox("Robot切換為無片?      ", "EFEM單動作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      pnlWaferRobotInformationLow->Color = (TColor)0x0068C6AA;
      pnlWaferRobotInformationLow1->Color = clSilver;
      pnlWaferRobotInformationLow2->Color = clSilver;
      pnlWaferRobotInformationLow->Refresh();
      pnlWaferRobotInformationLow1->Refresh();
      pnlWaferRobotInformationLow2->Refresh();
   }
   else {
      if(pnlWaferChuckInformation2->Color == clLime || pnlWaferAlignerInformation2->Color == clLime) {
         pnlAlarmMessage->Caption = "Chuck或Aligner上有片! 無法設定Robot為有片.";
         return;
      }
      // 若已UnLoad就不可以有片
      if(btnCassetteLoad->Caption == "Load") {
         pnlAlarmMessage->Caption = "CST尚未Load! 無法設定Robot為有片.";
         return;
      }
      if(Application->MessageBox("Robot切換為有片?      ", "EFEM單動作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         return;
      }
      pnlWaferRobotInformationLow->Color = clLime;
      pnlWaferRobotInformationLow1->Color = clLime;
      pnlWaferRobotInformationLow2->Color = clLime;
      pnlWaferRobotInformationLow->Refresh();
      pnlWaferRobotInformationLow1->Refresh();
      pnlWaferRobotInformationLow2->Refresh();
   }
}
//---------------------------------------------------------------------------
// 2023 7 25 - chc for demo
// 初始: clGray
void __fastcall TMainForm::Label188Click(TObject *Sender)
{
TPanel *panel,*panelsel;

   // Wafer
   for(int i=0 ; i<11 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1)));
      panelsel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      panel->Color = clLime;
      panelsel->Color = clLime;
   }

   // Work
   for(int i=3 ; i<4 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1)));
      panelsel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      //panel->Color = clOlive;
      panelsel->Color = clOlive;
   }

   // Done
   for(int i=0 ; i<3 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1)));
      panelsel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      //panel->Color = clGreen;
      panelsel->Color = clGreen;
   }

   // Chuck
   pnlWaferChuckInformation->Color = clLime;
   cbLP2E84->Checked = false;
   btnLoadWafer->Enabled = false;
   pnlLoadWafer->Color = clLime;
}
//---------------------------------------------------------------------------
// 2023 7 25 - chc Load System Parameters
void __fastcall TMainForm::LoadSystemConfigParameters()
{
TIniFile *pSystemFile;

   SystemConfigName = SystemDirectory + "\\SystemConfig.ini";
   pSystemFile = new TIniFile(SystemConfigName);

   // Lamp Life
   SystemConfig.LampLife = pSystemFile->ReadInteger("Alignment","Lamp Life"                            ,2000);
   edLampLife->Text = IntToStr(SystemConfig.LampLife);

   // 加入SECS Port: edSECSPort
   SystemConfig.SECSPort = pSystemFile->ReadInteger("Alignment","SECSPort"                             ,5200);
   edSECSPort->Text = IntToStr(SystemConfig.SECSPort);

   // 12" Edge
   // 1
   SystemConfig.W12Edge[0].X = pSystemFile->ReadInteger("W12Edge1","X"       ,3973563);
   SystemConfig.W12Edge[0].Y = pSystemFile->ReadInteger("W12Edge1","Y"       ,-214311);
   SystemConfig.W12Edge[0].Z = pSystemFile->ReadInteger("W12Edge1","Z"       ,250000);
   ed12EdgeX1->Text = IntToStr(SystemConfig.W12Edge[0].X);
   ed12EdgeY1->Text = IntToStr(SystemConfig.W12Edge[0].Y);
   ed12EdgeZ1->Text = IntToStr(SystemConfig.W12Edge[0].Z);
   // Edge Intensit
   SystemConfig.W12Edge[0].Intensity = pSystemFile->ReadInteger("W12Edge1","Intensity"    ,80);
   ed12EdgeIntensity1->Text = IntToStr(SystemConfig.W12Edge[0].Intensity);

   // 2
   SystemConfig.W12Edge[1].X = pSystemFile->ReadInteger("W12Edge2","X"       ,2219828);
   SystemConfig.W12Edge[1].Y = pSystemFile->ReadInteger("W12Edge2","Y"       ,-215394);
   SystemConfig.W12Edge[1].Z = pSystemFile->ReadInteger("W12Edge2","Z"       ,250000);
   ed12EdgeX2->Text = IntToStr(SystemConfig.W12Edge[1].X);
   ed12EdgeY2->Text = IntToStr(SystemConfig.W12Edge[1].Y);
   ed12EdgeZ2->Text = IntToStr(SystemConfig.W12Edge[1].Z);
   // Edge Intensit
   SystemConfig.W12Edge[1].Intensity = pSystemFile->ReadInteger("W12Edge2","Intensity"    ,80);
   ed12EdgeIntensity2->Text = IntToStr(SystemConfig.W12Edge[1].Intensity);

   // 3
   SystemConfig.W12Edge[2].X = pSystemFile->ReadInteger("W12Edge3","X"       ,2645519);
   SystemConfig.W12Edge[2].Y = pSystemFile->ReadInteger("W12Edge3","Y"       ,2425166);
   SystemConfig.W12Edge[2].Z = pSystemFile->ReadInteger("W12Edge3","Z"       ,250000);
   ed12EdgeX3->Text = IntToStr(SystemConfig.W12Edge[2].X);
   ed12EdgeY3->Text = IntToStr(SystemConfig.W12Edge[2].Y);
   ed12EdgeZ3->Text = IntToStr(SystemConfig.W12Edge[2].Z);
   // Edge Intensit
   SystemConfig.W12Edge[2].Intensity = pSystemFile->ReadInteger("W12Edge3","Intensity"    ,80);
   ed12EdgeIntensity3->Text = IntToStr(SystemConfig.W12Edge[2].Intensity);

   // 8" Edge
   // 1
   SystemConfig.W8Edge[0].X = pSystemFile->ReadInteger("W8Edge1","X"         ,3973563);
   SystemConfig.W8Edge[0].Y = pSystemFile->ReadInteger("W8Edge1","Y"         ,-21431);
   SystemConfig.W8Edge[0].Z = pSystemFile->ReadInteger("W8Edge1","Z"         ,250000);
   ed8EdgeX1->Text = IntToStr(SystemConfig.W8Edge[0].X);
   ed8EdgeY1->Text = IntToStr(SystemConfig.W8Edge[0].Y);
   ed8EdgeZ1->Text = IntToStr(SystemConfig.W8Edge[0].Z);
   // Edge Intensit
   SystemConfig.W8Edge[0].Intensity = pSystemFile->ReadInteger("W8Edge1","Intensity"    ,80);
   ed8EdgeIntensity1->Text = IntToStr(SystemConfig.W8Edge[0].Intensity);

   // 2
   SystemConfig.W8Edge[1].X = pSystemFile->ReadInteger("W8Edge2","X"         ,2219828);
   SystemConfig.W8Edge[1].Y = pSystemFile->ReadInteger("W8Edge2","Y"         ,-215394);
   SystemConfig.W8Edge[1].Z = pSystemFile->ReadInteger("W8Edge2","Z"         ,250000);
   ed8EdgeX2->Text = IntToStr(SystemConfig.W8Edge[1].X);
   ed8EdgeY2->Text = IntToStr(SystemConfig.W8Edge[1].Y);
   ed8EdgeZ2->Text = IntToStr(SystemConfig.W8Edge[1].Z);
   // Edge Intensit
   SystemConfig.W8Edge[1].Intensity = pSystemFile->ReadInteger("W8Edge2","Intensity"    ,80);
   ed8EdgeIntensity2->Text = IntToStr(SystemConfig.W8Edge[1].Intensity);

   // 3
   SystemConfig.W8Edge[2].X = pSystemFile->ReadInteger("W8Edge3","X"         ,26455119);
   SystemConfig.W8Edge[2].Y = pSystemFile->ReadInteger("W8Edge3","Y"         ,2425166);
   SystemConfig.W8Edge[2].Z = pSystemFile->ReadInteger("W8Edge3","Z"         ,250000);
   ed8EdgeX3->Text = IntToStr(SystemConfig.W8Edge[2].X);
   ed8EdgeY3->Text = IntToStr(SystemConfig.W8Edge[2].Y);
   ed8EdgeZ3->Text = IntToStr(SystemConfig.W8Edge[2].Z);
   // Edge Intensit
   SystemConfig.W8Edge[2].Intensity = pSystemFile->ReadInteger("W8Edge3","Intensity"    ,80);
   ed8EdgeIntensity3->Text = IntToStr(SystemConfig.W8Edge[2].Intensity);

   pSystemFile->UpdateFile();
   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2023 7 25 - chc Edge
// 12"
// 8"
// SECS Port
// Lamp Life time
void __fastcall TMainForm::btnSystemConfigSaveClick(TObject *Sender)
{

TIniFile *pSystemFile;

   SystemConfigName = SystemDirectory + "\\SystemConfig.ini";
   pSystemFile = new TIniFile(SystemConfigName);

   // 12" Edge
   // 1
   SystemConfig.W12Edge[0].X = ed12EdgeX1->Text.ToInt();
   SystemConfig.W12Edge[0].Y = ed12EdgeY1->Text.ToInt();
   SystemConfig.W12Edge[0].Z = ed12EdgeZ1->Text.ToInt();
   pSystemFile->WriteInteger("W12Edge1","X"                                     ,SystemConfig.W12Edge[0].X);
   pSystemFile->WriteInteger("W12Edge1","Y"                                     ,SystemConfig.W12Edge[0].Y);
   pSystemFile->WriteInteger("W12Edge1","Z"                                     ,SystemConfig.W12Edge[0].Z);
   SystemConfig.W12Edge[0].Intensity = ed12EdgeIntensity1->Text.ToInt();
   pSystemFile->WriteInteger("W12Edge1","Intensity"                             ,SystemConfig.W12Edge[0].Intensity);

   // 2
   SystemConfig.W12Edge[1].X = ed12EdgeX2->Text.ToInt();
   SystemConfig.W12Edge[1].Y = ed12EdgeY2->Text.ToInt();
   SystemConfig.W12Edge[1].Z = ed12EdgeZ2->Text.ToInt();
   pSystemFile->WriteInteger("W12Edge2","X"                                     ,SystemConfig.W12Edge[1].X);
   pSystemFile->WriteInteger("W12Edge2","Y"                                     ,SystemConfig.W12Edge[1].Y);
   pSystemFile->WriteInteger("W12Edge2","Z"                                     ,SystemConfig.W12Edge[1].Z);
   SystemConfig.W12Edge[1].Intensity = ed12EdgeIntensity2->Text.ToInt();
   pSystemFile->WriteInteger("W12Edge2","Intensity"                             ,SystemConfig.W12Edge[1].Intensity);

   // 3
   SystemConfig.W12Edge[2].X = ed12EdgeX3->Text.ToInt();
   SystemConfig.W12Edge[2].Y = ed12EdgeY3->Text.ToInt();
   SystemConfig.W12Edge[2].Z = ed12EdgeZ3->Text.ToInt();
   pSystemFile->WriteInteger("W12Edge3","X"                                     ,SystemConfig.W12Edge[2].X);
   pSystemFile->WriteInteger("W12Edge3","Y"                                     ,SystemConfig.W12Edge[2].Y);
   pSystemFile->WriteInteger("W12Edge3","Z"                                     ,SystemConfig.W12Edge[2].Z);
   SystemConfig.W12Edge[2].Intensity = ed12EdgeIntensity3->Text.ToInt();
   pSystemFile->WriteInteger("W12Edge3","Intensity"                             ,SystemConfig.W12Edge[2].Intensity);

   // 8" Edge
   // 1
   SystemConfig.W8Edge[0].X = ed8EdgeX1->Text.ToInt();
   SystemConfig.W8Edge[0].Y = ed8EdgeY1->Text.ToInt();
   SystemConfig.W8Edge[0].Z = ed8EdgeZ1->Text.ToInt();
   pSystemFile->WriteInteger("W8Edge1","X"                                      ,SystemConfig.W8Edge[0].X);
   pSystemFile->WriteInteger("W8Edge1","Y"                                      ,SystemConfig.W8Edge[0].Y);
   pSystemFile->WriteInteger("W8Edge1","Z"                                      ,SystemConfig.W8Edge[0].Z);
   SystemConfig.W8Edge[0].Intensity = ed8EdgeIntensity1->Text.ToInt();
   pSystemFile->WriteInteger("W8Edge1","Intensity"                             ,SystemConfig.W8Edge[0].Intensity);

   // 2
   SystemConfig.W8Edge[1].X = ed8EdgeX2->Text.ToInt();
   SystemConfig.W8Edge[1].Y = ed8EdgeY2->Text.ToInt();
   SystemConfig.W8Edge[1].Z = ed8EdgeZ2->Text.ToInt();
   pSystemFile->WriteInteger("W8Edge2","X"                                      ,SystemConfig.W8Edge[1].X);
   pSystemFile->WriteInteger("W8Edge2","Y"                                      ,SystemConfig.W8Edge[1].Y);
   pSystemFile->WriteInteger("W8Edge2","Z"                                      ,SystemConfig.W8Edge[1].Z);
   SystemConfig.W8Edge[1].Intensity = ed8EdgeIntensity2->Text.ToInt();
   pSystemFile->WriteInteger("W8Edge2","Intensity"                             ,SystemConfig.W8Edge[1].Intensity);

   // 3
   SystemConfig.W8Edge[2].X = ed8EdgeX3->Text.ToInt();
   SystemConfig.W8Edge[2].Y = ed8EdgeY3->Text.ToInt();
   SystemConfig.W8Edge[2].Z = ed8EdgeZ3->Text.ToInt();
   pSystemFile->WriteInteger("W8Edge3","X"                                      ,SystemConfig.W8Edge[2].X);
   pSystemFile->WriteInteger("W8Edge3","Y"                                      ,SystemConfig.W8Edge[2].Y);
   pSystemFile->WriteInteger("W8Edge3","Z"                                      ,SystemConfig.W8Edge[2].Z);
   SystemConfig.W8Edge[2].Intensity = ed8EdgeIntensity3->Text.ToInt();
   pSystemFile->WriteInteger("W8Edge3","Intensity"                              ,SystemConfig.W8Edge[2].Intensity);

   // Lamp Life
   SystemConfig.LampLife = edLampLife->Text.ToInt();
   pSystemFile->WriteInteger("Alignment","Lamp Life"                            ,SystemConfig.LampLife);

   // SECS Port: edSECSPort
   SystemConfig.SECSPort = edSECSPort->Text.ToInt();
   pSystemFile->WriteInteger("Alignment","SECSPort"                             ,SystemConfig.SECSPort);

   pSystemFile->UpdateFile();
   delete pSystemFile;

}
//---------------------------------------------------------------------------
// 2023 7 26 - chc LP2單獨Load
void __fastcall TMainForm::btnCassette2LoadClick(TObject *Sender)
{

   // RCMD: 1-Cancel, 2-Abort SECSRemoteCommand
   // @@@@ 要確認是否要做? 可能另一個LP在運作中
   if(rgLoadPortSelect->ItemIndex == LOADPORT_2)
      SECSRemoteCommand = SECS_REMOTE_NONE;

   // 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   // 2023 7 31 - chc @@@@ 要確認是否要做? 可能另一個LP在運作中
   if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {
      if(boolInLoadWafer == true) {
         if(btnCassette2Load->Caption == "UnLoad")
            pnlAlarmMessage->Caption = "Cannot do UnLoad during fetching!";
         else
            pnlAlarmMessage->Caption = "Cannot do Load during fetching!";
         WriteSystemLog(pnlAlarmMessage->Caption);
         Beep(500);
         return;
      }
      if(boolInUnloadWafer == true) {
         if(btnCassette2Load->Caption == "UnLoad")
            pnlAlarmMessage->Caption = "Cannot do UnLoad during storing!";
         else
            pnlAlarmMessage->Caption = "Cannot do Load during storing!";
         WriteSystemLog(pnlAlarmMessage->Caption);
         Beep(500);
         return;
      }
      if(boolInMeasureRun == true) {
         if(btnCassette2Load->Caption == "UnLoad")
            pnlAlarmMessage->Caption = "Cannot do UnLoad during measuring!";
         else
            pnlAlarmMessage->Caption = "Cannot do Load during measuring!";
         WriteSystemLog(pnlAlarmMessage->Caption);
         Beep(500);
         return;
      }
   }

   // 2021 10 27 - chc 將取片Status清成灰色
   // 2023 7 31 - chc @@@@ 要確認是否要做? 可能另一個LP在運作中
   if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {

      pnlLoadWafer->Color = clSilver;
      pnlUnloadWafer->Color = clSilver;
      pnlMeasure->Color = clSilver;
      pnlOriginal->Color = clSilver;
      pnlZeroPosition->Color = clSilver;
      pnlTargetPosition->Color = clSilver;
      pnlSetLimit->Color = clSilver;
   }

   // 2021 9 8b - chc 有CST
   rgCST2Exist->ItemIndex = WAFER_EXIST_YES;

   // 2021 6 11 - chc alarm, 先決定Recipe
   // 2021 9 15 - chc 離線才要問
   if(cbOffLine->Checked == true) {

      if(btnCassette2Load->Caption == "Load") {
         if(Application->MessageBox("是否已切換到正確Recipe?      ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            return;
         }
      }
   }

   // 2021 5 4 - chc SetupEFEMSocket
   if(EFEMMode == EFEM_RORZE) {

      // 2021 10 15 - chc Message
      pnlOperationMessage->Caption = "LP2 Loading...";

      // 2021 11 11 - chc 禁用pcSystem
      pcSystem->Enabled = false;

      // 2021 11 12 - chc Log
      WriteSystemLog(pnlOperationMessage->Caption);

      pnlCassette2Load->Color = clSilver;
      if(pnlLoadPort2ORGN->Color == clLime) {
         WriteSystemLog("檢查LoadPort...");

          // 2023 7 31 - chc @@@@ 要確認是否要做? 可能另一個LP在運作中
         if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {

            rgRobotStage->ItemIndex = ROBOT_STAGE_LP2;
            // 12": Low Arm
            if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_12)
               rgRobotArm->ItemIndex = ROBOT_ARM_LOW;
            // 8": Up Arm
            else if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_8)
               rgRobotArm->ItemIndex = ROBOT_ARM_UP;
            // None
            else
               rgRobotArm->ItemIndex = WAFER_SIZE_NONE;
            // Slot1
            combRobotSlot->ItemIndex = 0;
            combRobotSlot->Text = "1";
            rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
         }
         // Load...
         if(btnCassette2Load->Caption == "Load") {
            pnlStartMessage->Caption = "Check before Cassette Loading...";
            pnlStartMessage->Visible = true;
         }
         else {
            pnlStartMessage->Caption = "Check before Cassette UnLoading...";
            pnlStartMessage->Visible = true;
         }
         // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
         if(BeforeLoadPortLoadUnloadFun(LOADPORT_2) == false) {
            pnlCassette2Load->Color = clRed;
            if(btnCassette2Load->Caption == "Load")
               pnlOperationMessage->Caption = "Load Fail!";
            else
               pnlOperationMessage->Caption = "Unload Fail!";

            // 2021 11 11 - chc 禁用pcSystem
            pcSystem->Enabled = true;

            WriteSystemLog(pnlOperationMessage->Caption);
            return;
         }
         // UnLoad
         if(btnCassette2Load->Caption == "UnLoad") {
            WriteSystemLog("執行BeforeUnload()...");
            if(BeforeUnload() == false) {
               pnlCassette2Load->Color = clRed;
               pnlAlarmMessage->Caption = "Unload Fail!";

               // 2021 11 11 - chc 禁用pcSystem
               pcSystem->Enabled = true;

               WriteSystemLog("執行BeforeUnload(): Fail");
               return;
            }
            WriteSystemLog("執行BeforeUnload(): Ok");
         }
      }

      // 2021 11 12 - chc Loadport異常
      else {
         pnlCassette2Load->Color = clRed;
         pnlAlarmMessage->Caption = "LP2 Error(ORGN not completed)!";
         pcSystem->Enabled = true;
         WriteSystemLog("pnlAlarmMessage->Caption");
         return;
      }

      boolLoadUnloadStatus = false;
      // Load
      if(btnCassette2Load->Caption == "Load") {
         // CST
         pnlEFEMCassette2->Color = clSilver;
         // Load...
         pnlStartMessage->Caption = "Cassette Loading...";
         pnlStartMessage->Visible = true;
         // LP1
         // 2021 5 5 - chc 送CSTREAD後, SECS會送MAP要求做LOAD動作
         // => 於人員LOAD時才做
         pnlLoadPort2CLMP->Color = clSilver;
         // 變更Port編號
         rgRFIDLoadPort->ItemIndex = LOADPORT_2;
         // 12"
         if(rgLoadPort2WaferSize->ItemIndex == WAFER_SIZE_12)
            rgRFIDWaferSize->ItemIndex = 1;
         else
            rgRFIDWaferSize->ItemIndex = 0;
         rgRFIDTagType->ItemIndex = 2;
         btnRFIDReadClick(this);
         WriteSystemLog("RFID完成1.");

         // SECS: 變更Port編號
         rgSECSPortNo->ItemIndex = LOADPORT_2;
         // 有連線時由SECS MAP 觸發LOAD
         int timeout,cnt;
         // 是否連線?
         if(pnlSECSConnect->Color == clLime && cbOffLine->Checked == false) {
            // 連線且Recmote才要做

            // 2023 8 1 - chc LP1/LP2
            //rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
            rgPortStatus2->ItemIndex = PORT_STATUS_CSTREAD;

            WriteSystemLog("boolSendSCESCommand: 19");
            rgSecsCommandSet->ItemIndex = -1;
            boolSendSCESCommand = true;
            rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
            timeout = 45;
         }
         else {
            timeout = 2;
            if(pnlSECSConnect->Color != clLime)
               WriteSystemLog("SECS未連線: 直接做Load");
            if(cbOffLine->Checked == true)
               WriteSystemLog("在Local狀態下: 直接做Load");

            btnLoadPort2CLMPClick(this);
         }
         cnt = 0;
         while(1) {
            WaitTime(1000);
            cnt++;
            if(cnt > timeout) {
               pnlOperationMessage->Caption = "LP2 Load Fail!";
               pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
               break;
            }
            if(pnlLoadPort2CLMP->Color == clLime) {
               pnlOperationMessage->Caption = "LP2 Loaded.";
               pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
               WriteSystemLog("boolSendSCESCommand: 6");

               // 2021 5 4 - chc 進入Run
               // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause
               //rgEQStatus->ItemIndex = EQ_STATUS_RUN;
               //rgSecsCommandSet->ItemIndex = -1;
               //boolSendSCESCommand = true;
               //rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;
               // 2021 10 27 - chc Load後為為EXECUTING
               //SendSECSStatus(EQ_STATUS_IDLE);
               SendSECSStatus(EQ_STATUS_EXECUTING);

               // 2021 6 3 - chc 禁止變更LoadPort
               rgLoadPortSelect->Enabled = false;

               // 2021 9 30 - chc CST
               pnlEFEMCassette2->Color = clLime;

               break;
            }
            else if(pnlLoadPort2CLMP->Color == clRed) {
               pnlOperationMessage->Caption = "LP2 Load Timeout失敗!";
               pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
               break;
            }
         }
      }
      // UnLoad
      else {
         // Unload...
         pnlStartMessage->Caption = "Cassette Unloading...";
         pnlStartMessage->Visible = true;

         // 2012 UnLoad再檢查一次
         WriteSystemLog("再執行BeforeUnload()...");
         if(BeforeUnload() == false) {
            pnlAlarmMessage->Caption = "LP2 Unload Fail!";
            WriteSystemLog("再執行BeforeUnload(): Fail");
err:
            pnlCassette2Load->Color = clRed;
            // 禁用pcSystem
            pcSystem->Enabled = true;
            return;
         }

         // 2023 8 1 - chc 是LP2才做
         if(rgLoadPortSelect->ItemIndex == LOADPORT_2) {

            WriteSystemLog("再執行BeforeUnload(): Ok");
            // 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
            if(boolInLoadWafer == true) {
               pnlAlarmMessage->Caption = "Cannot do UnLoad during fetching!";
               WriteSystemLog(pnlAlarmMessage->Caption);
               goto err;
            }
            if(boolInUnloadWafer == true) {
               pnlAlarmMessage->Caption = "Cannot do UnLoad during storing!";
               WriteSystemLog(pnlAlarmMessage->Caption);
               goto err;
            }
         }
         // LP2
         btnLoadPort2UCLMClick(this);
         if(pnlLoadPort2UCLM->Color == clLime) {
            pnlOperationMessage->Caption = "LP2 UnLoad finished.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;

            // LOTEND
            // 2023 8 1 - chc LP1/LP2
            //rgPortStatus->ItemIndex = PORT_STATUS_LOTEND;
            rgPortStatus2->ItemIndex = PORT_STATUS_LOTEND;

            WriteSystemLog("boolSendSCESCommand: 7");

            // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
            //rgEQStatus->ItemIndex = EQ_STATUS_IDLE;
            //rgSecsCommandSet->ItemIndex = -1;
            //boolSendSCESCommand = true;
            //rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
            // 2021 10 27 - chc Unload後改成Ready
            //SendSECSStatus(EQ_STATUS_IDLE);
            // 2021 10 27 - chc Unload完成為Idle
            //SendSECSStatus(EQ_STATUS_READY);
            SendSECSStatus(EQ_STATUS_IDLE);

            // 2021 6 3 - chc 可變更LoadPort
            rgLoadPortSelect->Enabled = true;

            // 2021 9 30 - chc CST
            pnlEFEMCassette2->Color = clSilver;

         }
      }
      if(boolLoadUnloadStatus == true)
         pnlCassette2Load->Color = clLime;
      else
         pnlCassette2Load->Color = clRed;

      // 2021 11 11 - chc 禁用pcSystem
      pcSystem->Enabled = true;

      pnlStartMessage->Visible = false;
      return;
   }

   // Hirata
   pnlCassette2Load->Color = clSilver;
   if(pnlLoadPort->Enabled == true) {

      // 2020 5 2 - chc Load...
      if(btnCassetteLoad->Caption == "Load") {
         pnlStartMessage->Caption = "Check before CST Loading...";
         pnlStartMessage->Visible = true;
      }
      else {
         pnlStartMessage->Caption = "Check before CST UnLoading...";
         pnlStartMessage->Visible = true;
      }

      // 2020 5 4 - chc 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
      if(BeforeLoadPortLoadUnload() == false) {
         pnlCassetteLoad->Color = clRed;
         return;
      }

      // 2020 7 17 - chc UnLoad
      if(btnCassetteLoad->Caption == "UnLoad") {
         if(BeforeUnload() == false) {
            pnlCassetteLoad->Color = clRed;
            return;
         }
      }

      boolLoadUnloadStatus = false;

      if(btnCassetteLoad->Caption == "Load") {

         // 2020 5 2 - chc Load...
         pnlStartMessage->Caption = "Cassette Loading...";
         pnlStartMessage->Visible = true;

         edLoadPortCmd->Text = "MOV:FPML;";
         btnLoadPortCMDClick(this);
         if(pnlCassetteLoad->Color == clLime) {
            pnlOperationMessage->Caption = "Load完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }
      else {

         // 2020 5 2 - chc Unload...
         pnlStartMessage->Caption = "Cassette Unloading...";
         pnlStartMessage->Visible = true;

         edLoadPortCmd->Text = "MOV:ORGN;";
         btnLoadPortCMDClick(this);
         if(pnlCassetteLoad->Color == clLime) {
            pnlOperationMessage->Caption = "UnLoad完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }

      // 2020 5 4 - chc 等20秒
      int cnt = 0;
      int max = 40;
      while(1) {
         if(boolLoadUnloadStatus == true) {
            pnlCassetteLoad->Color = clLime;
            break;
         }
         cnt++;
         if(cnt > max) {
            pnlCassetteLoad->Color = clRed;
            break;
         }
         WaitTime(500);
      }

      // 2020 5 2 - chc Load...
      pnlStartMessage->Visible = false;

   }

//######
/* 彰化

   // 2022 2 13 - chc RCMD: 1-Cancel, 2-Abort SECSRemoteCommand
   SECSRemoteCommand = SECS_REMOTE_NONE;

   // 2021 11 12 - chc 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
   if(boolInLoadWafer == true) {
      if(btnCassetteLoad->Caption == "UnLoad")
         pnlAlarmMessage->Caption = "取片中不能做UnLoad!";
      else
         pnlAlarmMessage->Caption = "取片中不能做Load!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      Beep(500);
      return;
   }
   if(boolInUnloadWafer == true) {
      if(btnCassetteLoad->Caption == "UnLoad")
         pnlAlarmMessage->Caption = "退片中不能做UnLoad!";
      else
         pnlAlarmMessage->Caption = "退片中不能做Load!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      Beep(500);
      return;
   }
   if(boolInMeasureRun == true) {
      if(btnCassetteLoad->Caption == "UnLoad")
         pnlAlarmMessage->Caption = "量測中不能做UnLoad!";
      else
         pnlAlarmMessage->Caption = "量測中不能做Load!";
      WriteSystemLog(pnlAlarmMessage->Caption);
      Beep(500);
      return;
   }

   // 2021 10 27 - chc 將取片Status清成灰色
   pnlLoadWafer->Color = clSilver;
   pnlUnloadWafer->Color = clSilver;
   pnlMeasure->Color = clSilver;
   pnlOriginal->Color = clSilver;
   pnlZeroPosition->Color = clSilver;
   pnlTargetPosition->Color = clSilver;
   pnlSetLimit->Color = clSilver;

   // 2021 9 8b - chc 有CST
   rgCSTExist->ItemIndex = WAFER_EXIST_YES;

   // 2021 6 11 - chc alarm, 先決定Recipe
   // 2021 9 15 - chc 離線才要問
   if(cbOffLine->Checked == true) {

      if(btnCassetteLoad->Caption == "Load") {
         if(Application->MessageBox("是否已切換到正確Recipe?      ", "Olympus Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            return;
         }
      }
   }

   // 2021 5 4 - chc SetupEFEMSocket
   if(EFEMMode == EFEM_RORZE) {

      // 2021 10 15 - chc Message
      pnlOperationMessage->Caption = "Loading...";

      // 2021 11 11 - chc 禁用pcSystem
      pcSystem->Enabled = false;

      // 2021 11 12 - chc Log
      WriteSystemLog(pnlOperationMessage->Caption);

      pnlCassetteLoad->Color = clSilver;
      if((rgLoadPortSelect->ItemIndex == LOADPORT_1 && pnlLoadPort1ORGN->Color == clLime) ||
         (rgLoadPortSelect->ItemIndex == LOADPORT_2 && pnlLoadPort2ORGN->Color == clLime)) {

         // 2021 11 12 - chc Log
         WriteSystemLog("檢查LoadPort...");

         // LP1: 8"
         if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
            rgRobotStage->ItemIndex = ROBOT_STAGE_LP1;
            rgRobotArm->ItemIndex = ROBOT_ARM_UP;
         }
         // LP2: 12"
         else {
            rgRobotStage->ItemIndex = ROBOT_STAGE_LP2;
            rgRobotArm->ItemIndex = ROBOT_ARM_LOW;
         }
         // Slot1
         combRobotSlot->ItemIndex = 0;
         combRobotSlot->Text = "1";
         rgRobotOperation->ItemIndex = ROBOT_HOME_GET;
         // Load...
         if(btnCassetteLoad->Caption == "Load") {
            pnlStartMessage->Caption = "Check before CST Loading...";
            pnlStartMessage->Visible = true;
         }
         else {
            pnlStartMessage->Caption = "Check before CST UnLoading...";
            pnlStartMessage->Visible = true;
         }
         // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
         if(BeforeLoadPortLoadUnload() == false) {
            pnlCassetteLoad->Color = clRed;

            // 2021 10 15 - chc Message
            if(btnCassetteLoad->Caption == "Load")
               pnlOperationMessage->Caption = "Load Fail!";
            else
               pnlOperationMessage->Caption = "Unload Fail!";

            // 2021 11 11 - chc 禁用pcSystem
            pcSystem->Enabled = true;

            // 2021 11 12 - chc Log
            WriteSystemLog(pnlOperationMessage->Caption);

            return;
         }
         // UnLoad
         if(btnCassetteLoad->Caption == "UnLoad") {

            // 2021 11 12 - chc Log
            WriteSystemLog("執行BeforeUnload()...");

            if(BeforeUnload() == false) {
               pnlCassetteLoad->Color = clRed;

               // 2021 10 15 - chc Message
               pnlAlarmMessage->Caption = "Unload Fail!";

               // 2021 11 11 - chc 禁用pcSystem
               pcSystem->Enabled = true;

               // 2021 11 12 - chc Log
               WriteSystemLog("執行BeforeUnload(): Fail");

               return;
            }

            // 2021 11 12 - chc Log
            WriteSystemLog("執行BeforeUnload(): Ok");

         }
      }

      // 2021 11 12 - chc Loadport異常
      else {
         pnlCassetteLoad->Color = clRed;
         pnlAlarmMessage->Caption = "Loadoport異常(未完成ORGN)!";
         pcSystem->Enabled = true;
         WriteSystemLog("pnlAlarmMessage->Caption");
         return;
      }

      boolLoadUnloadStatus = false;
      // Load
      if(btnCassetteLoad->Caption == "Load") {

         // 2021 9 30 - chc CST
         pnlEFEMCassette2->Color = clSilver;
         // Load...
         pnlStartMessage->Caption = "Cassette Loading...";
         pnlStartMessage->Visible = true;
         // LP1: 8"
         if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {

            // 2021 5 5 - chc 送CSTREAD後, SECS會送MAP要求做LOAD動作
            // => 於人員LOAD時才做
            pnlLoadPort1CLMP->Color = clSilver;

            // 2021 9 8b - chc 變更Port編號
            //rgRFIDLoadPort->ItemIndex = LOADPORT_1;
            rgRFIDLoadPort->ItemIndex = LOADPORT_2;

            // 12"
            if(rgLoadPort1WaferSize->ItemIndex == 0)
               rgRFIDWaferSize->ItemIndex = 1;
            else
               rgRFIDWaferSize->ItemIndex = 0;
            rgRFIDTagType->ItemIndex = 2;
            btnRFIDReadClick(this);
            WriteSystemLog("RFID完成1.");

            // 2021 9 8 - chc 變更Port編號
            rgSECSPortNo->ItemIndex = LOADPORT_1;
            //rgSECSPortNo->ItemIndex = LOADPORT_2;

            // 2022 3 8 - chc 要移到裡面: 連線且Recmote才要做
            //rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
            //WriteSystemLog("boolSendSCESCommand: 19");
            //rgSecsCommandSet->ItemIndex = -1;
            //boolSendSCESCommand = true;
            //rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

            // 2021 5 5 - chc 有連線時由SECS MAP觸發LOAD
            int timeout,cnt;

            // 2021 6 3 - chc 是否連線?
            //if(pnlSECSConnect->Color == clLime) {
            if(pnlSECSConnect->Color == clLime && cbOffLine->Checked == false) {

               // 2022 3 8 - chc 要移到裡面: 連線且Recmote才要做
               rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
               WriteSystemLog("boolSendSCESCommand: 19");
               rgSecsCommandSet->ItemIndex = -1;
               boolSendSCESCommand = true;
               rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

               // 2021 9 15 - chc 改成30秒
               //timeout = 20;
               // 2022 3 8 - chc 改成45秒
               //timeout = 30;
               timeout = 45;

            }
            else {
               timeout = 2;

               // 2022 3 8 - chc Log
               if(pnlSECSConnect->Color != clLime)
                  WriteSystemLog("SECS未連線: 直接做Load");
               if(cbOffLine->Checked == true)
                  WriteSystemLog("在Local狀態下: 直接做Load");

               btnLoadPort1CLMPClick(this);

            // 2021 5 5 - chc 有連線時由SECS MAP觸發LOAD
            }
            cnt = 0;
            while(1) {
               WaitTime(1000);
               cnt++;
               if(cnt > timeout) {
                  // 2021 6 30c - chc LP1/LP2: 吋
                  //pnlOperationMessage->Caption = "LP1 Load失敗!";
                  pnlOperationMessage->Caption = "8吋Port Load失敗!";

                  pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
                  break;
               }

               if(pnlLoadPort1CLMP->Color == clLime) {
                  // 2021 6 30c - chc LP1/LP2: 吋
                  //pnlOperationMessage->Caption = "LP1 Load完成.";
                  pnlOperationMessage->Caption = "8吋Port Load完成.";

                  pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
                  WriteSystemLog("boolSendSCESCommand: 5");

                  // 2021 5 4 - chc 進入Run
                  // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause
                  //rgEQStatus->ItemIndex = EQ_STATUS_RUN;
                  //rgSecsCommandSet->ItemIndex = -1;
                  //boolSendSCESCommand = true;
                  //rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;
                  // 2021 10 27 - chc Load後為為EXECUTING
                  //SendSECSStatus(EQ_STATUS_IDLE);
                  SendSECSStatus(EQ_STATUS_EXECUTING);

                  // 2021 6 3 - chc 禁止變更LoadPort
                  rgLoadPortSelect->Enabled = false;

                  // 2021 9 30 - chc CST
                  pnlEFEMCassette2->Color = clLime;

                  break;
               }
               else if(pnlLoadPort1CLMP->Color == clRed) {
                  // 2021 6 30c - chc LP1/LP2: 吋
                  //pnlOperationMessage->Caption = "LP1 Load Timeout失敗!";
                  pnlOperationMessage->Caption = "8吋Port Load Timeout失敗!";

                  pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
                  break;
               }
            }

         }
         else {

            // 2021 5 5 - chc 送CSTREAD後, SECS會送MAP要求做LOAD動作
            // => 於人員LOAD時才做
            pnlLoadPort2CLMP->Color = clSilver;

            // 2021 9 8b - chc 變更Port編號
            //rgRFIDLoadPort->ItemIndex = LOADPORT_2;
            rgRFIDLoadPort->ItemIndex = LOADPORT_1;

            // 12"
            if(rgLoadPort2WaferSize->ItemIndex == 0)
               rgRFIDWaferSize->ItemIndex = 1;
            // 8"
            else
               rgRFIDWaferSize->ItemIndex = 0;
            rgRFIDTagType->ItemIndex = 2;
            // 等2秒
            btnRFIDReadClick(this);
            WriteSystemLog("RFID完成2.");

            // 2021 9 8 - chc 變更Port編號
            rgSECSPortNo->ItemIndex = LOADPORT_2;
            //rgSECSPortNo->ItemIndex = LOADPORT_1;

            // 2022 3 8 - chc 要移到裡面: 連線且Recmote才要做
            //rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
            //WriteSystemLog("boolSendSCESCommand: 19-1");
            //rgSecsCommandSet->ItemIndex = -1;
            //boolSendSCESCommand = true;
            //// 改變rgSecsCommandSet->ItemIndex就會送出
            //rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

            // 2021 5 5 - chc 有連線時由SECS MAP觸發LOAD
            int timeout,cnt;

            // 2021 6 3 - chc 是否連線?
            //if(pnlSECSConnect->Color == clLime) {
            if(pnlSECSConnect->Color == clLime && cbOffLine->Checked == false) {

               // 2022 3 8 - chc 要移到裡面: 連線且Recmote才要做
               rgPortStatus->ItemIndex = PORT_STATUS_CSTREAD;
               WriteSystemLog("boolSendSCESCommand: 19-1");
               rgSecsCommandSet->ItemIndex = -1;
               boolSendSCESCommand = true;
               // 改變rgSecsCommandSet->ItemIndex就會送出
               rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;

               // 2021 9 15 - chc 改成30秒
               //timeout = 20;
               // 2022 3 8 - chc 改成45秒
               //timeout = 30;
               timeout = 45;

            }
            else {
               timeout = 2;

               // 2022 3 8 - chc Log
               if(pnlSECSConnect->Color != clLime)
                  WriteSystemLog("SECS未連線: 直接做Load");
               if(cbOffLine->Checked == true)
                  WriteSystemLog("在Local狀態下: 直接做Load");

               btnLoadPort2CLMPClick(this);

            // 2021 5 5 - chc 有連線時由SECS MAP觸發LOAD
            }
            cnt = 0;
            while(1) {
               WaitTime(1000);
               cnt++;
               if(cnt > timeout) {
                  // 2021 6 30c - chc LP1/LP2: 吋
                  //pnlOperationMessage->Caption = "LP2 Load Timeout失敗!";
                  pnlOperationMessage->Caption = "12吋Port Load Timeout失敗!";

                  pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
                  break;
               }

               if(pnlLoadPort2CLMP->Color == clLime) {
                  // 2021 6 30c - chc LP1/LP2: 寸
                  //pnlOperationMessage->Caption = "LP2 Load完成.";
                  pnlOperationMessage->Caption = "12吋Port Load完成.";

                  pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
                  WriteSystemLog("boolSendSCESCommand: 6");
                  // 2021 5 4 - chc 進入Run
                  // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause
                  //rgEQStatus->ItemIndex = EQ_STATUS_RUN;
                  //rgSecsCommandSet->ItemIndex = -1;
                  //boolSendSCESCommand = true;
                  //rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;
                  // 2021 10 27 - chc Load後為為EXECUTING
                  //SendSECSStatus(EQ_STATUS_IDLE);
                  SendSECSStatus(EQ_STATUS_EXECUTING);

                  // 2021 6 3 - chc 禁止變更LoadPort
                  rgLoadPortSelect->Enabled = false;

                  // 2021 9 30 - chc CST
                  pnlEFEMCassette2->Color = clLime;

                  break;
               }
               else if(pnlLoadPort2CLMP->Color == clRed) {
                  // 2021 6 30c - chc LP1/LP2: 寸
                  //pnlOperationMessage->Caption = "LP2 Load失敗!";
                  pnlOperationMessage->Caption = "2吋Port Load失敗!";

                  pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
                  break;
               }
            }
         }
      }
      // UnLoad
      else {
         // Unload...
         pnlStartMessage->Caption = "Cassette Unloading...";
         pnlStartMessage->Visible = true;

         // 2012 UnLoad再檢查一次
         WriteSystemLog("再執行BeforeUnload()...");
         if(BeforeUnload() == false) {
            pnlAlarmMessage->Caption = "Unload Fail!";
            WriteSystemLog("再執行BeforeUnload(): Fail");
err:
            pnlCassetteLoad->Color = clRed;
            // 禁用pcSystem
            pcSystem->Enabled = true;
            return;
         }
         WriteSystemLog("再執行BeforeUnload(): Ok");
         // 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
         if(boolInLoadWafer == true) {
            pnlAlarmMessage->Caption = "取片中不能做Unload!";
            WriteSystemLog(pnlAlarmMessage->Caption);
            goto err;
         }
         if(boolInUnloadWafer == true) {
            pnlAlarmMessage->Caption = "退片中不能做Unload!";
            WriteSystemLog(pnlAlarmMessage->Caption);
            goto err;
         }
         // LP1: 8"
         if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
            btnLoadPort1UCLMClick(this);
            if(pnlLoadPort1UCLM->Color == clLime) {
               // 2021 6 30c - chc LP1/LP2: 吋
               //pnlOperationMessage->Caption = "LP1 UnLoad完成.";
               pnlOperationMessage->Caption = "8吋Port UnLoad完成.";

               pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
               // LOTEND
               rgPortStatus->ItemIndex = PORT_STATUS_LOTEND;

               WriteSystemLog("boolSendSCESCommand: 7");

               // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
               //rgEQStatus->ItemIndex = EQ_STATUS_IDLE;
               //rgSecsCommandSet->ItemIndex = -1;
               //boolSendSCESCommand = true;
               //rgSecsCommandSet->ItemIndex = SECS_CMD_PTST_1 - SECS_CMD_STAT_1;
               // 2021 10 27 - chc Unload後改成Ready
               //SendSECSStatus(EQ_STATUS_IDLE);
               // 2021 10 27 - chc Unload完成為Idle
               //SendSECSStatus(EQ_STATUS_READY);
               SendSECSStatus(EQ_STATUS_IDLE);

               // 2021 6 3 - chc 可變更LoadPort
               rgLoadPortSelect->Enabled = true;

               // 2021 9 30 - chc CST
               pnlEFEMCassette2->Color = clSilver;

            }
         }
         else {
            btnLoadPort2UCLMClick(this);
            if(pnlLoadPort2UCLM->Color == clLime) {
               // 2021 6 30c - chc LP1/LP2: 吋
               //pnlOperationMessage->Caption = "LP2 UnLoad完成.";
               pnlOperationMessage->Caption = "12吋Port UnLoad完成.";

               pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
               WriteSystemLog("boolSendSCESCommand: 8");

               // 2021 10 21 - chc 由Idle/Run/Down改成Init/Idle/Setup/Ready/Execution/Pause: SendSECSStatus(EQ_STATUS_IDLE)
               //rgEQStatus->ItemIndex = EQ_STATUS_IDLE;
               //rgSecsCommandSet->ItemIndex = -1;
               //boolSendSCESCommand = true;
               //rgSecsCommandSet->ItemIndex = SECS_CMD_STAT_1 - SECS_CMD_STAT_1;
               // 2021 10 27 - chc Unload後改成Ready
               //SendSECSStatus(EQ_STATUS_IDLE);
               // 2021 10 27 - chc Unload完成為Idle
               //SendSECSStatus(EQ_STATUS_READY);
               SendSECSStatus(EQ_STATUS_IDLE);

               // 2021 6 3 - chc 可變更LoadPort
               rgLoadPortSelect->Enabled = true;

               // 2021 9 30 - chc CST
               pnlEFEMCassette2->Color = clSilver;

            }
         }
      }
      if(boolLoadUnloadStatus == true)
         pnlCassetteLoad->Color = clLime;
      else
         pnlCassetteLoad->Color = clRed;

      // 2021 11 11 - chc 禁用pcSystem
      pcSystem->Enabled = true;

      pnlStartMessage->Visible = false;
      return;
   }

   // Hirata
   pnlCassetteLoad->Color = clSilver;
   if(pnlLoadPort->Enabled == true) {

      // 2020 5 2 - chc Load...
      if(btnCassetteLoad->Caption == "Load") {
         pnlStartMessage->Caption = "Check before CST Loading...";
         pnlStartMessage->Visible = true;
      }
      else {
         pnlStartMessage->Caption = "Check before CST UnLoading...";
         pnlStartMessage->Visible = true;
      }

      // 2020 5 4 - chc 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
      if(BeforeLoadPortLoadUnload() == false) {
         pnlCassetteLoad->Color = clRed;
         return;
      }

      // 2020 7 17 - chc UnLoad
      if(btnCassetteLoad->Caption == "UnLoad") {
         if(BeforeUnload() == false) {
            pnlCassetteLoad->Color = clRed;
            return;
         }
      }

      boolLoadUnloadStatus = false;

      if(btnCassetteLoad->Caption == "Load") {

         // 2020 5 2 - chc Load...
         pnlStartMessage->Caption = "Cassette Loading...";
         pnlStartMessage->Visible = true;

         edLoadPortCmd->Text = "MOV:FPML;";
         btnLoadPortCMDClick(this);
         if(pnlCassetteLoad->Color == clLime) {
            pnlOperationMessage->Caption = "Load完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }
      else {

         // 2020 5 2 - chc Unload...
         pnlStartMessage->Caption = "Cassette Unloading...";
         pnlStartMessage->Visible = true;

         edLoadPortCmd->Text = "MOV:ORGN;";
         btnLoadPortCMDClick(this);
         if(pnlCassetteLoad->Color == clLime) {
            pnlOperationMessage->Caption = "UnLoad完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }

      // 2020 5 4 - chc 等20秒
      int cnt = 0;
      int max = 40;
      while(1) {
         if(boolLoadUnloadStatus == true) {
            pnlCassetteLoad->Color = clLime;
            break;
         }
         cnt++;
         if(cnt > max) {
            pnlCassetteLoad->Color = clRed;
            break;
         }
         WaitTime(500);
      }

      // 2020 5 2 - chc Load...
      pnlStartMessage->Visible = false;

   }
*/
}
//---------------------------------------------------------------------------
// 2023 7 27 - chc 切換LoadPort先Disable
void __fastcall TMainForm::rgLoadPortSelectChange(TObject *Sender,
      int ButtonIndex)
{

   if(rgLoadPortSelect->ItemIndex == LOADPORT_1) {
      //btnCassette2Load->Enabled = false;
      pnlCassetteStatus->Color = clSilver;
      pnlCassette2Status->Color = (TColor)0x00F0F0F0;
   }
   else {
      //btnCassetteLoad->Enabled = false;
      pnlCassette2Status->Color = clSilver;
      pnlCassetteStatus->Color = (TColor)0x00F0F0F0;
   }

}
//---------------------------------------------------------------------------
// 2023 7 31 - chc 偵測pnlLoadPortS12是否為1?
bool __fastcall TMainForm::BeforeLoadPortLoadUnloadFun(int portno)
{

   // Tazmo
   if(EFEMMode == EFEM_RORZE) {
      // Placement
      if(portno == LOADPORT_1) {
         btnLoadPort1GPIOClick(this);
         if(pnlLoadPort1Presence->Color == clSilver) {
            pnlAlarmMessage->Caption = "LP1 has no FOUP!";
            return false;
         }
      }
      else {
         btnLoadPort2GPIOClick(this);
         if(pnlLoadPort2Presence->Color == clSilver) {
            pnlAlarmMessage->Caption = "LP2 has no FOUP!";
            return false;
         }
      }
      return true;
   }

   // Hirata
   // 取得LoadPort Status
   // 2020 5 6 - chc 不能看S12
   /*
   btnLoadPortStasClick(this);
   WaitTime(1000);
   if(pnlLoadPort->Enabled == false) {
      pnlLoadPortMessage->Caption = "LoadPort作動異常!";
      return false;
   }
   // 看Protrution? 1-Ok, 0-NG(有東西)
   if(pnlLoadPortS12->Caption != "1") {
      pnlLoadPortMessage->Caption = "LoadPort柵有障礙物!";
      return false;
   }
   */

   return true;
}
//---------------------------------------------------------------------------
// 2023 8 1 - chc Vieworks CCD
//CString Left( int nCount ) const;                   //左第1個開始取前nCount個字符
//CString Mid( int nFirst ) const;                    //左?第 nFirst+1 字符開始,取后面所有的字符
//CString Mid( int nFirst, int nCount ) const;        //左?第 nFirst+1 字符開始,取后面  nCount 個字符
//CString Right( int nCount ) const;                  //右第1個開始取右向左前 nCount 個字符
int GetCustomCommand(VWSDK::HCAMERA hCamera, char* cpFeatureName, UINT* unValue, VWSDK::GET_CUSTOM_COMMAND eCmdType)
{
VWSDK::RESULT eRet = VWSDK::RESULT_ERROR;
int len;

   char chResult[100] = { 0, };
   size_t szResult = sizeof(chResult);

   eRet = CameraGetCustomCommand(hCamera, cpFeatureName, chResult, &szResult, eCmdType);
   if(eRet == VWSDK::RESULT_SUCCESS){
      if(0 == strcmp(cpFeatureName, "PixelSize") && VWSDK::GET_CUSTOM_COMMAND_VALUE == eCmdType){
	 // Bpp8 Bpp10 Bpp12 ...
	 AnsiString strTmp(chResult);
         // 4到最後
         // 1234567890
         len = strTmp.Length();
	 *unValue = strTmp.SubString(4,len-3).ToInt();
      }
      else
      	 *unValue = atoi(chResult);
   }

   return eRet;
}
//---------------------------------------------------------------------------
// 2023 8 1 - chc Vieworks CCD
void GetDeviceInfo(int nIndex, AnsiString *strVenderName, AnsiString *strModelName, AnsiString *strDeviceVersion, AnsiString *strDeviceID)
{

   if(NULL == m_pCamera) {
      MainForm->WriteSystemLog("GetDeviceInfo: Fail");
      return;
   }

   const int STR_SIZE =	256;

   char szVendorName[STR_SIZE];
   size_t cbVendor = sizeof( szVendorName );

   char szModelName[ STR_SIZE ];
   size_t cbModel = sizeof( szModelName );

   char szVersion[ STR_SIZE ];
   size_t cbVersion = sizeof ( szVersion );

   char szID[ STR_SIZE ];
   size_t cbID = sizeof ( szID );


   if(VWSDK::CameraGetDeviceVendorName( m_pCamera, nIndex, szVendorName, &cbVendor ) == VWSDK::RESULT_SUCCESS ) {
      *strVenderName = szVendorName;
   }

   if(VWSDK::CameraGetDeviceModelName( m_pCamera, nIndex, szModelName, &cbModel ) == VWSDK::RESULT_SUCCESS ) {
      *strModelName = szModelName;
   }

   if(VWSDK::CameraGetDeviceVersion( m_pCamera, nIndex, szVersion, &cbVersion ) == VWSDK::RESULT_SUCCESS ) {
      *strDeviceVersion = szVersion;
   }

   if(VWSDK::CameraGetDeviceID( m_pCamera, nIndex, szID, &cbID ) == VWSDK::RESULT_SUCCESS ) {
      *strDeviceID = szID;
   }
}
//---------------------------------------------------------------------------
// 2023 8 1 - chc Vieworks CCD
void __fastcall TMainForm::btnLiveClick(TObject *Sender)
{

   if(NULL == m_pCamera) {
      MainForm->WriteSystemLog("btnLiveClick: Fail");
      return;
   }

   BOOL bGrabbing = FALSE;
   VWSDK::CameraGetGrabCondition( m_pCamera, bGrabbing);
   if(bGrabbing) {
      Application->MessageBox("Now living... Please 'Grab' first.", MB_OK );
      return;
   }

   UINT nWidth = 0;
   UINT nHeight = 0;
   UINT nInputWidth = 0;
   UINT nInputHeight = 0;
   GetCustomCommand(m_pCamera, "Width", &nWidth, VWSDK::GET_CUSTOM_COMMAND_VALUE);
   GetCustomCommand(m_pCamera, "Height", &nHeight, VWSDK::GET_CUSTOM_COMMAND_VALUE);
   nInputWidth = nWidth;
   nInputHeight = nHeight;
   pnlWidth->Caption = IntToStr(nWidth);
   pnlHeight->Caption = IntToStr(nHeight);
   m_Width = nWidth;
   m_Height = nHeight;

   {
      // CameraSetReadoutMode
      char chValue[10] = { 0, };
      // This property values may be different for each GigE camera.
      // READOUT_NORMAL			= 0
      // READOUT_AOI				= 1
      // READOUT_BINNING			= 2
      // READOUT_HORIZONTALSTART	= 3
      // READOUT_HORIZONTALEND	= 4
      // READOUT_VERTICALSTART	= 5
      // READOUT_VERTICALEND		= 6
      // READOUT_BINNINGFATOR		= 7
      //sprintf(chValue, "%d", 1);                                                // READOUT_AOI = 1
      //VWSDK::RESULT ret = VWSDK::CameraSetCustomCommand(m_pCamera, "ReadoutMode", chValue);
      AnsiString str;
      str.sprintf("%d",1);
      VWSDK::RESULT ret = VWSDK::CameraSetCustomCommand(m_pCamera, "ReadoutMode", str.c_str());
   }

   {
      // CameraSetHorizontalStart/End
      VWSDK::CameraSetCustomCommand(m_pCamera, "HorizontalStart", "0");
      char chValue[100] = { 0, };
      //sprintf(chValue, "%d", nInputWidth - 1);
      //VWSDK::CameraSetCustomCommand(m_pCamera, "HorizontalEnd", chValue);
      AnsiString str;
      str.sprintf("%d",nInputWidth - 1);
      VWSDK::CameraSetCustomCommand(m_pCamera, "HorizontalEnd", str.c_str());

      // CameraSetVerticalStart/End
      VWSDK::CameraSetCustomCommand(m_pCamera, "VerticalStart", "0");
      ZeroMemory(chValue, sizeof(chValue));

      //sprintf(chValue, "%d", nInputHeight - 1);
      //VWSDK::CameraSetCustomCommand(m_pCamera, "VerticalEnd", chValue);
      str.sprintf("%d",nInputHeight - 1);
      VWSDK::CameraSetCustomCommand(m_pCamera, "VerticalEnd", str.c_str());
   }

   VWSDK::PIXEL_FORMAT pixelFormat = VWSDK::PIXEL_FORMAT_BGR8;
   //VWSDK::PIXEL_FORMAT pixelFormat = VWSDK::PIXEL_FORMAT_BAYRG8;

   VWSDK::CameraGetPixelFormat( m_pCamera, &pixelFormat);
   if(nInputWidth != nWidth || nInputHeight != nHeight) {
      if(VWSDK::RESULT_SUCCESS != VWSDK::CameraChangeBufferFormat( m_pCamera, m_imagebuffernumber, nInputWidth, nInputHeight, pixelFormat)) {
	 Application->MessageBox("Can't change the camera buffer.", MB_OK);
	 return;
      }
      // 取得總長度W*H*3
      MakeUnPackedBuffer();
   }

   if(VWSDK::CameraGrab( m_pCamera ) == VWSDK::RESULT_SUCCESS) {

   }
   else {
      return;
   }
}
//---------------------------------------------------------------------------
// 2023 8 1 - chc Vieworks CCD
void __fastcall TMainForm::btnGrabClick(TObject *Sender)
{

   if(NULL == m_pCamera) {
      MainForm->WriteSystemLog("btnGrabClick: Fail");
      return;
   }

   VWSDK::CameraAbort(m_pCamera);
}
//---------------------------------------------------------------------------
// 2023 8 1 - chc Vieworks CCD
void MakeUnPackedBuffer()
{

   if(NULL == m_pCamera) {
      MainForm->WriteSystemLog("MakeUnPackedBuffer: Fail");
      // ERROR
      return;
   }

   if(m_pUnpackedImage) {
      delete [] m_pUnpackedImage;
      m_pUnpackedImage = NULL;
   }

   //Get image width,height
   UINT nWidth = 0;
   UINT nHeight = 0;
   GetCustomCommand(m_pCamera, "Width", &nWidth, VWSDK::GET_CUSTOM_COMMAND_VALUE);
   GetCustomCommand(m_pCamera, "Height", &nHeight, VWSDK::GET_CUSTOM_COMMAND_VALUE);

   VWSDK::PIXEL_FORMAT pixelFormat = VWSDK::PIXEL_FORMAT_BGR8;
   VWSDK::CameraGetPixelFormat( m_pCamera, &pixelFormat);

   if(pixelFormat == VWSDK::PIXEL_FORMAT_BGR8)
      m_pUnpackedImage = new BYTE[nWidth*nHeight*3];
   else
      m_pUnpackedImage = new BYTE[nWidth*nHeight*3];


}
//---------------------------------------------------------------------------
// 2023 8 1 - chc Vieworks Image
void __fastcall TMainForm::rgCCDSourceChange(TObject *Sender,
      int ButtonIndex)
{

   if(rgCCDSource->ItemIndex == 0) {
      pnlVieworks->Visible = false;
   }
   else {
      pnlVieworks->Visible = true;
   }
}
//---------------------------------------------------------------------------
// 2023 8 1 - chc Vieworks Image
// 1024*1200 - 764*896
// Offset: 712*424
void __fastcall TMainForm::SetupVieworksView()
{

   pnlVieworks->Left = 104;
   pnlVieworks->Top = 11;
   pnlVieworks->Width = 1065;
   pnlVieworks->Height = 910;

   imVieworks->Left = 152;
   imVieworks->Top = 8;
   imVieworks->Width = 764;
   imVieworks->Height = 896;

}
//---------------------------------------------------------------------------
// 2023 8 2 - chc XY/RGB
void __fastcall TMainForm::imVieworksMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy;

   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imVieworks->Canvas->Pixels[X][Y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = X + sx;
   pnlCCDY->Caption = Y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",X,Y);
   sbSystemMessage->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystemMessage->Panels->Items[4]->Text = str;
}
//---------------------------------------------------------------------------
void __fastcall TMainForm::DisplayVCCD(int cnt)
{
int sindex;
unsigned char *dptr;
int sum = 0;
int w,h;

   sindex = 0;
   w = EImageAry.GetWidth();
   h = EImageAry.GetHeight();
   if(w != m_Width) {
      WriteSystemLog("Width(Err): " + IntToStr(m_Width) + "," + IntToStr(w));
   }
   if(h != m_Height) {
      WriteSystemLog("Height(Err): " + IntToStr(m_Height) + "," + IntToStr(h));
   }

   for(int row=0; row<m_Height ; row++) {
      // bitmap
      if(MainForm->rgImageType->ItemIndex == 0) {
         dptr = (Byte *) MainForm->imVieworks->Picture->Bitmap->ScanLine[row];        //讀取第 row 列
         //dindex = 0;
         //for(int col=0; col<m_Width; col++) {
         //   dptr[dindex++] = svptr[sindex++];                                       // 藍色分量
         //   dptr[dindex++] = svptr[sindex++];                                       // 綠色分量
         //   dptr[dindex++] = svptr[sindex++];                                       // 紅色分量
         //   //sindex += 3;
         //}
         // 由svptr到dptr
         memcpy(dptr, svptr,m_Width*3);
      }
      // eVision
      else if(MainForm->rgImageType->ItemIndex == 1 || MainForm->rgImageType->ItemIndex == 2) {
         dptr = (unsigned char *)MainForm->EImageAry.GetImagePtr(0,row);
         memcpy(dptr, svptr,m_Width*3);
      }
      // pattern
      else if(MainForm->rgImageType->ItemIndex == 3) {
         dptr = (unsigned char *)MainForm->EImageAry.GetImagePtr(0,row);
         for(int i=0 ; i<m_Width*3 ; i++) {
            if((cnt % 10) < 5)
               dptr[i] = 0x99;
            else
               dptr[i] = 0x55;
         }
      }
      sum += svptr[10];
      svptr += m_Width*3;

      //MainForm->pnlCCDRun->Caption = "2a:" + IntToStr(m_Width) + "," + IntToStr(m_Height) + "," + IntToStr(row+1);
      //MainForm->WriteSystemLog(MainForm->pnlCCDRun->Caption);

   }

   MainForm->pnlCCDRun->Caption = "3:" + IntToStr(m_Width) + "," + IntToStr(m_Height);
   MainForm->WriteSystemLog(MainForm->pnlCCDRun->Caption);

   if(MainForm->rgImageType->ItemIndex == 1) {
      //MainForm->EImageAry.Draw(MainForm->imVieworks->Canvas->Handle);
      MainForm->EImageAryROI.SetPlacement(0,0,m_Width,m_Height);
      MainForm->EImageAryROI.Draw(MainForm->imVieworks->Canvas->Handle);
   }
   // file
   else if(MainForm->rgImageType->ItemIndex == 2 || MainForm->rgImageType->ItemIndex == 3) {
      MainForm->EImageAry.Save("D:\\Test.bmp",E_FILE_FORMAT_COLOR_BMP);
      MainForm->imVieworks->Picture->LoadFromFile("D:\\Test.bmp");
   }
   MainForm->imVieworks->Refresh();
   MainForm->pnlSum->Caption = IntToStr(sum);
}
//---------------------------------------------------------------------------

void __fastcall TMainForm::imCloseClick(TObject *Sender)
{

   pnlHomeStep->Visible = false;
}
//---------------------------------------------------------------------------
